#!/bin/sh
# Self-modifying ni image: https://github.com/spencertipping/ni
module_0='newline="$(printf "\\n ")" && newline="${newline% }"
module() {
  [ $# -eq 2 ] && module_v="$2" || module_v="$(cat)"
  eval "module_$module_index=\"\$module_v\""
  [ ${1%.sh} = $1 ] || eval "eval \"\$module_v\"" || echo "in module $1" >&2
  modules="$modules$newline$1"
  module_index=$((module_index + 1))
}
module_index=1
modules=boot.sh
meta_hook() meta_hooks="$meta_hooks$newline$(cat)"'
eval "$module_0"
module 'meta/struct.sh' <<'dde5a2e8b421df3f747b6c849ad813250a8cf2b63743976ccbdae26ebdaaf2eb'
# Data structure metaprogramming
cell_index=0
cell() {
  eval "$1=_$2_\$cell_index"
  cell_index=$((cell_index + 1))
  [ "${cell_index%000}" = "$cell_index" ] || gc
}

# Defines a named structure with a constructor and GC visitor.
defined_structs=
defstruct() {
  defined_structs="$defined_structs $1"
  defstruct_name=$1
  defstruct_visitor="gc_$1() eval \"\$1=\\\""
  defstruct_ctor="$1() { cell ${1}_cell $1; eval \""
  shift

  defstruct_i=2
  for defstruct_field; do
    defstruct_ctor="$defstruct_ctor$newline\${${defstruct_name}_cell}_$defstruct_field=\$$defstruct_i"
    defstruct_visitor="$defstruct_visitor \${2}_$defstruct_field"
    eval "$defstruct_field() eval \"\$1=\\\"\\\$\${2}_$defstruct_field\"\\\""
    eval "${defstruct_field}_set() eval \"\${1}_$defstruct_field=\\\"\\\$2\\\"\""
    defstruct_i=$((defstruct_i + 1))
  done

  eval "$defstruct_ctor$newline\$1=\$${defstruct_name}_cell\"; }"
  eval "$defstruct_visitor\\\"\""
}

# Defines a type-prefixed multimethod; e.g. "defmulti str" would expand into a
# call to cons_str "$@" if called with $2 as a cons cell.
defmulti() eval "$1() {
                   multi_${1}_type=\${2%_*}
                   \${multi_${1}_type#_}_$1 \"\$@\"
                 }"

# Default multimethods available for all structures
defmulti str
dde5a2e8b421df3f747b6c849ad813250a8cf2b63743976ccbdae26ebdaaf2eb
module 'meta/lisp.sh' <<'2ce696b6e075b0cee14ebd6c02132224ab1efcb4b12bb5f76b533c42edba097a'
# Lisp in POSIX shell ... because we can.

# Reader
lisp_convert() sed 's/\([^$]\|^\)\([][(){}]\)/\1 \2 /g'
lisp_read() {
  lisp_read_dest=$1
  shift
  cons lisp_read_r '' ''
  for lisp_read_x; do
    if [ -z "${lisp_read_x#[[(\{]}" ]; then
      cons lisp_read_r '' $lisp_read_r
    elif [ -z "${lisp_read_x#[])\}]}" ]; then
      uncons lisp_read_head lisp_read_r $lisp_read_r
      h lisp_read_tailhead $lisp_read_r
      list_reverse lisp_read_head $lisp_read_head
      if [ "$lisp_read_x" = "]" ]; then
        vec lisp_read_head $lisp_read_head
      elif [ "$lisp_read_x" = "}" ]; then
        # Go back and stringify the keys into sh primitives.
        hashmap lisp_read_map
        while [ -n "$lisp_read_head" ]; do
          uncons lisp_read_head_k lisp_read_head $lisp_read_head
          uncons lisp_read_head_v lisp_read_head $lisp_read_head
          str lisp_read_head_k $lisp_read_head_k
          assoc $lisp_read_map $lisp_read_head_k $lisp_read_head_v
        done
        lisp_read_head=$lisp_read_map
      fi
      cons ${lisp_read_r}_h $lisp_read_head $lisp_read_tailhead
    else
      h lisp_read_head $lisp_read_r
      atom lisp_read_cell $lisp_read_x
      cons ${lisp_read_r}_h $lisp_read_cell "$lisp_read_head"
    fi
  done
  h $lisp_read_dest $lisp_read_r
  eval "list_reverse $lisp_read_dest \$$lisp_read_dest"
}

# Compiler
# This lisp uses a TCL-style evaluation model; that is, () is interpolated but
# words themselves are assumed to be self-representing.
2ce696b6e075b0cee14ebd6c02132224ab1efcb4b12bb5f76b533c42edba097a
module 'meta/list.sh' <<'fe793c0e5ea99832e216de8c6ef46295bfb60915e4da3994c6e74947acf13e17'
# Linked list functions

list_reverse() {
  if [ -n "$2" ]; then
    uncons list_reverse_h list_reverse_t $2
    cons list_reverse_l $list_reverse_h $3
    list_reverse "$1" "$list_reverse_t" $list_reverse_l
  else
    eval "$1=\$3"
  fi
}

# Like the usual (apply), but doesn't accept any intermediate arguments; that
# is, it's just a function and a list.
apply_last() {
  apply_last_f=$1
  apply_last_r=$2
  apply_last_l=$3
  shift 3
  while [ -n "$apply_last_l" ]; do
    uncons apply_last_h apply_last_l $apply_last_l
    set -- "$@" "$apply_last_h"
  done
  $apply_last_f $apply_last_r "$@"
}
fe793c0e5ea99832e216de8c6ef46295bfb60915e4da3994c6e74947acf13e17
module 'meta/vector.sh' <<'282f73b3b0c39b92d5c15a4be3291eb4f2c8edacce7d0397e4367ab773fd9c1f'
# Vector data structure

# This is roughly what defstruct generates, though this is a bit more
# complicated because it supports variable arity.
vector() {
  vector_r=$1
  shift
  cell vector_cell vector
  eval "${vector_cell}_n=0"
  for vector_x; do
    eval "vector_n=\$${vector_cell}_n"
    eval "${vector_cell}_$vector_n=\"\$vector_x\"
          ${vector_cell}_n=\$(($vector_n + 1))"
  done
  eval "$vector_r=\$vector_cell"
}

vector_gc() {
  vector_gc_r=$1
  eval "vector_gc_n=\$${2}_n"
  vector_gc_i=0
  vector_gc_s=
  while [ $vector_gc_i -lt $vector_gc_n ]; do
    eval "vector_gc_s=\"\$vector_gc_s \$${2}_$vector_gc_i\""
    vector_gc_i=$((vector_gc_i + 1))
  done
  eval "$vector_gc_r=\"\$vector_gc_s\""
}

n()   eval "$1=\"\$${2}_n\""
nth() eval "$1=\"\$${2}_$3\""

vector_str() {
  vector_str_i=0
  vector_str_s=''
  n vector_str_n $2
  while [ $vector_str_i -lt $vector_str_n ]; do
    set -- "$1" "$2" "$vector_str_s" "$vector_str_i" "$vector_str_n"
    nth vector_str_x $2 $vector_str_i
    str vector_str_x $vector_str_x
    vector_str_s="$3 $vector_str_x"
    vector_str_i=$(($4 + 1))
    vector_str_n=$5
  done
  eval "$1=\"[\${vector_str_s# }]\""
}

# Converts a list reference to a vector, unlike (vector) above which makes one
# out of its shell arguments.
vec() {
  vec_r=$1
  vec_l=$2
  shift 2
  set --
  while [ -n "$vec_l" ]; do
    uncons vec_h vec_l $vec_l
    set -- "$@" "$vec_h"
  done
  vector "$vec_r" "$@"
}
282f73b3b0c39b92d5c15a4be3291eb4f2c8edacce7d0397e4367ab773fd9c1f
module 'meta/cons.sh' <<'9ea29467cc2eea0ad32edc8e1abdb737f72192a3c4ccc97e3c475a41ed5cdbc5'
# Cons cell primitive
meta_hook <<'EOF'
defstruct cons h t
EOF

# NB: non-standard calling convention. This is used only within sh functions
# (i.e. what it does isn't expressible in lisp mode).
uncons() eval "$1=\"\$${3}_h\"; $2=\"\$${3}_t\""

_str() eval "$1=nil"            # nil case; nil is empty string

cons_str() {
  cons_str_x="$2"
  cons_str_s=
  while [ -n "$cons_str_x" ]; do
    h cons_str_h $cons_str_x
    t cons_str_x $cons_str_x
    set -- "$1" "$cons_str_x" "$cons_str_s"     # for recursion
    str cons_str_h $cons_str_h
    cons_str_s="$3 $cons_str_h"
    cons_str_x="$2"
  done
  eval "$1=\"(\${cons_str_s# })\""
}
9ea29467cc2eea0ad32edc8e1abdb737f72192a3c4ccc97e3c475a41ed5cdbc5
module 'meta/hashmap.sh' <<'85326126cc64bd4b7346e4b3a6ad000d20a54c035561ba8d9e5327828fd3d8cb'
# Hashmap data structure
# (Not technically a hashmap because we piggyback off of the parent shell's
#  global variable table; i.e. we're not doing anything clever here.)

# Constructed from pairs of arguments:
# hashmap result k1 v1 k2 v2 ... kn vn
hashmap() {
  hashmap_r=$1
  cell hashmap_cell hashmap
  shift
  while [ $# -gt 0 ]; do
    assoc $hashmap_cell "$1" "$2"
    shift 2
  done
  eval "$hashmap_r=\$hashmap_cell"
}

hashmap_gc() {
  hashmap_gc_keys=
  keys hashmap_gc_l $2
  while [ -n "$hashmap_gc_l" ]; do
    uncons hashmap_gc_k hashmap_gc_l $hashmap_gc_l
    hashmap_gc_keys="$hashmap_gc_keys $hashmap_gc_k"
  done
  eval "$1=\"\$hashmap_gc_keys\""
}

hashmap_str() {
  hashmap_str_s=
  keys hashmap_str_l $2
  while [ -n "$hashmap_str_l" ]; do
    uncons hashmap_str_k hashmap_str_l $hashmap_str_l
    set -- "$1" "$2" "$hashmap_str_s $hashmap_str_k" "$hashmap_str_l"
    get hashmap_str_v $2 $hashmap_str_k
    str hashmap_str_v $hashmap_str_v
    hashmap_str_s="$3 $hashmap_str_v"
    hashmap_str_l="$4"
  done
  eval "$1=\"{\$hashmap_str_s}\""
}

assoc() eval "${1}_key_$2=\"\$3\"
              if [ -n \"\$${1}_cell_$2\" ]; then
                cons ${1}_keys \"\$2\" \$${1}_keys
                ${1}_cell_$2=\$${1}_keys
              fi"

keys()     eval "$1=\$${2}_keys"
get()      eval "$1=\"\$${2}_key_$3\""
contains() eval "[ -n \"${2}_cell_$3\" ] && $1=t || $1="
85326126cc64bd4b7346e4b3a6ad000d20a54c035561ba8d9e5327828fd3d8cb
module 'meta/atom.sh' <<'ccf495cdd56f80fd109a7c041931a8e2c14746212212f9cf01d4f8ba61bb03e7'
# Atoms
meta_hook <<'EOF'
defstruct string x
defstruct atom   x
EOF

string_str() eval "$1=\"\$${2}_x\""
atom_str()   eval "$1=\"\$${2}_x\""
ccf495cdd56f80fd109a7c041931a8e2c14746212212f9cf01d4f8ba61bb03e7
module 'meta/.struct.sh.swp' <<'58f6e03f3322657736b4f9bff1f472759bec87233e25dd4f4cd72abf19940e80'
b0VIM 7.4—Vqj!spencertippingxenorophidae~spencertipping/r/initiative/ni/src/meta/struct.shutf-83210#"! Utp'ad<
ô
'ßÒÉ¬‹[YXúÒ¾[SRB(Á1ßº³²pNLKüÂª~J65ô
defmulti strddefmulti str# Default multimethods available for all structures                 }"                   \${multi_${1}_type#_}_$1 \"\$@\"                   multi_${1}_type=\${2%_*}defmulti() eval "$1() {# call to cons_str "$@" if called with $2 as a cons cell.# Defines a type-prefixed multimethod; e.g. "defmulti str" would expand into a}  eval "$defstruct_visitor\\\"\""  eval "$defstruct_ctor$newline\$1=\$${defstruct_name}_cell\"; }"  done    defstruct_i=$((defstruct_i + 1))    eval "${defstruct_field}_set() eval \"\${1}_$defstruct_field=\\\"\\\$2\\\"\""    eval "$defstruct_field() eval \"\$1=\\\"\\\$\${2}_$defstruct_field\"\\\""    defstruct_visitor="$defstruct_visitor \${2}_$defstruct_field"    defstruct_ctor="$defstruct_ctor$newline\${${defstruct_name}_cell}_$defstruct_field=\$$defstruct_i"  for defstruct_field; do  defstruct_i=2  shift  defstruct_ctor="$1() { cell ${1}_cell $1; eval \""  defstruct_visitor="gc_$1() eval \"\$1=\\\""  defstruct_name=$1  defined_structs="$defined_structs $1"defstruct() {defined_structs=# Defines a named structure with a constructor and GC visitor.}  [ "${cell_index%000}" = "$cell_index" ] || gc  cell_index=$((cell_index + 1))  eval "$1=_$2_\$cell_index"cell() {cell_index=0# Data structure metaprogramming
58f6e03f3322657736b4f9bff1f472759bec87233e25dd4f4cd72abf19940e80
module 'self/repl.sh' <<'dff27cc55234b6f46883b3a6be243f7ecb84530f5360da656b9e76a003cc88c3'
# REPL environment for testing things and editing the image
# Explodes the image into the filesystem, cd's there, and runs a sub-shell
# that's prepopulated with all of ni's shell state. This means the subshell
# will be a POSIX shell, not bash, ksh, or csh.
#
# If you want your preferred shell in an exploded state directory (but without
# in-memory state), you can use repl_stateless.

repl_sh() {
  sh_repl_self_dir="$(self | sha3)"

}
dff27cc55234b6f46883b3a6be243f7ecb84530f5360da656b9e76a003cc88c3
module 'self/fs.sh' <<'a827483ae7afd5a7d7445adcaed9cb97ef5a8b1e3b4570a3492806d00b145dcb'
# Filesystem interop

# Usage: tmpdir destination_var
# Returns the original tmpdir if the destination var is already populated and
# exists.
tmpdir() {
  eval "[ -e \"\$${1:-self_tmpdir}/.this-is-a-ni-tmpdir\" ]" && return
  tmpdir_prefix="${TMPDIR:-/tmp}/ni-$$"
  tmpdir_index=0
  until mkdir "$tmpdir_prefix-$tmpdir_index" 2>/dev/null; do
    tmpdir_prefix=$((tmpdir_prefix + 1))
  done
  touch "$tmpdir_prefix-$tmpdir_index/.this-is-a-ni-tmpdir"
  eval "${1:-self_tmpdir}=\$tmpdir_prefix-\$tmpdir_index"
}

tmpdir_free() {
  [ $# -eq 0 ] && set -- "$self_tmpdir"
  if [ ! -e "$1/.this-is-a-ni-tmpdir" ]; then
    verb "ni: trying to clean up a tmpdir ($1)" \
         "    but this tmpdir doesn't appear to have been created by ni" \
         "    in this case, not doing anything" >&2
    return 1
  fi
  rm -r "$1"
}

# It's important to create a tmpdir at startup. If we don't, then a subprocess
# will; but subprocesses can't modify our variable-space so we won't see it
# (and therefore won't clean it up). The way around this is to prepend tmpdir
# to the list of start hooks so it happens before anything gets jitted.
setup_hooks="tmpdir$newline$start_hooks"
shutdown_hooks="$shutdown_hooks${newline}tmpdir_free"

# Exhume/inhume self to/from FS
# Usage: exhume existing-directory (populates self to directory)
exhume() {
  exhume_i=0
  exhume_old_ifs="$IFS"
  IFS="$newline"
  for exhume_m in $modules; do
    mkdir -p "$1/${exhume_m%/*}"
    eval "verb \"\$module_$exhume_i\"" > "$1/$exhume_m"
    exhume_i=$((exhume_i + 1))
  done
  IFS="$exhume_old_ifs"
}

# Usage: inhume exhumed-directory (populates directory to self)
# NB: just as exhume doesn't create one, this function doesn't remove the
# directory. Also, inhumed files are in arbitrary order except for boot.sh,
# which always goes first.
inhume() {
  module_index=0
  module boot.sh "$(cat "$1/boot.sh")"
  inhume_old_ifs="$IFS"

  # Always inhume meta stuff first
  IFS="$newline"
  for inhume_f in $(find "$1/meta" -type f); do
    IFS="$inhume_old_ifs"
    module "${inhume_f#$1}" "$(cat "$inhume_f")"
  done

  IFS="$newline"
  for inhume_f in $(find "$1" -type f); do
    IFS="$inhume_old_ifs"
    [ "$inhume_f" != "$1/boot.sh" ] \
      && [ "${inhume_f#$1/meta/}" = "$inhume_f" ] \
      && module "${inhume_f#$1}" "$(cat "$inhume_f")"
  done
}
a827483ae7afd5a7d7445adcaed9cb97ef5a8b1e3b4570a3492806d00b145dcb
module 'self/image.sh' <<'77d065e887c8fc9cacae07ca878b337decc7bbdf0156c4558f230766ffe4ee17'
# Retrieves a module's text by name
# Usage: module_get destination_var module/name
# Does nothing if the variable is already set, which makes it possible to use
# this function repeatedly without a performance hit.
module_get() {
  eval "[ -n \"\$$1\" ]" && return
  module_get_old_ifs="$IFS"
  IFS="$newline"
  module_get_i=0
  for module_get_name in $modules; do
    if [ "$2" = "$module_get_name" ]; then
      eval "$1=\"\$module_$module_get_i\""
      IFS="$module_get_old_ifs"
      return 0
    fi
    module_get_i=$((module_get_i + 1))
  done
  IFS="$module_get_old_ifs"
}

# Prints a representation of this object to stdout.
self() {
  main_setup
  verb "#!/bin/sh" \
       "# Self-modifying ni image: https://github.com/spencertipping/ni" \
       "module_0='$module_0'" \
       'eval "$module_0"'

  self_old_ifs="$IFS"
  IFS="$newline"
  self_i=0
  for self_m in $modules; do
    if [ $self_m != boot.sh ]; then
      eval "self_marker=\"\$(echo \"\$module_$self_i\" | sha3)\""
      verb "module '$self_m' <<'$self_marker'"
      eval "verb \"\$module_$self_i\""
      verb "$self_marker"
    fi
    self_i=$((self_i + 1))
  done
  IFS="$self_old_ifs"
  verb 'main "$@"'
}
77d065e887c8fc9cacae07ca878b337decc7bbdf0156c4558f230766ffe4ee17
module 'bin/sha3.c' <<'44df5c8e41a4bf87977fa99c9dbe0530bfe2ba7c0faf73952bdaa2da3e6d77f4'
/* Calculates the SHA3-256 of stdin and argv. This is used throughout ni to
 * cache intermediate results.
 *
 * Code from https://github.com/gvanas/KeccakCodePackage/blob/master/Standalone/CompactFIPS202/Keccak-more-compact.c;
 * modified here to read from a file descriptor and to alias pointers for a
 * speedup of about 4x */

#include <unistd.h>
#include <sys/types.h>

#define FOR(i,n) for(i=0; i<n; ++i)
typedef unsigned char u8;
typedef unsigned long long int u64;
typedef unsigned int ui;

void Keccak(ui r, ui c, const u8 *in, u64 inLen, u8 sfx, u8 *out, u64 outLen);

int LFSR86540(u8 *R) { (*R)=((*R)<<1)^(((*R)&0x80)?0x71:0); return ((*R)&2)>>1; }
#define ROL(a,o) ((((u64)a)<<o)^(((u64)a)>>(64-o)))
#define rL(x,y) (*(u64*)((u8*)s+8*(x+5*y)))
#define wL(x,y,l) (*(u64*)((u8*)s+8*(x+5*y))=(l))
#define XL(x,y,l) (*(u64*)((u8*)s+8*(x+5*y))^=(l))
void KeccakF1600(void *s)
{
    ui r,x,y,i,j,Y; u8 R=0x01; u64 C[5],D;
    for(i=0; i<24; i++) {
        /*Î¸*/ FOR(x,5) C[x]=rL(x,0)^rL(x,1)^rL(x,2)^rL(x,3)^rL(x,4); FOR(x,5) { D=C[(x+4)%5]^ROL(C[(x+1)%5],1); FOR(y,5) XL(x,y,D); }
        /*ÏÏ€*/ x=1; y=r=0; D=rL(x,y); FOR(j,24) { r+=j+1; Y=(2*x+3*y)%5; x=y; y=Y; C[0]=rL(x,y); wL(x,y,ROL(D,r%64)); D=C[0]; }
        /*Ï‡*/ FOR(y,5) { FOR(x,5) C[x]=rL(x,y); FOR(x,5) wL(x,y,C[x]^((~C[(x+1)%5])&C[(x+2)%5])); }
        /*Î¹*/ FOR(j,7) if (LFSR86540(&R)) XL(0,0,(u64)1<<((1<<j)-1));
    }
}
int main()
{
    /*initialize*/ u8 ia[65536], *in = ia, oa[32], *out = oa; u64 inLen; u8 s[200]; ui R=1088/8; ui i,b=0; u64 outLen=32; FOR(i,200) s[i]=0;
    /*absorb*/ while ((inLen = read(0, in = ia, 65536)) > 0) while(inLen>0) { b=(inLen<R)?inLen:R; FOR(i,b) s[i]^=in[i]; in+=b; inLen-=b; if (b==R) { KeccakF1600(s); b=0; } }
    /*pad*/ s[b]^=6; if((6&0x80)&&(b==(R-1))) KeccakF1600(s); s[R-1]^=0x80; KeccakF1600(s);
    /*squeeze*/ while(outLen>0) { b=(outLen<R)?outLen:R; FOR(i,b) out[i]=s[i]; out+=b; outLen-=b; if(outLen>0) KeccakF1600(s); }

    u8 oh[65], *hex="0123456789abcdef"; FOR(i, 32) { oh[i<<1]=hex[oa[i]>>4]; oh[i<<1|1]=hex[oa[i]&15]; }
    oh[64]='\n'; write(1, oh, 65); return 0;
}
44df5c8e41a4bf87977fa99c9dbe0530bfe2ba7c0faf73952bdaa2da3e6d77f4
module 'main.sh' <<'50d1ae2fe4e42136d521375a1380c0c8857b6dfd4d150ff39cd7552dab23eb32'
main_is_setup=
main_setup() {
  [ -n "$main_is_setup" ] && return
  eval "$meta_hooks"
  eval "$setup_hooks"
  main_is_setup=t
}

main() {
  main_setup
  lisp_read r $(lisp_convert)
  str s $r
  verb "$s" >&2
  eval "$shutdown_hooks"
}
50d1ae2fe4e42136d521375a1380c0c8857b6dfd4d150ff39cd7552dab23eb32
module 'jit/jit-c.sh' <<'093b0a379b09a2ef39f5c708cdf6f2bc835f80856df1073d261fa1cff1801eee'
# JIT support for C99 programs
# Calling convention is like this, except that heredocs inside $() don't seem
# to be allowed:
#
# jit_program=$(jit_c [c99-option...] <<'EOF'
# #include <stdio.h>
# int main() {
#   printf("hello world\n");
#   return 0;
# }
# EOF
# )
#
# $jit_program "$@"             # to execute the program
# jit_c_free $jit_program       # to deallocate the program

jit_c_index=0
jit_c() {
  tmpdir
  jit_c_index=$((jit_c_index + 1))
  jit_c_source="$self_tmpdir/jit-c-$jit_c_index.c"
  cat > "$jit_c_source"
  c99 "$@" "$jit_c_source" -o "${jit_c_source%.c}"
  verb "${jit_c_source%.c}"
}

jit_c_free() rm "$1" "$1.c"
093b0a379b09a2ef39f5c708cdf6f2bc835f80856df1073d261fa1cff1801eee
module 'jit/jit-mvn.sh' <<'56d5b4c2e782305b4a824587cbecb0b18e42c98f3295bab87f1c7367ef81ae5b'
# JVM JIT using maven as the frontend

# POM generation stuff
# The goal here is to make it trivial to build a working POM file, without
# typing out a whole bunch of XML. This is done by defining POM-macro functions
# that handle various command-line options and generate the relevant XML
# fragments for you. For example, here's the dependency generator:

mvn_pom_deps() {
  verb '<dependencies>'
  for mvn_pom_deps_d; do
    # Dependencies are specified using this syntax:
    # [groupId/]artifactId=version[:scope]
    mvn_pom_deps_ga="${1%%=*}"
    mvn_pom_deps_vs="${1##*=}"
    mvn_pom_deps_g="${mvn_pom_deps_ga%%/*}"
    mvn_pom_deps_s="${mvn_pom_deps_vs##*:}"
    [ "$mvn_pom_deps_s" = "$mvn_pom_deps_vs" ] \
      && mvn_pom_deps_s= \
      || mvn_pom_deps_s="<scope>$mvn_pom_deps_s</scope>"
    verb "<dependency>" \
         "<groupId>$mvn_pom_deps_g</groupId>" \
         "<artifactId>${mvn_pom_deps_ga##*/}</artifactId>" \
         "<version>${mvn_pom_deps_vs%%:*}</version>" \
         "$mvn_pom_deps_s</dependency>"
  done
  verb '</dependencies>'
}

# Calling syntax for the above would be this:
#
# mvn_pom --deps foo.bar/bif=1.0.0-SNAPSHOT:development \
#                foo.bar/baz=10:test \
#         --...
#
# ni detects the end of arguments to a generator by looking for the next option
# starting with --.

mvn_pom() {
  : TODO
}

# Usage: jit_program=$(jit_mvn Foobar [-Dgroup/artifact=version ...] ... <<'EOF'
# public class Foobar {
#   public static void main(String[] args) {
#     System.out.println("hello world!");
#   }
# }
# EOF
# )
#
# $jit_program "$@"
# jit_mvn_free $jit_program
jit_mvn() {
  jit_mvn_result=$1
  jit_mvn_main=$2
}
56d5b4c2e782305b4a824587cbecb0b18e42c98f3295bab87f1c7367ef81ae5b
module 'util/verb.sh' <<'4bf7f00fb83d3d5dbc0d6e24cc6e619101606be286fdd821a4dae8cca0ffd540'
# Safe echo: works around the POSIX statement that "echo" is allowed to
# interpret its arguments
verb() {
  for verb_arg; do
    printf "%s\n" "$verb_arg"
  done
}
4bf7f00fb83d3d5dbc0d6e24cc6e619101606be286fdd821a4dae8cca0ffd540
module 'util/sha3.sh' <<'17b94d7782eee6bcf42fa454add973958ee2388c8e0126b68956b3475a9bb0e9'
# Support for hashing arbitrary data through the jit-C interface
sha3() { sha3_setup; "$sha3_jit"; }
sha3_setup() {
  [ -n "$sha3_jit" ] && return
  module_get sha3_source bin/sha3.c
  sha3_jit="$(verb "$sha3_source" | jit_c)"
  unset sha3_source
}

setup_hooks="$setup_hooks${newline}sha3_setup"
17b94d7782eee6bcf42fa454add973958ee2388c8e0126b68956b3475a9bb0e9
main "$@"
