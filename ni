#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/buffer#;
$V=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$W=[$f,$V];
$X=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/buffer#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/cat#;
$j1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$k1=[$f,$j1];
$l1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/cat#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/exec#;
$v1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$w1=[$f,$v1];
$x1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$y1=[$i,$x1];
$z1=[];
$A1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[$w1,$y1,$C1];
$E1=q#/io/exec#;
$F1=bless({$e,$D1,$D,$E1},$F);
$G1=q#ni.doc:/io/mio#;
$H1=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$I1=[$f,$H1];
$J1=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$K1=q#
      #;
$L1=[$i,$J1,$K1];
$M1=[$I1,$L1];
$N1=q#/io/mio#;
$O1=bless({$e,$M1,$D,$N1},$F);
$P1=q#ni.doc:/io/pid#;
$Q1=[];
$R1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$S1=bless({$o,$Q1,$q,$R1,$s,$t},$u);
$T1=[$n,$S1];
$U1=[];
$V1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$W1=bless({$o,$U1,$q,$V1,$s,$t},$u);
$X1=[$n,$W1];
$Y1=[];
$Z1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$c2=bless({$o,$Y1,$q,$Z1,$s,$t},$u);
$d2=[$n,$c2];
$e2=[$T1,$X1,$d2];
$f2=q#/io/pid#;
$g2=bless({$e,$e2,$D,$f2},$F);
$h2=q#ni.doc:/lib#;
$i2=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$j2=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$k2=[$i,$i2,$j2];
$l2=[$k2];
$m2=q#/lib#;
$n2=bless({$e,$l2,$D,$m2},$F);
$o2=q#ni.doc:/lib/doc#;
$p2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$q2=[$f,$p2];
$r2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$s2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$t2=[];
$u2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$v2=bless({$o,$t2,$q,$u2,$s,$t},$u);
$w2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$x2=[];
$y2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$z2=bless({$o,$x2,$q,$y2,$s,$t},$u);
$A2=[$i,$r2,$s2,$n,$v2,$w2,$n,$z2];
$B2=[$q2,$A2];
$C2=q#/lib/doc#;
$D2=bless({$e,$B2,$D,$C2},$F);
$E2=q#ni.doc:/semantic#;
$F2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$G2=[$i,$F2];
$H2=[$G2];
$I2=q#/semantic#;
$J2=bless({$e,$H2,$D,$I2},$F);
$K2=q#ni:/class#;
$L2=q#applied_to#;
$M2=q#class#;
$N2=q#class.c#;
$O2=q#fabric/rmi.c#;
$P2=q#io/buffer.c#;
$Q2=q#io/cat.c#;
$R2=q#io/exec.c#;
$S2=q#io/fd.c#;
$T2=q#io/file.c#;
$U2=q#io/mio.c#;
$V2=q#io/mio_channel.c#;
$W2=q#io/null.c#;
$X2=q#io/object.c#;
$Y2=q#io/pid.c#;
$Z2=q#io/str.c#;
$c3=q#io/transfer.c#;
$d3=q#io/transfer_async.c#;
$e3=q#io/transfer_sync.c#;
$f3=q#lib/behavior.c#;
$g3=q#lib/branch.c#;
$h3=q#lib/dataslice.c#;
$i3=q#lib/doc.c#;
$j3=q#lib/fn.c#;
$k3=q#lib/image.c#;
$l3=q#lib/ni.c#;
$m3=q#lib/quote_simple.c#;
$n3=q#lib/slice.c#;
$o3=q#lib/tag.c#;
$p3=q#lib/test_value.c#;
$q3=q#metaclass.c#;
$r3=q#module.c#;
$s3=q#object.c#;
$t3=q#semantic/dimension#;
$u3=q#semantic/dimension.c#;
$v3=q#semantic/task.c#;
$w3={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$x3=q#slices#;
$y3=q#metaclass#;
$z3=q#module#;
$A3={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$B3=q#/module#;
$C3=q#/lib/perlbranch.b#;
$D3={};
$E3=q#ctor#;
$F3=undef;
$G3=q#dtor#;
$H3=q#methods#;
$I3=q#add#;
$J3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$K3=bless({$q,$J3,$s,$t},$u);
$L3=q#apply#;
$M3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3={$I3,$K3,$L3,$N3};
$P3=q#/lib/branch.b#;
$Q3=q#lib/slice#;
$R3=bless({$L2,$D3,$E3,$F3,$G3,$F3,$H3,$O3,$D,$P3},$Q3);
$S3=q#lib/branch#;
$T3=q#lib/slice::ctors#;
$U3={};
$V3=q#my $s = shift; ni->def($s->name, $s)#;
$W3=bless({$q,$V3,$s,$t},$u);
$X3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$Y3=bless({$q,$X3,$s,$t},$u);
$Z3={$D,$Y3};
$c4=q#/lib/named.b#;
$d4=bless({$L2,$U3,$E3,$W3,$G3,$F3,$H3,$Z3,$D,$c4},$Q3);
$e4=q#lib/tag#;
$f4={};
$g4=q#namespace#;
$h4=q#'ni'#;
$i4=bless({$q,$h4,$s,$t},$u);
$j4={$g4,$i4};
$k4=q#/lib/named_in_ni.b#;
$l4=bless({$L2,$f4,$E3,$F3,$G3,$F3,$H3,$j4,$D,$k4},$Q3);
$m4={};
$n4=q#package#;
$o4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$p4=bless({$q,$o4,$s,$t},$u);
$q4={$n4,$p4};
$r4=q#/lib/namespaced.b#;
$s4=bless({$L2,$m4,$E3,$F3,$G3,$F3,$H3,$q4,$D,$r4},$Q3);
$t4={};
$u4=q#resolve#;
$v4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4={$u4,$w4};
$y4=q#/lib/resolver.b#;
$z4=bless({$L2,$t4,$E3,$F3,$G3,$F3,$H3,$x4,$D,$y4},$Q3);
$A4=[$R3,$d4,$l4,$s4,$z4];
$B4=bless({$D,$C3,$x3,$A4},$e4);
$C4=q#lib/tag::ctors#;
$D4={};
$E4=q#my $s = shift; $s->apply($s->package)#;
$F4=bless({$q,$E4,$s,$t},$u);
$G4=q#instantiate#;
$H4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$I4=bless({$q,$H4,$s,$t},$u);
$J4={$G4,$I4};
$K4=q#/lib/class_init.b#;
$L4=bless({$L2,$D4,$E3,$F4,$G3,$F3,$H3,$J4,$D,$K4},$Q3);
$M4=q#fabric/rmi#;
$N4=q#io/buffer#;
$O4=q#io/cat#;
$P4=q#io/exec#;
$Q4=q#io/fd#;
$R4=q#io/file#;
$S4=q#io/mio#;
$T4=q#io/mio_channel#;
$U4=q#io/null#;
$V4=q#io/object#;
$W4=q#io/pid#;
$X4=q#io/str#;
$Y4=q#io/transfer#;
$Z4=q#io/transfer_async#;
$c5=q#io/transfer_sync#;
$d5=q#lib/behavior#;
$e5=q#lib/dataslice#;
$f5=q#lib/image#;
$g5=q#lib/ni#;
$h5=q#lib/quote_simple#;
$i5=q#lib/test_value#;
$j5=q#object#;
$k5=q#semantic/task#;
$l5={$M2,1,$N2,1,$M4,1,$O2,1,$N4,1,$P2,1,$O4,1,$Q2,1,$P4,1,$R2,1,$Q4,1,$S2,1,$R4,1,$T2,1,$S4,1,$U2,1,$T4,1,$V2,1,$U4,1,$W2,1,$V4,1,$X2,1,$W4,1,$Y2,1,$X4,1,$Z2,1,$Y4,1,$c3,1,$Z4,1,$d3,1,$c5,1,$e3,1,$d5,1,$f3,1,$S3,1,$g3,1,$e5,1,$h3,1,$F,1,$i3,1,$u,1,$j3,1,$f5,1,$k3,1,$g5,1,$l3,1,$h5,1,$m3,1,$Q3,1,$n3,1,$e4,1,$o3,1,$i5,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$j5,1,$s3,1,$t3,1,$u3,1,$k5,1,$v3,1};
$m5=q#/object#;
$n5={};
$o5=q#ni 'ni:/' . ref shift#;
$p5=bless({$q,$o5,$s,$t},$u);
$q5={$M2,$p5};
$r5=q#/lib/instance.b#;
$s5=bless({$L2,$n5,$E3,$F3,$G3,$F3,$H3,$q5,$D,$r5},$Q3);
$t5=[$s5];
$u5=bless({$L2,$l5,$D,$m5,$x3,$t5},$s3);
$v5=q#object.c::ctors#;
$w5={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$d5,1,$f3,1,$S3,1,$g3,1,$e5,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$Q3,1,$n3,1,$e4,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$x5=q#/lib/behavior#;
$y5={};
$z5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$A5=bless({$q,$z5,$s,$t},$u);
$B5={$e,$A5};
$C5=q#/lib/documentable.b#;
$D5=bless({$L2,$y5,$E3,$F3,$G3,$F3,$H3,$B5,$D,$C5},$Q3);
$E5=[$u5,$D5];
$F5=bless({$L2,$w5,$D,$x5,$x3,$E5},$f3);
$G5=q#lib/behavior.c::ctors#;
$H5={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$S3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$I5=q#/lib/definition.b#;
$J5={};
$K5=q#def#;
$L5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/definition_def.b#;
$P5=bless({$L2,$J5,$E3,$F3,$G3,$F3,$H3,$N5,$D,$O5},$Q3);
$Q5={};
$R5=q#ro#;
$S5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$T5=bless({$q,$S5,$s,$t},$u);
$U5=q#rw#;
$V5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$W5=bless({$q,$V5,$s,$t},$u);
$X5={$R5,$T5,$U5,$W5};
$Y5=q#/lib/accessor.b#;
$Z5=bless({$L2,$Q5,$E3,$F3,$G3,$F3,$H3,$X5,$D,$Y5},$Q3);
$c6={};
$d6=q#(""#;
$e6=q#shift->name#;
$f6=bless({$q,$e6,$s,$t},$u);
$g6={$d6,$f6};
$h6=q#/lib/name_as_string.b#;
$i6=bless({$L2,$c6,$E3,$F3,$G3,$F3,$H3,$g6,$D,$h6},$Q3);
$j6={};
$k6=q#(eq#;
$l6=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$m6=bless({$q,$l6,$s,$t},$u);
$n6={$k6,$m6};
$o6=q#/lib/ref_eq.b#;
$p6=bless({$L2,$j6,$E3,$F3,$G3,$F3,$H3,$n6,$D,$o6},$Q3);
$q6={};
$r6=q#defdata#;
$s6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$t6=bless({$q,$s6,$s,$t},$u);
$u6={$r6,$t6};
$v6=q#/lib/definition_defdata.b#;
$w6=bless({$L2,$q6,$E3,$F3,$G3,$F3,$H3,$u6,$D,$v6},$Q3);
$x6=[$P5,$Z5,$i6,$p6,$w6];
$y6=bless({$L2,$H5,$D,$I5,$x3,$x6},$S3);
$z6=q#lib/branch::ctors#;
$A6=[$B4,$L4,$u5,$F5,$y6];
$B6=bless({$L2,$A3,$D,$B3,$x3,$A6},$r3);
$C6=q#module.c::ctors#;
$D6={};
$E6=q#DESTROY#;
$F6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$G6=bless({$q,$F6,$s,$t},$u);
$H6=q#new#;
$I6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$J6=bless({$q,$I6,$s,$t},$u);
$K6={$E6,$G6,$H6,$J6};
$L6=q#/lib/instantiable.b#;
$M6=bless({$L2,$D6,$H3,$K6,$D,$L6},$Q3);
$N6={};
$O6=q#child#;
$P6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$Q6=bless({$q,$P6,$s,$t},$u);
$R6={$O6,$Q6};
$S6=q#/lib/subclass.b#;
$T6=bless({$L2,$N6,$E3,$F3,$G3,$F3,$H3,$R6,$D,$S6},$Q3);
$U6=[$B6,$M6,$L4,$B6,$T6];
$V6=bless({$L2,$w3,$D,$E,$x3,$U6},$N2);
$W6=q#class.c::ctors#;
$X6=q#ni:/class.c#;
$Y6={$N2,1,$u3,1};
$Z6=q#/class.c#;
$c7={$N2,1,$r3,1,$u3,1};
$d7=q#/module.c#;
$e7={$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$r3,1,$s3,1,$u3,1,$v3,1};
$f7=q#/object.c#;
$g7=[$V6];
$h7=bless({$L2,$e7,$D,$f7,$x3,$g7},$y3);
$i7=q#metaclass::ctors#;
$j7={$N2,1,$f3,1,$g3,1,$h3,1,$n3,1,$o3,1,$r3,1,$u3,1};
$k7=q#/lib/behavior.c#;
$l7=[$h7];
$m7=bless({$L2,$j7,$D,$k7,$x3,$l7},$y3);
$n7=[$h7,$M6,$m7];
$o7=bless({$L2,$c7,$D,$d7,$x3,$n7},$y3);
$p7=[$o7];
$q7=bless({$L2,$Y6,$D,$Z6,$x3,$p7},$y3);
$r7=q#ni:/fabric/rmi#;
$s7={$M4,1};
$t7=q#/fabric/rmi#;
$u7={};
$v7=[];
$w7=q#my ($class, $io, $quote) = @_;#;
$x7=bless({$o,$v7,$q,$w7,$s,$t},$u);
$y7={$G4,$x7};
$z7=q#/fabric/rmi_init.b#;
$A7=bless({$L2,$u7,$E3,$F3,$G3,$F3,$H3,$y7,$D,$z7},$Q3);
$B7=[$u5,$A7];
$C7=bless({$L2,$s7,$D,$t7,$x3,$B7},$O2);
$D7=q#fabric/rmi.c::ctors#;
$E7=q#ni:/fabric/rmi.c#;
$F7={$O2,1};
$G7=q#/fabric/rmi.c#;
$H7=[$h7];
$I7=bless({$L2,$F7,$D,$G7,$x3,$H7},$y3);
$J7=q#ni:/fabric/rmi_init.b#;
$K7=q#ni:/io/buffer#;
$L7={$N4,1};
$M7={$N4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1,$T4,1,$U4,1,$V4,1,$W4,1,$X4,1};
$N7=q#/io/object#;
$O7={};
$P7=q#(bool#;
$Q7=[];
$R7=bless({$o,$Q7,$q,1,$s,$t},$u);
$S7={$P7,$R7};
$T7=q#/io/object_ops.b#;
$U7=bless({$L2,$O7,$E3,$F3,$G3,$F3,$H3,$S7,$D,$T7},$Q3);
$V7={};
$W7=q#die#;
$X7=[];
$Y7=q#shift; die join " ", @_#;
$Z7=bless({$o,$X7,$q,$Y7,$s,$t},$u);
$c8=q#io_check#;
$d8=[];
$e8=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$f8=bless({$o,$d8,$q,$e8,$s,$t},$u);
$g8=q#io_check_defined#;
$h8=[];
$i8=q#shift->io_check(sub {defined shift}, @_)#;
$j8=bless({$o,$h8,$q,$i8,$s,$t},$u);
$k8=q#io_check_true#;
$l8=[];
$m8=q#shift->io_check(sub {shift}, @_)#;
$n8=bless({$o,$l8,$q,$m8,$s,$t},$u);
$o8={$W7,$Z7,$c8,$f8,$g8,$j8,$k8,$n8};
$p8=q#/io/object_checks.b#;
$q8=bless({$L2,$V7,$E3,$F3,$G3,$F3,$H3,$o8,$D,$p8},$Q3);
$r8={};
$s8=q#(+#;
$t8=[];
$u8=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$v8=bless({$o,$t8,$q,$u8,$s,$t},$u);
$w8={$s8,$v8};
$x8=q#/io/object_constructors.b#;
$y8=bless({$L2,$r8,$E3,$F3,$G3,$F3,$H3,$w8,$D,$x8},$Q3);
$z8={};
$A8=q#read_all#;
$B8=[];
$C8=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$D8=bless({$o,$B8,$q,$C8,$s,$t},$u);
$E8=q#write_all#;
$F8=[];
$G8=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_async($self);#;
$H8=bless({$o,$F8,$q,$G8,$s,$t},$u);
$I8={$A8,$D8,$E8,$H8};
$J8=q#/io/object_memory.b#;
$K8=bless({$L2,$z8,$E3,$F3,$G3,$F3,$H3,$I8,$D,$J8},$Q3);
$L8={};
$M8=q#connect_sync#;
$N8=[];
$O8=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$P8=bless({$o,$N8,$q,$O8,$s,$t},$u);
$Q8=q#into_sync#;
$R8=[];
$S8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$T8=bless({$o,$R8,$q,$S8,$s,$t},$u);
$U8={$M8,$P8,$Q8,$T8};
$V8=q#/io/object_transfer_sync.b#;
$W8=bless({$L2,$L8,$E3,$F3,$G3,$F3,$H3,$U8,$D,$V8},$Q3);
$X8={};
$Y8=q#connect_async#;
$Z8=[];
$c9=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$d9=bless({$o,$Z8,$q,$c9,$s,$t},$u);
$e9=q#into_async#;
$f9=[];
$g9=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$h9=bless({$o,$f9,$q,$g9,$s,$t},$u);
$i9={$Y8,$d9,$e9,$h9};
$j9=q#/io/object_transfer_async.b#;
$k9=bless({$L2,$X8,$E3,$F3,$G3,$F3,$H3,$i9,$D,$j9},$Q3);
$l9=[$u5,$U7,$q8,$y8,$K8,$W8,$k9,$k9,$W8];
$m9=bless({$L2,$M7,$D,$N7,$x3,$l9},$X2);
$n9=q#io/object.c::ctors#;
$o9={};
$p9=[];
$q9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$r9=bless({$o,$p9,$q,$q9,$s,$t},$u);
$s9={$G4,$r9};
$t9=q#/io/buffer_init.b#;
$u9=bless({$L2,$o9,$E3,$F3,$G3,$F3,$H3,$s9,$D,$t9},$Q3);
$v9={};
$w9=q#read#;
$x9=[];
$y9=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9=q#read_capacity#;
$B9=[];
$C9=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$D9=bless({$o,$B9,$q,$C9,$s,$t},$u);
$E9=q#write#;
$F9=[];
$G9=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$H9=bless({$o,$F9,$q,$G9,$s,$t},$u);
$I9=q#write_capacity#;
$J9=[];
$K9=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$L9=bless({$o,$J9,$q,$K9,$s,$t},$u);
$M9={$w9,$z9,$A9,$D9,$E9,$H9,$I9,$L9};
$N9=q#/io/buffer_io.b#;
$O9=bless({$L2,$v9,$E3,$F3,$G3,$F3,$H3,$M9,$D,$N9},$Q3);
$P9=[$m9,$u9,$O9];
$Q9=bless({$L2,$L7,$D,$g1,$x3,$P9},$P2);
$R9=q#io/buffer.c::ctors#;
$S9=q#ni:/io/buffer.c#;
$T9={$P2,1};
$U9=q#/io/buffer.c#;
$V9={$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1};
$W9=q#/io/object.c#;
$X9={};
$Y9=q#def_transfer_method#;
$Z9=[];
$ca=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$da=bless({$o,$Z9,$q,$ca,$s,$t},$u);
$ea={$Y9,$da};
$fa=q#/io/object.c_transfer_def.b#;
$ga=bless({$L2,$X9,$E3,$F3,$G3,$F3,$H3,$ea,$D,$fa},$Q3);
$ha=[$h7,$ga];
$ia=bless({$L2,$V9,$D,$W9,$x3,$ha},$y3);
$ja=[$ia];
$ka=bless({$L2,$T9,$D,$U9,$x3,$ja},$y3);
$la=q#ni:/io/buffer_init.b#;
$ma=q#ni:/io/buffer_io.b#;
$na=q#ni:/io/cat#;
$oa={$O4,1};
$pa={};
$qa=[];
$ra=q#shift; +{fs => [@_]}#;
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta={$G4,$sa};
$ua=q#/io/cat_init.b#;
$va=bless({$L2,$pa,$E3,$F3,$G3,$F3,$H3,$ta,$D,$ua},$Q3);
$wa={};
$xa=[];
$ya=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$za=bless({$o,$xa,$q,$ya,$s,$t},$u);
$Aa={$w9,$za};
$Ba=q#/io/cat_read.b#;
$Ca=bless({$L2,$wa,$E3,$F3,$G3,$F3,$H3,$Aa,$D,$Ba},$Q3);
$Da=[$m9,$va,$Ca];
$Ea=bless({$L2,$oa,$D,$s1,$x3,$Da},$Q2);
$Fa=q#io/cat.c::ctors#;
$Ga=q#ni:/io/cat.c#;
$Ha={$Q2,1};
$Ia=q#/io/cat.c#;
$Ja=[$ia];
$Ka=bless({$L2,$Ha,$D,$Ia,$x3,$Ja},$y3);
$La=q#ni:/io/cat_init.b#;
$Ma=q#ni:/io/cat_read.b#;
$Na=q#ni:/io/exec#;
$Oa={$P4,1};
$Pa={};
$Qa=q#argv#;
$Ra=[];
$Sa=q#shift->{'argv'}#;
$Ta=bless({$o,$Ra,$q,$Sa,$s,$t},$u);
$Ua={$Qa,$Ta};
$Va=q#/io/exec_ro.b#;
$Wa=bless({$L2,$Pa,$E3,$F3,$G3,$F3,$H3,$Ua,$D,$Va},$Q3);
$Xa={};
$Ya=[];
$Za=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db={$G4,$cb};
$eb=q#/io/exec_init.b#;
$fb=bless({$L2,$Xa,$E3,$F3,$G3,$F3,$H3,$db,$D,$eb},$Q3);
$gb={};
$hb=q#connect#;
$ib=[];
$jb=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb=q#in_pipe#;
$mb=[];
$nb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#out_pipe#;
$qb=[];
$rb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#setup_stdio#;
$ub=[];
$vb=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb={$hb,$kb,$lb,$ob,$pb,$sb,$tb,$wb};
$yb=q#/io/exec_io_setup.b#;
$zb=bless({$L2,$gb,$E3,$F3,$G3,$F3,$H3,$xb,$D,$yb},$Q3);
$Ab={};
$Bb=q#binds_fd#;
$Cb=[];
$Db=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb=q#fd#;
$Gb=[];
$Hb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#stderr#;
$Kb=[];
$Lb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#stdin#;
$Ob=[];
$Pb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb=q#stdout#;
$Sb=[];
$Tb=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb={$Bb,$Eb,$Fb,$Ib,$Jb,$Mb,$Nb,$Qb,$Rb,$Ub};
$Wb=q#/io/exec_io_accessors.b#;
$Xb=bless({$L2,$Ab,$E3,$F3,$G3,$F3,$H3,$Vb,$D,$Wb},$Q3);
$Yb={};
$Zb=q#env#;
$cc=[];
$dc=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc={$Zb,$ec};
$gc=q#/io/exec_env.b#;
$hc=bless({$L2,$Yb,$E3,$F3,$G3,$F3,$H3,$fc,$D,$gc},$Q3);
$ic={};
$jc=q#exec#;
$kc=[];
$lc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc=q#fork#;
$oc=[];
$pc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc=q#move_fds#;
$sc=[];
$tc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$uc=bless({$o,$sc,$q,$tc,$s,$t},$u);
$vc={$jc,$mc,$nc,$qc,$rc,$uc};
$wc=q#/io/exec_fork.b#;
$xc=bless({$L2,$ic,$E3,$F3,$G3,$F3,$H3,$vc,$D,$wc},$Q3);
$yc=[$m9,$Wa,$fb,$zb,$Xb,$hc,$xc];
$zc=bless({$L2,$Oa,$D,$E1,$x3,$yc},$R2);
$Ac=q#io/exec.c::ctors#;
$Bc=q#ni:/io/exec.c#;
$Cc={$R2,1};
$Dc=q#/io/exec.c#;
$Ec=[$ia];
$Fc=bless({$L2,$Cc,$D,$Dc,$x3,$Ec},$y3);
$Gc=q#ni:/io/exec_env.b#;
$Hc=q#ni:/io/exec_fork.b#;
$Ic=q#ni:/io/exec_init.b#;
$Jc=q#ni:/io/exec_io_accessors.b#;
$Kc=q#ni:/io/exec_io_setup.b#;
$Lc=q#ni:/io/exec_ro.b#;
$Mc=q#ni:/io/fd#;
$Nc={$Q4,1};
$Oc=q#/io/fd#;
$Pc={};
$Qc=[];
$Rc=q#shift->{'fd'}#;
$Sc=bless({$o,$Qc,$q,$Rc,$s,$t},$u);
$Tc={$Fb,$Sc};
$Uc=q#/io/fd_readers.b#;
$Vc=bless({$L2,$Pc,$E3,$F3,$G3,$F3,$H3,$Tc,$D,$Uc},$Q3);
$Wc={};
$Xc=[];
$Yc=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd={$G4,$Zc};
$dd=q#/io/fd_init.b#;
$ed=bless({$L2,$Wc,$E3,$F3,$G3,$F3,$H3,$cd,$D,$dd},$Q3);
$fd={};
$gd=q#be#;
$hd=[];
$id=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$gd,$jd};
$ld=q#/io/fd_shell.b#;
$md=bless({$L2,$fd,$E3,$F3,$G3,$F3,$H3,$kd,$D,$ld},$Q3);
$nd={};
$od=q#cloexec#;
$pd=[];
$qd=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$rd=bless({$o,$pd,$q,$qd,$s,$t},$u);
$sd=q#fcntl_flag#;
$td=[];
$ud=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd=q#nonblock#;
$xd=[];
$yd=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$zd=bless({$o,$xd,$q,$yd,$s,$t},$u);
$Ad={$od,$rd,$sd,$vd,$wd,$zd};
$Bd=q#/io/fd_fcntl.b#;
$Cd=bless({$L2,$nd,$E3,$F3,$G3,$F3,$H3,$Ad,$D,$Bd},$Q3);
$Dd={};
$Ed=[];
$Fd=q#shift->close#;
$Gd=bless({$o,$Ed,$q,$Fd,$s,$t},$u);
$Hd=q#close#;
$Id=[];
$Jd=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Kd=bless({$o,$Id,$q,$Jd,$s,$t},$u);
$Ld={$Hd,$Kd};
$Md=q#/io/fd_gc.b#;
$Nd=bless({$L2,$Dd,$E3,$F3,$G3,$Gd,$H3,$Ld,$D,$Md},$Q3);
$Od={};
$Pd=[];
$Qd=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$Rd=bless({$o,$Pd,$q,$Qd,$s,$t},$u);
$Sd=[];
$Td=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$Ud=bless({$o,$Sd,$q,$Td,$s,$t},$u);
$Vd={$w9,$Rd,$E9,$Ud};
$Wd=q#/io/fd_perlio.b#;
$Xd=bless({$L2,$Od,$E3,$F3,$G3,$F3,$H3,$Vd,$D,$Wd},$Q3);
$Yd=[$m9,$Vc,$ed,$md,$Cd,$Nd,$Xd];
$Zd=bless({$L2,$Nc,$D,$Oc,$x3,$Yd},$S2);
$ce=q#io/fd.c::ctors#;
$de=q#ni:/io/fd.c#;
$ee={$S2,1};
$fe=q#/io/fd.c#;
$ge=[$ia];
$he=bless({$L2,$ee,$D,$fe,$x3,$ge},$y3);
$ie=q#ni:/io/fd_fcntl.b#;
$je=q#ni:/io/fd_gc.b#;
$ke=q#ni:/io/fd_init.b#;
$le=q#ni:/io/fd_perlio.b#;
$me=q#ni:/io/fd_readers.b#;
$ne=q#ni:/io/fd_shell.b#;
$oe=q#ni:/io/file#;
$pe={$R4,1};
$qe=q#/io/file#;
$re={};
$se=[];
$te=q#shift->{'name'}#;
$ue=bless({$o,$se,$q,$te,$s,$t},$u);
$ve={$D,$ue};
$we=q#/io/file_readers.b#;
$xe=bless({$L2,$re,$E3,$F3,$G3,$F3,$H3,$ve,$D,$we},$Q3);
$ye={};
$ze=q#mode#;
$Ae=[];
$Be=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Ce=bless({$o,$Ae,$q,$Be,$s,$t},$u);
$De={$ze,$Ce};
$Ee=q#/io/file_accessors.b#;
$Fe=bless({$L2,$ye,$E3,$F3,$G3,$F3,$H3,$De,$D,$Ee},$Q3);
$Ge={};
$He=[];
$Ie=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Je=bless({$o,$He,$q,$Ie,$s,$t},$u);
$Ke={$G4,$Je};
$Le=q#/io/file_init.b#;
$Me=bless({$L2,$Ge,$E3,$F3,$G3,$F3,$H3,$Ke,$D,$Le},$Q3);
$Ne={};
$Oe=[];
$Pe=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Qe=bless({$o,$Oe,$q,$Pe,$s,$t},$u);
$Re=q#r#;
$Se=[];
$Te=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ue=bless({$o,$Se,$q,$Te,$s,$t},$u);
$Ve=[];
$We=q#shift->r->read(@_)#;
$Xe=bless({$o,$Ve,$q,$We,$s,$t},$u);
$Ye=q#w#;
$Ze=[];
$cf=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$df=bless({$o,$Ze,$q,$cf,$s,$t},$u);
$ef=[];
$ff=q#shift->w->write(@_)#;
$gf=bless({$o,$ef,$q,$ff,$s,$t},$u);
$hf={$Hd,$Qe,$Re,$Ue,$w9,$Xe,$Ye,$df,$E9,$gf};
$if=q#/io/file_io.b#;
$jf=bless({$L2,$Ne,$E3,$F3,$G3,$F3,$H3,$hf,$D,$if},$Q3);
$kf=[$m9,$xe,$Fe,$Me,$jf];
$lf=bless({$L2,$pe,$D,$qe,$x3,$kf},$T2);
$mf=q#io/file.c::ctors#;
$nf=q#ni:/io/file.c#;
$of={$T2,1};
$pf=q#/io/file.c#;
$qf=[$ia];
$rf=bless({$L2,$of,$D,$pf,$x3,$qf},$y3);
$sf=q#ni:/io/file_accessors.b#;
$tf=q#ni:/io/file_init.b#;
$uf=q#ni:/io/file_io.b#;
$vf=q#ni:/io/file_readers.b#;
$wf=q#ni:/io/mio#;
$xf={$S4,1};
$yf={};
$zf=q#io#;
$Af=[];
$Bf=q#shift->{'io'}#;
$Cf=bless({$o,$Af,$q,$Bf,$s,$t},$u);
$Df=q#packet_size#;
$Ef=[];
$Ff=q#shift->{'packet_size'}#;
$Gf=bless({$o,$Ef,$q,$Ff,$s,$t},$u);
$Hf={$zf,$Cf,$Df,$Gf};
$If=q#/io/mio_ro.b#;
$Jf=bless({$L2,$yf,$E3,$F3,$G3,$F3,$H3,$Hf,$D,$If},$Q3);
$Kf={};
$Lf=[];
$Mf=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of={$G4,$Nf};
$Pf=q#/io/mio_init.b#;
$Qf=bless({$L2,$Kf,$E3,$F3,$G3,$F3,$H3,$Of,$D,$Pf},$Q3);
$Rf={};
$Sf=q#next_sender#;
$Tf=[];
$Uf=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$Vf=bless({$o,$Tf,$q,$Uf,$s,$t},$u);
$Wf={$Sf,$Vf};
$Xf=q#/io/mio_rr_scheduler.b#;
$Yf=bless({$L2,$Rf,$E3,$F3,$G3,$F3,$H3,$Wf,$D,$Xf},$Q3);
$Zf={};
$cg=[];
$dg=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$eg=bless({$o,$cg,$q,$dg,$s,$t},$u);
$fg=[];
$gg=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$hg=bless({$o,$fg,$q,$gg,$s,$t},$u);
$ig=[];
$jg=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;#;
$kg=bless({$o,$ig,$q,$jg,$s,$t},$u);
$lg={$Hd,$eg,$w9,$hg,$E9,$kg};
$mg=q#/io/mio_io.b#;
$ng=bless({$L2,$Zf,$E3,$F3,$G3,$F3,$H3,$lg,$D,$mg},$Q3);
$og={};
$pg=q#channel#;
$qg=[];
$rg=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$sg=bless({$o,$qg,$q,$rg,$s,$t},$u);
$tg=q#channels#;
$ug=[];
$vg=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$wg=bless({$o,$ug,$q,$vg,$s,$t},$u);
$xg=q#unchannel#;
$yg=[];
$zg=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$Ag=bless({$o,$yg,$q,$zg,$s,$t},$u);
$Bg={$pg,$sg,$tg,$wg,$xg,$Ag};
$Cg=q#/io/mio_channel.b#;
$Dg=bless({$L2,$og,$E3,$F3,$G3,$F3,$H3,$Bg,$D,$Cg},$Q3);
$Eg=[$m9,$Jf,$Qf,$Yf,$ng,$Dg];
$Fg=bless({$L2,$xf,$D,$N1,$x3,$Eg},$U2);
$Gg=q#io/mio.c::ctors#;
$Hg=q#ni:/io/mio.c#;
$Ig={$U2,1};
$Jg=q#/io/mio.c#;
$Kg=[$ia];
$Lg=bless({$L2,$Ig,$D,$Jg,$x3,$Kg},$y3);
$Mg=q#ni:/io/mio_channel#;
$Ng={$T4,1};
$Og=q#/io/mio_channel#;
$Pg={};
$Qg=q#capacity#;
$Rg=[];
$Sg=q#shift->{'capacity'}#;
$Tg=bless({$o,$Rg,$q,$Sg,$s,$t},$u);
$Ug=q#id#;
$Vg=[];
$Wg=q#shift->{'id'}#;
$Xg=bless({$o,$Vg,$q,$Wg,$s,$t},$u);
$Yg=q#mio#;
$Zg=[];
$ch=q#shift->{'mio'}#;
$dh=bless({$o,$Zg,$q,$ch,$s,$t},$u);
$eh={$Qg,$Tg,$Ug,$Xg,$Yg,$dh};
$fh=q#/io/mio_channel_ro.b#;
$gh=bless({$L2,$Pg,$E3,$F3,$G3,$F3,$H3,$eh,$D,$fh},$Q3);
$hh={};
$ih=[];
$jh=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$kh=bless({$o,$ih,$q,$jh,$s,$t},$u);
$lh={$G4,$kh};
$mh=q#/io/mio_channel_init.b#;
$nh=bless({$L2,$hh,$E3,$F3,$G3,$F3,$H3,$lh,$D,$mh},$Q3);
$oh={};
$ph=[];
$qh=bless({$o,$ph,$q,$Fd,$s,$t},$u);
$rh={};
$sh=q#/io/mio_channel_lifecycle.b#;
$th=bless({$L2,$oh,$E3,$F3,$G3,$qh,$H3,$rh,$D,$sh},$Q3);
$uh={};
$vh=[];
$wh=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$xh=bless({$o,$vh,$q,$wh,$s,$t},$u);
$yh=[];
$zh=q#shift->{read_buffer} ->read(@_)#;
$Ah=bless({$o,$yh,$q,$zh,$s,$t},$u);
$Bh=[];
$Ch=q#shift->{write_buffer}->write(@_)#;
$Dh=bless({$o,$Bh,$q,$Ch,$s,$t},$u);
$Eh={$Hd,$xh,$w9,$Ah,$E9,$Dh};
$Fh=q#/io/mio_channel_io.b#;
$Gh=bless({$L2,$uh,$E3,$F3,$G3,$F3,$H3,$Eh,$D,$Fh},$Q3);
$Hh=[$m9,$gh,$nh,$th,$Gh];
$Ih=bless({$L2,$Ng,$D,$Og,$x3,$Hh},$V2);
$Jh=q#io/mio_channel.c::ctors#;
$Kh=q#ni:/io/mio_channel.b#;
$Lh=q#ni:/io/mio_channel.c#;
$Mh={$V2,1};
$Nh=q#/io/mio_channel.c#;
$Oh=[$ia];
$Ph=bless({$L2,$Mh,$D,$Nh,$x3,$Oh},$y3);
$Qh=q#ni:/io/mio_channel_init.b#;
$Rh=q#ni:/io/mio_channel_io.b#;
$Sh=q#ni:/io/mio_channel_lifecycle.b#;
$Th=q#ni:/io/mio_channel_ro.b#;
$Uh=q#ni:/io/mio_init.b#;
$Vh=q#ni:/io/mio_io.b#;
$Wh=q#ni:/io/mio_ro.b#;
$Xh=q#ni:/io/mio_rr_scheduler.b#;
$Yh=q#ni:/io/named_io_fns.b#;
$Zh={};
$ci=q#fcntl#;
$di=[];
$ei=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$fi=bless({$o,$di,$q,$ei,$s,$t},$u);
$gi=[];
$hi=q#CORE::fork#;
$ii=bless({$o,$gi,$q,$hi,$s,$t},$u);
$ji=q#open2#;
$ki=[];
$li=q#CORE::open $_[0], $_[1]#;
$mi=bless({$o,$ki,$q,$li,$s,$t},$u);
$ni=q#waitpid#;
$oi=[];
$pi=q#CORE::waitpid $_[0], $_[1]#;
$qi=bless({$o,$oi,$q,$pi,$s,$t},$u);
$ri={$ci,$fi,$nc,$ii,$ji,$mi,$ni,$qi};
$si=q#/io/named_io_fns.b#;
$ti=bless({$L2,$Zh,$E3,$F3,$G3,$F3,$H3,$ri,$D,$si},$Q3);
$ui=q#main#;
$vi=q#ni:/io/null#;
$wi={$U4,1};
$xi=q#/io/null#;
$yi={};
$zi=[];
$Ai=q#+{fd => undef}#;
$Bi=bless({$o,$zi,$q,$Ai,$s,$t},$u);
$Ci={$G4,$Bi};
$Di=q#/io/null_init.b#;
$Ei=bless({$L2,$yi,$E3,$F3,$G3,$F3,$H3,$Ci,$D,$Di},$Q3);
$Fi={};
$Gi=[];
$Hi=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Ii=bless({$o,$Gi,$q,$Hi,$s,$t},$u);
$Ji=[];
$Ki=q#shift->fd->read(@_)#;
$Li=bless({$o,$Ji,$q,$Ki,$s,$t},$u);
$Mi=[];
$Ni=q#shift->fd->write(@_)#;
$Oi=bless({$o,$Mi,$q,$Ni,$s,$t},$u);
$Pi={$Fb,$Ii,$w9,$Li,$E9,$Oi};
$Qi=q#/io/null_io.b#;
$Ri=bless({$L2,$Fi,$E3,$F3,$G3,$F3,$H3,$Pi,$D,$Qi},$Q3);
$Si=[$m9,$Ei,$Ri];
$Ti=bless({$L2,$wi,$D,$xi,$x3,$Si},$W2);
$Ui=q#io/null.c::ctors#;
$Vi=q#ni:/io/null.c#;
$Wi={$W2,1};
$Xi=q#/io/null.c#;
$Yi=[$ia];
$Zi=bless({$L2,$Wi,$D,$Xi,$x3,$Yi},$y3);
$cj=q#ni:/io/null_init.b#;
$dj=q#ni:/io/null_io.b#;
$ej=q#ni:/io/object#;
$fj=q#ni:/io/object.c#;
$gj=q#ni:/io/object.c_transfer_def.b#;
$hj=q#ni:/io/object_checks.b#;
$ij=q#ni:/io/object_constructors.b#;
$jj=q#ni:/io/object_memory.b#;
$kj=q#ni:/io/object_ops.b#;
$lj=q#ni:/io/object_transfer_async.b#;
$mj=q#ni:/io/object_transfer_sync.b#;
$nj=q#ni:/io/pid#;
$oj={$W4,1};
$pj={};
$qj=q#pid#;
$rj=[];
$sj=q#shift->{'pid'}#;
$tj=bless({$o,$rj,$q,$sj,$s,$t},$u);
$uj=q#status#;
$vj=[];
$wj=q#shift->{'status'}#;
$xj=bless({$o,$vj,$q,$wj,$s,$t},$u);
$yj={$qj,$tj,$uj,$xj};
$zj=q#/io/pid_readers.b#;
$Aj=bless({$L2,$pj,$E3,$F3,$G3,$F3,$H3,$yj,$D,$zj},$Q3);
$Bj={};
$Cj=[];
$Dj=q#shift->await#;
$Ej=bless({$o,$Cj,$q,$Dj,$s,$t},$u);
$Fj=[];
$Gj=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Hj=bless({$o,$Fj,$q,$Gj,$s,$t},$u);
$Ij={$G4,$Hj};
$Jj=q#/io/pid_init.b#;
$Kj=bless({$L2,$Bj,$E3,$F3,$G3,$Ej,$H3,$Ij,$D,$Jj},$Q3);
$Lj={};
$Mj=q#await#;
$Nj=[];
$Oj=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Pj=bless({$o,$Nj,$q,$Oj,$s,$t},$u);
$Qj=q#running#;
$Rj=[];
$Sj=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Tj=bless({$o,$Rj,$q,$Sj,$s,$t},$u);
$Uj={$Mj,$Pj,$Qj,$Tj};
$Vj=q#/io/pid_wait.b#;
$Wj=bless({$L2,$Lj,$E3,$F3,$G3,$F3,$H3,$Uj,$D,$Vj},$Q3);
$Xj={};
$Yj=[];
$Zj=q#shift->stdout->read(@_)#;
$ck=bless({$o,$Yj,$q,$Zj,$s,$t},$u);
$dk=[];
$ek=q#shift->stdin->write(@_)#;
$fk=bless({$o,$dk,$q,$ek,$s,$t},$u);
$gk={$w9,$ck,$E9,$fk};
$hk=q#/io/pid_io.b#;
$ik=bless({$L2,$Xj,$E3,$F3,$G3,$F3,$H3,$gk,$D,$hk},$Q3);
$jk={};
$kk=[];
$lk=q#$_[0]->{external_fds}{$_[1]}#;
$mk=bless({$o,$kk,$q,$lk,$s,$t},$u);
$nk=[];
$ok=q#shift->fd(2)#;
$pk=bless({$o,$nk,$q,$ok,$s,$t},$u);
$qk=[];
$rk=q#shift->fd(0)#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk=[];
$uk=q#shift->fd(1)#;
$vk=bless({$o,$tk,$q,$uk,$s,$t},$u);
$wk={$Fb,$mk,$Jb,$pk,$Nb,$sk,$Rb,$vk};
$xk=q#/io/pid_accessors.b#;
$yk=bless({$L2,$jk,$E3,$F3,$G3,$F3,$H3,$wk,$D,$xk},$Q3);
$zk=[$m9,$Aj,$Kj,$Wj,$ik,$yk];
$Ak=bless({$L2,$oj,$D,$f2,$x3,$zk},$Y2);
$Bk=q#io/pid.c::ctors#;
$Ck=q#ni:/io/pid.c#;
$Dk={$Y2,1};
$Ek=q#/io/pid.c#;
$Fk=[$ia];
$Gk=bless({$L2,$Dk,$D,$Ek,$x3,$Fk},$y3);
$Hk=q#ni:/io/pid_accessors.b#;
$Ik=q#ni:/io/pid_init.b#;
$Jk=q#ni:/io/pid_io.b#;
$Kk=q#ni:/io/pid_readers.b#;
$Lk=q#ni:/io/pid_wait.b#;
$Mk=q#ni:/io/str#;
$Nk={$X4,1};
$Ok=q#/io/str#;
$Pk={};
$Qk=q#data#;
$Rk=[];
$Sk=q#shift->{'data'}#;
$Tk=bless({$o,$Rk,$q,$Sk,$s,$t},$u);
$Uk=q#end#;
$Vk=[];
$Wk=q#shift->{'end'}#;
$Xk=bless({$o,$Vk,$q,$Wk,$s,$t},$u);
$Yk=q#start#;
$Zk=[];
$cl=q#shift->{'start'}#;
$dl=bless({$o,$Zk,$q,$cl,$s,$t},$u);
$el={$Qk,$Tk,$Uk,$Xk,$Yk,$dl};
$fl=q#/io/str_ro.b#;
$gl=bless({$L2,$Pk,$E3,$F3,$G3,$F3,$H3,$el,$D,$fl},$Q3);
$hl={};
$il=[];
$jl=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$kl=bless({$o,$il,$q,$jl,$s,$t},$u);
$ll={$G4,$kl};
$ml=q#/io/str_init.b#;
$nl=bless({$L2,$hl,$E3,$F3,$G3,$F3,$H3,$ll,$D,$ml},$Q3);
$ol={};
$pl=[];
$ql=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl=q#remaining#;
$tl=[];
$ul=q#my $self = shift; $$self{end} - $$self{start}#;
$vl=bless({$o,$tl,$q,$ul,$s,$t},$u);
$wl=[];
$xl=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$yl=bless({$o,$wl,$q,$xl,$s,$t},$u);
$zl={$w9,$rl,$sl,$vl,$E9,$yl};
$Al=q#/io/str_io.b#;
$Bl=bless({$L2,$ol,$E3,$F3,$G3,$F3,$H3,$zl,$D,$Al},$Q3);
$Cl=[$m9,$gl,$nl,$Bl];
$Dl=bless({$L2,$Nk,$D,$Ok,$x3,$Cl},$Z2);
$El=q#io/str.c::ctors#;
$Fl=q#ni:/io/str.c#;
$Gl={$Z2,1};
$Hl=q#/io/str.c#;
$Il=[$ia];
$Jl=bless({$L2,$Gl,$D,$Hl,$x3,$Il},$y3);
$Kl=q#ni:/io/str_init.b#;
$Ll=q#ni:/io/str_io.b#;
$Ml=q#ni:/io/str_ro.b#;
$Nl=q#ni:/io/transfer#;
$Ol={$Y4,1,$Z4,1,$c5,1};
$Pl=q#/io/transfer#;
$Ql={$Y4,1,$Z4,1,$c5,1,$k5,1};
$Rl=q#/semantic/task#;
$Sl={};
$Tl=q#outcome#;
$Ul=[];
$Vl=q#shift->{'outcome'}#;
$Wl=bless({$o,$Ul,$q,$Vl,$s,$t},$u);
$Xl={$Tl,$Wl};
$Yl=q#/semantic/task_ro.b#;
$Zl=bless({$L2,$Sl,$E3,$F3,$G3,$F3,$H3,$Xl,$D,$Yl},$Q3);
$cm={};
$dm=q#failure#;
$em=[];
$fm=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$gm=bless({$o,$em,$q,$fm,$s,$t},$u);
$hm=q#success#;
$im=[];
$jm=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$km=bless({$o,$im,$q,$jm,$s,$t},$u);
$lm={$dm,$gm,$hm,$km};
$mm=q#/semantic/task_outcome.b#;
$nm=bless({$L2,$cm,$E3,$F3,$G3,$F3,$H3,$lm,$D,$mm},$Q3);
$om=[$u5,$Zl,$nm];
$pm=bless({$L2,$Ql,$D,$Rl,$x3,$om},$v3);
$qm=q#semantic/task.c::ctors#;
$rm={};
$sm=[];
$tm=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$um=bless({$o,$sm,$q,$tm,$s,$t},$u);
$vm=[];
$wm=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$xm=bless({$o,$vm,$q,$wm,$s,$t},$u);
$ym=[];
$zm=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Am=bless({$o,$ym,$q,$zm,$s,$t},$u);
$Bm={$w9,$xm,$E9,$Am};
$Cm=q#/io/transfer_io_interop.b#;
$Dm=bless({$L2,$rm,$E3,$um,$G3,$F3,$H3,$Bm,$D,$Cm},$Q3);
$Em={};
$Fm=q#pressure#;
$Gm=[];
$Hm=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$Im=bless({$o,$Gm,$q,$Hm,$s,$t},$u);
$Jm=q#read_limit_throughput#;
$Km=[];
$Lm=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$Mm=bless({$o,$Km,$q,$Lm,$s,$t},$u);
$Nm=q#throughput#;
$Om=[];
$Pm=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$Qm=bless({$o,$Om,$q,$Pm,$s,$t},$u);
$Rm=q#write_limit_throughput#;
$Sm=[];
$Tm=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$Um=bless({$o,$Sm,$q,$Tm,$s,$t},$u);
$Vm={$Fm,$Im,$Jm,$Mm,$Nm,$Qm,$Rm,$Um};
$Wm=q#/io/transfer_io_measurement.b#;
$Xm=bless({$L2,$Em,$E3,$F3,$G3,$F3,$H3,$Vm,$D,$Wm},$Q3);
$Ym=[$pm,$Dm,$Xm];
$Zm=bless({$L2,$Ol,$D,$Pl,$x3,$Ym},$c3);
$cn=q#io/transfer.c::ctors#;
$dn=q#ni:/io/transfer.c#;
$en={$c3,1,$d3,1,$e3,1};
$fn=q#/io/transfer.c#;
$gn={$c3,1,$d3,1,$e3,1,$v3,1};
$hn=q#/semantic/task.c#;
$in=[$h7];
$jn=bless({$L2,$gn,$D,$hn,$x3,$in},$y3);
$kn={};
$ln=[];
$mn=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$nn=bless({$o,$ln,$q,$mn,$s,$t},$u);
$on={};
$pn=q#/io/transfer.c_into.b#;
$qn=bless({$L2,$kn,$E3,$nn,$G3,$F3,$H3,$on,$D,$pn},$Q3);
$rn=[$jn,$qn];
$sn=bless({$L2,$en,$D,$fn,$x3,$rn},$y3);
$tn=q#ni:/io/transfer.c_into.b#;
$un=q#ni:/io/transfer_async#;
$vn={$Z4,1};
$wn=q#/io/transfer_async#;
$xn={};
$yn=q#dest_io#;
$zn=[];
$An=q#shift->{'dest_io'}#;
$Bn=bless({$o,$zn,$q,$An,$s,$t},$u);
$Cn=[];
$Dn=bless({$o,$Cn,$q,$Wg,$s,$t},$u);
$En=q#source_io#;
$Fn=[];
$Gn=q#shift->{'source_io'}#;
$Hn=bless({$o,$Fn,$q,$Gn,$s,$t},$u);
$In={$yn,$Bn,$Ug,$Dn,$En,$Hn};
$Jn=q#/io/transfer_async_ro.b#;
$Kn=bless({$L2,$xn,$E3,$F3,$G3,$F3,$H3,$In,$D,$Jn},$Q3);
$Ln={};
$Mn=[];
$Nn=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$On=bless({$o,$Mn,$q,$Nn,$s,$t},$u);
$Pn={$G4,$On};
$Qn=q#/io/transfer_async_init.b#;
$Rn=bless({$L2,$Ln,$E3,$F3,$G3,$F3,$H3,$Pn,$D,$Qn},$Q3);
$Sn={};
$Tn=[];
$Un=q#ni('ni:/io/transfer_async')->track(shift)#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn=[];
$Xn=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$Yn=bless({$o,$Wn,$q,$Xn,$s,$t},$u);
$Zn={};
$co=q#/io/transfer_async_lifecycle.b#;
$do=bless({$L2,$Sn,$E3,$Vn,$G3,$Yn,$H3,$Zn,$D,$co},$Q3);
$eo={};
$fo=q#run#;
$go=[];
$ho=q#shift#;
$io=bless({$o,$go,$q,$ho,$s,$t},$u);
$jo=q#run_async#;
$ko=[];
$lo=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$mo=bless({$o,$ko,$q,$lo,$s,$t},$u);
$no={$fo,$io,$jo,$mo};
$oo=q#/io/transfer_async_run.b#;
$po=bless({$L2,$eo,$E3,$F3,$G3,$F3,$H3,$no,$D,$oo},$Q3);
$qo=[$Zm,$Kn,$Rn,$do,$po];
$ro=q#tracked_transfers#;
$so={};
$to=bless({$L2,$vn,$D,$wn,$x3,$qo,$ro,$so},$d3);
$uo=q#io/transfer_async.c::ctors#;
$vo=q#ni:/io/transfer_async.c#;
$wo={$d3,1};
$xo=q#/io/transfer_async.c#;
$yo={};
$zo=[];
$Ao=q#shift->{tracked_transfers} = {}#;
$Bo=bless({$o,$zo,$q,$Ao,$s,$t},$u);
$Co=q#track#;
$Do=[];
$Eo=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go=q#untrack#;
$Ho=[];
$Io=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$Jo=bless({$o,$Ho,$q,$Io,$s,$t},$u);
$Ko={$Co,$Fo,$Go,$Jo};
$Lo=q#/io/transfer_async.c_tracker.b#;
$Mo=bless({$L2,$yo,$E3,$Bo,$G3,$F3,$H3,$Ko,$D,$Lo},$Q3);
$No=[$sn,$Mo];
$Oo=bless({$L2,$wo,$D,$xo,$x3,$No},$y3);
$Po=q#ni:/io/transfer_async.c_tracker.b#;
$Qo=q#ni:/io/transfer_async_init.b#;
$Ro=q#ni:/io/transfer_async_lifecycle.b#;
$So=q#ni:/io/transfer_async_ro.b#;
$To=q#ni:/io/transfer_async_run.b#;
$Uo=q#ni:/io/transfer_io_interop.b#;
$Vo=q#ni:/io/transfer_io_measurement.b#;
$Wo=q#ni:/io/transfer_sync#;
$Xo={$c5,1};
$Yo=q#/io/transfer_sync#;
$Zo={};
$cp=[];
$dp=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$ep=bless({$o,$cp,$q,$dp,$s,$t},$u);
$fp={$G4,$ep};
$gp=q#/io/transfer_sync_init.b#;
$hp=bless({$L2,$Zo,$E3,$F3,$G3,$F3,$H3,$fp,$D,$gp},$Q3);
$ip={};
$jp=[];
$kp=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$lp=bless({$o,$jp,$q,$kp,$s,$t},$u);
$mp={$fo,$lp};
$np=q#/io/transfer_sync_run.b#;
$op=bless({$L2,$ip,$E3,$F3,$G3,$F3,$H3,$mp,$D,$np},$Q3);
$pp=[$Zm,$hp,$op];
$qp=bless({$L2,$Xo,$D,$Yo,$x3,$pp},$e3);
$rp=q#io/transfer_sync.c::ctors#;
$sp=q#ni:/io/transfer_sync.c#;
$tp={$e3,1};
$up=q#/io/transfer_sync.c#;
$vp=[$sn];
$wp=bless({$L2,$tp,$D,$up,$x3,$vp},$y3);
$xp=q#ni:/io/transfer_sync_init.b#;
$yp=q#ni:/io/transfer_sync_run.b#;
$zp=q#ni:/lib/accessor.b#;
$Ap=q#ni:/lib/behavior#;
$Bp=q#ni:/lib/behavior.c#;
$Cp=q#ni:/lib/branch#;
$Dp={$S3,1};
$Ep=q#/lib/branch#;
$Fp={};
$Gp=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Hp=bless({$q,$Gp,$s,$t},$u);
$Ip={$G4,$Hp};
$Jp=q#/lib/branch_init.b#;
$Kp=bless({$L2,$Fp,$E3,$F3,$G3,$F3,$H3,$Ip,$D,$Jp},$Q3);
$Lp=[$F5,$d4,$R3,$Kp,$y6];
$Mp=bless({$L2,$Dp,$D,$Ep,$x3,$Lp},$g3);
$Np=q#lib/branch.c::ctors#;
$Op=q#ni:/lib/branch.b#;
$Pp=q#ni:/lib/branch.c#;
$Qp={$g3,1};
$Rp=q#/lib/branch.c#;
$Sp=[$m7];
$Tp=bless({$L2,$Qp,$D,$Rp,$x3,$Sp},$y3);
$Up=q#ni:/lib/branch_init.b#;
$Vp=q#ni:/lib/class_init.b#;
$Wp=q#ni:/lib/dataslice#;
$Xp={$e5,1};
$Yp=q#/lib/dataslice#;
$Zp={};
$cq=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$dq=bless({$q,$cq,$s,$t},$u);
$eq={$G4,$dq};
$fq=q#/lib/dataslice_init.b#;
$gq=bless({$L2,$Zp,$E3,$F3,$G3,$F3,$H3,$eq,$D,$fq},$Q3);
$hq={};
$iq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$jq=bless({$q,$iq,$s,$t},$u);
$kq={$L3,$jq};
$lq=q#/lib/dataslice_apply.b#;
$mq=bless({$L2,$hq,$E3,$F3,$G3,$F3,$H3,$kq,$D,$lq},$Q3);
$nq=[$F5,$gq,$mq];
$oq=bless({$L2,$Xp,$D,$Yp,$x3,$nq},$h3);
$pq=q#lib/dataslice.c::ctors#;
$qq=q#ni:/lib/dataslice.c#;
$rq={$h3,1};
$sq=q#/lib/dataslice.c#;
$tq=[$m7];
$uq=bless({$L2,$rq,$D,$sq,$x3,$tq},$y3);
$vq=q#ni:/lib/dataslice_apply.b#;
$wq=q#ni:/lib/dataslice_init.b#;
$xq=q#ni:/lib/definition.b#;
$yq=q#ni:/lib/definition_def.b#;
$zq=q#ni:/lib/definition_defdata.b#;
$Aq=q#ni:/lib/doc#;
$Bq={$F,1};
$Cq={};
$Dq=q#shift; +{name => shift, doc => []}#;
$Eq=bless({$q,$Dq,$s,$t},$u);
$Fq={$G4,$Eq};
$Gq=q#/lib/doc_init.b#;
$Hq=bless({$L2,$Cq,$E3,$F3,$G3,$F3,$H3,$Fq,$D,$Gq},$Q3);
$Iq={};
$Jq=q#'ni.doc'#;
$Kq=bless({$q,$Jq,$s,$t},$u);
$Lq={$g4,$Kq};
$Mq=q#/lib/doc_namespace.b#;
$Nq=bless({$L2,$Iq,$E3,$F3,$G3,$F3,$H3,$Lq,$D,$Mq},$Q3);
$Oq={};
$Pq=q#AUTOLOAD#;
$Qq=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Rq=bless({$q,$Qq,$s,$t},$u);
$Sq={$Pq,$Rq};
$Tq=q#/lib/doc_define.b#;
$Uq=bless({$L2,$Oq,$E3,$F3,$G3,$F3,$H3,$Sq,$D,$Tq},$Q3);
$Vq={};
$Wq=q#shift->referent#;
$Xq=bless({$q,$Wq,$s,$t},$u);
$Yq=q#referent#;
$Zq=q#ni 'ni:' . shift->{name}#;
$cr=bless({$q,$Zq,$s,$t},$u);
$dr={$Uk,$Xq,$Yq,$cr};
$er=q#/lib/doc_end.b#;
$fr=bless({$L2,$Vq,$E3,$F3,$G3,$F3,$H3,$dr,$D,$er},$Q3);
$gr={};
$hr=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$ir=bless({$q,$hr,$s,$t},$u);
$jr=q#tests#;
$kr=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$lr=bless({$q,$kr,$s,$t},$u);
$mr={$n,$ir,$jr,$lr};
$nr=q#/lib/doc_test.b#;
$or=bless({$L2,$gr,$E3,$F3,$G3,$F3,$H3,$mr,$D,$nr},$Q3);
$pr=[$u5,$d4,$Hq,$Nq,$Uq,$fr,$or];
$qr=bless({$L2,$Bq,$D,$C2,$x3,$pr},$i3);
$rr=q#lib/doc.c::ctors#;
$sr=q#ni:/lib/doc.c#;
$tr={$i3,1};
$ur=q#/lib/doc.c#;
$vr=[$h7];
$wr=bless({$L2,$tr,$D,$ur,$x3,$vr},$y3);
$xr=q#ni:/lib/doc_define.b#;
$yr=q#ni:/lib/doc_end.b#;
$zr=q#ni:/lib/doc_init.b#;
$Ar=q#ni:/lib/doc_namespace.b#;
$Br=q#ni:/lib/doc_test.b#;
$Cr=q#ni:/lib/documentable.b#;
$Dr=q#ni:/lib/fn#;
$Er={$u,1};
$Fr=q#/lib/fn#;
$Gr={};
$Hr=q#shift->compile#;
$Ir=bless({$q,$Hr,$s,$t},$u);
$Jr=q#compile#;
$Kr=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Lr=bless({$q,$Kr,$s,$t},$u);
$Mr=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Nr=bless({$q,$Mr,$s,$t},$u);
$Or={$Jr,$Lr,$G4,$Nr};
$Pr=q#/lib/fn_init.b#;
$Qr=bless({$L2,$Gr,$E3,$Ir,$G3,$F3,$H3,$Or,$D,$Pr},$Q3);
$Rr={};
$Sr=[];
$Tr=q#shift->{'annotations'}#;
$Ur=bless({$o,$Sr,$q,$Tr,$s,$t},$u);
$Vr=[];
$Wr=q#shift->{'code'}#;
$Xr=bless({$o,$Vr,$q,$Wr,$s,$t},$u);
$Yr=q#fn#;
$Zr=[];
$cs=q#shift->{'fn'}#;
$ds=bless({$o,$Zr,$q,$cs,$s,$t},$u);
$es={$o,$Ur,$q,$Xr,$Yr,$ds};
$fs=q#/lib/fn_ro.b#;
$gs=bless({$L2,$Rr,$E3,$F3,$G3,$F3,$H3,$es,$D,$fs},$Q3);
$hs={};
$is=[];
$js=q#shift->{code}#;
$ks=bless({$o,$is,$q,$js,$s,$t},$u);
$ls=[];
$ms=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$ns=bless({$o,$ls,$q,$ms,$s,$t},$u);
$os={$d6,$ks,$k6,$ns};
$ps=q#/lib/fn_ops.b#;
$qs=bless({$L2,$hs,$E3,$F3,$G3,$F3,$H3,$os,$D,$ps},$Q3);
$rs={};
$ss=q#serialize#;
$ts=[];
$us=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$vs=bless({$o,$ts,$q,$us,$s,$t},$u);
$ws={$ss,$vs};
$xs=q#/lib/fn_serialize.b#;
$ys=bless({$L2,$rs,$E3,$F3,$G3,$F3,$H3,$ws,$D,$xs},$Q3);
$zs=[$u5,$M6,$Qr,$gs,$qs,$ys];
$As=bless({$L2,$Er,$D,$Fr,$x3,$zs},$j3);
$Bs=q#lib/fn.c::ctors#;
$Cs=q#ni:/lib/fn.c#;
$Ds={$j3,1};
$Es=q#/lib/fn.c#;
$Fs=[$h7];
$Gs=bless({$L2,$Ds,$D,$Es,$x3,$Fs},$y3);
$Hs=q#ni:/lib/fn_init.b#;
$Is=q#ni:/lib/fn_ops.b#;
$Js=q#ni:/lib/fn_ro.b#;
$Ks=q#ni:/lib/fn_serialize.b#;
$Ls=q#ni:/lib/gensym_generator_compact.b#;
$Ms={};
$Ns=q#gensym#;
$Os=[];
$Ps=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Qs=bless({$o,$Os,$q,$Ps,$s,$t},$u);
$Rs={$Ns,$Qs};
$Ss=q#/lib/gensym_generator_compact.b#;
$Ts=bless({$L2,$Ms,$E3,$F3,$G3,$F3,$H3,$Rs,$D,$Ss},$Q3);
$Us=q#ni:/lib/global_static_test.b#;
$Vs={};
$Ws=q#now#;
$Xs=[];
$Ys=q#ni('ni:/lib/test_value')->new(shift)#;
$Zs=q#($)#;
$ct=bless({$o,$Xs,$q,$Ys,$s,$Zs},$u);
$dt={$Ws,$ct};
$et=q#/lib/global_static_test.b#;
$ft=bless({$L2,$Vs,$E3,$F3,$G3,$F3,$H3,$dt,$D,$et},$Q3);
$gt=q#ni:/lib/image#;
$ht={$f5,1};
$it=q#/lib/image#;
$jt={};
$kt=[];
$lt=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$mt=bless({$o,$kt,$q,$lt,$s,$t},$u);
$nt={$G4,$mt};
$ot=q#/lib/image_init.b#;
$pt=bless({$L2,$jt,$E3,$F3,$G3,$F3,$H3,$nt,$D,$ot},$Q3);
$qt={};
$rt=q#address#;
$st=[];
$tt=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$ut=bless({$o,$st,$q,$tt,$s,$t},$u);
$vt=q#allocate_gensym#;
$wt=[];
$xt=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$yt=bless({$o,$wt,$q,$xt,$s,$t},$u);
$zt=q#boot_side_effect#;
$At=[];
$Bt=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ct=bless({$o,$At,$q,$Bt,$s,$t},$u);
$Dt=q#circular_links#;
$Et=[];
$Ft=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Gt=bless({$o,$Et,$q,$Ft,$s,$t},$u);
$Ht=q#finalizer#;
$It=[];
$Jt=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Kt=bless({$o,$It,$q,$Jt,$s,$t},$u);
$Lt=q#quote#;
$Mt=[];
$Nt=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ot=bless({$o,$Mt,$q,$Nt,$s,$t},$u);
$Pt=q#reconstruction#;
$Qt=[];
$Rt=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$St=bless({$o,$Qt,$q,$Rt,$s,$t},$u);
$Tt=q#side_effect#;
$Ut=[];
$Vt=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Wt=bless({$o,$Ut,$q,$Vt,$s,$t},$u);
$Xt=[];
$Yt=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Zt=bless({$o,$Xt,$q,$Yt,$s,$t},$u);
$cu={$rt,$ut,$vt,$yt,$zt,$Ct,$Dt,$Gt,$Ht,$Kt,$Lt,$Ot,$Pt,$St,$Tt,$Wt,$E9,$Zt};
$du=q#/lib/image_quoting.b#;
$eu=bless({$L2,$qt,$E3,$F3,$G3,$F3,$H3,$cu,$D,$du},$Q3);
$fu={};
$gu=q#quote_code#;
$hu=[];
$iu=q#shift->die('cannot quote perl CODE refs', shift)#;
$ju=bless({$o,$hu,$q,$iu,$s,$t},$u);
$ku={$gu,$ju};
$lu=q#/lib/quote_code_fail.b#;
$mu=bless({$L2,$fu,$E3,$F3,$G3,$F3,$H3,$ku,$D,$lu},$Q3);
$nu={};
$ou=q#quote_array#;
$pu=[];
$qu=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$ru=bless({$o,$pu,$q,$qu,$s,$t},$u);
$su=q#quote_hash#;
$tu=[];
$uu=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$vu=bless({$o,$tu,$q,$uu,$s,$t},$u);
$wu=q#quote_scalar#;
$xu=[];
$yu=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$zu=bless({$o,$xu,$q,$yu,$s,$t},$u);
$Au=q#quote_scalar_ref#;
$Bu=[];
$Cu=q#'\\\\' . shift->quote(${$_[0]})#;
$Du=bless({$o,$Bu,$q,$Cu,$s,$t},$u);
$Eu=q#quote_value#;
$Fu=[];
$Gu=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Hu=bless({$o,$Fu,$q,$Gu,$s,$t},$u);
$Iu={$ou,$ru,$su,$vu,$wu,$zu,$Au,$Du,$Eu,$Hu};
$Ju=q#/lib/quote_values.b#;
$Ku=bless({$L2,$nu,$E3,$F3,$G3,$F3,$H3,$Iu,$D,$Ju},$Q3);
$Lu={};
$Mu=q#quote_blessed#;
$Nu=[];
$Ou=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Pu=bless({$o,$Nu,$q,$Ou,$s,$t},$u);
$Qu=q#quote_class#;
$Ru=[];
$Su=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Tu=bless({$o,$Ru,$q,$Su,$s,$t},$u);
$Uu=q#quote_object#;
$Vu=[];
$Wu=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Xu=bless({$o,$Vu,$q,$Wu,$s,$t},$u);
$Yu={$Mu,$Pu,$Qu,$Tu,$Uu,$Xu};
$Zu=q#/lib/quote_objects.b#;
$cv=bless({$L2,$Lu,$E3,$F3,$G3,$F3,$H3,$Yu,$D,$Zu},$Q3);
$dv={};
$ev=q#circular_arrayref#;
$fv=[];
$gv=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$hv=bless({$o,$fv,$q,$gv,$s,$t},$u);
$iv=q#circular_hashref#;
$jv=[];
$kv=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$lv=bless({$o,$jv,$q,$kv,$s,$t},$u);
$mv=q#is_circular#;
$nv=[];
$ov=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$pv=bless({$o,$nv,$q,$ov,$s,$t},$u);
$qv={$ev,$hv,$iv,$lv,$mv,$pv};
$rv=q#/lib/quote_circular_addressed.b#;
$sv=bless({$L2,$dv,$E3,$F3,$G3,$F3,$H3,$qv,$D,$rv},$Q3);
$tv=[$u5,$pt,$eu,$mu,$Ku,$cv,$sv,$Ts];
$uv=bless({$L2,$ht,$D,$it,$x3,$tv},$k3);
$vv=q#lib/image.c::ctors#;
$wv=q#ni:/lib/image.c#;
$xv={$k3,1};
$yv=q#/lib/image.c#;
$zv=[$h7];
$Av=bless({$L2,$xv,$D,$yv,$x3,$zv},$y3);
$Bv=q#ni:/lib/image_init.b#;
$Cv=q#ni:/lib/image_quoting.b#;
$Dv=q#ni:/lib/instance.b#;
$Ev=q#ni:/lib/instantiable.b#;
$Fv=q#ni:/lib/json.b#;
$Gv={};
$Hv=q#json_decode#;
$Iv=[];
$Jv=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Kv=bless({$o,$Iv,$q,$Jv,$s,$Zs},$u);
$Lv=q#json_encode#;
$Mv=[];
$Nv=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Ov=bless({$o,$Mv,$q,$Nv,$s,$Zs},$u);
$Pv=q#json_escape#;
$Qv=[];
$Rv=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Sv=bless({$o,$Qv,$q,$Rv,$s,$Zs},$u);
$Tv=q#json_unescape#;
$Uv=[];
$Vv=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Wv=bless({$o,$Uv,$q,$Vv,$s,$Zs},$u);
$Xv=q#json_unescape_one#;
$Yv=[];
$Zv=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$cw=bless({$o,$Yv,$q,$Zv,$s,$Zs},$u);
$dw={$Hv,$Kv,$Lv,$Ov,$Pv,$Sv,$Tv,$Wv,$Xv,$cw};
$ew=q#/lib/json.b#;
$fw=bless({$L2,$Gv,$E3,$F3,$G3,$F3,$H3,$dw,$D,$ew},$Q3);
$gw=q#ni#;
$hw=q#ni:/lib/name_as_string.b#;
$iw=q#ni:/lib/named.b#;
$jw=q#ni:/lib/named_in_ni.b#;
$kw=q#ni:/lib/namespaced.b#;
$lw=q#ni:/lib/ni#;
$mw={$g5,1};
$nw=q#/lib/ni#;
$ow={};
$pw=q#extend#;
$qw=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$rw=bless({$q,$qw,$s,$t},$u);
$sw=q#is_mutable#;
$tw=q#$0 ne "-" && -w $0#;
$uw=bless({$q,$tw,$s,$t},$u);
$vw=q#modify#;
$ww=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$xw=bless({$q,$ww,$s,$t},$u);
$yw={$pw,$rw,$sw,$uw,$vw,$xw};
$zw=q#/lib/ni_self.b#;
$Aw=bless({$L2,$ow,$E3,$F3,$G3,$F3,$H3,$yw,$D,$zw},$Q3);
$Bw={};
$Cw=q#--internal/+=#;
$Dw=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Ew=bless({$q,$Dw,$s,$t},$u);
$Fw=q#--internal/eval#;
$Gw=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Hw=bless({$q,$Gw,$s,$t},$u);
$Iw=q#--internal/image#;
$Jw=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Kw=bless({$q,$Jw,$s,$t},$u);
$Lw=q#--internal/test#;
$Mw=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Nw=bless({$q,$Mw,$s,$t},$u);
$Ow=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Pw=bless({$q,$Ow,$s,$t},$u);
$Qw={$Cw,$Ew,$Fw,$Hw,$Iw,$Kw,$Lw,$Nw,$fo,$Pw};
$Rw=q#/lib/ni_main.b#;
$Sw=bless({$L2,$Bw,$E3,$F3,$G3,$F3,$H3,$Qw,$D,$Rw},$Q3);
$Tw={};
$Uw=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Vw=bless({$q,$Uw,$s,$t},$u);
$Ww=q#resolver_for#;
$Xw=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Yw=bless({$q,$Xw,$s,$t},$u);
$Zw={$u4,$Vw,$Ww,$Yw};
$cx=q#/lib/ni_resolver.b#;
$dx=bless({$L2,$Tw,$E3,$F3,$G3,$F3,$H3,$Zw,$D,$cx},$Q3);
$ex={};
$fx=q#exists#;
$gx=q#exists $_[0]->{named}{$_[1]}#;
$hx=bless({$q,$gx,$s,$t},$u);
$ix=q#quoted#;
$jx=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$kx=bless({$q,$jx,$s,$t},$u);
$lx={$fx,$hx,$ix,$kx};
$mx=q#/lib/ni_image.b#;
$nx=bless({$L2,$ex,$E3,$F3,$G3,$F3,$H3,$lx,$D,$mx},$Q3);
$ox=[$u5,$Aw,$Sw,$dx,$nx];
$px=bless({$L2,$mw,$D,$nw,$x3,$ox},$l3);
$qx=q#lib/ni.c::ctors#;
$rx=q#ni:/lib/ni.c#;
$sx={$l3,1};
$tx=q#/lib/ni.c#;
$ux=[$h7];
$vx=bless({$L2,$sx,$D,$tx,$x3,$ux},$y3);
$wx=q#ni:/lib/ni_image.b#;
$xx=q#ni:/lib/ni_main.b#;
$yx=q#ni:/lib/ni_resolver.b#;
$zx=q#ni:/lib/ni_self.b#;
$Ax=q#ni:/lib/ni_static_util.b#;
$Bx={};
$Cx=q#abbrev#;
$Dx=[];
$Ex=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Fx=bless({$o,$Dx,$q,$Ex,$s,$t},$u);
$Gx=q#dor#;
$Hx=[];
$Ix=q#defined $_[0] ? $_[0] : $_[1]#;
$Jx=bless({$o,$Hx,$q,$Ix,$s,$t},$u);
$Kx=q#indent#;
$Lx=[];
$Mx=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Nx=bless({$o,$Lx,$q,$Mx,$s,$t},$u);
$Ox=q#max#;
$Px=[];
$Qx=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Rx=bless({$o,$Px,$q,$Qx,$s,$t},$u);
$Sx=q#maxstr#;
$Tx=[];
$Ux=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Vx=bless({$o,$Tx,$q,$Ux,$s,$t},$u);
$Wx=q#mean#;
$Xx=[];
$Yx=q#sum(@_) / (@_ || 1)#;
$Zx=bless({$o,$Xx,$q,$Yx,$s,$t},$u);
$cy=q#min#;
$dy=[];
$ey=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$fy=bless({$o,$dy,$q,$ey,$s,$t},$u);
$gy=q#minstr#;
$hy=[];
$iy=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$jy=bless({$o,$hy,$q,$iy,$s,$t},$u);
$ky=q#sgr#;
$ly=[];
$my=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$ny=bless({$o,$ly,$q,$my,$s,$t},$u);
$oy=q#sr#;
$py=[];
$qy=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$ry=bless({$o,$py,$q,$qy,$s,$t},$u);
$sy=q#sum#;
$ty=[];
$uy=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$vy=bless({$o,$ty,$q,$uy,$s,$t},$u);
$wy=q#swap#;
$xy=[];
$yy=q#@_[0, 1] = @_[1, 0]#;
$zy=bless({$o,$xy,$q,$yy,$s,$t},$u);
$Ay={$Cx,$Fx,$Gx,$Jx,$Kx,$Nx,$Ox,$Rx,$Sx,$Vx,$Wx,$Zx,$cy,$fy,$gy,$jy,$ky,$ny,$oy,$ry,$sy,$vy,$wy,$zy};
$By=q#/lib/ni_static_util.b#;
$Cy=bless({$L2,$Bx,$E3,$F3,$G3,$F3,$H3,$Ay,$D,$By},$Q3);
$Dy=q#ni:/lib/perlbranch.b#;
$Ey=q#ni:/lib/quote_circular_addressed.b#;
$Fy=q#ni:/lib/quote_code_fail.b#;
$Gy=q#ni:/lib/quote_objects.b#;
$Hy=q#ni:/lib/quote_simple#;
$Iy={$h5,1};
$Jy=q#/lib/quote_simple#;
$Ky={};
$Ly=[];
$My=q#+{}#;
$Ny=bless({$o,$Ly,$q,$My,$s,$t},$u);
$Oy={$G4,$Ny};
$Py=q#/lib/quote_simple_init.b#;
$Qy=bless({$L2,$Ky,$E3,$F3,$G3,$F3,$H3,$Oy,$D,$Py},$Q3);
$Ry={};
$Sy=[];
$Ty=bless({$o,$Sy,$q,0,$s,$t},$u);
$Uy=[];
$Vy=q#shift->quote_value(shift)#;
$Wy=bless({$o,$Uy,$q,$Vy,$s,$t},$u);
$Xy={$mv,$Ty,$Lt,$Wy};
$Yy=q#/lib/quote_simple_quote.b#;
$Zy=bless({$L2,$Ry,$E3,$F3,$G3,$F3,$H3,$Xy,$D,$Yy},$Q3);
$cz=[$u5,$Qy,$Zy,$mu,$Ku,$cv];
$dz=bless({$L2,$Iy,$D,$Jy,$x3,$cz},$m3);
$ez=q#lib/quote_simple.c::ctors#;
$fz=q#ni:/lib/quote_simple.c#;
$gz={$m3,1};
$hz=q#/lib/quote_simple.c#;
$iz=[$h7];
$jz=bless({$L2,$gz,$D,$hz,$x3,$iz},$y3);
$kz=q#ni:/lib/quote_simple_init.b#;
$lz=q#ni:/lib/quote_simple_quote.b#;
$mz=q#ni:/lib/quote_values.b#;
$nz=q#ni:/lib/ref_eq.b#;
$oz=q#ni:/lib/resolver.b#;
$pz=q#ni:/lib/slice#;
$qz={$Q3,1};
$rz=q#/lib/slice#;
$sz=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$tz=bless({$q,$sz,$s,$t},$u);
$uz=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$vz=bless({$q,$uz,$s,$t},$u);
$wz=q#lib/slice::apply#;
$xz=q#lib/slice::apply_unsafe#;
$yz={};
$zz=q#apply_unsafe#;
$Az={$L3,$tz,$zz,$vz};
$Bz=q#/lib/slice.b#;
$Cz=bless({$L2,$yz,$H3,$Az,$D,$Bz},$Q3);
$Dz={};
$Ez=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Fz=bless({$q,$Ez,$s,$t},$u);
$Gz={$G4,$Fz};
$Hz=q#/lib/slice_init.b#;
$Iz=bless({$L2,$Dz,$H3,$Gz,$D,$Hz},$Q3);
$Jz={};
$Kz=[];
$Lz=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Mz=bless({$o,$Kz,$q,$Lz,$s,$t},$u);
$Nz={$ss,$Mz};
$Oz=q#/lib/slice_serialize.b#;
$Pz=bless({$L2,$Jz,$E3,$F3,$G3,$F3,$H3,$Nz,$D,$Oz},$Q3);
$Qz=[$F5,$d4,$Cz,$Iz,$Pz];
$Rz=bless({$L2,$qz,$D,$rz,$x3,$Qz},$n3);
$Sz=q#lib/slice.c::ctors#;
$Tz=q#ni:/lib/slice.b#;
$Uz=q#ni:/lib/slice.c#;
$Vz={$n3,1};
$Wz=q#/lib/slice.c#;
$Xz=[$m7];
$Yz=bless({$L2,$Vz,$D,$Wz,$x3,$Xz},$y3);
$Zz=q#ni:/lib/slice_init.b#;
$cA=q#ni:/lib/slice_serialize.b#;
$dA=q#ni:/lib/static_fn.b#;
$eA={};
$fA=[];
$gA=q#ni('ni:/lib/fn')->new(@_)#;
$hA=bless({$o,$fA,$q,$gA,$s,$Zs},$u);
$iA=q#fp#;
$jA=[];
$kA=q#($$)#;
$lA=bless({$o,$jA,$q,$gA,$s,$kA},$u);
$mA={$Yr,$hA,$iA,$lA};
$nA=q#/lib/static_fn.b#;
$oA=bless({$L2,$eA,$E3,$F3,$G3,$F3,$H3,$mA,$D,$nA},$Q3);
$pA=q#ni:/lib/subclass.b#;
$qA=q#ni:/lib/tag#;
$rA={$e4,1};
$sA=q#/lib/tag#;
$tA={};
$uA=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$vA=bless({$q,$uA,$s,$t},$u);
$wA={$L3,$vA};
$xA=q#/lib/tag.b#;
$yA=bless({$L2,$tA,$E3,$F3,$G3,$F3,$H3,$wA,$D,$xA},$Q3);
$zA={};
$AA=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$BA=bless({$q,$AA,$s,$t},$u);
$CA={$G4,$BA};
$DA=q#/lib/tag_init.b#;
$EA=bless({$L2,$zA,$E3,$F3,$G3,$F3,$H3,$CA,$D,$DA},$Q3);
$FA=[$F5,$d4,$yA,$EA];
$GA=bless({$L2,$rA,$D,$sA,$x3,$FA},$o3);
$HA=q#lib/tag.c::ctors#;
$IA=q#ni:/lib/tag.b#;
$JA=q#ni:/lib/tag.c#;
$KA={$o3,1};
$LA=q#/lib/tag.c#;
$MA=[$m7];
$NA=bless({$L2,$KA,$D,$LA,$x3,$MA},$y3);
$OA=q#ni:/lib/tag_init.b#;
$PA=q#ni:/lib/test_value#;
$QA={$i5,1};
$RA=q#/lib/test_value#;
$SA={};
$TA=[];
$UA=q#\\$_[1]#;
$VA=bless({$o,$TA,$q,$UA,$s,$t},$u);
$WA={$G4,$VA};
$XA=q#/lib/test_value_init.b#;
$YA=bless({$L2,$SA,$E3,$F3,$G3,$F3,$H3,$WA,$D,$XA},$Q3);
$ZA={};
$cB=q#(==#;
$dB=[];
$eB=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$fB=bless({$o,$dB,$q,$eB,$s,$t},$u);
$gB=q#diff#;
$hB=[];
$iB=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]}
    unless !defined($lhs) && !defined($rhs) || $lhs eq $rhs;
}
return undef;#;
$jB=bless({$o,$hB,$q,$iB,$s,$t},$u);
$kB={$cB,$fB,$gB,$jB};
$lB=q#/lib/test_value_eq.b#;
$mB=bless({$L2,$ZA,$E3,$F3,$G3,$F3,$H3,$kB,$D,$lB},$Q3);
$nB={};
$oB=[];
$pB=q#ni::json_encode ${$_[0]}#;
$qB=bless({$o,$oB,$q,$pB,$s,$t},$u);
$rB={$d6,$qB};
$sB=q#/lib/test_value_str.b#;
$tB=bless({$L2,$nB,$E3,$F3,$G3,$F3,$H3,$rB,$D,$sB},$Q3);
$uB=[$u5,$YA,$mB,$tB];
$vB=bless({$L2,$QA,$D,$RA,$x3,$uB},$p3);
$wB=q#lib/test_value.c::ctors#;
$xB=q#ni:/lib/test_value.c#;
$yB={$p3,1};
$zB=q#/lib/test_value.c#;
$AB=[$h7];
$BB=bless({$L2,$yB,$D,$zB,$x3,$AB},$y3);
$CB=q#ni:/lib/test_value_eq.b#;
$DB=q#ni:/lib/test_value_init.b#;
$EB=q#ni:/lib/test_value_str.b#;
$FB=q#ni:/metaclass#;
$GB={$y3,1};
$HB=q#/metaclass#;
$IB=[$B4,$M6,$L4,$B6];
$JB=bless({$L2,$GB,$D,$HB,$x3,$IB},$q3);
$KB=q#metaclass.c::ctors#;
$LB=q#ni:/metaclass.c#;
$MB={$q3,1};
$NB=q#/metaclass.c#;
$OB=[$V6];
$PB=bless({$L2,$MB,$D,$NB,$x3,$OB},$y3);
$QB=q#ni:/module#;
$RB=q#ni:/module.c#;
$SB=q#ni:/object#;
$TB=q#ni:/object.c#;
$UB=q#ni:/semantic/dimension#;
$VB={$t3,1};
$WB=q#/semantic/dimension#;
$XB=[$V6];
$YB=bless({$L2,$VB,$D,$WB,$x3,$XB},$u3);
$ZB=q#semantic/dimension.c::ctors#;
$cC=q#ni:/semantic/dimension.c#;
$dC={$u3,1};
$eC=q#/semantic/dimension.c#;
$fC=[$q7];
$gC=bless({$L2,$dC,$D,$eC,$x3,$fC},$y3);
$hC=q#ni:/semantic/task#;
$iC=q#ni:/semantic/task.c#;
$jC=q#ni:/semantic/task_outcome.b#;
$kC=q#ni:/semantic/task_ro.b#;
$lC=q#ni:main#;
$mC={$ui,1};
$nC=[$oA,$ft,$ti];
$oC=bless({$L2,$mC,$D,$ui,$x3,$nC},$z3);
$pC=q#module::ctors#;
$qC=q#ni:ni#;
$rC={$gw,1};
$sC={$gw,1};
$tC=q#json_escapes#;
$uC=q##;
$vC=q#b#;
$wC=q#	#;
$xC=q#t#;
$yC=q#
#;
$zC=q#n#;
$AC=q##;
$BC=q#"#;
$CC=q#/#;
$DC=q#\\#;
$EC={$uC,$vC,$wC,$xC,$yC,$zC,$AC,$Re,$BC,$BC,$CC,$CC,$DC,$DC};
$FC=q#json_unescapes#;
$GC={$BC,$BC,$CC,$CC,$DC,$DC,$vC,$uC,$zC,$yC,$Re,$AC,$xC,$wC};
$HC={$tC,$EC,$FC,$GC};
$IC=q#/lib/json_data.b#;
$JC=bless({$L2,$sC,$Qk,$HC,$D,$IC},$e5);
$KC=q#lib/dataslice::ctors#;
$LC=[$JC,$fw,$Cy];
$MC=bless({$L2,$rC,$D,$gw,$x3,$LC},$z3);
$NC={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$F1,$G1,$O1,$P1,$g2,$h2,$n2,$o2,$D2,$E2,$J2,$K2,$V6,$X6,$q7,$r7,$C7,$E7,$I7,$J7,$A7,$K7,$Q9,$S9,$ka,$la,$u9,$ma,$O9,$na,$Ea,$Ga,$Ka,$La,$va,$Ma,$Ca,$Na,$zc,$Bc,$Fc,$Gc,$hc,$Hc,$xc,$Ic,$fb,$Jc,$Xb,$Kc,$zb,$Lc,$Wa,$Mc,$Zd,$de,$he,$ie,$Cd,$je,$Nd,$ke,$ed,$le,$Xd,$me,$Vc,$ne,$md,$oe,$lf,$nf,$rf,$sf,$Fe,$tf,$Me,$uf,$jf,$vf,$xe,$wf,$Fg,$Hg,$Lg,$Mg,$Ih,$Kh,$Dg,$Lh,$Ph,$Qh,$nh,$Rh,$Gh,$Sh,$th,$Th,$gh,$Uh,$Qf,$Vh,$ng,$Wh,$Jf,$Xh,$Yf,$Yh,$ti,$vi,$Ti,$Vi,$Zi,$cj,$Ei,$dj,$Ri,$ej,$m9,$fj,$ia,$gj,$ga,$hj,$q8,$ij,$y8,$jj,$K8,$kj,$U7,$lj,$k9,$mj,$W8,$nj,$Ak,$Ck,$Gk,$Hk,$yk,$Ik,$Kj,$Jk,$ik,$Kk,$Aj,$Lk,$Wj,$Mk,$Dl,$Fl,$Jl,$Kl,$nl,$Ll,$Bl,$Ml,$gl,$Nl,$Zm,$dn,$sn,$tn,$qn,$un,$to,$vo,$Oo,$Po,$Mo,$Qo,$Rn,$Ro,$do,$So,$Kn,$To,$po,$Uo,$Dm,$Vo,$Xm,$Wo,$qp,$sp,$wp,$xp,$hp,$yp,$op,$zp,$Z5,$Ap,$F5,$Bp,$m7,$Cp,$Mp,$Op,$R3,$Pp,$Tp,$Up,$Kp,$Vp,$L4,$Wp,$oq,$qq,$uq,$vq,$mq,$wq,$gq,$xq,$y6,$yq,$P5,$zq,$w6,$Aq,$qr,$sr,$wr,$xr,$Uq,$yr,$fr,$zr,$Hq,$Ar,$Nq,$Br,$or,$Cr,$D5,$Dr,$As,$Cs,$Gs,$Hs,$Qr,$Is,$qs,$Js,$gs,$Ks,$ys,$Ls,$Ts,$Us,$ft,$gt,$uv,$wv,$Av,$Bv,$pt,$Cv,$eu,$Dv,$s5,$Ev,$M6,$Fv,$fw,$hw,$i6,$iw,$d4,$jw,$l4,$kw,$s4,$lw,$px,$rx,$vx,$wx,$nx,$xx,$Sw,$yx,$dx,$zx,$Aw,$Ax,$Cy,$Dy,$B4,$Ey,$sv,$Fy,$mu,$Gy,$cv,$Hy,$dz,$fz,$jz,$kz,$Qy,$lz,$Zy,$mz,$Ku,$nz,$p6,$oz,$z4,$pz,$Rz,$Tz,$Cz,$Uz,$Yz,$Zz,$Iz,$cA,$Pz,$dA,$oA,$pA,$T6,$qA,$GA,$IA,$yA,$JA,$NA,$OA,$EA,$PA,$vB,$xB,$BB,$CB,$mB,$DB,$YA,$EB,$tB,$FB,$JB,$LB,$PB,$QB,$B6,$RB,$o7,$SB,$u5,$TB,$h7,$UB,$YB,$cC,$gC,$hC,$pm,$iC,$jn,$jC,$nm,$kC,$Zl,$lC,$oC,$qC,$MC};
$OC=q#resolvers#;
$PC=[];
$QC=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$RC=bless({$o,$PC,$q,$QC,$s,$t},$u);
$SC=q#file#;
$TC=[];
$UC=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$VC=bless({$o,$TC,$q,$UC,$s,$t},$u);
$WC=q#null#;
$XC=[];
$YC=q#ni('ni:/io/null')->new#;
$ZC=bless({$o,$XC,$q,$YC,$s,$t},$u);
$cD=q#sh#;
$dD=[];
$eD=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$fD=bless({$o,$dD,$q,$eD,$s,$t},$u);
$gD=q#str#;
$hD=[];
$iD=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$jD=bless({$o,$hD,$q,$iD,$s,$t},$u);
$kD={$Fb,$RC,$SC,$VC,$WC,$ZC,$cD,$fD,$gD,$jD};
$lD=bless({$c,$NC,$OC,$kD},$g5);
$mD=q#lib/ni::ctors#;
*$xz=\&$vz;
*$wz=\&$tz;
$R3->apply_unsafe($M2);
$R3->apply_unsafe($N2);
$R3->apply_unsafe($O2);
$R3->apply_unsafe($P2);
$R3->apply_unsafe($Q2);
$R3->apply_unsafe($R2);
$R3->apply_unsafe($S2);
$R3->apply_unsafe($T2);
$R3->apply_unsafe($U2);
$R3->apply_unsafe($V2);
$R3->apply_unsafe($W2);
$R3->apply_unsafe($X2);
$R3->apply_unsafe($Y2);
$R3->apply_unsafe($Z2);
$R3->apply_unsafe($c3);
$R3->apply_unsafe($d3);
$R3->apply_unsafe($e3);
$R3->apply_unsafe($f3);
$R3->apply_unsafe($S3);
$R3->apply_unsafe($g3);
$R3->apply_unsafe($h3);
$R3->apply_unsafe($i3);
$R3->apply_unsafe($j3);
$R3->apply_unsafe($k3);
$R3->apply_unsafe($l3);
$R3->apply_unsafe($m3);
$R3->apply_unsafe($n3);
$R3->apply_unsafe($o3);
$R3->apply_unsafe($p3);
$R3->apply_unsafe($y3);
$R3->apply_unsafe($q3);
$R3->apply_unsafe($z3);
$R3->apply_unsafe($r3);
$R3->apply_unsafe($s3);
$R3->apply_unsafe($t3);
$R3->apply_unsafe($u3);
$R3->apply_unsafe($v3);
$d4->apply_unsafe($M2);
$d4->apply_unsafe($N2);
$d4->apply_unsafe($O2);
$d4->apply_unsafe($P2);
$d4->apply_unsafe($Q2);
$d4->apply_unsafe($R2);
$d4->apply_unsafe($S2);
$d4->apply_unsafe($T2);
$d4->apply_unsafe($U2);
$d4->apply_unsafe($V2);
$d4->apply_unsafe($W2);
$d4->apply_unsafe($X2);
$d4->apply_unsafe($Y2);
$d4->apply_unsafe($Z2);
$d4->apply_unsafe($c3);
$d4->apply_unsafe($d3);
$d4->apply_unsafe($e3);
$d4->apply_unsafe($f3);
$d4->apply_unsafe($S3);
$d4->apply_unsafe($g3);
$d4->apply_unsafe($h3);
$d4->apply_unsafe($F);
$d4->apply_unsafe($i3);
$d4->apply_unsafe($j3);
$d4->apply_unsafe($k3);
$d4->apply_unsafe($l3);
$d4->apply_unsafe($m3);
$d4->apply_unsafe($Q3);
$d4->apply_unsafe($n3);
$d4->apply_unsafe($e4);
$d4->apply_unsafe($o3);
$d4->apply_unsafe($p3);
$d4->apply_unsafe($y3);
$d4->apply_unsafe($q3);
$d4->apply_unsafe($z3);
$d4->apply_unsafe($r3);
$d4->apply_unsafe($s3);
$d4->apply_unsafe($t3);
$d4->apply_unsafe($u3);
$d4->apply_unsafe($v3);
$l4->apply_unsafe($M2);
$l4->apply_unsafe($N2);
$l4->apply_unsafe($O2);
$l4->apply_unsafe($P2);
$l4->apply_unsafe($Q2);
$l4->apply_unsafe($R2);
$l4->apply_unsafe($S2);
$l4->apply_unsafe($T2);
$l4->apply_unsafe($U2);
$l4->apply_unsafe($V2);
$l4->apply_unsafe($W2);
$l4->apply_unsafe($X2);
$l4->apply_unsafe($Y2);
$l4->apply_unsafe($Z2);
$l4->apply_unsafe($c3);
$l4->apply_unsafe($d3);
$l4->apply_unsafe($e3);
$l4->apply_unsafe($f3);
$l4->apply_unsafe($S3);
$l4->apply_unsafe($g3);
$l4->apply_unsafe($h3);
$l4->apply_unsafe($i3);
$l4->apply_unsafe($j3);
$l4->apply_unsafe($k3);
$l4->apply_unsafe($l3);
$l4->apply_unsafe($m3);
$l4->apply_unsafe($Q3);
$l4->apply_unsafe($n3);
$l4->apply_unsafe($e4);
$l4->apply_unsafe($o3);
$l4->apply_unsafe($p3);
$l4->apply_unsafe($y3);
$l4->apply_unsafe($q3);
$l4->apply_unsafe($z3);
$l4->apply_unsafe($r3);
$l4->apply_unsafe($s3);
$l4->apply_unsafe($t3);
$l4->apply_unsafe($u3);
$l4->apply_unsafe($v3);
$s4->apply_unsafe($M2);
$s4->apply_unsafe($N2);
$s4->apply_unsafe($O2);
$s4->apply_unsafe($P2);
$s4->apply_unsafe($Q2);
$s4->apply_unsafe($R2);
$s4->apply_unsafe($S2);
$s4->apply_unsafe($T2);
$s4->apply_unsafe($U2);
$s4->apply_unsafe($V2);
$s4->apply_unsafe($W2);
$s4->apply_unsafe($X2);
$s4->apply_unsafe($Y2);
$s4->apply_unsafe($Z2);
$s4->apply_unsafe($c3);
$s4->apply_unsafe($d3);
$s4->apply_unsafe($e3);
$s4->apply_unsafe($f3);
$s4->apply_unsafe($S3);
$s4->apply_unsafe($g3);
$s4->apply_unsafe($h3);
$s4->apply_unsafe($i3);
$s4->apply_unsafe($j3);
$s4->apply_unsafe($k3);
$s4->apply_unsafe($l3);
$s4->apply_unsafe($m3);
$s4->apply_unsafe($Q3);
$s4->apply_unsafe($n3);
$s4->apply_unsafe($e4);
$s4->apply_unsafe($o3);
$s4->apply_unsafe($p3);
$s4->apply_unsafe($y3);
$s4->apply_unsafe($q3);
$s4->apply_unsafe($z3);
$s4->apply_unsafe($r3);
$s4->apply_unsafe($s3);
$s4->apply_unsafe($t3);
$s4->apply_unsafe($u3);
$s4->apply_unsafe($v3);
$z4->apply_unsafe($M2);
$z4->apply_unsafe($N2);
$z4->apply_unsafe($O2);
$z4->apply_unsafe($P2);
$z4->apply_unsafe($Q2);
$z4->apply_unsafe($R2);
$z4->apply_unsafe($S2);
$z4->apply_unsafe($T2);
$z4->apply_unsafe($U2);
$z4->apply_unsafe($V2);
$z4->apply_unsafe($W2);
$z4->apply_unsafe($X2);
$z4->apply_unsafe($Y2);
$z4->apply_unsafe($Z2);
$z4->apply_unsafe($c3);
$z4->apply_unsafe($d3);
$z4->apply_unsafe($e3);
$z4->apply_unsafe($f3);
$z4->apply_unsafe($S3);
$z4->apply_unsafe($g3);
$z4->apply_unsafe($h3);
$z4->apply_unsafe($i3);
$z4->apply_unsafe($j3);
$z4->apply_unsafe($k3);
$z4->apply_unsafe($l3);
$z4->apply_unsafe($m3);
$z4->apply_unsafe($n3);
$z4->apply_unsafe($e4);
$z4->apply_unsafe($o3);
$z4->apply_unsafe($p3);
$z4->apply_unsafe($y3);
$z4->apply_unsafe($q3);
$z4->apply_unsafe($z3);
$z4->apply_unsafe($r3);
$z4->apply_unsafe($s3);
$z4->apply_unsafe($t3);
$z4->apply_unsafe($u3);
$z4->apply_unsafe($v3);
$L4->apply_unsafe($M2);
$L4->apply_unsafe($N2);
$L4->apply_unsafe($O2);
$L4->apply_unsafe($P2);
$L4->apply_unsafe($Q2);
$L4->apply_unsafe($R2);
$L4->apply_unsafe($S2);
$L4->apply_unsafe($T2);
$L4->apply_unsafe($U2);
$L4->apply_unsafe($V2);
$L4->apply_unsafe($W2);
$L4->apply_unsafe($X2);
$L4->apply_unsafe($Y2);
$L4->apply_unsafe($Z2);
$L4->apply_unsafe($c3);
$L4->apply_unsafe($d3);
$L4->apply_unsafe($e3);
$L4->apply_unsafe($f3);
$L4->apply_unsafe($g3);
$L4->apply_unsafe($h3);
$L4->apply_unsafe($i3);
$L4->apply_unsafe($j3);
$L4->apply_unsafe($k3);
$L4->apply_unsafe($l3);
$L4->apply_unsafe($m3);
$L4->apply_unsafe($n3);
$L4->apply_unsafe($o3);
$L4->apply_unsafe($p3);
$L4->apply_unsafe($y3);
$L4->apply_unsafe($q3);
$L4->apply_unsafe($z3);
$L4->apply_unsafe($r3);
$L4->apply_unsafe($s3);
$L4->apply_unsafe($t3);
$L4->apply_unsafe($u3);
$L4->apply_unsafe($v3);
$s5->apply_unsafe($M2);
$s5->apply_unsafe($N2);
$s5->apply_unsafe($M4);
$s5->apply_unsafe($O2);
$s5->apply_unsafe($N4);
$s5->apply_unsafe($P2);
$s5->apply_unsafe($O4);
$s5->apply_unsafe($Q2);
$s5->apply_unsafe($P4);
$s5->apply_unsafe($R2);
$s5->apply_unsafe($Q4);
$s5->apply_unsafe($S2);
$s5->apply_unsafe($R4);
$s5->apply_unsafe($T2);
$s5->apply_unsafe($S4);
$s5->apply_unsafe($U2);
$s5->apply_unsafe($T4);
$s5->apply_unsafe($V2);
$s5->apply_unsafe($U4);
$s5->apply_unsafe($W2);
$s5->apply_unsafe($V4);
$s5->apply_unsafe($X2);
$s5->apply_unsafe($W4);
$s5->apply_unsafe($Y2);
$s5->apply_unsafe($X4);
$s5->apply_unsafe($Z2);
$s5->apply_unsafe($Y4);
$s5->apply_unsafe($c3);
$s5->apply_unsafe($Z4);
$s5->apply_unsafe($d3);
$s5->apply_unsafe($c5);
$s5->apply_unsafe($e3);
$s5->apply_unsafe($d5);
$s5->apply_unsafe($f3);
$s5->apply_unsafe($S3);
$s5->apply_unsafe($g3);
$s5->apply_unsafe($e5);
$s5->apply_unsafe($h3);
$s5->apply_unsafe($F);
$s5->apply_unsafe($i3);
$s5->apply_unsafe($u);
$s5->apply_unsafe($j3);
$s5->apply_unsafe($f5);
$s5->apply_unsafe($k3);
$s5->apply_unsafe($g5);
$s5->apply_unsafe($l3);
$s5->apply_unsafe($h5);
$s5->apply_unsafe($m3);
$s5->apply_unsafe($Q3);
$s5->apply_unsafe($n3);
$s5->apply_unsafe($e4);
$s5->apply_unsafe($o3);
$s5->apply_unsafe($i5);
$s5->apply_unsafe($p3);
$s5->apply_unsafe($y3);
$s5->apply_unsafe($q3);
$s5->apply_unsafe($z3);
$s5->apply_unsafe($r3);
$s5->apply_unsafe($j5);
$s5->apply_unsafe($s3);
$s5->apply_unsafe($t3);
$s5->apply_unsafe($u3);
$s5->apply_unsafe($k5);
$s5->apply_unsafe($v3);
$D5->apply_unsafe($M2);
$D5->apply_unsafe($N2);
$D5->apply_unsafe($O2);
$D5->apply_unsafe($P2);
$D5->apply_unsafe($Q2);
$D5->apply_unsafe($R2);
$D5->apply_unsafe($S2);
$D5->apply_unsafe($T2);
$D5->apply_unsafe($U2);
$D5->apply_unsafe($V2);
$D5->apply_unsafe($W2);
$D5->apply_unsafe($X2);
$D5->apply_unsafe($Y2);
$D5->apply_unsafe($Z2);
$D5->apply_unsafe($c3);
$D5->apply_unsafe($d3);
$D5->apply_unsafe($e3);
$D5->apply_unsafe($d5);
$D5->apply_unsafe($f3);
$D5->apply_unsafe($S3);
$D5->apply_unsafe($g3);
$D5->apply_unsafe($e5);
$D5->apply_unsafe($h3);
$D5->apply_unsafe($i3);
$D5->apply_unsafe($j3);
$D5->apply_unsafe($k3);
$D5->apply_unsafe($l3);
$D5->apply_unsafe($m3);
$D5->apply_unsafe($Q3);
$D5->apply_unsafe($n3);
$D5->apply_unsafe($e4);
$D5->apply_unsafe($o3);
$D5->apply_unsafe($p3);
$D5->apply_unsafe($y3);
$D5->apply_unsafe($q3);
$D5->apply_unsafe($z3);
$D5->apply_unsafe($r3);
$D5->apply_unsafe($s3);
$D5->apply_unsafe($t3);
$D5->apply_unsafe($u3);
$D5->apply_unsafe($v3);
$P5->apply_unsafe($M2);
$P5->apply_unsafe($N2);
$P5->apply_unsafe($O2);
$P5->apply_unsafe($P2);
$P5->apply_unsafe($Q2);
$P5->apply_unsafe($R2);
$P5->apply_unsafe($S2);
$P5->apply_unsafe($T2);
$P5->apply_unsafe($U2);
$P5->apply_unsafe($V2);
$P5->apply_unsafe($W2);
$P5->apply_unsafe($X2);
$P5->apply_unsafe($Y2);
$P5->apply_unsafe($Z2);
$P5->apply_unsafe($c3);
$P5->apply_unsafe($d3);
$P5->apply_unsafe($e3);
$P5->apply_unsafe($f3);
$P5->apply_unsafe($S3);
$P5->apply_unsafe($g3);
$P5->apply_unsafe($h3);
$P5->apply_unsafe($i3);
$P5->apply_unsafe($j3);
$P5->apply_unsafe($k3);
$P5->apply_unsafe($l3);
$P5->apply_unsafe($m3);
$P5->apply_unsafe($n3);
$P5->apply_unsafe($o3);
$P5->apply_unsafe($p3);
$P5->apply_unsafe($y3);
$P5->apply_unsafe($q3);
$P5->apply_unsafe($z3);
$P5->apply_unsafe($r3);
$P5->apply_unsafe($s3);
$P5->apply_unsafe($t3);
$P5->apply_unsafe($u3);
$P5->apply_unsafe($v3);
$Z5->apply_unsafe($M2);
$Z5->apply_unsafe($N2);
$Z5->apply_unsafe($O2);
$Z5->apply_unsafe($P2);
$Z5->apply_unsafe($Q2);
$Z5->apply_unsafe($R2);
$Z5->apply_unsafe($S2);
$Z5->apply_unsafe($T2);
$Z5->apply_unsafe($U2);
$Z5->apply_unsafe($V2);
$Z5->apply_unsafe($W2);
$Z5->apply_unsafe($X2);
$Z5->apply_unsafe($Y2);
$Z5->apply_unsafe($Z2);
$Z5->apply_unsafe($c3);
$Z5->apply_unsafe($d3);
$Z5->apply_unsafe($e3);
$Z5->apply_unsafe($f3);
$Z5->apply_unsafe($S3);
$Z5->apply_unsafe($g3);
$Z5->apply_unsafe($h3);
$Z5->apply_unsafe($i3);
$Z5->apply_unsafe($j3);
$Z5->apply_unsafe($k3);
$Z5->apply_unsafe($l3);
$Z5->apply_unsafe($m3);
$Z5->apply_unsafe($n3);
$Z5->apply_unsafe($o3);
$Z5->apply_unsafe($p3);
$Z5->apply_unsafe($y3);
$Z5->apply_unsafe($q3);
$Z5->apply_unsafe($z3);
$Z5->apply_unsafe($r3);
$Z5->apply_unsafe($s3);
$Z5->apply_unsafe($t3);
$Z5->apply_unsafe($u3);
$Z5->apply_unsafe($v3);
$i6->apply_unsafe($M2);
$i6->apply_unsafe($N2);
$i6->apply_unsafe($O2);
$i6->apply_unsafe($P2);
$i6->apply_unsafe($Q2);
$i6->apply_unsafe($R2);
$i6->apply_unsafe($S2);
$i6->apply_unsafe($T2);
$i6->apply_unsafe($U2);
$i6->apply_unsafe($V2);
$i6->apply_unsafe($W2);
$i6->apply_unsafe($X2);
$i6->apply_unsafe($Y2);
$i6->apply_unsafe($Z2);
$i6->apply_unsafe($c3);
$i6->apply_unsafe($d3);
$i6->apply_unsafe($e3);
$i6->apply_unsafe($f3);
$i6->apply_unsafe($S3);
$i6->apply_unsafe($g3);
$i6->apply_unsafe($h3);
$i6->apply_unsafe($i3);
$i6->apply_unsafe($j3);
$i6->apply_unsafe($k3);
$i6->apply_unsafe($l3);
$i6->apply_unsafe($m3);
$i6->apply_unsafe($n3);
$i6->apply_unsafe($o3);
$i6->apply_unsafe($p3);
$i6->apply_unsafe($y3);
$i6->apply_unsafe($q3);
$i6->apply_unsafe($z3);
$i6->apply_unsafe($r3);
$i6->apply_unsafe($s3);
$i6->apply_unsafe($t3);
$i6->apply_unsafe($u3);
$i6->apply_unsafe($v3);
$p6->apply_unsafe($M2);
$p6->apply_unsafe($N2);
$p6->apply_unsafe($O2);
$p6->apply_unsafe($P2);
$p6->apply_unsafe($Q2);
$p6->apply_unsafe($R2);
$p6->apply_unsafe($S2);
$p6->apply_unsafe($T2);
$p6->apply_unsafe($U2);
$p6->apply_unsafe($V2);
$p6->apply_unsafe($W2);
$p6->apply_unsafe($X2);
$p6->apply_unsafe($Y2);
$p6->apply_unsafe($Z2);
$p6->apply_unsafe($c3);
$p6->apply_unsafe($d3);
$p6->apply_unsafe($e3);
$p6->apply_unsafe($f3);
$p6->apply_unsafe($S3);
$p6->apply_unsafe($g3);
$p6->apply_unsafe($h3);
$p6->apply_unsafe($i3);
$p6->apply_unsafe($j3);
$p6->apply_unsafe($k3);
$p6->apply_unsafe($l3);
$p6->apply_unsafe($m3);
$p6->apply_unsafe($n3);
$p6->apply_unsafe($o3);
$p6->apply_unsafe($p3);
$p6->apply_unsafe($y3);
$p6->apply_unsafe($q3);
$p6->apply_unsafe($z3);
$p6->apply_unsafe($r3);
$p6->apply_unsafe($s3);
$p6->apply_unsafe($t3);
$p6->apply_unsafe($u3);
$p6->apply_unsafe($v3);
$w6->apply_unsafe($M2);
$w6->apply_unsafe($N2);
$w6->apply_unsafe($O2);
$w6->apply_unsafe($P2);
$w6->apply_unsafe($Q2);
$w6->apply_unsafe($R2);
$w6->apply_unsafe($S2);
$w6->apply_unsafe($T2);
$w6->apply_unsafe($U2);
$w6->apply_unsafe($V2);
$w6->apply_unsafe($W2);
$w6->apply_unsafe($X2);
$w6->apply_unsafe($Y2);
$w6->apply_unsafe($Z2);
$w6->apply_unsafe($c3);
$w6->apply_unsafe($d3);
$w6->apply_unsafe($e3);
$w6->apply_unsafe($f3);
$w6->apply_unsafe($S3);
$w6->apply_unsafe($g3);
$w6->apply_unsafe($h3);
$w6->apply_unsafe($i3);
$w6->apply_unsafe($j3);
$w6->apply_unsafe($k3);
$w6->apply_unsafe($l3);
$w6->apply_unsafe($m3);
$w6->apply_unsafe($n3);
$w6->apply_unsafe($o3);
$w6->apply_unsafe($p3);
$w6->apply_unsafe($y3);
$w6->apply_unsafe($q3);
$w6->apply_unsafe($z3);
$w6->apply_unsafe($r3);
$w6->apply_unsafe($s3);
$w6->apply_unsafe($t3);
$w6->apply_unsafe($u3);
$w6->apply_unsafe($v3);
$M6->apply_unsafe($M2);
$M6->apply_unsafe($N2);
$M6->apply_unsafe($O2);
$M6->apply_unsafe($P2);
$M6->apply_unsafe($Q2);
$M6->apply_unsafe($R2);
$M6->apply_unsafe($S2);
$M6->apply_unsafe($T2);
$M6->apply_unsafe($U2);
$M6->apply_unsafe($V2);
$M6->apply_unsafe($W2);
$M6->apply_unsafe($X2);
$M6->apply_unsafe($Y2);
$M6->apply_unsafe($Z2);
$M6->apply_unsafe($c3);
$M6->apply_unsafe($d3);
$M6->apply_unsafe($e3);
$M6->apply_unsafe($f3);
$M6->apply_unsafe($g3);
$M6->apply_unsafe($h3);
$M6->apply_unsafe($i3);
$M6->apply_unsafe($u);
$M6->apply_unsafe($j3);
$M6->apply_unsafe($k3);
$M6->apply_unsafe($l3);
$M6->apply_unsafe($m3);
$M6->apply_unsafe($Q3);
$M6->apply_unsafe($n3);
$M6->apply_unsafe($e4);
$M6->apply_unsafe($o3);
$M6->apply_unsafe($p3);
$M6->apply_unsafe($y3);
$M6->apply_unsafe($q3);
$M6->apply_unsafe($r3);
$M6->apply_unsafe($s3);
$M6->apply_unsafe($t3);
$M6->apply_unsafe($u3);
$M6->apply_unsafe($v3);
$T6->apply_unsafe($M2);
$T6->apply_unsafe($N2);
$T6->apply_unsafe($O2);
$T6->apply_unsafe($P2);
$T6->apply_unsafe($Q2);
$T6->apply_unsafe($R2);
$T6->apply_unsafe($S2);
$T6->apply_unsafe($T2);
$T6->apply_unsafe($U2);
$T6->apply_unsafe($V2);
$T6->apply_unsafe($W2);
$T6->apply_unsafe($X2);
$T6->apply_unsafe($Y2);
$T6->apply_unsafe($Z2);
$T6->apply_unsafe($c3);
$T6->apply_unsafe($d3);
$T6->apply_unsafe($e3);
$T6->apply_unsafe($f3);
$T6->apply_unsafe($g3);
$T6->apply_unsafe($h3);
$T6->apply_unsafe($i3);
$T6->apply_unsafe($j3);
$T6->apply_unsafe($k3);
$T6->apply_unsafe($l3);
$T6->apply_unsafe($m3);
$T6->apply_unsafe($n3);
$T6->apply_unsafe($o3);
$T6->apply_unsafe($p3);
$T6->apply_unsafe($q3);
$T6->apply_unsafe($r3);
$T6->apply_unsafe($s3);
$T6->apply_unsafe($t3);
$T6->apply_unsafe($u3);
$T6->apply_unsafe($v3);
$A7->apply_unsafe($M4);
$U7->apply_unsafe($N4);
$U7->apply_unsafe($O4);
$U7->apply_unsafe($P4);
$U7->apply_unsafe($Q4);
$U7->apply_unsafe($R4);
$U7->apply_unsafe($S4);
$U7->apply_unsafe($T4);
$U7->apply_unsafe($U4);
$U7->apply_unsafe($V4);
$U7->apply_unsafe($W4);
$U7->apply_unsafe($X4);
$q8->apply_unsafe($N4);
$q8->apply_unsafe($O4);
$q8->apply_unsafe($P4);
$q8->apply_unsafe($Q4);
$q8->apply_unsafe($R4);
$q8->apply_unsafe($S4);
$q8->apply_unsafe($T4);
$q8->apply_unsafe($U4);
$q8->apply_unsafe($V4);
$q8->apply_unsafe($W4);
$q8->apply_unsafe($X4);
$y8->apply_unsafe($N4);
$y8->apply_unsafe($O4);
$y8->apply_unsafe($P4);
$y8->apply_unsafe($Q4);
$y8->apply_unsafe($R4);
$y8->apply_unsafe($S4);
$y8->apply_unsafe($T4);
$y8->apply_unsafe($U4);
$y8->apply_unsafe($V4);
$y8->apply_unsafe($W4);
$y8->apply_unsafe($X4);
$K8->apply_unsafe($N4);
$K8->apply_unsafe($O4);
$K8->apply_unsafe($P4);
$K8->apply_unsafe($Q4);
$K8->apply_unsafe($R4);
$K8->apply_unsafe($S4);
$K8->apply_unsafe($T4);
$K8->apply_unsafe($U4);
$K8->apply_unsafe($V4);
$K8->apply_unsafe($W4);
$K8->apply_unsafe($X4);
$W8->apply_unsafe($N4);
$W8->apply_unsafe($O4);
$W8->apply_unsafe($P4);
$W8->apply_unsafe($Q4);
$W8->apply_unsafe($R4);
$W8->apply_unsafe($S4);
$W8->apply_unsafe($T4);
$W8->apply_unsafe($U4);
$W8->apply_unsafe($V4);
$W8->apply_unsafe($W4);
$W8->apply_unsafe($X4);
$k9->apply_unsafe($N4);
$k9->apply_unsafe($O4);
$k9->apply_unsafe($P4);
$k9->apply_unsafe($Q4);
$k9->apply_unsafe($R4);
$k9->apply_unsafe($S4);
$k9->apply_unsafe($T4);
$k9->apply_unsafe($U4);
$k9->apply_unsafe($V4);
$k9->apply_unsafe($W4);
$k9->apply_unsafe($X4);
$u9->apply_unsafe($N4);
$O9->apply_unsafe($N4);
$ga->apply_unsafe($P2);
$ga->apply_unsafe($Q2);
$ga->apply_unsafe($R2);
$ga->apply_unsafe($S2);
$ga->apply_unsafe($T2);
$ga->apply_unsafe($U2);
$ga->apply_unsafe($V2);
$ga->apply_unsafe($W2);
$ga->apply_unsafe($X2);
$ga->apply_unsafe($Y2);
$ga->apply_unsafe($Z2);
$va->apply_unsafe($O4);
$Ca->apply_unsafe($O4);
$Wa->apply_unsafe($P4);
$fb->apply_unsafe($P4);
$zb->apply_unsafe($P4);
$Xb->apply_unsafe($P4);
$hc->apply_unsafe($P4);
$xc->apply_unsafe($P4);
$Vc->apply_unsafe($Q4);
$ed->apply_unsafe($Q4);
$md->apply_unsafe($Q4);
$Cd->apply_unsafe($Q4);
$Nd->apply_unsafe($Q4);
$Xd->apply_unsafe($Q4);
$xe->apply_unsafe($R4);
$Fe->apply_unsafe($R4);
$Me->apply_unsafe($R4);
$jf->apply_unsafe($R4);
$Jf->apply_unsafe($S4);
$Qf->apply_unsafe($S4);
$Yf->apply_unsafe($S4);
$ng->apply_unsafe($S4);
$Dg->apply_unsafe($S4);
$gh->apply_unsafe($T4);
$nh->apply_unsafe($T4);
$th->apply_unsafe($T4);
$Gh->apply_unsafe($T4);
$ti->apply_unsafe($ui);
$Ei->apply_unsafe($U4);
$Ri->apply_unsafe($U4);
$Aj->apply_unsafe($W4);
$Kj->apply_unsafe($W4);
$Wj->apply_unsafe($W4);
$ik->apply_unsafe($W4);
$yk->apply_unsafe($W4);
$gl->apply_unsafe($X4);
$nl->apply_unsafe($X4);
$Bl->apply_unsafe($X4);
$Zl->apply_unsafe($Y4);
$Zl->apply_unsafe($Z4);
$Zl->apply_unsafe($c5);
$Zl->apply_unsafe($k5);
$nm->apply_unsafe($Y4);
$nm->apply_unsafe($Z4);
$nm->apply_unsafe($c5);
$nm->apply_unsafe($k5);
$Dm->apply_unsafe($Y4);
$Dm->apply_unsafe($Z4);
$Dm->apply_unsafe($c5);
$Xm->apply_unsafe($Y4);
$Xm->apply_unsafe($Z4);
$Xm->apply_unsafe($c5);
$qn->apply_unsafe($c3);
$qn->apply_unsafe($d3);
$qn->apply_unsafe($e3);
$Kn->apply_unsafe($Z4);
$Rn->apply_unsafe($Z4);
$do->apply_unsafe($Z4);
$po->apply_unsafe($Z4);
$Mo->apply_unsafe($d3);
$hp->apply_unsafe($c5);
$op->apply_unsafe($c5);
$Kp->apply_unsafe($S3);
$gq->apply_unsafe($e5);
$mq->apply_unsafe($e5);
$Hq->apply_unsafe($F);
$Nq->apply_unsafe($F);
$Uq->apply_unsafe($F);
$fr->apply_unsafe($F);
$or->apply_unsafe($F);
$Qr->apply_unsafe($u);
$gs->apply_unsafe($u);
$qs->apply_unsafe($u);
$ys->apply_unsafe($u);
$Ts->apply_unsafe($f5);
$ft->apply_unsafe($ui);
$pt->apply_unsafe($f5);
$eu->apply_unsafe($f5);
$mu->apply_unsafe($f5);
$mu->apply_unsafe($h5);
$Ku->apply_unsafe($f5);
$Ku->apply_unsafe($h5);
$cv->apply_unsafe($f5);
$cv->apply_unsafe($h5);
$sv->apply_unsafe($f5);
$fw->apply_unsafe($gw);
$Aw->apply_unsafe($g5);
$Sw->apply_unsafe($g5);
$dx->apply_unsafe($g5);
$nx->apply_unsafe($g5);
$Cy->apply_unsafe($gw);
$Qy->apply_unsafe($h5);
$Zy->apply_unsafe($h5);
$Cz->apply_unsafe($Q3);
$Iz->apply_unsafe($Q3);
$Pz->apply_unsafe($Q3);
$oA->apply_unsafe($ui);
$yA->apply_unsafe($e4);
$EA->apply_unsafe($e4);
$YA->apply_unsafe($i5);
$mB->apply_unsafe($i5);
$tB->apply_unsafe($i5);
$ni::self=$lD;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($B1)for@$w;
&$_($F1)for@$H;
&$_($O1)for@$H;
&$_($S1)for@$w;
&$_($W1)for@$w;
&$_($c2)for@$w;
&$_($g2)for@$H;
&$_($n2)for@$H;
&$_($v2)for@$w;
&$_($z2)for@$w;
&$_($D2)for@$H;
&$_($J2)for@$H;
&$_($K3)for@$w;
&$_($N3)for@$w;
&$_($R3)for@$T3;
&$_($W3)for@$w;
&$_($Y3)for@$w;
&$_($d4)for@$T3;
&$_($i4)for@$w;
&$_($l4)for@$T3;
&$_($p4)for@$w;
&$_($s4)for@$T3;
&$_($w4)for@$w;
&$_($z4)for@$T3;
&$_($B4)for@$C4;
&$_($F4)for@$w;
&$_($I4)for@$w;
&$_($L4)for@$T3;
&$_($p5)for@$w;
&$_($s5)for@$T3;
&$_($u5)for@$v5;
&$_($A5)for@$w;
&$_($D5)for@$T3;
&$_($F5)for@$G5;
&$_($M5)for@$w;
&$_($P5)for@$T3;
&$_($T5)for@$w;
&$_($W5)for@$w;
&$_($Z5)for@$T3;
&$_($f6)for@$w;
&$_($i6)for@$T3;
&$_($m6)for@$w;
&$_($p6)for@$T3;
&$_($t6)for@$w;
&$_($w6)for@$T3;
&$_($y6)for@$z6;
&$_($B6)for@$C6;
&$_($G6)for@$w;
&$_($J6)for@$w;
&$_($M6)for@$T3;
&$_($Q6)for@$w;
&$_($T6)for@$T3;
&$_($V6)for@$W6;
&$_($h7)for@$i7;
&$_($m7)for@$i7;
&$_($o7)for@$i7;
&$_($q7)for@$i7;
&$_($x7)for@$w;
&$_($A7)for@$T3;
&$_($C7)for@$D7;
&$_($I7)for@$i7;
&$_($R7)for@$w;
&$_($U7)for@$T3;
&$_($Z7)for@$w;
&$_($f8)for@$w;
&$_($j8)for@$w;
&$_($n8)for@$w;
&$_($q8)for@$T3;
&$_($v8)for@$w;
&$_($y8)for@$T3;
&$_($D8)for@$w;
&$_($H8)for@$w;
&$_($K8)for@$T3;
&$_($P8)for@$w;
&$_($T8)for@$w;
&$_($W8)for@$T3;
&$_($d9)for@$w;
&$_($h9)for@$w;
&$_($k9)for@$T3;
&$_($m9)for@$n9;
&$_($r9)for@$w;
&$_($u9)for@$T3;
&$_($z9)for@$w;
&$_($D9)for@$w;
&$_($H9)for@$w;
&$_($L9)for@$w;
&$_($O9)for@$T3;
&$_($Q9)for@$R9;
&$_($da)for@$w;
&$_($ga)for@$T3;
&$_($ia)for@$i7;
&$_($ka)for@$i7;
&$_($sa)for@$w;
&$_($va)for@$T3;
&$_($za)for@$w;
&$_($Ca)for@$T3;
&$_($Ea)for@$Fa;
&$_($Ka)for@$i7;
&$_($Ta)for@$w;
&$_($Wa)for@$T3;
&$_($cb)for@$w;
&$_($fb)for@$T3;
&$_($kb)for@$w;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($zb)for@$T3;
&$_($Eb)for@$w;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Ub)for@$w;
&$_($Xb)for@$T3;
&$_($ec)for@$w;
&$_($hc)for@$T3;
&$_($mc)for@$w;
&$_($qc)for@$w;
&$_($uc)for@$w;
&$_($xc)for@$T3;
&$_($zc)for@$Ac;
&$_($Fc)for@$i7;
&$_($Sc)for@$w;
&$_($Vc)for@$T3;
&$_($Zc)for@$w;
&$_($ed)for@$T3;
&$_($jd)for@$w;
&$_($md)for@$T3;
&$_($rd)for@$w;
&$_($vd)for@$w;
&$_($zd)for@$w;
&$_($Cd)for@$T3;
&$_($Gd)for@$w;
&$_($Kd)for@$w;
&$_($Nd)for@$T3;
&$_($Rd)for@$w;
&$_($Ud)for@$w;
&$_($Xd)for@$T3;
&$_($Zd)for@$ce;
&$_($he)for@$i7;
&$_($ue)for@$w;
&$_($xe)for@$T3;
&$_($Ce)for@$w;
&$_($Fe)for@$T3;
&$_($Je)for@$w;
&$_($Me)for@$T3;
&$_($Qe)for@$w;
&$_($Ue)for@$w;
&$_($Xe)for@$w;
&$_($df)for@$w;
&$_($gf)for@$w;
&$_($jf)for@$T3;
&$_($lf)for@$mf;
&$_($rf)for@$i7;
&$_($Cf)for@$w;
&$_($Gf)for@$w;
&$_($Jf)for@$T3;
&$_($Nf)for@$w;
&$_($Qf)for@$T3;
&$_($Vf)for@$w;
&$_($Yf)for@$T3;
&$_($eg)for@$w;
&$_($hg)for@$w;
&$_($kg)for@$w;
&$_($ng)for@$T3;
&$_($sg)for@$w;
&$_($wg)for@$w;
&$_($Ag)for@$w;
&$_($Dg)for@$T3;
&$_($Fg)for@$Gg;
&$_($Lg)for@$i7;
&$_($Tg)for@$w;
&$_($Xg)for@$w;
&$_($dh)for@$w;
&$_($gh)for@$T3;
&$_($kh)for@$w;
&$_($nh)for@$T3;
&$_($qh)for@$w;
&$_($th)for@$T3;
&$_($xh)for@$w;
&$_($Ah)for@$w;
&$_($Dh)for@$w;
&$_($Gh)for@$T3;
&$_($Ih)for@$Jh;
&$_($Ph)for@$i7;
&$_($fi)for@$w;
&$_($ii)for@$w;
&$_($mi)for@$w;
&$_($qi)for@$w;
&$_($ti)for@$T3;
&$_($Bi)for@$w;
&$_($Ei)for@$T3;
&$_($Ii)for@$w;
&$_($Li)for@$w;
&$_($Oi)for@$w;
&$_($Ri)for@$T3;
&$_($Ti)for@$Ui;
&$_($Zi)for@$i7;
&$_($tj)for@$w;
&$_($xj)for@$w;
&$_($Aj)for@$T3;
&$_($Ej)for@$w;
&$_($Hj)for@$w;
&$_($Kj)for@$T3;
&$_($Pj)for@$w;
&$_($Tj)for@$w;
&$_($Wj)for@$T3;
&$_($ck)for@$w;
&$_($fk)for@$w;
&$_($ik)for@$T3;
&$_($mk)for@$w;
&$_($pk)for@$w;
&$_($sk)for@$w;
&$_($vk)for@$w;
&$_($yk)for@$T3;
&$_($Ak)for@$Bk;
&$_($Gk)for@$i7;
&$_($Tk)for@$w;
&$_($Xk)for@$w;
&$_($dl)for@$w;
&$_($gl)for@$T3;
&$_($kl)for@$w;
&$_($nl)for@$T3;
&$_($rl)for@$w;
&$_($vl)for@$w;
&$_($yl)for@$w;
&$_($Bl)for@$T3;
&$_($Dl)for@$El;
&$_($Jl)for@$i7;
&$_($Wl)for@$w;
&$_($Zl)for@$T3;
&$_($gm)for@$w;
&$_($km)for@$w;
&$_($nm)for@$T3;
&$_($pm)for@$qm;
&$_($um)for@$w;
&$_($xm)for@$w;
&$_($Am)for@$w;
&$_($Dm)for@$T3;
&$_($Im)for@$w;
&$_($Mm)for@$w;
&$_($Qm)for@$w;
&$_($Um)for@$w;
&$_($Xm)for@$T3;
&$_($Zm)for@$cn;
&$_($jn)for@$i7;
&$_($nn)for@$w;
&$_($qn)for@$T3;
&$_($sn)for@$i7;
&$_($Bn)for@$w;
&$_($Dn)for@$w;
&$_($Hn)for@$w;
&$_($Kn)for@$T3;
&$_($On)for@$w;
&$_($Rn)for@$T3;
&$_($Vn)for@$w;
&$_($Yn)for@$w;
&$_($do)for@$T3;
&$_($io)for@$w;
&$_($mo)for@$w;
&$_($po)for@$T3;
&$_($to)for@$uo;
&$_($Bo)for@$w;
&$_($Fo)for@$w;
&$_($Jo)for@$w;
&$_($Mo)for@$T3;
&$_($Oo)for@$i7;
&$_($ep)for@$w;
&$_($hp)for@$T3;
&$_($lp)for@$w;
&$_($op)for@$T3;
&$_($qp)for@$rp;
&$_($wp)for@$i7;
&$_($Hp)for@$w;
&$_($Kp)for@$T3;
&$_($Mp)for@$Np;
&$_($Tp)for@$i7;
&$_($dq)for@$w;
&$_($gq)for@$T3;
&$_($jq)for@$w;
&$_($mq)for@$T3;
&$_($oq)for@$pq;
&$_($uq)for@$i7;
&$_($Eq)for@$w;
&$_($Hq)for@$T3;
&$_($Kq)for@$w;
&$_($Nq)for@$T3;
&$_($Rq)for@$w;
&$_($Uq)for@$T3;
&$_($Xq)for@$w;
&$_($cr)for@$w;
&$_($fr)for@$T3;
&$_($ir)for@$w;
&$_($lr)for@$w;
&$_($or)for@$T3;
&$_($qr)for@$rr;
&$_($wr)for@$i7;
&$_($Ir)for@$w;
&$_($Lr)for@$w;
&$_($Nr)for@$w;
&$_($Qr)for@$T3;
&$_($Ur)for@$w;
&$_($Xr)for@$w;
&$_($ds)for@$w;
&$_($gs)for@$T3;
&$_($ks)for@$w;
&$_($ns)for@$w;
&$_($qs)for@$T3;
&$_($vs)for@$w;
&$_($ys)for@$T3;
&$_($As)for@$Bs;
&$_($Gs)for@$i7;
&$_($Qs)for@$w;
&$_($Ts)for@$T3;
&$_($ct)for@$w;
&$_($ft)for@$T3;
&$_($mt)for@$w;
&$_($pt)for@$T3;
&$_($ut)for@$w;
&$_($yt)for@$w;
&$_($Ct)for@$w;
&$_($Gt)for@$w;
&$_($Kt)for@$w;
&$_($Ot)for@$w;
&$_($St)for@$w;
&$_($Wt)for@$w;
&$_($Zt)for@$w;
&$_($eu)for@$T3;
&$_($ju)for@$w;
&$_($mu)for@$T3;
&$_($ru)for@$w;
&$_($vu)for@$w;
&$_($zu)for@$w;
&$_($Du)for@$w;
&$_($Hu)for@$w;
&$_($Ku)for@$T3;
&$_($Pu)for@$w;
&$_($Tu)for@$w;
&$_($Xu)for@$w;
&$_($cv)for@$T3;
&$_($hv)for@$w;
&$_($lv)for@$w;
&$_($pv)for@$w;
&$_($sv)for@$T3;
&$_($uv)for@$vv;
&$_($Av)for@$i7;
&$_($Kv)for@$w;
&$_($Ov)for@$w;
&$_($Sv)for@$w;
&$_($Wv)for@$w;
&$_($cw)for@$w;
&$_($fw)for@$T3;
&$_($rw)for@$w;
&$_($uw)for@$w;
&$_($xw)for@$w;
&$_($Aw)for@$T3;
&$_($Ew)for@$w;
&$_($Hw)for@$w;
&$_($Kw)for@$w;
&$_($Nw)for@$w;
&$_($Pw)for@$w;
&$_($Sw)for@$T3;
&$_($Vw)for@$w;
&$_($Yw)for@$w;
&$_($dx)for@$T3;
&$_($hx)for@$w;
&$_($kx)for@$w;
&$_($nx)for@$T3;
&$_($px)for@$qx;
&$_($vx)for@$i7;
&$_($Fx)for@$w;
&$_($Jx)for@$w;
&$_($Nx)for@$w;
&$_($Rx)for@$w;
&$_($Vx)for@$w;
&$_($Zx)for@$w;
&$_($fy)for@$w;
&$_($jy)for@$w;
&$_($ny)for@$w;
&$_($ry)for@$w;
&$_($vy)for@$w;
&$_($zy)for@$w;
&$_($Cy)for@$T3;
&$_($Ny)for@$w;
&$_($Qy)for@$T3;
&$_($Ty)for@$w;
&$_($Wy)for@$w;
&$_($Zy)for@$T3;
&$_($dz)for@$ez;
&$_($jz)for@$i7;
&$_($tz)for@$w;
&$_($vz)for@$w;
&$_($Cz)for@$T3;
&$_($Fz)for@$w;
&$_($Iz)for@$T3;
&$_($Mz)for@$w;
&$_($Pz)for@$T3;
&$_($Rz)for@$Sz;
&$_($Yz)for@$i7;
&$_($hA)for@$w;
&$_($lA)for@$w;
&$_($oA)for@$T3;
&$_($vA)for@$w;
&$_($yA)for@$T3;
&$_($BA)for@$w;
&$_($EA)for@$T3;
&$_($GA)for@$HA;
&$_($NA)for@$i7;
&$_($VA)for@$w;
&$_($YA)for@$T3;
&$_($fB)for@$w;
&$_($jB)for@$w;
&$_($mB)for@$T3;
&$_($qB)for@$w;
&$_($tB)for@$T3;
&$_($vB)for@$wB;
&$_($BB)for@$i7;
&$_($JB)for@$KB;
&$_($PB)for@$i7;
&$_($YB)for@$ZB;
&$_($gC)for@$i7;
&$_($oC)for@$pC;
&$_($JC)for@$KC;
&$_($MC)for@$pC;
&$_($RC)for@$w;
&$_($VC)for@$w;
&$_($ZC)for@$w;
&$_($fD)for@$w;
&$_($jD)for@$w;
&$_($lD)for@$mD;
ni->run(@ARGV);
__DATA__
