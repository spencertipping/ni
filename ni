#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/buffer#;
$V=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$W=[$f,$V];
$X=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/buffer#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/cat#;
$j1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$k1=[$f,$j1];
$l1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/cat#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/exec#;
$v1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$w1=[$f,$v1];
$x1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$y1=[$i,$x1];
$z1=[];
$A1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[$w1,$y1,$C1];
$E1=q#/io/exec#;
$F1=bless({$e,$D1,$D,$E1},$F);
$G1=q#ni.doc:/io/mio#;
$H1=q#
    my $mio = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel;
    my $c2 = $mio->channel;
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    $mio->into_sync($socket_or_something);#;
$I1=[$f,$H1];
$J1=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel. The channel is assumed to be durable and order-preserving;
      this multiplexing interface just interleaves multiple data streams to
      make sure large transfers along one channel don't cause arbitrarily large
      delays along other channels.#;
$K1=q#In IO terms, channel objects behave like nonblocking sockets.#;
$L1=q#
      #;
$M1=[$i,$J1,$K1,$L1];
$N1=[$I1,$M1];
$O1=q#/io/mio#;
$P1=bless({$e,$N1,$D,$O1},$F);
$Q1=q#ni.doc:/io/pid#;
$R1=[];
$S1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[];
$W1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$X1=bless({$o,$V1,$q,$W1,$s,$t},$u);
$Y1=[$n,$X1];
$Z1=[];
$c2=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$d2=bless({$o,$Z1,$q,$c2,$s,$t},$u);
$e2=[$n,$d2];
$f2=[$U1,$Y1,$e2];
$g2=q#/io/pid#;
$h2=bless({$e,$f2,$D,$g2},$F);
$i2=q#ni.doc:/lib#;
$j2=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$k2=[$i,$j2];
$l2=[$k2];
$m2=q#/lib#;
$n2=bless({$e,$l2,$D,$m2},$F);
$o2=q#ni.doc:/lib/doc#;
$p2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$q2=[$f,$p2];
$r2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$s2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$t2=[];
$u2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$v2=bless({$o,$t2,$q,$u2,$s,$t},$u);
$w2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$x2=[];
$y2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$z2=bless({$o,$x2,$q,$y2,$s,$t},$u);
$A2=[$i,$r2,$s2,$n,$v2,$w2,$n,$z2];
$B2=[$q2,$A2];
$C2=q#/lib/doc#;
$D2=bless({$e,$B2,$D,$C2},$F);
$E2=q#ni.doc:/semantic#;
$F2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$G2=[$i,$F2];
$H2=[$G2];
$I2=q#/semantic#;
$J2=bless({$e,$H2,$D,$I2},$F);
$K2=q#ni:/class#;
$L2=q#applied_to#;
$M2=q#class#;
$N2=q#class.c#;
$O2=q#fabric/rmi.c#;
$P2=q#io/buffer.c#;
$Q2=q#io/cat.c#;
$R2=q#io/exec.c#;
$S2=q#io/fd.c#;
$T2=q#io/file.c#;
$U2=q#io/mio.c#;
$V2=q#io/mio_channel.c#;
$W2=q#io/null.c#;
$X2=q#io/object.c#;
$Y2=q#io/pid.c#;
$Z2=q#io/str.c#;
$c3=q#io/transfer.c#;
$d3=q#io/transfer_async.c#;
$e3=q#io/transfer_sync.c#;
$f3=q#lib/behavior.c#;
$g3=q#lib/branch.c#;
$h3=q#lib/dataslice.c#;
$i3=q#lib/doc.c#;
$j3=q#lib/fn.c#;
$k3=q#lib/image.c#;
$l3=q#lib/ni.c#;
$m3=q#lib/quote_simple.c#;
$n3=q#lib/slice.c#;
$o3=q#lib/tag.c#;
$p3=q#lib/test_value.c#;
$q3=q#metaclass.c#;
$r3=q#module.c#;
$s3=q#object.c#;
$t3=q#semantic/dimension#;
$u3=q#semantic/dimension.c#;
$v3=q#semantic/task.c#;
$w3={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$x3=q#slices#;
$y3=q#metaclass#;
$z3=q#module#;
$A3={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$B3=q#/module#;
$C3=q#/lib/perlbranch.b#;
$D3={};
$E3=q#ctor#;
$F3=undef;
$G3=q#dtor#;
$H3=q#methods#;
$I3=q#add#;
$J3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$K3=bless({$q,$J3,$s,$t},$u);
$L3=q#apply#;
$M3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3={$I3,$K3,$L3,$N3};
$P3=q#/lib/branch.b#;
$Q3=q#lib/slice#;
$R3=bless({$L2,$D3,$E3,$F3,$G3,$F3,$H3,$O3,$D,$P3},$Q3);
$S3=q#lib/branch#;
$T3=q#lib/slice::ctors#;
$U3={};
$V3=q#my $s = shift; ni->def($s->name, $s)#;
$W3=bless({$q,$V3,$s,$t},$u);
$X3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$Y3=bless({$q,$X3,$s,$t},$u);
$Z3={$D,$Y3};
$c4=q#/lib/named.b#;
$d4=bless({$L2,$U3,$E3,$W3,$G3,$F3,$H3,$Z3,$D,$c4},$Q3);
$e4=q#lib/tag#;
$f4={};
$g4=q#namespace#;
$h4=q#'ni'#;
$i4=bless({$q,$h4,$s,$t},$u);
$j4={$g4,$i4};
$k4=q#/lib/named_in_ni.b#;
$l4=bless({$L2,$f4,$E3,$F3,$G3,$F3,$H3,$j4,$D,$k4},$Q3);
$m4={};
$n4=q#package#;
$o4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$p4=bless({$q,$o4,$s,$t},$u);
$q4={$n4,$p4};
$r4=q#/lib/namespaced.b#;
$s4=bless({$L2,$m4,$E3,$F3,$G3,$F3,$H3,$q4,$D,$r4},$Q3);
$t4={};
$u4=q#resolve#;
$v4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4={$u4,$w4};
$y4=q#/lib/resolver.b#;
$z4=bless({$L2,$t4,$E3,$F3,$G3,$F3,$H3,$x4,$D,$y4},$Q3);
$A4=[$R3,$d4,$l4,$s4,$z4];
$B4=bless({$D,$C3,$x3,$A4},$e4);
$C4=q#lib/tag::ctors#;
$D4={};
$E4=q#my $s = shift; $s->apply($s->package)#;
$F4=bless({$q,$E4,$s,$t},$u);
$G4=q#instantiate#;
$H4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$I4=bless({$q,$H4,$s,$t},$u);
$J4={$G4,$I4};
$K4=q#/lib/class_init.b#;
$L4=bless({$L2,$D4,$E3,$F4,$G3,$F3,$H3,$J4,$D,$K4},$Q3);
$M4=q#fabric/rmi#;
$N4=q#io/buffer#;
$O4=q#io/cat#;
$P4=q#io/exec#;
$Q4=q#io/fd#;
$R4=q#io/file#;
$S4=q#io/mio#;
$T4=q#io/mio_channel#;
$U4=q#io/null#;
$V4=q#io/object#;
$W4=q#io/pid#;
$X4=q#io/str#;
$Y4=q#io/transfer#;
$Z4=q#io/transfer_async#;
$c5=q#io/transfer_sync#;
$d5=q#lib/behavior#;
$e5=q#lib/dataslice#;
$f5=q#lib/image#;
$g5=q#lib/ni#;
$h5=q#lib/quote_simple#;
$i5=q#lib/test_value#;
$j5=q#object#;
$k5=q#semantic/task#;
$l5={$M2,1,$N2,1,$M4,1,$O2,1,$N4,1,$P2,1,$O4,1,$Q2,1,$P4,1,$R2,1,$Q4,1,$S2,1,$R4,1,$T2,1,$S4,1,$U2,1,$T4,1,$V2,1,$U4,1,$W2,1,$V4,1,$X2,1,$W4,1,$Y2,1,$X4,1,$Z2,1,$Y4,1,$c3,1,$Z4,1,$d3,1,$c5,1,$e3,1,$d5,1,$f3,1,$S3,1,$g3,1,$e5,1,$h3,1,$F,1,$i3,1,$u,1,$j3,1,$f5,1,$k3,1,$g5,1,$l3,1,$h5,1,$m3,1,$Q3,1,$n3,1,$e4,1,$o3,1,$i5,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$j5,1,$s3,1,$t3,1,$u3,1,$k5,1,$v3,1};
$m5=q#/object#;
$n5={};
$o5=q#ni 'ni:/' . ref shift#;
$p5=bless({$q,$o5,$s,$t},$u);
$q5={$M2,$p5};
$r5=q#/lib/instance.b#;
$s5=bless({$L2,$n5,$E3,$F3,$G3,$F3,$H3,$q5,$D,$r5},$Q3);
$t5=[$s5];
$u5=bless({$L2,$l5,$D,$m5,$x3,$t5},$s3);
$v5=q#object.c::ctors#;
$w5={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$d5,1,$f3,1,$S3,1,$g3,1,$e5,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$Q3,1,$n3,1,$e4,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$x5=q#/lib/behavior#;
$y5={};
$z5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$A5=bless({$q,$z5,$s,$t},$u);
$B5={$e,$A5};
$C5=q#/lib/documentable.b#;
$D5=bless({$L2,$y5,$E3,$F3,$G3,$F3,$H3,$B5,$D,$C5},$Q3);
$E5=[$u5,$D5];
$F5=bless({$L2,$w5,$D,$x5,$x3,$E5},$f3);
$G5=q#lib/behavior.c::ctors#;
$H5={$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$S3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$y3,1,$q3,1,$z3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1};
$I5=q#/lib/definition.b#;
$J5={};
$K5=q#def#;
$L5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/definition_def.b#;
$P5=bless({$L2,$J5,$E3,$F3,$G3,$F3,$H3,$N5,$D,$O5},$Q3);
$Q5={};
$R5=q#ro#;
$S5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$T5=bless({$q,$S5,$s,$t},$u);
$U5=q#rw#;
$V5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$W5=bless({$q,$V5,$s,$t},$u);
$X5={$R5,$T5,$U5,$W5};
$Y5=q#/lib/accessor.b#;
$Z5=bless({$L2,$Q5,$E3,$F3,$G3,$F3,$H3,$X5,$D,$Y5},$Q3);
$c6={};
$d6=q#(""#;
$e6=q#shift->name#;
$f6=bless({$q,$e6,$s,$t},$u);
$g6={$d6,$f6};
$h6=q#/lib/name_as_string.b#;
$i6=bless({$L2,$c6,$E3,$F3,$G3,$F3,$H3,$g6,$D,$h6},$Q3);
$j6={};
$k6=q#(eq#;
$l6=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$m6=bless({$q,$l6,$s,$t},$u);
$n6={$k6,$m6};
$o6=q#/lib/ref_eq.b#;
$p6=bless({$L2,$j6,$E3,$F3,$G3,$F3,$H3,$n6,$D,$o6},$Q3);
$q6={};
$r6=q#defdata#;
$s6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$t6=bless({$q,$s6,$s,$t},$u);
$u6={$r6,$t6};
$v6=q#/lib/definition_defdata.b#;
$w6=bless({$L2,$q6,$E3,$F3,$G3,$F3,$H3,$u6,$D,$v6},$Q3);
$x6=[$P5,$Z5,$i6,$p6,$w6];
$y6=bless({$L2,$H5,$D,$I5,$x3,$x6},$S3);
$z6=q#lib/branch::ctors#;
$A6=[$B4,$L4,$u5,$F5,$y6];
$B6=bless({$L2,$A3,$D,$B3,$x3,$A6},$r3);
$C6=q#module.c::ctors#;
$D6={};
$E6=q#DESTROY#;
$F6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$G6=bless({$q,$F6,$s,$t},$u);
$H6=q#new#;
$I6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$J6=bless({$q,$I6,$s,$t},$u);
$K6={$E6,$G6,$H6,$J6};
$L6=q#/lib/instantiable.b#;
$M6=bless({$L2,$D6,$H3,$K6,$D,$L6},$Q3);
$N6={};
$O6=q#child#;
$P6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$Q6=bless({$q,$P6,$s,$t},$u);
$R6={$O6,$Q6};
$S6=q#/lib/subclass.b#;
$T6=bless({$L2,$N6,$E3,$F3,$G3,$F3,$H3,$R6,$D,$S6},$Q3);
$U6=[$B6,$M6,$L4,$B6,$T6];
$V6=bless({$L2,$w3,$D,$E,$x3,$U6},$N2);
$W6=q#class.c::ctors#;
$X6=q#ni:/class.c#;
$Y6={$N2,1,$u3,1};
$Z6=q#/class.c#;
$c7={$N2,1,$r3,1,$u3,1};
$d7=q#/module.c#;
$e7={$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$r3,1,$s3,1,$u3,1,$v3,1};
$f7=q#/object.c#;
$g7=[$V6];
$h7=bless({$L2,$e7,$D,$f7,$x3,$g7},$y3);
$i7=q#metaclass::ctors#;
$j7={$N2,1,$f3,1,$g3,1,$h3,1,$n3,1,$o3,1,$r3,1,$u3,1};
$k7=q#/lib/behavior.c#;
$l7=[$h7];
$m7=bless({$L2,$j7,$D,$k7,$x3,$l7},$y3);
$n7=[$h7,$M6,$m7];
$o7=bless({$L2,$c7,$D,$d7,$x3,$n7},$y3);
$p7=[$o7];
$q7=bless({$L2,$Y6,$D,$Z6,$x3,$p7},$y3);
$r7=q#ni:/fabric/rmi#;
$s7={$M4,1};
$t7=q#/fabric/rmi#;
$u7={};
$v7=[];
$w7=q#my ($class, $io, $quote) = @_;#;
$x7=bless({$o,$v7,$q,$w7,$s,$t},$u);
$y7={$G4,$x7};
$z7=q#/fabric/rmi_init.b#;
$A7=bless({$L2,$u7,$E3,$F3,$G3,$F3,$H3,$y7,$D,$z7},$Q3);
$B7=[$u5,$A7];
$C7=bless({$L2,$s7,$D,$t7,$x3,$B7},$O2);
$D7=q#fabric/rmi.c::ctors#;
$E7=q#ni:/fabric/rmi.c#;
$F7={$O2,1};
$G7=q#/fabric/rmi.c#;
$H7=[$h7];
$I7=bless({$L2,$F7,$D,$G7,$x3,$H7},$y3);
$J7=q#ni:/fabric/rmi_init.b#;
$K7=q#ni:/io/buffer#;
$L7={$N4,1};
$M7={$N4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1,$T4,1,$U4,1,$V4,1,$W4,1,$X4,1};
$N7=q#/io/object#;
$O7={};
$P7=q#(bool#;
$Q7=[];
$R7=bless({$o,$Q7,$q,1,$s,$t},$u);
$S7={$P7,$R7};
$T7=q#/io/object_ops.b#;
$U7=bless({$L2,$O7,$E3,$F3,$G3,$F3,$H3,$S7,$D,$T7},$Q3);
$V7={};
$W7=q#die#;
$X7=[];
$Y7=q#shift; die join " ", @_#;
$Z7=bless({$o,$X7,$q,$Y7,$s,$t},$u);
$c8=q#io_check#;
$d8=[];
$e8=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$f8=bless({$o,$d8,$q,$e8,$s,$t},$u);
$g8=q#io_check_defined#;
$h8=[];
$i8=q#shift->io_check(sub {defined shift}, @_)#;
$j8=bless({$o,$h8,$q,$i8,$s,$t},$u);
$k8=q#io_check_true#;
$l8=[];
$m8=q#shift->io_check(sub {shift}, @_)#;
$n8=bless({$o,$l8,$q,$m8,$s,$t},$u);
$o8={$W7,$Z7,$c8,$f8,$g8,$j8,$k8,$n8};
$p8=q#/io/object_checks.b#;
$q8=bless({$L2,$V7,$E3,$F3,$G3,$F3,$H3,$o8,$D,$p8},$Q3);
$r8={};
$s8=q#(+#;
$t8=[];
$u8=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$v8=bless({$o,$t8,$q,$u8,$s,$t},$u);
$w8={$s8,$v8};
$x8=q#/io/object_constructors.b#;
$y8=bless({$L2,$r8,$E3,$F3,$G3,$F3,$H3,$w8,$D,$x8},$Q3);
$z8={};
$A8=q#read_all#;
$B8=[];
$C8=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$D8=bless({$o,$B8,$q,$C8,$s,$t},$u);
$E8=q#write_all#;
$F8=[];
$G8=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_async($self);#;
$H8=bless({$o,$F8,$q,$G8,$s,$t},$u);
$I8={$A8,$D8,$E8,$H8};
$J8=q#/io/object_memory.b#;
$K8=bless({$L2,$z8,$E3,$F3,$G3,$F3,$H3,$I8,$D,$J8},$Q3);
$L8={};
$M8=q#into_sync#;
$N8=[];
$O8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$P8=bless({$o,$N8,$q,$O8,$s,$t},$u);
$Q8={$M8,$P8};
$R8=q#/io/object_transfer_sync.b#;
$S8=bless({$L2,$L8,$E3,$F3,$G3,$F3,$H3,$Q8,$D,$R8},$Q3);
$T8={};
$U8=q#into_async#;
$V8=[];
$W8=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$X8=bless({$o,$V8,$q,$W8,$s,$t},$u);
$Y8={$U8,$X8};
$Z8=q#/io/object_transfer_async.b#;
$c9=bless({$L2,$T8,$E3,$F3,$G3,$F3,$H3,$Y8,$D,$Z8},$Q3);
$d9=[$u5,$U7,$q8,$y8,$K8,$S8,$c9,$c9,$S8];
$e9=bless({$L2,$M7,$D,$N7,$x3,$d9},$X2);
$f9=q#io/object.c::ctors#;
$g9={};
$h9=[];
$i9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$j9=bless({$o,$h9,$q,$i9,$s,$t},$u);
$k9={$G4,$j9};
$l9=q#/io/buffer_init.b#;
$m9=bless({$L2,$g9,$E3,$F3,$G3,$F3,$H3,$k9,$D,$l9},$Q3);
$n9={};
$o9=q#read#;
$p9=[];
$q9=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$r9=bless({$o,$p9,$q,$q9,$s,$t},$u);
$s9=q#read_capacity#;
$t9=[];
$u9=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$v9=bless({$o,$t9,$q,$u9,$s,$t},$u);
$w9=q#write#;
$x9=[];
$y9=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9=q#write_capacity#;
$B9=[];
$C9=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$D9=bless({$o,$B9,$q,$C9,$s,$t},$u);
$E9={$o9,$r9,$s9,$v9,$w9,$z9,$A9,$D9};
$F9=q#/io/buffer_io.b#;
$G9=bless({$L2,$n9,$E3,$F3,$G3,$F3,$H3,$E9,$D,$F9},$Q3);
$H9=[$e9,$m9,$G9];
$I9=bless({$L2,$L7,$D,$g1,$x3,$H9},$P2);
$J9=q#io/buffer.c::ctors#;
$K9=q#ni:/io/buffer.c#;
$L9={$P2,1};
$M9=q#/io/buffer.c#;
$N9={$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1};
$O9=q#/io/object.c#;
$P9=[$h7];
$Q9=bless({$L2,$N9,$D,$O9,$x3,$P9},$y3);
$R9=[$Q9];
$S9=bless({$L2,$L9,$D,$M9,$x3,$R9},$y3);
$T9=q#ni:/io/buffer_init.b#;
$U9=q#ni:/io/buffer_io.b#;
$V9=q#ni:/io/cat#;
$W9={$O4,1};
$X9={};
$Y9=[];
$Z9=q#shift; +{fs => [@_]}#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da={$G4,$ca};
$ea=q#/io/cat_init.b#;
$fa=bless({$L2,$X9,$E3,$F3,$G3,$F3,$H3,$da,$D,$ea},$Q3);
$ga={};
$ha=[];
$ia=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$ja=bless({$o,$ha,$q,$ia,$s,$t},$u);
$ka={$o9,$ja};
$la=q#/io/cat_read.b#;
$ma=bless({$L2,$ga,$E3,$F3,$G3,$F3,$H3,$ka,$D,$la},$Q3);
$na=[$e9,$fa,$ma];
$oa=bless({$L2,$W9,$D,$s1,$x3,$na},$Q2);
$pa=q#io/cat.c::ctors#;
$qa=q#ni:/io/cat.c#;
$ra={$Q2,1};
$sa=q#/io/cat.c#;
$ta=[$Q9];
$ua=bless({$L2,$ra,$D,$sa,$x3,$ta},$y3);
$va=q#ni:/io/cat_init.b#;
$wa=q#ni:/io/cat_read.b#;
$xa=q#ni:/io/exec#;
$ya={$P4,1};
$za={};
$Aa=q#argv#;
$Ba=[];
$Ca=q#shift->{'argv'}#;
$Da=bless({$o,$Ba,$q,$Ca,$s,$t},$u);
$Ea={$Aa,$Da};
$Fa=q#/io/exec_ro.b#;
$Ga=bless({$L2,$za,$E3,$F3,$G3,$F3,$H3,$Ea,$D,$Fa},$Q3);
$Ha={};
$Ia=[];
$Ja=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Ka=bless({$o,$Ia,$q,$Ja,$s,$t},$u);
$La={$G4,$Ka};
$Ma=q#/io/exec_init.b#;
$Na=bless({$L2,$Ha,$E3,$F3,$G3,$F3,$H3,$La,$D,$Ma},$Q3);
$Oa={};
$Pa=q#connect#;
$Qa=[];
$Ra=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta=q#in_pipe#;
$Ua=[];
$Va=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#out_pipe#;
$Ya=[];
$Za=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db=q#setup_stdio#;
$eb=[];
$fb=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb={$Pa,$Sa,$Ta,$Wa,$Xa,$cb,$db,$gb};
$ib=q#/io/exec_io_setup.b#;
$jb=bless({$L2,$Oa,$E3,$F3,$G3,$F3,$H3,$hb,$D,$ib},$Q3);
$kb={};
$lb=q#binds_fd#;
$mb=[];
$nb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#fd#;
$qb=[];
$rb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#stderr#;
$ub=[];
$vb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#stdin#;
$yb=[];
$zb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb=q#stdout#;
$Cb=[];
$Db=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb={$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab,$Bb,$Eb};
$Gb=q#/io/exec_io_accessors.b#;
$Hb=bless({$L2,$kb,$E3,$F3,$G3,$F3,$H3,$Fb,$D,$Gb},$Q3);
$Ib={};
$Jb=q#env#;
$Kb=[];
$Lb=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb={$Jb,$Mb};
$Ob=q#/io/exec_env.b#;
$Pb=bless({$L2,$Ib,$E3,$F3,$G3,$F3,$H3,$Nb,$D,$Ob},$Q3);
$Qb={};
$Rb=q#exec#;
$Sb=[];
$Tb=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#fork#;
$Wb=[];
$Xb=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#move_fds#;
$cc=[];
$dc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc={$Rb,$Ub,$Vb,$Yb,$Zb,$ec};
$gc=q#/io/exec_fork.b#;
$hc=bless({$L2,$Qb,$E3,$F3,$G3,$F3,$H3,$fc,$D,$gc},$Q3);
$ic=[$e9,$Ga,$Na,$jb,$Hb,$Pb,$hc];
$jc=bless({$L2,$ya,$D,$E1,$x3,$ic},$R2);
$kc=q#io/exec.c::ctors#;
$lc=q#ni:/io/exec.c#;
$mc={$R2,1};
$nc=q#/io/exec.c#;
$oc=[$Q9];
$pc=bless({$L2,$mc,$D,$nc,$x3,$oc},$y3);
$qc=q#ni:/io/exec_env.b#;
$rc=q#ni:/io/exec_fork.b#;
$sc=q#ni:/io/exec_init.b#;
$tc=q#ni:/io/exec_io_accessors.b#;
$uc=q#ni:/io/exec_io_setup.b#;
$vc=q#ni:/io/exec_ro.b#;
$wc=q#ni:/io/fd#;
$xc={$Q4,1};
$yc=q#/io/fd#;
$zc={};
$Ac=[];
$Bc=q#shift->{'fd'}#;
$Cc=bless({$o,$Ac,$q,$Bc,$s,$t},$u);
$Dc={$pb,$Cc};
$Ec=q#/io/fd_readers.b#;
$Fc=bless({$L2,$zc,$E3,$F3,$G3,$F3,$H3,$Dc,$D,$Ec},$Q3);
$Gc={};
$Hc=[];
$Ic=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Jc=bless({$o,$Hc,$q,$Ic,$s,$t},$u);
$Kc={$G4,$Jc};
$Lc=q#/io/fd_init.b#;
$Mc=bless({$L2,$Gc,$E3,$F3,$G3,$F3,$H3,$Kc,$D,$Lc},$Q3);
$Nc={};
$Oc=q#be#;
$Pc=[];
$Qc=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$t},$u);
$Sc={$Oc,$Rc};
$Tc=q#/io/fd_shell.b#;
$Uc=bless({$L2,$Nc,$E3,$F3,$G3,$F3,$H3,$Sc,$D,$Tc},$Q3);
$Vc={};
$Wc=q#cloexec#;
$Xc=[];
$Yc=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd=q#fcntl_flag#;
$dd=[];
$ed=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd=q#nonblock#;
$hd=[];
$id=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$Wc,$Zc,$cd,$fd,$gd,$jd};
$ld=q#/io/fd_fcntl.b#;
$md=bless({$L2,$Vc,$E3,$F3,$G3,$F3,$H3,$kd,$D,$ld},$Q3);
$nd={};
$od=[];
$pd=q#shift->close#;
$qd=bless({$o,$od,$q,$pd,$s,$t},$u);
$rd=q#close#;
$sd=[];
$td=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$ud=bless({$o,$sd,$q,$td,$s,$t},$u);
$vd={$rd,$ud};
$wd=q#/io/fd_gc.b#;
$xd=bless({$L2,$nd,$E3,$F3,$G3,$qd,$H3,$vd,$D,$wd},$Q3);
$yd={};
$zd=[];
$Ad=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$Bd=bless({$o,$zd,$q,$Ad,$s,$t},$u);
$Cd=[];
$Dd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd={$o9,$Bd,$w9,$Ed};
$Gd=q#/io/fd_perlio.b#;
$Hd=bless({$L2,$yd,$E3,$F3,$G3,$F3,$H3,$Fd,$D,$Gd},$Q3);
$Id=[$e9,$Fc,$Mc,$Uc,$md,$xd,$Hd];
$Jd=bless({$L2,$xc,$D,$yc,$x3,$Id},$S2);
$Kd=q#io/fd.c::ctors#;
$Ld=q#ni:/io/fd.c#;
$Md={$S2,1};
$Nd=q#/io/fd.c#;
$Od=[$Q9];
$Pd=bless({$L2,$Md,$D,$Nd,$x3,$Od},$y3);
$Qd=q#ni:/io/fd_fcntl.b#;
$Rd=q#ni:/io/fd_gc.b#;
$Sd=q#ni:/io/fd_init.b#;
$Td=q#ni:/io/fd_perlio.b#;
$Ud=q#ni:/io/fd_readers.b#;
$Vd=q#ni:/io/fd_shell.b#;
$Wd=q#ni:/io/file#;
$Xd={$R4,1};
$Yd=q#/io/file#;
$Zd={};
$ce=[];
$de=q#shift->{'name'}#;
$ee=bless({$o,$ce,$q,$de,$s,$t},$u);
$fe={$D,$ee};
$ge=q#/io/file_readers.b#;
$he=bless({$L2,$Zd,$E3,$F3,$G3,$F3,$H3,$fe,$D,$ge},$Q3);
$ie={};
$je=q#mode#;
$ke=[];
$le=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$me=bless({$o,$ke,$q,$le,$s,$t},$u);
$ne={$je,$me};
$oe=q#/io/file_accessors.b#;
$pe=bless({$L2,$ie,$E3,$F3,$G3,$F3,$H3,$ne,$D,$oe},$Q3);
$qe={};
$re=[];
$se=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$te=bless({$o,$re,$q,$se,$s,$t},$u);
$ue={$G4,$te};
$ve=q#/io/file_init.b#;
$we=bless({$L2,$qe,$E3,$F3,$G3,$F3,$H3,$ue,$D,$ve},$Q3);
$xe={};
$ye=[];
$ze=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Ae=bless({$o,$ye,$q,$ze,$s,$t},$u);
$Be=q#r#;
$Ce=[];
$De=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe=[];
$Ge=q#shift->r->read(@_)#;
$He=bless({$o,$Fe,$q,$Ge,$s,$t},$u);
$Ie=q#w#;
$Je=[];
$Ke=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Le=bless({$o,$Je,$q,$Ke,$s,$t},$u);
$Me=[];
$Ne=q#shift->w->write(@_)#;
$Oe=bless({$o,$Me,$q,$Ne,$s,$t},$u);
$Pe={$rd,$Ae,$Be,$Ee,$o9,$He,$Ie,$Le,$w9,$Oe};
$Qe=q#/io/file_io.b#;
$Re=bless({$L2,$xe,$E3,$F3,$G3,$F3,$H3,$Pe,$D,$Qe},$Q3);
$Se=[$e9,$he,$pe,$we,$Re];
$Te=bless({$L2,$Xd,$D,$Yd,$x3,$Se},$T2);
$Ue=q#io/file.c::ctors#;
$Ve=q#ni:/io/file.c#;
$We={$T2,1};
$Xe=q#/io/file.c#;
$Ye=[$Q9];
$Ze=bless({$L2,$We,$D,$Xe,$x3,$Ye},$y3);
$cf=q#ni:/io/file_accessors.b#;
$df=q#ni:/io/file_init.b#;
$ef=q#ni:/io/file_io.b#;
$ff=q#ni:/io/file_readers.b#;
$gf=q#ni:/io/mio#;
$hf={$S4,1};
$if={};
$jf=q#io#;
$kf=[];
$lf=q#shift->{'io'}#;
$mf=bless({$o,$kf,$q,$lf,$s,$t},$u);
$nf=q#packet_size#;
$of=[];
$pf=q#shift->{'packet_size'}#;
$qf=bless({$o,$of,$q,$pf,$s,$t},$u);
$rf={$jf,$mf,$nf,$qf};
$sf=q#/io/mio_ro.b#;
$tf=bless({$L2,$if,$E3,$F3,$G3,$F3,$H3,$rf,$D,$sf},$Q3);
$uf={};
$vf=[];
$wf=q#my ($self, %args) = @_;
+{packet_size       => $args{packet_size} || 32768,
  channel_capacity  => $args{channel_capacity} || 65536,
  channel_id        => 0,
  channels          => {}};#;
$xf=bless({$o,$vf,$q,$wf,$s,$t},$u);
$yf={$G4,$xf};
$zf=q#/io/mio_init.b#;
$Af=bless({$L2,$uf,$E3,$F3,$G3,$F3,$H3,$yf,$D,$zf},$Q3);
$Bf={};
$Cf=q#data_packet#;
$Df=[];
$Ef=q#my $self       = shift;
my $channel_id = shift;
pack 'NN/a', $channel_id, $_[0];#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=q#eof_packet#;
$Hf=[];
$If=q#my ($self, $channel_id) = @_;
pack 'NN', $channel_id, 0;#;
$Jf=bless({$o,$Hf,$q,$If,$s,$t},$u);
$Kf={$Cf,$Ff,$Gf,$Jf};
$Lf=q#/io/mio_packet.b#;
$Mf=bless({$L2,$Bf,$E3,$F3,$G3,$F3,$H3,$Kf,$D,$Lf},$Q3);
$Nf={};
$Of=[];
$Pf=bless({$o,$Of,$q,$t,$s,$t},$u);
$Qf=[];
$Rf=bless({$o,$Qf,$q,$t,$s,$t},$u);
$Sf={$o9,$Pf,$w9,$Rf};
$Tf=q#/io/mio_io.b#;
$Uf=bless({$L2,$Nf,$E3,$F3,$G3,$F3,$H3,$Sf,$D,$Tf},$Q3);
$Vf={};
$Wf=q#channel#;
$Xf=[];
$Yf=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$c;#;
$Zf=bless({$o,$Xf,$q,$Yf,$s,$t},$u);
$cg=q#channels#;
$dg=[];
$eg=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$fg=bless({$o,$dg,$q,$eg,$s,$t},$u);
$gg={$Wf,$Zf,$cg,$fg};
$hg=q#/io/mio_channel.b#;
$ig=bless({$L2,$Vf,$E3,$F3,$G3,$F3,$H3,$gg,$D,$hg},$Q3);
$jg=[$e9,$tf,$Af,$Mf,$Uf,$ig];
$kg=bless({$L2,$hf,$D,$O1,$x3,$jg},$U2);
$lg=q#io/mio.c::ctors#;
$mg=q#ni:/io/mio.c#;
$ng={$U2,1};
$og=q#/io/mio.c#;
$pg=[$Q9];
$qg=bless({$L2,$ng,$D,$og,$x3,$pg},$y3);
$rg=q#ni:/io/mio_channel#;
$sg={$T4,1};
$tg=q#/io/mio_channel#;
$ug={};
$vg=q#capacity#;
$wg=[];
$xg=q#shift->{'capacity'}#;
$yg=bless({$o,$wg,$q,$xg,$s,$t},$u);
$zg=q#channel_id#;
$Ag=[];
$Bg=q#shift->{'channel_id'}#;
$Cg=bless({$o,$Ag,$q,$Bg,$s,$t},$u);
$Dg=q#mio#;
$Eg=[];
$Fg=q#shift->{'mio'}#;
$Gg=bless({$o,$Eg,$q,$Fg,$s,$t},$u);
$Hg={$vg,$yg,$zg,$Cg,$Dg,$Gg};
$Ig=q#/io/mio_channel_ro.b#;
$Jg=bless({$L2,$ug,$E3,$F3,$G3,$F3,$H3,$Hg,$D,$Ig},$Q3);
$Kg={};
$Lg=[];
$Mg=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  channel_id   => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Ng=bless({$o,$Lg,$q,$Mg,$s,$t},$u);
$Og={$G4,$Ng};
$Pg=q#/io/mio_channel_init.b#;
$Qg=bless({$L2,$Kg,$E3,$F3,$G3,$F3,$H3,$Og,$D,$Pg},$Q3);
$Rg={};
$Sg=[];
$Tg=q#shift->{read_buffer} ->read(@_)#;
$Ug=bless({$o,$Sg,$q,$Tg,$s,$t},$u);
$Vg=[];
$Wg=q#shift->{write_buffer}->write(@_)#;
$Xg=bless({$o,$Vg,$q,$Wg,$s,$t},$u);
$Yg={$o9,$Ug,$w9,$Xg};
$Zg=q#/io/mio_channel_io.b#;
$ch=bless({$L2,$Rg,$E3,$F3,$G3,$F3,$H3,$Yg,$D,$Zg},$Q3);
$dh=[$e9,$Jg,$Qg,$ch];
$eh=bless({$L2,$sg,$D,$tg,$x3,$dh},$V2);
$fh=q#io/mio_channel.c::ctors#;
$gh=q#ni:/io/mio_channel.b#;
$hh=q#ni:/io/mio_channel.c#;
$ih={$V2,1};
$jh=q#/io/mio_channel.c#;
$kh=[$Q9];
$lh=bless({$L2,$ih,$D,$jh,$x3,$kh},$y3);
$mh=q#ni:/io/mio_channel_init.b#;
$nh=q#ni:/io/mio_channel_io.b#;
$oh=q#ni:/io/mio_channel_ro.b#;
$ph=q#ni:/io/mio_init.b#;
$qh=q#ni:/io/mio_io.b#;
$rh=q#ni:/io/mio_packet.b#;
$sh=q#ni:/io/mio_ro.b#;
$th=q#ni:/io/named_io_fns.b#;
$uh={};
$vh=q#fcntl#;
$wh=[];
$xh=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$yh=bless({$o,$wh,$q,$xh,$s,$t},$u);
$zh=[];
$Ah=q#CORE::fork#;
$Bh=bless({$o,$zh,$q,$Ah,$s,$t},$u);
$Ch=q#open2#;
$Dh=[];
$Eh=q#CORE::open $_[0], $_[1]#;
$Fh=bless({$o,$Dh,$q,$Eh,$s,$t},$u);
$Gh=q#waitpid#;
$Hh=[];
$Ih=q#CORE::waitpid $_[0], $_[1]#;
$Jh=bless({$o,$Hh,$q,$Ih,$s,$t},$u);
$Kh={$vh,$yh,$Vb,$Bh,$Ch,$Fh,$Gh,$Jh};
$Lh=q#/io/named_io_fns.b#;
$Mh=bless({$L2,$uh,$E3,$F3,$G3,$F3,$H3,$Kh,$D,$Lh},$Q3);
$Nh=q#main#;
$Oh=q#ni:/io/null#;
$Ph={$U4,1};
$Qh=q#/io/null#;
$Rh={};
$Sh=[];
$Th=q#+{fd => undef}#;
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh={$G4,$Uh};
$Wh=q#/io/null_init.b#;
$Xh=bless({$L2,$Rh,$E3,$F3,$G3,$F3,$H3,$Vh,$D,$Wh},$Q3);
$Yh={};
$Zh=[];
$ci=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$di=bless({$o,$Zh,$q,$ci,$s,$t},$u);
$ei=[];
$fi=q#shift->fd->read(@_)#;
$gi=bless({$o,$ei,$q,$fi,$s,$t},$u);
$hi=[];
$ii=q#shift->fd->write(@_)#;
$ji=bless({$o,$hi,$q,$ii,$s,$t},$u);
$ki={$pb,$di,$o9,$gi,$w9,$ji};
$li=q#/io/null_io.b#;
$mi=bless({$L2,$Yh,$E3,$F3,$G3,$F3,$H3,$ki,$D,$li},$Q3);
$ni=[$e9,$Xh,$mi];
$oi=bless({$L2,$Ph,$D,$Qh,$x3,$ni},$W2);
$pi=q#io/null.c::ctors#;
$qi=q#ni:/io/null.c#;
$ri={$W2,1};
$si=q#/io/null.c#;
$ti=[$Q9];
$ui=bless({$L2,$ri,$D,$si,$x3,$ti},$y3);
$vi=q#ni:/io/null_init.b#;
$wi=q#ni:/io/null_io.b#;
$xi=q#ni:/io/object#;
$yi=q#ni:/io/object.c#;
$zi=q#ni:/io/object_checks.b#;
$Ai=q#ni:/io/object_constructors.b#;
$Bi=q#ni:/io/object_memory.b#;
$Ci=q#ni:/io/object_ops.b#;
$Di=q#ni:/io/object_transfer_async.b#;
$Ei=q#ni:/io/object_transfer_sync.b#;
$Fi=q#ni:/io/pid#;
$Gi={$W4,1};
$Hi={};
$Ii=q#pid#;
$Ji=[];
$Ki=q#shift->{'pid'}#;
$Li=bless({$o,$Ji,$q,$Ki,$s,$t},$u);
$Mi=q#status#;
$Ni=[];
$Oi=q#shift->{'status'}#;
$Pi=bless({$o,$Ni,$q,$Oi,$s,$t},$u);
$Qi={$Ii,$Li,$Mi,$Pi};
$Ri=q#/io/pid_readers.b#;
$Si=bless({$L2,$Hi,$E3,$F3,$G3,$F3,$H3,$Qi,$D,$Ri},$Q3);
$Ti={};
$Ui=[];
$Vi=q#shift->await#;
$Wi=bless({$o,$Ui,$q,$Vi,$s,$t},$u);
$Xi=[];
$Yi=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Zi=bless({$o,$Xi,$q,$Yi,$s,$t},$u);
$cj={$G4,$Zi};
$dj=q#/io/pid_init.b#;
$ej=bless({$L2,$Ti,$E3,$F3,$G3,$Wi,$H3,$cj,$D,$dj},$Q3);
$fj={};
$gj=q#await#;
$hj=[];
$ij=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$jj=bless({$o,$hj,$q,$ij,$s,$t},$u);
$kj=q#running#;
$lj=[];
$mj=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$nj=bless({$o,$lj,$q,$mj,$s,$t},$u);
$oj={$gj,$jj,$kj,$nj};
$pj=q#/io/pid_wait.b#;
$qj=bless({$L2,$fj,$E3,$F3,$G3,$F3,$H3,$oj,$D,$pj},$Q3);
$rj={};
$sj=[];
$tj=q#shift->stdout->read(@_)#;
$uj=bless({$o,$sj,$q,$tj,$s,$t},$u);
$vj=[];
$wj=q#shift->stdin->write(@_)#;
$xj=bless({$o,$vj,$q,$wj,$s,$t},$u);
$yj={$o9,$uj,$w9,$xj};
$zj=q#/io/pid_io.b#;
$Aj=bless({$L2,$rj,$E3,$F3,$G3,$F3,$H3,$yj,$D,$zj},$Q3);
$Bj={};
$Cj=[];
$Dj=q#$_[0]->{external_fds}{$_[1]}#;
$Ej=bless({$o,$Cj,$q,$Dj,$s,$t},$u);
$Fj=[];
$Gj=q#shift->fd(2)#;
$Hj=bless({$o,$Fj,$q,$Gj,$s,$t},$u);
$Ij=[];
$Jj=q#shift->fd(0)#;
$Kj=bless({$o,$Ij,$q,$Jj,$s,$t},$u);
$Lj=[];
$Mj=q#shift->fd(1)#;
$Nj=bless({$o,$Lj,$q,$Mj,$s,$t},$u);
$Oj={$pb,$Ej,$tb,$Hj,$xb,$Kj,$Bb,$Nj};
$Pj=q#/io/pid_accessors.b#;
$Qj=bless({$L2,$Bj,$E3,$F3,$G3,$F3,$H3,$Oj,$D,$Pj},$Q3);
$Rj=[$e9,$Si,$ej,$qj,$Aj,$Qj];
$Sj=bless({$L2,$Gi,$D,$g2,$x3,$Rj},$Y2);
$Tj=q#io/pid.c::ctors#;
$Uj=q#ni:/io/pid.c#;
$Vj={$Y2,1};
$Wj=q#/io/pid.c#;
$Xj=[$Q9];
$Yj=bless({$L2,$Vj,$D,$Wj,$x3,$Xj},$y3);
$Zj=q#ni:/io/pid_accessors.b#;
$ck=q#ni:/io/pid_init.b#;
$dk=q#ni:/io/pid_io.b#;
$ek=q#ni:/io/pid_readers.b#;
$fk=q#ni:/io/pid_wait.b#;
$gk=q#ni:/io/str#;
$hk={$X4,1};
$ik=q#/io/str#;
$jk={};
$kk=q#data#;
$lk=[];
$mk=q#shift->{'data'}#;
$nk=bless({$o,$lk,$q,$mk,$s,$t},$u);
$ok=q#end#;
$pk=[];
$qk=q#shift->{'end'}#;
$rk=bless({$o,$pk,$q,$qk,$s,$t},$u);
$sk=q#start#;
$tk=[];
$uk=q#shift->{'start'}#;
$vk=bless({$o,$tk,$q,$uk,$s,$t},$u);
$wk={$kk,$nk,$ok,$rk,$sk,$vk};
$xk=q#/io/str_ro.b#;
$yk=bless({$L2,$jk,$E3,$F3,$G3,$F3,$H3,$wk,$D,$xk},$Q3);
$zk={};
$Ak=[];
$Bk=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Ck=bless({$o,$Ak,$q,$Bk,$s,$t},$u);
$Dk={$G4,$Ck};
$Ek=q#/io/str_init.b#;
$Fk=bless({$L2,$zk,$E3,$F3,$G3,$F3,$H3,$Dk,$D,$Ek},$Q3);
$Gk={};
$Hk=[];
$Ik=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Jk=bless({$o,$Hk,$q,$Ik,$s,$t},$u);
$Kk=q#remaining#;
$Lk=[];
$Mk=q#my $self = shift; $$self{end} - $$self{start}#;
$Nk=bless({$o,$Lk,$q,$Mk,$s,$t},$u);
$Ok=[];
$Pk=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Qk=bless({$o,$Ok,$q,$Pk,$s,$t},$u);
$Rk={$o9,$Jk,$Kk,$Nk,$w9,$Qk};
$Sk=q#/io/str_io.b#;
$Tk=bless({$L2,$Gk,$E3,$F3,$G3,$F3,$H3,$Rk,$D,$Sk},$Q3);
$Uk=[$e9,$yk,$Fk,$Tk];
$Vk=bless({$L2,$hk,$D,$ik,$x3,$Uk},$Z2);
$Wk=q#io/str.c::ctors#;
$Xk=q#ni:/io/str.c#;
$Yk={$Z2,1};
$Zk=q#/io/str.c#;
$cl=[$Q9];
$dl=bless({$L2,$Yk,$D,$Zk,$x3,$cl},$y3);
$el=q#ni:/io/str_init.b#;
$fl=q#ni:/io/str_io.b#;
$gl=q#ni:/io/str_ro.b#;
$hl=q#ni:/io/transfer#;
$il={$Y4,1,$Z4,1,$c5,1};
$jl=q#/io/transfer#;
$kl={$Y4,1,$Z4,1,$c5,1,$k5,1};
$ll=q#/semantic/task#;
$ml={};
$nl=q#outcome#;
$ol=[];
$pl=q#shift->{'outcome'}#;
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl={$nl,$ql};
$sl=q#/semantic/task_ro.b#;
$tl=bless({$L2,$ml,$E3,$F3,$G3,$F3,$H3,$rl,$D,$sl},$Q3);
$ul={};
$vl=q#failure#;
$wl=[];
$xl=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$yl=bless({$o,$wl,$q,$xl,$s,$t},$u);
$zl=q#success#;
$Al=[];
$Bl=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Cl=bless({$o,$Al,$q,$Bl,$s,$t},$u);
$Dl={$vl,$yl,$zl,$Cl};
$El=q#/semantic/task_outcome.b#;
$Fl=bless({$L2,$ul,$E3,$F3,$G3,$F3,$H3,$Dl,$D,$El},$Q3);
$Gl=[$u5,$tl,$Fl];
$Hl=bless({$L2,$kl,$D,$ll,$x3,$Gl},$v3);
$Il=q#semantic/task.c::ctors#;
$Jl={};
$Kl=[];
$Ll=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Ml=bless({$o,$Kl,$q,$Ll,$s,$t},$u);
$Nl=[];
$Ol=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Pl=bless({$o,$Nl,$q,$Ol,$s,$t},$u);
$Ql=[];
$Rl=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Sl=bless({$o,$Ql,$q,$Rl,$s,$t},$u);
$Tl={$o9,$Pl,$w9,$Sl};
$Ul=q#/io/transfer_io_interop.b#;
$Vl=bless({$L2,$Jl,$E3,$Ml,$G3,$F3,$H3,$Tl,$D,$Ul},$Q3);
$Wl={};
$Xl=q#pressure#;
$Yl=[];
$Zl=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$cm=bless({$o,$Yl,$q,$Zl,$s,$t},$u);
$dm=q#read_limit_throughput#;
$em=[];
$fm=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$gm=bless({$o,$em,$q,$fm,$s,$t},$u);
$hm=q#throughput#;
$im=[];
$jm=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$km=bless({$o,$im,$q,$jm,$s,$t},$u);
$lm=q#write_limit_throughput#;
$mm=[];
$nm=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$om=bless({$o,$mm,$q,$nm,$s,$t},$u);
$pm={$Xl,$cm,$dm,$gm,$hm,$km,$lm,$om};
$qm=q#/io/transfer_io_measurement.b#;
$rm=bless({$L2,$Wl,$E3,$F3,$G3,$F3,$H3,$pm,$D,$qm},$Q3);
$sm=[$Hl,$Vl,$rm];
$tm=bless({$L2,$il,$D,$jl,$x3,$sm},$c3);
$um=q#io/transfer.c::ctors#;
$vm=q#ni:/io/transfer.c#;
$wm={$c3,1,$d3,1,$e3,1};
$xm=q#/io/transfer.c#;
$ym={$c3,1,$d3,1,$e3,1,$v3,1};
$zm=q#/semantic/task.c#;
$Am=[$h7];
$Bm=bless({$L2,$ym,$D,$zm,$x3,$Am},$y3);
$Cm={};
$Dm=[];
$Em=q#my $self = shift;
ni('ni:/io/object')->def("/io/object_transfer_$1.b",
  "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\\@_)->run})
if $self->name =~ /transfer_(\\w+)$/;#;
$Fm=bless({$o,$Dm,$q,$Em,$s,$t},$u);
$Gm={};
$Hm=q#/io/transfer.c_into.b#;
$Im=bless({$L2,$Cm,$E3,$Fm,$G3,$F3,$H3,$Gm,$D,$Hm},$Q3);
$Jm=[$Bm,$Im];
$Km=bless({$L2,$wm,$D,$xm,$x3,$Jm},$y3);
$Lm=q#ni:/io/transfer.c_into.b#;
$Mm=q#ni:/io/transfer_async#;
$Nm={$Z4,1};
$Om=q#/io/transfer_async#;
$Pm={};
$Qm=q#dest_io#;
$Rm=[];
$Sm=q#shift->{'dest_io'}#;
$Tm=bless({$o,$Rm,$q,$Sm,$s,$t},$u);
$Um=q#id#;
$Vm=[];
$Wm=q#shift->{'id'}#;
$Xm=bless({$o,$Vm,$q,$Wm,$s,$t},$u);
$Ym=q#source_io#;
$Zm=[];
$cn=q#shift->{'source_io'}#;
$dn=bless({$o,$Zm,$q,$cn,$s,$t},$u);
$en={$Qm,$Tm,$Um,$Xm,$Ym,$dn};
$fn=q#/io/transfer_async_ro.b#;
$gn=bless({$L2,$Pm,$E3,$F3,$G3,$F3,$H3,$en,$D,$fn},$Q3);
$hn={};
$in=[];
$jn=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$kn=bless({$o,$in,$q,$jn,$s,$t},$u);
$ln={$G4,$kn};
$mn=q#/io/transfer_async_init.b#;
$nn=bless({$L2,$hn,$E3,$F3,$G3,$F3,$H3,$ln,$D,$mn},$Q3);
$on={};
$pn=[];
$qn=q#ni('ni:/io/transfer_async')->track(shift)#;
$rn=bless({$o,$pn,$q,$qn,$s,$t},$u);
$sn=[];
$tn=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$un=bless({$o,$sn,$q,$tn,$s,$t},$u);
$vn={};
$wn=q#/io/transfer_async_lifecycle.b#;
$xn=bless({$L2,$on,$E3,$rn,$G3,$un,$H3,$vn,$D,$wn},$Q3);
$yn={};
$zn=q#run#;
$An=[];
$Bn=q#shift#;
$Cn=bless({$o,$An,$q,$Bn,$s,$t},$u);
$Dn=q#run_async#;
$En=[];
$Fn=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Gn=bless({$o,$En,$q,$Fn,$s,$t},$u);
$Hn={$zn,$Cn,$Dn,$Gn};
$In=q#/io/transfer_async_run.b#;
$Jn=bless({$L2,$yn,$E3,$F3,$G3,$F3,$H3,$Hn,$D,$In},$Q3);
$Kn=[$tm,$gn,$nn,$xn,$Jn];
$Ln=q#tracked_transfers#;
$Mn={};
$Nn=bless({$L2,$Nm,$D,$Om,$x3,$Kn,$Ln,$Mn},$d3);
$On=q#io/transfer_async.c::ctors#;
$Pn=q#ni:/io/transfer_async.c#;
$Qn={$d3,1};
$Rn=q#/io/transfer_async.c#;
$Sn={};
$Tn=[];
$Un=q#shift->{tracked_transfers} = {}#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn=q#track#;
$Xn=[];
$Yn=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$Zn=bless({$o,$Xn,$q,$Yn,$s,$t},$u);
$co=q#untrack#;
$do=[];
$eo=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$fo=bless({$o,$do,$q,$eo,$s,$t},$u);
$go={$Wn,$Zn,$co,$fo};
$ho=q#/io/transfer_async.c_tracker.b#;
$io=bless({$L2,$Sn,$E3,$Vn,$G3,$F3,$H3,$go,$D,$ho},$Q3);
$jo=[$Km,$io];
$ko=bless({$L2,$Qn,$D,$Rn,$x3,$jo},$y3);
$lo=q#ni:/io/transfer_async.c_tracker.b#;
$mo=q#ni:/io/transfer_async_init.b#;
$no=q#ni:/io/transfer_async_lifecycle.b#;
$oo=q#ni:/io/transfer_async_ro.b#;
$po=q#ni:/io/transfer_async_run.b#;
$qo=q#ni:/io/transfer_io_interop.b#;
$ro=q#ni:/io/transfer_io_measurement.b#;
$so=q#ni:/io/transfer_sync#;
$to={$c5,1};
$uo=q#/io/transfer_sync#;
$vo={};
$wo=[];
$xo=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$yo=bless({$o,$wo,$q,$xo,$s,$t},$u);
$zo={$G4,$yo};
$Ao=q#/io/transfer_sync_init.b#;
$Bo=bless({$L2,$vo,$E3,$F3,$G3,$F3,$H3,$zo,$D,$Ao},$Q3);
$Co={};
$Do=[];
$Eo=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go={$zn,$Fo};
$Ho=q#/io/transfer_sync_run.b#;
$Io=bless({$L2,$Co,$E3,$F3,$G3,$F3,$H3,$Go,$D,$Ho},$Q3);
$Jo=[$tm,$Bo,$Io];
$Ko=bless({$L2,$to,$D,$uo,$x3,$Jo},$e3);
$Lo=q#io/transfer_sync.c::ctors#;
$Mo=q#ni:/io/transfer_sync.c#;
$No={$e3,1};
$Oo=q#/io/transfer_sync.c#;
$Po=[$Km];
$Qo=bless({$L2,$No,$D,$Oo,$x3,$Po},$y3);
$Ro=q#ni:/io/transfer_sync_init.b#;
$So=q#ni:/io/transfer_sync_run.b#;
$To=q#ni:/lib/accessor.b#;
$Uo=q#ni:/lib/behavior#;
$Vo=q#ni:/lib/behavior.c#;
$Wo=q#ni:/lib/branch#;
$Xo={$S3,1};
$Yo=q#/lib/branch#;
$Zo={};
$cp=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$dp=bless({$q,$cp,$s,$t},$u);
$ep={$G4,$dp};
$fp=q#/lib/branch_init.b#;
$gp=bless({$L2,$Zo,$E3,$F3,$G3,$F3,$H3,$ep,$D,$fp},$Q3);
$hp=[$F5,$d4,$R3,$gp,$y6];
$ip=bless({$L2,$Xo,$D,$Yo,$x3,$hp},$g3);
$jp=q#lib/branch.c::ctors#;
$kp=q#ni:/lib/branch.b#;
$lp=q#ni:/lib/branch.c#;
$mp={$g3,1};
$np=q#/lib/branch.c#;
$op=[$m7];
$pp=bless({$L2,$mp,$D,$np,$x3,$op},$y3);
$qp=q#ni:/lib/branch_init.b#;
$rp=q#ni:/lib/class_init.b#;
$sp=q#ni:/lib/dataslice#;
$tp={$e5,1};
$up=q#/lib/dataslice#;
$vp={};
$wp=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$xp=bless({$q,$wp,$s,$t},$u);
$yp={$G4,$xp};
$zp=q#/lib/dataslice_init.b#;
$Ap=bless({$L2,$vp,$E3,$F3,$G3,$F3,$H3,$yp,$D,$zp},$Q3);
$Bp={};
$Cp=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Dp=bless({$q,$Cp,$s,$t},$u);
$Ep={$L3,$Dp};
$Fp=q#/lib/dataslice_apply.b#;
$Gp=bless({$L2,$Bp,$E3,$F3,$G3,$F3,$H3,$Ep,$D,$Fp},$Q3);
$Hp=[$F5,$Ap,$Gp];
$Ip=bless({$L2,$tp,$D,$up,$x3,$Hp},$h3);
$Jp=q#lib/dataslice.c::ctors#;
$Kp=q#ni:/lib/dataslice.c#;
$Lp={$h3,1};
$Mp=q#/lib/dataslice.c#;
$Np=[$m7];
$Op=bless({$L2,$Lp,$D,$Mp,$x3,$Np},$y3);
$Pp=q#ni:/lib/dataslice_apply.b#;
$Qp=q#ni:/lib/dataslice_init.b#;
$Rp=q#ni:/lib/definition.b#;
$Sp=q#ni:/lib/definition_def.b#;
$Tp=q#ni:/lib/definition_defdata.b#;
$Up=q#ni:/lib/doc#;
$Vp={$F,1};
$Wp={};
$Xp=q#shift; +{name => shift, doc => []}#;
$Yp=bless({$q,$Xp,$s,$t},$u);
$Zp={$G4,$Yp};
$cq=q#/lib/doc_init.b#;
$dq=bless({$L2,$Wp,$E3,$F3,$G3,$F3,$H3,$Zp,$D,$cq},$Q3);
$eq={};
$fq=q#'ni.doc'#;
$gq=bless({$q,$fq,$s,$t},$u);
$hq={$g4,$gq};
$iq=q#/lib/doc_namespace.b#;
$jq=bless({$L2,$eq,$E3,$F3,$G3,$F3,$H3,$hq,$D,$iq},$Q3);
$kq={};
$lq=q#AUTOLOAD#;
$mq=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$nq=bless({$q,$mq,$s,$t},$u);
$oq={$lq,$nq};
$pq=q#/lib/doc_define.b#;
$qq=bless({$L2,$kq,$E3,$F3,$G3,$F3,$H3,$oq,$D,$pq},$Q3);
$rq={};
$sq=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$tq=bless({$q,$sq,$s,$t},$u);
$uq=q#tests#;
$vq=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$wq=bless({$q,$vq,$s,$t},$u);
$xq={$n,$tq,$uq,$wq};
$yq=q#/lib/doc_test.b#;
$zq=bless({$L2,$rq,$E3,$F3,$G3,$F3,$H3,$xq,$D,$yq},$Q3);
$Aq=[$u5,$d4,$dq,$jq,$qq,$zq];
$Bq=bless({$L2,$Vp,$D,$C2,$x3,$Aq},$i3);
$Cq=q#lib/doc.c::ctors#;
$Dq=q#ni:/lib/doc.c#;
$Eq={$i3,1};
$Fq=q#/lib/doc.c#;
$Gq=[$h7];
$Hq=bless({$L2,$Eq,$D,$Fq,$x3,$Gq},$y3);
$Iq=q#ni:/lib/doc_define.b#;
$Jq=q#ni:/lib/doc_init.b#;
$Kq=q#ni:/lib/doc_namespace.b#;
$Lq=q#ni:/lib/doc_test.b#;
$Mq=q#ni:/lib/documentable.b#;
$Nq=q#ni:/lib/fn#;
$Oq={$u,1};
$Pq=q#/lib/fn#;
$Qq={};
$Rq=q#shift->compile#;
$Sq=bless({$q,$Rq,$s,$t},$u);
$Tq=q#compile#;
$Uq=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Vq=bless({$q,$Uq,$s,$t},$u);
$Wq=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Xq=bless({$q,$Wq,$s,$t},$u);
$Yq={$Tq,$Vq,$G4,$Xq};
$Zq=q#/lib/fn_init.b#;
$cr=bless({$L2,$Qq,$E3,$Sq,$G3,$F3,$H3,$Yq,$D,$Zq},$Q3);
$dr={};
$er=[];
$fr=q#shift->{'annotations'}#;
$gr=bless({$o,$er,$q,$fr,$s,$t},$u);
$hr=[];
$ir=q#shift->{'code'}#;
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr=q#fn#;
$lr=[];
$mr=q#shift->{'fn'}#;
$nr=bless({$o,$lr,$q,$mr,$s,$t},$u);
$or={$o,$gr,$q,$jr,$kr,$nr};
$pr=q#/lib/fn_ro.b#;
$qr=bless({$L2,$dr,$E3,$F3,$G3,$F3,$H3,$or,$D,$pr},$Q3);
$rr={};
$sr=[];
$tr=q#shift->{code}#;
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr=[];
$wr=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$xr=bless({$o,$vr,$q,$wr,$s,$t},$u);
$yr={$d6,$ur,$k6,$xr};
$zr=q#/lib/fn_ops.b#;
$Ar=bless({$L2,$rr,$E3,$F3,$G3,$F3,$H3,$yr,$D,$zr},$Q3);
$Br={};
$Cr=q#serialize#;
$Dr=[];
$Er=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Fr=bless({$o,$Dr,$q,$Er,$s,$t},$u);
$Gr={$Cr,$Fr};
$Hr=q#/lib/fn_serialize.b#;
$Ir=bless({$L2,$Br,$E3,$F3,$G3,$F3,$H3,$Gr,$D,$Hr},$Q3);
$Jr=[$u5,$M6,$cr,$qr,$Ar,$Ir];
$Kr=bless({$L2,$Oq,$D,$Pq,$x3,$Jr},$j3);
$Lr=q#lib/fn.c::ctors#;
$Mr=q#ni:/lib/fn.c#;
$Nr={$j3,1};
$Or=q#/lib/fn.c#;
$Pr=[$h7];
$Qr=bless({$L2,$Nr,$D,$Or,$x3,$Pr},$y3);
$Rr=q#ni:/lib/fn_init.b#;
$Sr=q#ni:/lib/fn_ops.b#;
$Tr=q#ni:/lib/fn_ro.b#;
$Ur=q#ni:/lib/fn_serialize.b#;
$Vr=q#ni:/lib/gensym_generator_compact.b#;
$Wr={};
$Xr=q#gensym#;
$Yr=[];
$Zr=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$cs=bless({$o,$Yr,$q,$Zr,$s,$t},$u);
$ds={$Xr,$cs};
$es=q#/lib/gensym_generator_compact.b#;
$fs=bless({$L2,$Wr,$E3,$F3,$G3,$F3,$H3,$ds,$D,$es},$Q3);
$gs=q#ni:/lib/global_static_test.b#;
$hs={};
$is=q#now#;
$js=[];
$ks=q#ni('ni:/lib/test_value')->new(shift)#;
$ls=q#($)#;
$ms=bless({$o,$js,$q,$ks,$s,$ls},$u);
$ns={$is,$ms};
$os=q#/lib/global_static_test.b#;
$ps=bless({$L2,$hs,$E3,$F3,$G3,$F3,$H3,$ns,$D,$os},$Q3);
$qs=q#ni:/lib/image#;
$rs={$f5,1};
$ss=q#/lib/image#;
$ts={};
$us=[];
$vs=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$ws=bless({$o,$us,$q,$vs,$s,$t},$u);
$xs={$G4,$ws};
$ys=q#/lib/image_init.b#;
$zs=bless({$L2,$ts,$E3,$F3,$G3,$F3,$H3,$xs,$D,$ys},$Q3);
$As={};
$Bs=q#address#;
$Cs=[];
$Ds=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Es=bless({$o,$Cs,$q,$Ds,$s,$t},$u);
$Fs=q#allocate_gensym#;
$Gs=[];
$Hs=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Is=bless({$o,$Gs,$q,$Hs,$s,$t},$u);
$Js=q#boot_side_effect#;
$Ks=[];
$Ls=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ms=bless({$o,$Ks,$q,$Ls,$s,$t},$u);
$Ns=q#circular_links#;
$Os=[];
$Ps=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Qs=bless({$o,$Os,$q,$Ps,$s,$t},$u);
$Rs=q#finalizer#;
$Ss=[];
$Ts=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Us=bless({$o,$Ss,$q,$Ts,$s,$t},$u);
$Vs=q#quote#;
$Ws=[];
$Xs=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ys=bless({$o,$Ws,$q,$Xs,$s,$t},$u);
$Zs=q#reconstruction#;
$ct=[];
$dt=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$et=bless({$o,$ct,$q,$dt,$s,$t},$u);
$ft=q#side_effect#;
$gt=[];
$ht=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$it=bless({$o,$gt,$q,$ht,$s,$t},$u);
$jt=[];
$kt=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$lt=bless({$o,$jt,$q,$kt,$s,$t},$u);
$mt={$Bs,$Es,$Fs,$Is,$Js,$Ms,$Ns,$Qs,$Rs,$Us,$Vs,$Ys,$Zs,$et,$ft,$it,$w9,$lt};
$nt=q#/lib/image_quoting.b#;
$ot=bless({$L2,$As,$E3,$F3,$G3,$F3,$H3,$mt,$D,$nt},$Q3);
$pt={};
$qt=q#quote_code#;
$rt=[];
$st=q#shift->die('cannot quote perl CODE refs', shift)#;
$tt=bless({$o,$rt,$q,$st,$s,$t},$u);
$ut={$qt,$tt};
$vt=q#/lib/quote_code_fail.b#;
$wt=bless({$L2,$pt,$E3,$F3,$G3,$F3,$H3,$ut,$D,$vt},$Q3);
$xt={};
$yt=q#quote_array#;
$zt=[];
$At=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Bt=bless({$o,$zt,$q,$At,$s,$t},$u);
$Ct=q#quote_hash#;
$Dt=[];
$Et=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Ft=bless({$o,$Dt,$q,$Et,$s,$t},$u);
$Gt=q#quote_scalar#;
$Ht=[];
$It=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Jt=bless({$o,$Ht,$q,$It,$s,$t},$u);
$Kt=q#quote_scalar_ref#;
$Lt=[];
$Mt=q#'\\\\' . shift->quote(${$_[0]})#;
$Nt=bless({$o,$Lt,$q,$Mt,$s,$t},$u);
$Ot=q#quote_value#;
$Pt=[];
$Qt=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Rt=bless({$o,$Pt,$q,$Qt,$s,$t},$u);
$St={$yt,$Bt,$Ct,$Ft,$Gt,$Jt,$Kt,$Nt,$Ot,$Rt};
$Tt=q#/lib/quote_values.b#;
$Ut=bless({$L2,$xt,$E3,$F3,$G3,$F3,$H3,$St,$D,$Tt},$Q3);
$Vt={};
$Wt=q#quote_blessed#;
$Xt=[];
$Yt=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Zt=bless({$o,$Xt,$q,$Yt,$s,$t},$u);
$cu=q#quote_class#;
$du=[];
$eu=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$fu=bless({$o,$du,$q,$eu,$s,$t},$u);
$gu=q#quote_object#;
$hu=[];
$iu=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$ju=bless({$o,$hu,$q,$iu,$s,$t},$u);
$ku={$Wt,$Zt,$cu,$fu,$gu,$ju};
$lu=q#/lib/quote_objects.b#;
$mu=bless({$L2,$Vt,$E3,$F3,$G3,$F3,$H3,$ku,$D,$lu},$Q3);
$nu={};
$ou=q#circular_arrayref#;
$pu=[];
$qu=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$ru=bless({$o,$pu,$q,$qu,$s,$t},$u);
$su=q#circular_hashref#;
$tu=[];
$uu=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$vu=bless({$o,$tu,$q,$uu,$s,$t},$u);
$wu=q#is_circular#;
$xu=[];
$yu=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$zu=bless({$o,$xu,$q,$yu,$s,$t},$u);
$Au={$ou,$ru,$su,$vu,$wu,$zu};
$Bu=q#/lib/quote_circular_addressed.b#;
$Cu=bless({$L2,$nu,$E3,$F3,$G3,$F3,$H3,$Au,$D,$Bu},$Q3);
$Du=[$u5,$zs,$ot,$wt,$Ut,$mu,$Cu,$fs];
$Eu=bless({$L2,$rs,$D,$ss,$x3,$Du},$k3);
$Fu=q#lib/image.c::ctors#;
$Gu=q#ni:/lib/image.c#;
$Hu={$k3,1};
$Iu=q#/lib/image.c#;
$Ju=[$h7];
$Ku=bless({$L2,$Hu,$D,$Iu,$x3,$Ju},$y3);
$Lu=q#ni:/lib/image_init.b#;
$Mu=q#ni:/lib/image_quoting.b#;
$Nu=q#ni:/lib/instance.b#;
$Ou=q#ni:/lib/instantiable.b#;
$Pu=q#ni:/lib/json.b#;
$Qu={};
$Ru=q#json_decode#;
$Su=[];
$Tu=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Uu=bless({$o,$Su,$q,$Tu,$s,$ls},$u);
$Vu=q#json_encode#;
$Wu=[];
$Xu=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Yu=bless({$o,$Wu,$q,$Xu,$s,$ls},$u);
$Zu=q#json_escape#;
$cv=[];
$dv=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$ev=bless({$o,$cv,$q,$dv,$s,$ls},$u);
$fv=q#json_unescape#;
$gv=[];
$hv=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$iv=bless({$o,$gv,$q,$hv,$s,$ls},$u);
$jv=q#json_unescape_one#;
$kv=[];
$lv=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$mv=bless({$o,$kv,$q,$lv,$s,$ls},$u);
$nv={$Ru,$Uu,$Vu,$Yu,$Zu,$ev,$fv,$iv,$jv,$mv};
$ov=q#/lib/json.b#;
$pv=bless({$L2,$Qu,$E3,$F3,$G3,$F3,$H3,$nv,$D,$ov},$Q3);
$qv=q#ni#;
$rv=q#ni:/lib/name_as_string.b#;
$sv=q#ni:/lib/named.b#;
$tv=q#ni:/lib/named_in_ni.b#;
$uv=q#ni:/lib/namespaced.b#;
$vv=q#ni:/lib/ni#;
$wv={$g5,1};
$xv=q#/lib/ni#;
$yv={};
$zv=q#extend#;
$Av=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Bv=bless({$q,$Av,$s,$t},$u);
$Cv=q#is_mutable#;
$Dv=q#$0 ne "-" && -w $0#;
$Ev=bless({$q,$Dv,$s,$t},$u);
$Fv=q#modify#;
$Gv=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Hv=bless({$q,$Gv,$s,$t},$u);
$Iv={$zv,$Bv,$Cv,$Ev,$Fv,$Hv};
$Jv=q#/lib/ni_self.b#;
$Kv=bless({$L2,$yv,$E3,$F3,$G3,$F3,$H3,$Iv,$D,$Jv},$Q3);
$Lv={};
$Mv=q#--internal/+=#;
$Nv=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Ov=bless({$q,$Nv,$s,$t},$u);
$Pv=q#--internal/eval#;
$Qv=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Rv=bless({$q,$Qv,$s,$t},$u);
$Sv=q#--internal/image#;
$Tv=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Uv=bless({$q,$Tv,$s,$t},$u);
$Vv=q#--internal/test#;
$Wv=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Xv=bless({$q,$Wv,$s,$t},$u);
$Yv=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Zv=bless({$q,$Yv,$s,$t},$u);
$cw={$Mv,$Ov,$Pv,$Rv,$Sv,$Uv,$Vv,$Xv,$zn,$Zv};
$dw=q#/lib/ni_main.b#;
$ew=bless({$L2,$Lv,$E3,$F3,$G3,$F3,$H3,$cw,$D,$dw},$Q3);
$fw={};
$gw=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$hw=bless({$q,$gw,$s,$t},$u);
$iw=q#resolver_for#;
$jw=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$kw=bless({$q,$jw,$s,$t},$u);
$lw={$u4,$hw,$iw,$kw};
$mw=q#/lib/ni_resolver.b#;
$nw=bless({$L2,$fw,$E3,$F3,$G3,$F3,$H3,$lw,$D,$mw},$Q3);
$ow={};
$pw=q#exists#;
$qw=q#exists $_[0]->{named}{$_[1]}#;
$rw=bless({$q,$qw,$s,$t},$u);
$sw=q#quoted#;
$tw=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$uw=bless({$q,$tw,$s,$t},$u);
$vw={$pw,$rw,$sw,$uw};
$ww=q#/lib/ni_image.b#;
$xw=bless({$L2,$ow,$E3,$F3,$G3,$F3,$H3,$vw,$D,$ww},$Q3);
$yw=[$u5,$Kv,$ew,$nw,$xw];
$zw=bless({$L2,$wv,$D,$xv,$x3,$yw},$l3);
$Aw=q#lib/ni.c::ctors#;
$Bw=q#ni:/lib/ni.c#;
$Cw={$l3,1};
$Dw=q#/lib/ni.c#;
$Ew=[$h7];
$Fw=bless({$L2,$Cw,$D,$Dw,$x3,$Ew},$y3);
$Gw=q#ni:/lib/ni_image.b#;
$Hw=q#ni:/lib/ni_main.b#;
$Iw=q#ni:/lib/ni_resolver.b#;
$Jw=q#ni:/lib/ni_self.b#;
$Kw=q#ni:/lib/ni_static_util.b#;
$Lw={};
$Mw=q#abbrev#;
$Nw=[];
$Ow=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Pw=bless({$o,$Nw,$q,$Ow,$s,$t},$u);
$Qw=q#dor#;
$Rw=[];
$Sw=q#defined $_[0] ? $_[0] : $_[1]#;
$Tw=bless({$o,$Rw,$q,$Sw,$s,$t},$u);
$Uw=q#indent#;
$Vw=[];
$Ww=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Xw=bless({$o,$Vw,$q,$Ww,$s,$t},$u);
$Yw=q#max#;
$Zw=[];
$cx=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$dx=bless({$o,$Zw,$q,$cx,$s,$t},$u);
$ex=q#maxstr#;
$fx=[];
$gx=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$hx=bless({$o,$fx,$q,$gx,$s,$t},$u);
$ix=q#mean#;
$jx=[];
$kx=q#sum(@_) / (@_ || 1)#;
$lx=bless({$o,$jx,$q,$kx,$s,$t},$u);
$mx=q#min#;
$nx=[];
$ox=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$px=bless({$o,$nx,$q,$ox,$s,$t},$u);
$qx=q#minstr#;
$rx=[];
$sx=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$tx=bless({$o,$rx,$q,$sx,$s,$t},$u);
$ux=q#sgr#;
$vx=[];
$wx=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$xx=bless({$o,$vx,$q,$wx,$s,$t},$u);
$yx=q#sr#;
$zx=[];
$Ax=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Bx=bless({$o,$zx,$q,$Ax,$s,$t},$u);
$Cx=q#sum#;
$Dx=[];
$Ex=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Fx=bless({$o,$Dx,$q,$Ex,$s,$t},$u);
$Gx=q#swap#;
$Hx=[];
$Ix=q#@_[0, 1] = @_[1, 0]#;
$Jx=bless({$o,$Hx,$q,$Ix,$s,$t},$u);
$Kx={$Mw,$Pw,$Qw,$Tw,$Uw,$Xw,$Yw,$dx,$ex,$hx,$ix,$lx,$mx,$px,$qx,$tx,$ux,$xx,$yx,$Bx,$Cx,$Fx,$Gx,$Jx};
$Lx=q#/lib/ni_static_util.b#;
$Mx=bless({$L2,$Lw,$E3,$F3,$G3,$F3,$H3,$Kx,$D,$Lx},$Q3);
$Nx=q#ni:/lib/perlbranch.b#;
$Ox=q#ni:/lib/quote_circular_addressed.b#;
$Px=q#ni:/lib/quote_code_fail.b#;
$Qx=q#ni:/lib/quote_objects.b#;
$Rx=q#ni:/lib/quote_simple#;
$Sx={$h5,1};
$Tx=q#/lib/quote_simple#;
$Ux={};
$Vx=[];
$Wx=q#+{}#;
$Xx=bless({$o,$Vx,$q,$Wx,$s,$t},$u);
$Yx={$G4,$Xx};
$Zx=q#/lib/quote_simple_init.b#;
$cy=bless({$L2,$Ux,$E3,$F3,$G3,$F3,$H3,$Yx,$D,$Zx},$Q3);
$dy={};
$ey=[];
$fy=bless({$o,$ey,$q,0,$s,$t},$u);
$gy=[];
$hy=q#shift->quote_value(shift)#;
$iy=bless({$o,$gy,$q,$hy,$s,$t},$u);
$jy={$wu,$fy,$Vs,$iy};
$ky=q#/lib/quote_simple_quote.b#;
$ly=bless({$L2,$dy,$E3,$F3,$G3,$F3,$H3,$jy,$D,$ky},$Q3);
$my=[$u5,$cy,$ly,$wt,$Ut,$mu];
$ny=bless({$L2,$Sx,$D,$Tx,$x3,$my},$m3);
$oy=q#lib/quote_simple.c::ctors#;
$py=q#ni:/lib/quote_simple.c#;
$qy={$m3,1};
$ry=q#/lib/quote_simple.c#;
$sy=[$h7];
$ty=bless({$L2,$qy,$D,$ry,$x3,$sy},$y3);
$uy=q#ni:/lib/quote_simple_init.b#;
$vy=q#ni:/lib/quote_simple_quote.b#;
$wy=q#ni:/lib/quote_values.b#;
$xy=q#ni:/lib/ref_eq.b#;
$yy=q#ni:/lib/resolver.b#;
$zy=q#ni:/lib/slice#;
$Ay={$Q3,1};
$By=q#/lib/slice#;
$Cy=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Dy=bless({$q,$Cy,$s,$t},$u);
$Ey=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Fy=bless({$q,$Ey,$s,$t},$u);
$Gy=q#lib/slice::apply#;
$Hy=q#lib/slice::apply_unsafe#;
$Iy={};
$Jy=q#apply_unsafe#;
$Ky={$L3,$Dy,$Jy,$Fy};
$Ly=q#/lib/slice.b#;
$My=bless({$L2,$Iy,$H3,$Ky,$D,$Ly},$Q3);
$Ny={};
$Oy=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Py=bless({$q,$Oy,$s,$t},$u);
$Qy={$G4,$Py};
$Ry=q#/lib/slice_init.b#;
$Sy=bless({$L2,$Ny,$H3,$Qy,$D,$Ry},$Q3);
$Ty={};
$Uy=[];
$Vy=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Wy=bless({$o,$Uy,$q,$Vy,$s,$t},$u);
$Xy={$Cr,$Wy};
$Yy=q#/lib/slice_serialize.b#;
$Zy=bless({$L2,$Ty,$E3,$F3,$G3,$F3,$H3,$Xy,$D,$Yy},$Q3);
$cz=[$F5,$d4,$My,$Sy,$Zy];
$dz=bless({$L2,$Ay,$D,$By,$x3,$cz},$n3);
$ez=q#lib/slice.c::ctors#;
$fz=q#ni:/lib/slice.b#;
$gz=q#ni:/lib/slice.c#;
$hz={$n3,1};
$iz=q#/lib/slice.c#;
$jz=[$m7];
$kz=bless({$L2,$hz,$D,$iz,$x3,$jz},$y3);
$lz=q#ni:/lib/slice_init.b#;
$mz=q#ni:/lib/slice_serialize.b#;
$nz=q#ni:/lib/static_fn.b#;
$oz={};
$pz=[];
$qz=q#ni('ni:/lib/fn')->new(@_)#;
$rz=bless({$o,$pz,$q,$qz,$s,$ls},$u);
$sz=q#fp#;
$tz=[];
$uz=q#($$)#;
$vz=bless({$o,$tz,$q,$qz,$s,$uz},$u);
$wz={$kr,$rz,$sz,$vz};
$xz=q#/lib/static_fn.b#;
$yz=bless({$L2,$oz,$E3,$F3,$G3,$F3,$H3,$wz,$D,$xz},$Q3);
$zz=q#ni:/lib/subclass.b#;
$Az=q#ni:/lib/tag#;
$Bz={$e4,1};
$Cz=q#/lib/tag#;
$Dz={};
$Ez=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Fz=bless({$q,$Ez,$s,$t},$u);
$Gz={$L3,$Fz};
$Hz=q#/lib/tag.b#;
$Iz=bless({$L2,$Dz,$E3,$F3,$G3,$F3,$H3,$Gz,$D,$Hz},$Q3);
$Jz={};
$Kz=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Lz=bless({$q,$Kz,$s,$t},$u);
$Mz={$G4,$Lz};
$Nz=q#/lib/tag_init.b#;
$Oz=bless({$L2,$Jz,$E3,$F3,$G3,$F3,$H3,$Mz,$D,$Nz},$Q3);
$Pz=[$F5,$d4,$Iz,$Oz];
$Qz=bless({$L2,$Bz,$D,$Cz,$x3,$Pz},$o3);
$Rz=q#lib/tag.c::ctors#;
$Sz=q#ni:/lib/tag.b#;
$Tz=q#ni:/lib/tag.c#;
$Uz={$o3,1};
$Vz=q#/lib/tag.c#;
$Wz=[$m7];
$Xz=bless({$L2,$Uz,$D,$Vz,$x3,$Wz},$y3);
$Yz=q#ni:/lib/tag_init.b#;
$Zz=q#ni:/lib/test_value#;
$cA={$i5,1};
$dA=q#/lib/test_value#;
$eA={};
$fA=[];
$gA=q#\\$_[1]#;
$hA=bless({$o,$fA,$q,$gA,$s,$t},$u);
$iA={$G4,$hA};
$jA=q#/lib/test_value_init.b#;
$kA=bless({$L2,$eA,$E3,$F3,$G3,$F3,$H3,$iA,$D,$jA},$Q3);
$lA={};
$mA=q#(==#;
$nA=[];
$oA=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$pA=bless({$o,$nA,$q,$oA,$s,$t},$u);
$qA=q#diff#;
$rA=[];
$sA=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$tA=bless({$o,$rA,$q,$sA,$s,$t},$u);
$uA={$mA,$pA,$qA,$tA};
$vA=q#/lib/test_value_eq.b#;
$wA=bless({$L2,$lA,$E3,$F3,$G3,$F3,$H3,$uA,$D,$vA},$Q3);
$xA={};
$yA=[];
$zA=q#ni::json_encode ${$_[0]}#;
$AA=bless({$o,$yA,$q,$zA,$s,$t},$u);
$BA={$d6,$AA};
$CA=q#/lib/test_value_str.b#;
$DA=bless({$L2,$xA,$E3,$F3,$G3,$F3,$H3,$BA,$D,$CA},$Q3);
$EA=[$u5,$kA,$wA,$DA];
$FA=bless({$L2,$cA,$D,$dA,$x3,$EA},$p3);
$GA=q#lib/test_value.c::ctors#;
$HA=q#ni:/lib/test_value.c#;
$IA={$p3,1};
$JA=q#/lib/test_value.c#;
$KA=[$h7];
$LA=bless({$L2,$IA,$D,$JA,$x3,$KA},$y3);
$MA=q#ni:/lib/test_value_eq.b#;
$NA=q#ni:/lib/test_value_init.b#;
$OA=q#ni:/lib/test_value_str.b#;
$PA=q#ni:/metaclass#;
$QA={$y3,1};
$RA=q#/metaclass#;
$SA=[$B4,$M6,$L4,$B6];
$TA=bless({$L2,$QA,$D,$RA,$x3,$SA},$q3);
$UA=q#metaclass.c::ctors#;
$VA=q#ni:/metaclass.c#;
$WA={$q3,1};
$XA=q#/metaclass.c#;
$YA=[$V6];
$ZA=bless({$L2,$WA,$D,$XA,$x3,$YA},$y3);
$cB=q#ni:/module#;
$dB=q#ni:/module.c#;
$eB=q#ni:/object#;
$fB=q#ni:/object.c#;
$gB=q#ni:/semantic/dimension#;
$hB={$t3,1};
$iB=q#/semantic/dimension#;
$jB=[$V6];
$kB=bless({$L2,$hB,$D,$iB,$x3,$jB},$u3);
$lB=q#semantic/dimension.c::ctors#;
$mB=q#ni:/semantic/dimension.c#;
$nB={$u3,1};
$oB=q#/semantic/dimension.c#;
$pB=[$q7];
$qB=bless({$L2,$nB,$D,$oB,$x3,$pB},$y3);
$rB=q#ni:/semantic/task#;
$sB=q#ni:/semantic/task.c#;
$tB=q#ni:/semantic/task_outcome.b#;
$uB=q#ni:/semantic/task_ro.b#;
$vB=q#ni:main#;
$wB={$Nh,1};
$xB=[$yz,$ps,$Mh];
$yB=bless({$L2,$wB,$D,$Nh,$x3,$xB},$z3);
$zB=q#module::ctors#;
$AB=q#ni:ni#;
$BB={$qv,1};
$CB={$qv,1};
$DB=q#json_escapes#;
$EB=q##;
$FB=q#b#;
$GB=q#	#;
$HB=q#t#;
$IB=q#
#;
$JB=q#n#;
$KB=q##;
$LB=q#"#;
$MB=q#/#;
$NB=q#\\#;
$OB={$EB,$FB,$GB,$HB,$IB,$JB,$KB,$Be,$LB,$LB,$MB,$MB,$NB,$NB};
$PB=q#json_unescapes#;
$QB={$LB,$LB,$MB,$MB,$NB,$NB,$FB,$EB,$JB,$IB,$Be,$KB,$HB,$GB};
$RB={$DB,$OB,$PB,$QB};
$SB=q#/lib/json_data.b#;
$TB=bless({$L2,$CB,$kk,$RB,$D,$SB},$e5);
$UB=q#lib/dataslice::ctors#;
$VB=[$TB,$pv,$Mx];
$WB=bless({$L2,$BB,$D,$qv,$x3,$VB},$z3);
$XB={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$F1,$G1,$P1,$Q1,$h2,$i2,$n2,$o2,$D2,$E2,$J2,$K2,$V6,$X6,$q7,$r7,$C7,$E7,$I7,$J7,$A7,$K7,$I9,$K9,$S9,$T9,$m9,$U9,$G9,$V9,$oa,$qa,$ua,$va,$fa,$wa,$ma,$xa,$jc,$lc,$pc,$qc,$Pb,$rc,$hc,$sc,$Na,$tc,$Hb,$uc,$jb,$vc,$Ga,$wc,$Jd,$Ld,$Pd,$Qd,$md,$Rd,$xd,$Sd,$Mc,$Td,$Hd,$Ud,$Fc,$Vd,$Uc,$Wd,$Te,$Ve,$Ze,$cf,$pe,$df,$we,$ef,$Re,$ff,$he,$gf,$kg,$mg,$qg,$rg,$eh,$gh,$ig,$hh,$lh,$mh,$Qg,$nh,$ch,$oh,$Jg,$ph,$Af,$qh,$Uf,$rh,$Mf,$sh,$tf,$th,$Mh,$Oh,$oi,$qi,$ui,$vi,$Xh,$wi,$mi,$xi,$e9,$yi,$Q9,$zi,$q8,$Ai,$y8,$Bi,$K8,$Ci,$U7,$Di,$c9,$Ei,$S8,$Fi,$Sj,$Uj,$Yj,$Zj,$Qj,$ck,$ej,$dk,$Aj,$ek,$Si,$fk,$qj,$gk,$Vk,$Xk,$dl,$el,$Fk,$fl,$Tk,$gl,$yk,$hl,$tm,$vm,$Km,$Lm,$Im,$Mm,$Nn,$Pn,$ko,$lo,$io,$mo,$nn,$no,$xn,$oo,$gn,$po,$Jn,$qo,$Vl,$ro,$rm,$so,$Ko,$Mo,$Qo,$Ro,$Bo,$So,$Io,$To,$Z5,$Uo,$F5,$Vo,$m7,$Wo,$ip,$kp,$R3,$lp,$pp,$qp,$gp,$rp,$L4,$sp,$Ip,$Kp,$Op,$Pp,$Gp,$Qp,$Ap,$Rp,$y6,$Sp,$P5,$Tp,$w6,$Up,$Bq,$Dq,$Hq,$Iq,$qq,$Jq,$dq,$Kq,$jq,$Lq,$zq,$Mq,$D5,$Nq,$Kr,$Mr,$Qr,$Rr,$cr,$Sr,$Ar,$Tr,$qr,$Ur,$Ir,$Vr,$fs,$gs,$ps,$qs,$Eu,$Gu,$Ku,$Lu,$zs,$Mu,$ot,$Nu,$s5,$Ou,$M6,$Pu,$pv,$rv,$i6,$sv,$d4,$tv,$l4,$uv,$s4,$vv,$zw,$Bw,$Fw,$Gw,$xw,$Hw,$ew,$Iw,$nw,$Jw,$Kv,$Kw,$Mx,$Nx,$B4,$Ox,$Cu,$Px,$wt,$Qx,$mu,$Rx,$ny,$py,$ty,$uy,$cy,$vy,$ly,$wy,$Ut,$xy,$p6,$yy,$z4,$zy,$dz,$fz,$My,$gz,$kz,$lz,$Sy,$mz,$Zy,$nz,$yz,$zz,$T6,$Az,$Qz,$Sz,$Iz,$Tz,$Xz,$Yz,$Oz,$Zz,$FA,$HA,$LA,$MA,$wA,$NA,$kA,$OA,$DA,$PA,$TA,$VA,$ZA,$cB,$B6,$dB,$o7,$eB,$u5,$fB,$h7,$gB,$kB,$mB,$qB,$rB,$Hl,$sB,$Bm,$tB,$Fl,$uB,$tl,$vB,$yB,$AB,$WB};
$YB=q#resolvers#;
$ZB=[];
$cC=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$dC=bless({$o,$ZB,$q,$cC,$s,$t},$u);
$eC=q#file#;
$fC=[];
$gC=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$hC=bless({$o,$fC,$q,$gC,$s,$t},$u);
$iC=q#null#;
$jC=[];
$kC=q#ni('ni:/io/null')->new#;
$lC=bless({$o,$jC,$q,$kC,$s,$t},$u);
$mC=q#sh#;
$nC=[];
$oC=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$pC=bless({$o,$nC,$q,$oC,$s,$t},$u);
$qC=q#str#;
$rC=[];
$sC=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$tC=bless({$o,$rC,$q,$sC,$s,$t},$u);
$uC={$pb,$dC,$eC,$hC,$iC,$lC,$mC,$pC,$qC,$tC};
$vC=bless({$c,$XB,$YB,$uC},$g5);
$wC=q#lib/ni::ctors#;
*$Hy=\&$Fy;
*$Gy=\&$Dy;
$R3->apply_unsafe($M2);
$R3->apply_unsafe($N2);
$R3->apply_unsafe($O2);
$R3->apply_unsafe($P2);
$R3->apply_unsafe($Q2);
$R3->apply_unsafe($R2);
$R3->apply_unsafe($S2);
$R3->apply_unsafe($T2);
$R3->apply_unsafe($U2);
$R3->apply_unsafe($V2);
$R3->apply_unsafe($W2);
$R3->apply_unsafe($X2);
$R3->apply_unsafe($Y2);
$R3->apply_unsafe($Z2);
$R3->apply_unsafe($c3);
$R3->apply_unsafe($d3);
$R3->apply_unsafe($e3);
$R3->apply_unsafe($f3);
$R3->apply_unsafe($S3);
$R3->apply_unsafe($g3);
$R3->apply_unsafe($h3);
$R3->apply_unsafe($i3);
$R3->apply_unsafe($j3);
$R3->apply_unsafe($k3);
$R3->apply_unsafe($l3);
$R3->apply_unsafe($m3);
$R3->apply_unsafe($n3);
$R3->apply_unsafe($o3);
$R3->apply_unsafe($p3);
$R3->apply_unsafe($y3);
$R3->apply_unsafe($q3);
$R3->apply_unsafe($z3);
$R3->apply_unsafe($r3);
$R3->apply_unsafe($s3);
$R3->apply_unsafe($t3);
$R3->apply_unsafe($u3);
$R3->apply_unsafe($v3);
$d4->apply_unsafe($M2);
$d4->apply_unsafe($N2);
$d4->apply_unsafe($O2);
$d4->apply_unsafe($P2);
$d4->apply_unsafe($Q2);
$d4->apply_unsafe($R2);
$d4->apply_unsafe($S2);
$d4->apply_unsafe($T2);
$d4->apply_unsafe($U2);
$d4->apply_unsafe($V2);
$d4->apply_unsafe($W2);
$d4->apply_unsafe($X2);
$d4->apply_unsafe($Y2);
$d4->apply_unsafe($Z2);
$d4->apply_unsafe($c3);
$d4->apply_unsafe($d3);
$d4->apply_unsafe($e3);
$d4->apply_unsafe($f3);
$d4->apply_unsafe($S3);
$d4->apply_unsafe($g3);
$d4->apply_unsafe($h3);
$d4->apply_unsafe($F);
$d4->apply_unsafe($i3);
$d4->apply_unsafe($j3);
$d4->apply_unsafe($k3);
$d4->apply_unsafe($l3);
$d4->apply_unsafe($m3);
$d4->apply_unsafe($Q3);
$d4->apply_unsafe($n3);
$d4->apply_unsafe($e4);
$d4->apply_unsafe($o3);
$d4->apply_unsafe($p3);
$d4->apply_unsafe($y3);
$d4->apply_unsafe($q3);
$d4->apply_unsafe($z3);
$d4->apply_unsafe($r3);
$d4->apply_unsafe($s3);
$d4->apply_unsafe($t3);
$d4->apply_unsafe($u3);
$d4->apply_unsafe($v3);
$l4->apply_unsafe($M2);
$l4->apply_unsafe($N2);
$l4->apply_unsafe($O2);
$l4->apply_unsafe($P2);
$l4->apply_unsafe($Q2);
$l4->apply_unsafe($R2);
$l4->apply_unsafe($S2);
$l4->apply_unsafe($T2);
$l4->apply_unsafe($U2);
$l4->apply_unsafe($V2);
$l4->apply_unsafe($W2);
$l4->apply_unsafe($X2);
$l4->apply_unsafe($Y2);
$l4->apply_unsafe($Z2);
$l4->apply_unsafe($c3);
$l4->apply_unsafe($d3);
$l4->apply_unsafe($e3);
$l4->apply_unsafe($f3);
$l4->apply_unsafe($S3);
$l4->apply_unsafe($g3);
$l4->apply_unsafe($h3);
$l4->apply_unsafe($i3);
$l4->apply_unsafe($j3);
$l4->apply_unsafe($k3);
$l4->apply_unsafe($l3);
$l4->apply_unsafe($m3);
$l4->apply_unsafe($Q3);
$l4->apply_unsafe($n3);
$l4->apply_unsafe($e4);
$l4->apply_unsafe($o3);
$l4->apply_unsafe($p3);
$l4->apply_unsafe($y3);
$l4->apply_unsafe($q3);
$l4->apply_unsafe($z3);
$l4->apply_unsafe($r3);
$l4->apply_unsafe($s3);
$l4->apply_unsafe($t3);
$l4->apply_unsafe($u3);
$l4->apply_unsafe($v3);
$s4->apply_unsafe($M2);
$s4->apply_unsafe($N2);
$s4->apply_unsafe($O2);
$s4->apply_unsafe($P2);
$s4->apply_unsafe($Q2);
$s4->apply_unsafe($R2);
$s4->apply_unsafe($S2);
$s4->apply_unsafe($T2);
$s4->apply_unsafe($U2);
$s4->apply_unsafe($V2);
$s4->apply_unsafe($W2);
$s4->apply_unsafe($X2);
$s4->apply_unsafe($Y2);
$s4->apply_unsafe($Z2);
$s4->apply_unsafe($c3);
$s4->apply_unsafe($d3);
$s4->apply_unsafe($e3);
$s4->apply_unsafe($f3);
$s4->apply_unsafe($S3);
$s4->apply_unsafe($g3);
$s4->apply_unsafe($h3);
$s4->apply_unsafe($i3);
$s4->apply_unsafe($j3);
$s4->apply_unsafe($k3);
$s4->apply_unsafe($l3);
$s4->apply_unsafe($m3);
$s4->apply_unsafe($Q3);
$s4->apply_unsafe($n3);
$s4->apply_unsafe($e4);
$s4->apply_unsafe($o3);
$s4->apply_unsafe($p3);
$s4->apply_unsafe($y3);
$s4->apply_unsafe($q3);
$s4->apply_unsafe($z3);
$s4->apply_unsafe($r3);
$s4->apply_unsafe($s3);
$s4->apply_unsafe($t3);
$s4->apply_unsafe($u3);
$s4->apply_unsafe($v3);
$z4->apply_unsafe($M2);
$z4->apply_unsafe($N2);
$z4->apply_unsafe($O2);
$z4->apply_unsafe($P2);
$z4->apply_unsafe($Q2);
$z4->apply_unsafe($R2);
$z4->apply_unsafe($S2);
$z4->apply_unsafe($T2);
$z4->apply_unsafe($U2);
$z4->apply_unsafe($V2);
$z4->apply_unsafe($W2);
$z4->apply_unsafe($X2);
$z4->apply_unsafe($Y2);
$z4->apply_unsafe($Z2);
$z4->apply_unsafe($c3);
$z4->apply_unsafe($d3);
$z4->apply_unsafe($e3);
$z4->apply_unsafe($f3);
$z4->apply_unsafe($S3);
$z4->apply_unsafe($g3);
$z4->apply_unsafe($h3);
$z4->apply_unsafe($i3);
$z4->apply_unsafe($j3);
$z4->apply_unsafe($k3);
$z4->apply_unsafe($l3);
$z4->apply_unsafe($m3);
$z4->apply_unsafe($n3);
$z4->apply_unsafe($e4);
$z4->apply_unsafe($o3);
$z4->apply_unsafe($p3);
$z4->apply_unsafe($y3);
$z4->apply_unsafe($q3);
$z4->apply_unsafe($z3);
$z4->apply_unsafe($r3);
$z4->apply_unsafe($s3);
$z4->apply_unsafe($t3);
$z4->apply_unsafe($u3);
$z4->apply_unsafe($v3);
$L4->apply_unsafe($M2);
$L4->apply_unsafe($N2);
$L4->apply_unsafe($O2);
$L4->apply_unsafe($P2);
$L4->apply_unsafe($Q2);
$L4->apply_unsafe($R2);
$L4->apply_unsafe($S2);
$L4->apply_unsafe($T2);
$L4->apply_unsafe($U2);
$L4->apply_unsafe($V2);
$L4->apply_unsafe($W2);
$L4->apply_unsafe($X2);
$L4->apply_unsafe($Y2);
$L4->apply_unsafe($Z2);
$L4->apply_unsafe($c3);
$L4->apply_unsafe($d3);
$L4->apply_unsafe($e3);
$L4->apply_unsafe($f3);
$L4->apply_unsafe($g3);
$L4->apply_unsafe($h3);
$L4->apply_unsafe($i3);
$L4->apply_unsafe($j3);
$L4->apply_unsafe($k3);
$L4->apply_unsafe($l3);
$L4->apply_unsafe($m3);
$L4->apply_unsafe($n3);
$L4->apply_unsafe($o3);
$L4->apply_unsafe($p3);
$L4->apply_unsafe($y3);
$L4->apply_unsafe($q3);
$L4->apply_unsafe($z3);
$L4->apply_unsafe($r3);
$L4->apply_unsafe($s3);
$L4->apply_unsafe($t3);
$L4->apply_unsafe($u3);
$L4->apply_unsafe($v3);
$s5->apply_unsafe($M2);
$s5->apply_unsafe($N2);
$s5->apply_unsafe($M4);
$s5->apply_unsafe($O2);
$s5->apply_unsafe($N4);
$s5->apply_unsafe($P2);
$s5->apply_unsafe($O4);
$s5->apply_unsafe($Q2);
$s5->apply_unsafe($P4);
$s5->apply_unsafe($R2);
$s5->apply_unsafe($Q4);
$s5->apply_unsafe($S2);
$s5->apply_unsafe($R4);
$s5->apply_unsafe($T2);
$s5->apply_unsafe($S4);
$s5->apply_unsafe($U2);
$s5->apply_unsafe($T4);
$s5->apply_unsafe($V2);
$s5->apply_unsafe($U4);
$s5->apply_unsafe($W2);
$s5->apply_unsafe($V4);
$s5->apply_unsafe($X2);
$s5->apply_unsafe($W4);
$s5->apply_unsafe($Y2);
$s5->apply_unsafe($X4);
$s5->apply_unsafe($Z2);
$s5->apply_unsafe($Y4);
$s5->apply_unsafe($c3);
$s5->apply_unsafe($Z4);
$s5->apply_unsafe($d3);
$s5->apply_unsafe($c5);
$s5->apply_unsafe($e3);
$s5->apply_unsafe($d5);
$s5->apply_unsafe($f3);
$s5->apply_unsafe($S3);
$s5->apply_unsafe($g3);
$s5->apply_unsafe($e5);
$s5->apply_unsafe($h3);
$s5->apply_unsafe($F);
$s5->apply_unsafe($i3);
$s5->apply_unsafe($u);
$s5->apply_unsafe($j3);
$s5->apply_unsafe($f5);
$s5->apply_unsafe($k3);
$s5->apply_unsafe($g5);
$s5->apply_unsafe($l3);
$s5->apply_unsafe($h5);
$s5->apply_unsafe($m3);
$s5->apply_unsafe($Q3);
$s5->apply_unsafe($n3);
$s5->apply_unsafe($e4);
$s5->apply_unsafe($o3);
$s5->apply_unsafe($i5);
$s5->apply_unsafe($p3);
$s5->apply_unsafe($y3);
$s5->apply_unsafe($q3);
$s5->apply_unsafe($z3);
$s5->apply_unsafe($r3);
$s5->apply_unsafe($j5);
$s5->apply_unsafe($s3);
$s5->apply_unsafe($t3);
$s5->apply_unsafe($u3);
$s5->apply_unsafe($k5);
$s5->apply_unsafe($v3);
$D5->apply_unsafe($M2);
$D5->apply_unsafe($N2);
$D5->apply_unsafe($O2);
$D5->apply_unsafe($P2);
$D5->apply_unsafe($Q2);
$D5->apply_unsafe($R2);
$D5->apply_unsafe($S2);
$D5->apply_unsafe($T2);
$D5->apply_unsafe($U2);
$D5->apply_unsafe($V2);
$D5->apply_unsafe($W2);
$D5->apply_unsafe($X2);
$D5->apply_unsafe($Y2);
$D5->apply_unsafe($Z2);
$D5->apply_unsafe($c3);
$D5->apply_unsafe($d3);
$D5->apply_unsafe($e3);
$D5->apply_unsafe($d5);
$D5->apply_unsafe($f3);
$D5->apply_unsafe($S3);
$D5->apply_unsafe($g3);
$D5->apply_unsafe($e5);
$D5->apply_unsafe($h3);
$D5->apply_unsafe($i3);
$D5->apply_unsafe($j3);
$D5->apply_unsafe($k3);
$D5->apply_unsafe($l3);
$D5->apply_unsafe($m3);
$D5->apply_unsafe($Q3);
$D5->apply_unsafe($n3);
$D5->apply_unsafe($e4);
$D5->apply_unsafe($o3);
$D5->apply_unsafe($p3);
$D5->apply_unsafe($y3);
$D5->apply_unsafe($q3);
$D5->apply_unsafe($z3);
$D5->apply_unsafe($r3);
$D5->apply_unsafe($s3);
$D5->apply_unsafe($t3);
$D5->apply_unsafe($u3);
$D5->apply_unsafe($v3);
$P5->apply_unsafe($M2);
$P5->apply_unsafe($N2);
$P5->apply_unsafe($O2);
$P5->apply_unsafe($P2);
$P5->apply_unsafe($Q2);
$P5->apply_unsafe($R2);
$P5->apply_unsafe($S2);
$P5->apply_unsafe($T2);
$P5->apply_unsafe($U2);
$P5->apply_unsafe($V2);
$P5->apply_unsafe($W2);
$P5->apply_unsafe($X2);
$P5->apply_unsafe($Y2);
$P5->apply_unsafe($Z2);
$P5->apply_unsafe($c3);
$P5->apply_unsafe($d3);
$P5->apply_unsafe($e3);
$P5->apply_unsafe($f3);
$P5->apply_unsafe($S3);
$P5->apply_unsafe($g3);
$P5->apply_unsafe($h3);
$P5->apply_unsafe($i3);
$P5->apply_unsafe($j3);
$P5->apply_unsafe($k3);
$P5->apply_unsafe($l3);
$P5->apply_unsafe($m3);
$P5->apply_unsafe($n3);
$P5->apply_unsafe($o3);
$P5->apply_unsafe($p3);
$P5->apply_unsafe($y3);
$P5->apply_unsafe($q3);
$P5->apply_unsafe($z3);
$P5->apply_unsafe($r3);
$P5->apply_unsafe($s3);
$P5->apply_unsafe($t3);
$P5->apply_unsafe($u3);
$P5->apply_unsafe($v3);
$Z5->apply_unsafe($M2);
$Z5->apply_unsafe($N2);
$Z5->apply_unsafe($O2);
$Z5->apply_unsafe($P2);
$Z5->apply_unsafe($Q2);
$Z5->apply_unsafe($R2);
$Z5->apply_unsafe($S2);
$Z5->apply_unsafe($T2);
$Z5->apply_unsafe($U2);
$Z5->apply_unsafe($V2);
$Z5->apply_unsafe($W2);
$Z5->apply_unsafe($X2);
$Z5->apply_unsafe($Y2);
$Z5->apply_unsafe($Z2);
$Z5->apply_unsafe($c3);
$Z5->apply_unsafe($d3);
$Z5->apply_unsafe($e3);
$Z5->apply_unsafe($f3);
$Z5->apply_unsafe($S3);
$Z5->apply_unsafe($g3);
$Z5->apply_unsafe($h3);
$Z5->apply_unsafe($i3);
$Z5->apply_unsafe($j3);
$Z5->apply_unsafe($k3);
$Z5->apply_unsafe($l3);
$Z5->apply_unsafe($m3);
$Z5->apply_unsafe($n3);
$Z5->apply_unsafe($o3);
$Z5->apply_unsafe($p3);
$Z5->apply_unsafe($y3);
$Z5->apply_unsafe($q3);
$Z5->apply_unsafe($z3);
$Z5->apply_unsafe($r3);
$Z5->apply_unsafe($s3);
$Z5->apply_unsafe($t3);
$Z5->apply_unsafe($u3);
$Z5->apply_unsafe($v3);
$i6->apply_unsafe($M2);
$i6->apply_unsafe($N2);
$i6->apply_unsafe($O2);
$i6->apply_unsafe($P2);
$i6->apply_unsafe($Q2);
$i6->apply_unsafe($R2);
$i6->apply_unsafe($S2);
$i6->apply_unsafe($T2);
$i6->apply_unsafe($U2);
$i6->apply_unsafe($V2);
$i6->apply_unsafe($W2);
$i6->apply_unsafe($X2);
$i6->apply_unsafe($Y2);
$i6->apply_unsafe($Z2);
$i6->apply_unsafe($c3);
$i6->apply_unsafe($d3);
$i6->apply_unsafe($e3);
$i6->apply_unsafe($f3);
$i6->apply_unsafe($S3);
$i6->apply_unsafe($g3);
$i6->apply_unsafe($h3);
$i6->apply_unsafe($i3);
$i6->apply_unsafe($j3);
$i6->apply_unsafe($k3);
$i6->apply_unsafe($l3);
$i6->apply_unsafe($m3);
$i6->apply_unsafe($n3);
$i6->apply_unsafe($o3);
$i6->apply_unsafe($p3);
$i6->apply_unsafe($y3);
$i6->apply_unsafe($q3);
$i6->apply_unsafe($z3);
$i6->apply_unsafe($r3);
$i6->apply_unsafe($s3);
$i6->apply_unsafe($t3);
$i6->apply_unsafe($u3);
$i6->apply_unsafe($v3);
$p6->apply_unsafe($M2);
$p6->apply_unsafe($N2);
$p6->apply_unsafe($O2);
$p6->apply_unsafe($P2);
$p6->apply_unsafe($Q2);
$p6->apply_unsafe($R2);
$p6->apply_unsafe($S2);
$p6->apply_unsafe($T2);
$p6->apply_unsafe($U2);
$p6->apply_unsafe($V2);
$p6->apply_unsafe($W2);
$p6->apply_unsafe($X2);
$p6->apply_unsafe($Y2);
$p6->apply_unsafe($Z2);
$p6->apply_unsafe($c3);
$p6->apply_unsafe($d3);
$p6->apply_unsafe($e3);
$p6->apply_unsafe($f3);
$p6->apply_unsafe($S3);
$p6->apply_unsafe($g3);
$p6->apply_unsafe($h3);
$p6->apply_unsafe($i3);
$p6->apply_unsafe($j3);
$p6->apply_unsafe($k3);
$p6->apply_unsafe($l3);
$p6->apply_unsafe($m3);
$p6->apply_unsafe($n3);
$p6->apply_unsafe($o3);
$p6->apply_unsafe($p3);
$p6->apply_unsafe($y3);
$p6->apply_unsafe($q3);
$p6->apply_unsafe($z3);
$p6->apply_unsafe($r3);
$p6->apply_unsafe($s3);
$p6->apply_unsafe($t3);
$p6->apply_unsafe($u3);
$p6->apply_unsafe($v3);
$w6->apply_unsafe($M2);
$w6->apply_unsafe($N2);
$w6->apply_unsafe($O2);
$w6->apply_unsafe($P2);
$w6->apply_unsafe($Q2);
$w6->apply_unsafe($R2);
$w6->apply_unsafe($S2);
$w6->apply_unsafe($T2);
$w6->apply_unsafe($U2);
$w6->apply_unsafe($V2);
$w6->apply_unsafe($W2);
$w6->apply_unsafe($X2);
$w6->apply_unsafe($Y2);
$w6->apply_unsafe($Z2);
$w6->apply_unsafe($c3);
$w6->apply_unsafe($d3);
$w6->apply_unsafe($e3);
$w6->apply_unsafe($f3);
$w6->apply_unsafe($S3);
$w6->apply_unsafe($g3);
$w6->apply_unsafe($h3);
$w6->apply_unsafe($i3);
$w6->apply_unsafe($j3);
$w6->apply_unsafe($k3);
$w6->apply_unsafe($l3);
$w6->apply_unsafe($m3);
$w6->apply_unsafe($n3);
$w6->apply_unsafe($o3);
$w6->apply_unsafe($p3);
$w6->apply_unsafe($y3);
$w6->apply_unsafe($q3);
$w6->apply_unsafe($z3);
$w6->apply_unsafe($r3);
$w6->apply_unsafe($s3);
$w6->apply_unsafe($t3);
$w6->apply_unsafe($u3);
$w6->apply_unsafe($v3);
$M6->apply_unsafe($M2);
$M6->apply_unsafe($N2);
$M6->apply_unsafe($O2);
$M6->apply_unsafe($P2);
$M6->apply_unsafe($Q2);
$M6->apply_unsafe($R2);
$M6->apply_unsafe($S2);
$M6->apply_unsafe($T2);
$M6->apply_unsafe($U2);
$M6->apply_unsafe($V2);
$M6->apply_unsafe($W2);
$M6->apply_unsafe($X2);
$M6->apply_unsafe($Y2);
$M6->apply_unsafe($Z2);
$M6->apply_unsafe($c3);
$M6->apply_unsafe($d3);
$M6->apply_unsafe($e3);
$M6->apply_unsafe($f3);
$M6->apply_unsafe($g3);
$M6->apply_unsafe($h3);
$M6->apply_unsafe($i3);
$M6->apply_unsafe($u);
$M6->apply_unsafe($j3);
$M6->apply_unsafe($k3);
$M6->apply_unsafe($l3);
$M6->apply_unsafe($m3);
$M6->apply_unsafe($Q3);
$M6->apply_unsafe($n3);
$M6->apply_unsafe($e4);
$M6->apply_unsafe($o3);
$M6->apply_unsafe($p3);
$M6->apply_unsafe($y3);
$M6->apply_unsafe($q3);
$M6->apply_unsafe($r3);
$M6->apply_unsafe($s3);
$M6->apply_unsafe($t3);
$M6->apply_unsafe($u3);
$M6->apply_unsafe($v3);
$T6->apply_unsafe($M2);
$T6->apply_unsafe($N2);
$T6->apply_unsafe($O2);
$T6->apply_unsafe($P2);
$T6->apply_unsafe($Q2);
$T6->apply_unsafe($R2);
$T6->apply_unsafe($S2);
$T6->apply_unsafe($T2);
$T6->apply_unsafe($U2);
$T6->apply_unsafe($V2);
$T6->apply_unsafe($W2);
$T6->apply_unsafe($X2);
$T6->apply_unsafe($Y2);
$T6->apply_unsafe($Z2);
$T6->apply_unsafe($c3);
$T6->apply_unsafe($d3);
$T6->apply_unsafe($e3);
$T6->apply_unsafe($f3);
$T6->apply_unsafe($g3);
$T6->apply_unsafe($h3);
$T6->apply_unsafe($i3);
$T6->apply_unsafe($j3);
$T6->apply_unsafe($k3);
$T6->apply_unsafe($l3);
$T6->apply_unsafe($m3);
$T6->apply_unsafe($n3);
$T6->apply_unsafe($o3);
$T6->apply_unsafe($p3);
$T6->apply_unsafe($q3);
$T6->apply_unsafe($r3);
$T6->apply_unsafe($s3);
$T6->apply_unsafe($t3);
$T6->apply_unsafe($u3);
$T6->apply_unsafe($v3);
$A7->apply_unsafe($M4);
$U7->apply_unsafe($N4);
$U7->apply_unsafe($O4);
$U7->apply_unsafe($P4);
$U7->apply_unsafe($Q4);
$U7->apply_unsafe($R4);
$U7->apply_unsafe($S4);
$U7->apply_unsafe($T4);
$U7->apply_unsafe($U4);
$U7->apply_unsafe($V4);
$U7->apply_unsafe($W4);
$U7->apply_unsafe($X4);
$q8->apply_unsafe($N4);
$q8->apply_unsafe($O4);
$q8->apply_unsafe($P4);
$q8->apply_unsafe($Q4);
$q8->apply_unsafe($R4);
$q8->apply_unsafe($S4);
$q8->apply_unsafe($T4);
$q8->apply_unsafe($U4);
$q8->apply_unsafe($V4);
$q8->apply_unsafe($W4);
$q8->apply_unsafe($X4);
$y8->apply_unsafe($N4);
$y8->apply_unsafe($O4);
$y8->apply_unsafe($P4);
$y8->apply_unsafe($Q4);
$y8->apply_unsafe($R4);
$y8->apply_unsafe($S4);
$y8->apply_unsafe($T4);
$y8->apply_unsafe($U4);
$y8->apply_unsafe($V4);
$y8->apply_unsafe($W4);
$y8->apply_unsafe($X4);
$K8->apply_unsafe($N4);
$K8->apply_unsafe($O4);
$K8->apply_unsafe($P4);
$K8->apply_unsafe($Q4);
$K8->apply_unsafe($R4);
$K8->apply_unsafe($S4);
$K8->apply_unsafe($T4);
$K8->apply_unsafe($U4);
$K8->apply_unsafe($V4);
$K8->apply_unsafe($W4);
$K8->apply_unsafe($X4);
$S8->apply_unsafe($N4);
$S8->apply_unsafe($O4);
$S8->apply_unsafe($P4);
$S8->apply_unsafe($Q4);
$S8->apply_unsafe($R4);
$S8->apply_unsafe($S4);
$S8->apply_unsafe($T4);
$S8->apply_unsafe($U4);
$S8->apply_unsafe($V4);
$S8->apply_unsafe($W4);
$S8->apply_unsafe($X4);
$c9->apply_unsafe($N4);
$c9->apply_unsafe($O4);
$c9->apply_unsafe($P4);
$c9->apply_unsafe($Q4);
$c9->apply_unsafe($R4);
$c9->apply_unsafe($S4);
$c9->apply_unsafe($T4);
$c9->apply_unsafe($U4);
$c9->apply_unsafe($V4);
$c9->apply_unsafe($W4);
$c9->apply_unsafe($X4);
$m9->apply_unsafe($N4);
$G9->apply_unsafe($N4);
$fa->apply_unsafe($O4);
$ma->apply_unsafe($O4);
$Ga->apply_unsafe($P4);
$Na->apply_unsafe($P4);
$jb->apply_unsafe($P4);
$Hb->apply_unsafe($P4);
$Pb->apply_unsafe($P4);
$hc->apply_unsafe($P4);
$Fc->apply_unsafe($Q4);
$Mc->apply_unsafe($Q4);
$Uc->apply_unsafe($Q4);
$md->apply_unsafe($Q4);
$xd->apply_unsafe($Q4);
$Hd->apply_unsafe($Q4);
$he->apply_unsafe($R4);
$pe->apply_unsafe($R4);
$we->apply_unsafe($R4);
$Re->apply_unsafe($R4);
$tf->apply_unsafe($S4);
$Af->apply_unsafe($S4);
$Mf->apply_unsafe($S4);
$Uf->apply_unsafe($S4);
$ig->apply_unsafe($S4);
$Jg->apply_unsafe($T4);
$Qg->apply_unsafe($T4);
$ch->apply_unsafe($T4);
$Mh->apply_unsafe($Nh);
$Xh->apply_unsafe($U4);
$mi->apply_unsafe($U4);
$Si->apply_unsafe($W4);
$ej->apply_unsafe($W4);
$qj->apply_unsafe($W4);
$Aj->apply_unsafe($W4);
$Qj->apply_unsafe($W4);
$yk->apply_unsafe($X4);
$Fk->apply_unsafe($X4);
$Tk->apply_unsafe($X4);
$tl->apply_unsafe($Y4);
$tl->apply_unsafe($Z4);
$tl->apply_unsafe($c5);
$tl->apply_unsafe($k5);
$Fl->apply_unsafe($Y4);
$Fl->apply_unsafe($Z4);
$Fl->apply_unsafe($c5);
$Fl->apply_unsafe($k5);
$Vl->apply_unsafe($Y4);
$Vl->apply_unsafe($Z4);
$Vl->apply_unsafe($c5);
$rm->apply_unsafe($Y4);
$rm->apply_unsafe($Z4);
$rm->apply_unsafe($c5);
$Im->apply_unsafe($c3);
$Im->apply_unsafe($d3);
$Im->apply_unsafe($e3);
$gn->apply_unsafe($Z4);
$nn->apply_unsafe($Z4);
$xn->apply_unsafe($Z4);
$Jn->apply_unsafe($Z4);
$io->apply_unsafe($d3);
$Bo->apply_unsafe($c5);
$Io->apply_unsafe($c5);
$gp->apply_unsafe($S3);
$Ap->apply_unsafe($e5);
$Gp->apply_unsafe($e5);
$dq->apply_unsafe($F);
$jq->apply_unsafe($F);
$qq->apply_unsafe($F);
$zq->apply_unsafe($F);
$cr->apply_unsafe($u);
$qr->apply_unsafe($u);
$Ar->apply_unsafe($u);
$Ir->apply_unsafe($u);
$fs->apply_unsafe($f5);
$ps->apply_unsafe($Nh);
$zs->apply_unsafe($f5);
$ot->apply_unsafe($f5);
$wt->apply_unsafe($f5);
$wt->apply_unsafe($h5);
$Ut->apply_unsafe($f5);
$Ut->apply_unsafe($h5);
$mu->apply_unsafe($f5);
$mu->apply_unsafe($h5);
$Cu->apply_unsafe($f5);
$pv->apply_unsafe($qv);
$Kv->apply_unsafe($g5);
$ew->apply_unsafe($g5);
$nw->apply_unsafe($g5);
$xw->apply_unsafe($g5);
$Mx->apply_unsafe($qv);
$cy->apply_unsafe($h5);
$ly->apply_unsafe($h5);
$My->apply_unsafe($Q3);
$Sy->apply_unsafe($Q3);
$Zy->apply_unsafe($Q3);
$yz->apply_unsafe($Nh);
$Iz->apply_unsafe($e4);
$Oz->apply_unsafe($e4);
$kA->apply_unsafe($i5);
$wA->apply_unsafe($i5);
$DA->apply_unsafe($i5);
$ni::self=$vC;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($B1)for@$w;
&$_($F1)for@$H;
&$_($P1)for@$H;
&$_($T1)for@$w;
&$_($X1)for@$w;
&$_($d2)for@$w;
&$_($h2)for@$H;
&$_($n2)for@$H;
&$_($v2)for@$w;
&$_($z2)for@$w;
&$_($D2)for@$H;
&$_($J2)for@$H;
&$_($K3)for@$w;
&$_($N3)for@$w;
&$_($R3)for@$T3;
&$_($W3)for@$w;
&$_($Y3)for@$w;
&$_($d4)for@$T3;
&$_($i4)for@$w;
&$_($l4)for@$T3;
&$_($p4)for@$w;
&$_($s4)for@$T3;
&$_($w4)for@$w;
&$_($z4)for@$T3;
&$_($B4)for@$C4;
&$_($F4)for@$w;
&$_($I4)for@$w;
&$_($L4)for@$T3;
&$_($p5)for@$w;
&$_($s5)for@$T3;
&$_($u5)for@$v5;
&$_($A5)for@$w;
&$_($D5)for@$T3;
&$_($F5)for@$G5;
&$_($M5)for@$w;
&$_($P5)for@$T3;
&$_($T5)for@$w;
&$_($W5)for@$w;
&$_($Z5)for@$T3;
&$_($f6)for@$w;
&$_($i6)for@$T3;
&$_($m6)for@$w;
&$_($p6)for@$T3;
&$_($t6)for@$w;
&$_($w6)for@$T3;
&$_($y6)for@$z6;
&$_($B6)for@$C6;
&$_($G6)for@$w;
&$_($J6)for@$w;
&$_($M6)for@$T3;
&$_($Q6)for@$w;
&$_($T6)for@$T3;
&$_($V6)for@$W6;
&$_($h7)for@$i7;
&$_($m7)for@$i7;
&$_($o7)for@$i7;
&$_($q7)for@$i7;
&$_($x7)for@$w;
&$_($A7)for@$T3;
&$_($C7)for@$D7;
&$_($I7)for@$i7;
&$_($R7)for@$w;
&$_($U7)for@$T3;
&$_($Z7)for@$w;
&$_($f8)for@$w;
&$_($j8)for@$w;
&$_($n8)for@$w;
&$_($q8)for@$T3;
&$_($v8)for@$w;
&$_($y8)for@$T3;
&$_($D8)for@$w;
&$_($H8)for@$w;
&$_($K8)for@$T3;
&$_($P8)for@$w;
&$_($S8)for@$T3;
&$_($X8)for@$w;
&$_($c9)for@$T3;
&$_($e9)for@$f9;
&$_($j9)for@$w;
&$_($m9)for@$T3;
&$_($r9)for@$w;
&$_($v9)for@$w;
&$_($z9)for@$w;
&$_($D9)for@$w;
&$_($G9)for@$T3;
&$_($I9)for@$J9;
&$_($Q9)for@$i7;
&$_($S9)for@$i7;
&$_($ca)for@$w;
&$_($fa)for@$T3;
&$_($ja)for@$w;
&$_($ma)for@$T3;
&$_($oa)for@$pa;
&$_($ua)for@$i7;
&$_($Da)for@$w;
&$_($Ga)for@$T3;
&$_($Ka)for@$w;
&$_($Na)for@$T3;
&$_($Sa)for@$w;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($gb)for@$w;
&$_($jb)for@$T3;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Eb)for@$w;
&$_($Hb)for@$T3;
&$_($Mb)for@$w;
&$_($Pb)for@$T3;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($hc)for@$T3;
&$_($jc)for@$kc;
&$_($pc)for@$i7;
&$_($Cc)for@$w;
&$_($Fc)for@$T3;
&$_($Jc)for@$w;
&$_($Mc)for@$T3;
&$_($Rc)for@$w;
&$_($Uc)for@$T3;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($jd)for@$w;
&$_($md)for@$T3;
&$_($qd)for@$w;
&$_($ud)for@$w;
&$_($xd)for@$T3;
&$_($Bd)for@$w;
&$_($Ed)for@$w;
&$_($Hd)for@$T3;
&$_($Jd)for@$Kd;
&$_($Pd)for@$i7;
&$_($ee)for@$w;
&$_($he)for@$T3;
&$_($me)for@$w;
&$_($pe)for@$T3;
&$_($te)for@$w;
&$_($we)for@$T3;
&$_($Ae)for@$w;
&$_($Ee)for@$w;
&$_($He)for@$w;
&$_($Le)for@$w;
&$_($Oe)for@$w;
&$_($Re)for@$T3;
&$_($Te)for@$Ue;
&$_($Ze)for@$i7;
&$_($mf)for@$w;
&$_($qf)for@$w;
&$_($tf)for@$T3;
&$_($xf)for@$w;
&$_($Af)for@$T3;
&$_($Ff)for@$w;
&$_($Jf)for@$w;
&$_($Mf)for@$T3;
&$_($Pf)for@$w;
&$_($Rf)for@$w;
&$_($Uf)for@$T3;
&$_($Zf)for@$w;
&$_($fg)for@$w;
&$_($ig)for@$T3;
&$_($kg)for@$lg;
&$_($qg)for@$i7;
&$_($yg)for@$w;
&$_($Cg)for@$w;
&$_($Gg)for@$w;
&$_($Jg)for@$T3;
&$_($Ng)for@$w;
&$_($Qg)for@$T3;
&$_($Ug)for@$w;
&$_($Xg)for@$w;
&$_($ch)for@$T3;
&$_($eh)for@$fh;
&$_($lh)for@$i7;
&$_($yh)for@$w;
&$_($Bh)for@$w;
&$_($Fh)for@$w;
&$_($Jh)for@$w;
&$_($Mh)for@$T3;
&$_($Uh)for@$w;
&$_($Xh)for@$T3;
&$_($di)for@$w;
&$_($gi)for@$w;
&$_($ji)for@$w;
&$_($mi)for@$T3;
&$_($oi)for@$pi;
&$_($ui)for@$i7;
&$_($Li)for@$w;
&$_($Pi)for@$w;
&$_($Si)for@$T3;
&$_($Wi)for@$w;
&$_($Zi)for@$w;
&$_($ej)for@$T3;
&$_($jj)for@$w;
&$_($nj)for@$w;
&$_($qj)for@$T3;
&$_($uj)for@$w;
&$_($xj)for@$w;
&$_($Aj)for@$T3;
&$_($Ej)for@$w;
&$_($Hj)for@$w;
&$_($Kj)for@$w;
&$_($Nj)for@$w;
&$_($Qj)for@$T3;
&$_($Sj)for@$Tj;
&$_($Yj)for@$i7;
&$_($nk)for@$w;
&$_($rk)for@$w;
&$_($vk)for@$w;
&$_($yk)for@$T3;
&$_($Ck)for@$w;
&$_($Fk)for@$T3;
&$_($Jk)for@$w;
&$_($Nk)for@$w;
&$_($Qk)for@$w;
&$_($Tk)for@$T3;
&$_($Vk)for@$Wk;
&$_($dl)for@$i7;
&$_($ql)for@$w;
&$_($tl)for@$T3;
&$_($yl)for@$w;
&$_($Cl)for@$w;
&$_($Fl)for@$T3;
&$_($Hl)for@$Il;
&$_($Ml)for@$w;
&$_($Pl)for@$w;
&$_($Sl)for@$w;
&$_($Vl)for@$T3;
&$_($cm)for@$w;
&$_($gm)for@$w;
&$_($km)for@$w;
&$_($om)for@$w;
&$_($rm)for@$T3;
&$_($tm)for@$um;
&$_($Bm)for@$i7;
&$_($Fm)for@$w;
&$_($Im)for@$T3;
&$_($Km)for@$i7;
&$_($Tm)for@$w;
&$_($Xm)for@$w;
&$_($dn)for@$w;
&$_($gn)for@$T3;
&$_($kn)for@$w;
&$_($nn)for@$T3;
&$_($rn)for@$w;
&$_($un)for@$w;
&$_($xn)for@$T3;
&$_($Cn)for@$w;
&$_($Gn)for@$w;
&$_($Jn)for@$T3;
&$_($Nn)for@$On;
&$_($Vn)for@$w;
&$_($Zn)for@$w;
&$_($fo)for@$w;
&$_($io)for@$T3;
&$_($ko)for@$i7;
&$_($yo)for@$w;
&$_($Bo)for@$T3;
&$_($Fo)for@$w;
&$_($Io)for@$T3;
&$_($Ko)for@$Lo;
&$_($Qo)for@$i7;
&$_($dp)for@$w;
&$_($gp)for@$T3;
&$_($ip)for@$jp;
&$_($pp)for@$i7;
&$_($xp)for@$w;
&$_($Ap)for@$T3;
&$_($Dp)for@$w;
&$_($Gp)for@$T3;
&$_($Ip)for@$Jp;
&$_($Op)for@$i7;
&$_($Yp)for@$w;
&$_($dq)for@$T3;
&$_($gq)for@$w;
&$_($jq)for@$T3;
&$_($nq)for@$w;
&$_($qq)for@$T3;
&$_($tq)for@$w;
&$_($wq)for@$w;
&$_($zq)for@$T3;
&$_($Bq)for@$Cq;
&$_($Hq)for@$i7;
&$_($Sq)for@$w;
&$_($Vq)for@$w;
&$_($Xq)for@$w;
&$_($cr)for@$T3;
&$_($gr)for@$w;
&$_($jr)for@$w;
&$_($nr)for@$w;
&$_($qr)for@$T3;
&$_($ur)for@$w;
&$_($xr)for@$w;
&$_($Ar)for@$T3;
&$_($Fr)for@$w;
&$_($Ir)for@$T3;
&$_($Kr)for@$Lr;
&$_($Qr)for@$i7;
&$_($cs)for@$w;
&$_($fs)for@$T3;
&$_($ms)for@$w;
&$_($ps)for@$T3;
&$_($ws)for@$w;
&$_($zs)for@$T3;
&$_($Es)for@$w;
&$_($Is)for@$w;
&$_($Ms)for@$w;
&$_($Qs)for@$w;
&$_($Us)for@$w;
&$_($Ys)for@$w;
&$_($et)for@$w;
&$_($it)for@$w;
&$_($lt)for@$w;
&$_($ot)for@$T3;
&$_($tt)for@$w;
&$_($wt)for@$T3;
&$_($Bt)for@$w;
&$_($Ft)for@$w;
&$_($Jt)for@$w;
&$_($Nt)for@$w;
&$_($Rt)for@$w;
&$_($Ut)for@$T3;
&$_($Zt)for@$w;
&$_($fu)for@$w;
&$_($ju)for@$w;
&$_($mu)for@$T3;
&$_($ru)for@$w;
&$_($vu)for@$w;
&$_($zu)for@$w;
&$_($Cu)for@$T3;
&$_($Eu)for@$Fu;
&$_($Ku)for@$i7;
&$_($Uu)for@$w;
&$_($Yu)for@$w;
&$_($ev)for@$w;
&$_($iv)for@$w;
&$_($mv)for@$w;
&$_($pv)for@$T3;
&$_($Bv)for@$w;
&$_($Ev)for@$w;
&$_($Hv)for@$w;
&$_($Kv)for@$T3;
&$_($Ov)for@$w;
&$_($Rv)for@$w;
&$_($Uv)for@$w;
&$_($Xv)for@$w;
&$_($Zv)for@$w;
&$_($ew)for@$T3;
&$_($hw)for@$w;
&$_($kw)for@$w;
&$_($nw)for@$T3;
&$_($rw)for@$w;
&$_($uw)for@$w;
&$_($xw)for@$T3;
&$_($zw)for@$Aw;
&$_($Fw)for@$i7;
&$_($Pw)for@$w;
&$_($Tw)for@$w;
&$_($Xw)for@$w;
&$_($dx)for@$w;
&$_($hx)for@$w;
&$_($lx)for@$w;
&$_($px)for@$w;
&$_($tx)for@$w;
&$_($xx)for@$w;
&$_($Bx)for@$w;
&$_($Fx)for@$w;
&$_($Jx)for@$w;
&$_($Mx)for@$T3;
&$_($Xx)for@$w;
&$_($cy)for@$T3;
&$_($fy)for@$w;
&$_($iy)for@$w;
&$_($ly)for@$T3;
&$_($ny)for@$oy;
&$_($ty)for@$i7;
&$_($Dy)for@$w;
&$_($Fy)for@$w;
&$_($My)for@$T3;
&$_($Py)for@$w;
&$_($Sy)for@$T3;
&$_($Wy)for@$w;
&$_($Zy)for@$T3;
&$_($dz)for@$ez;
&$_($kz)for@$i7;
&$_($rz)for@$w;
&$_($vz)for@$w;
&$_($yz)for@$T3;
&$_($Fz)for@$w;
&$_($Iz)for@$T3;
&$_($Lz)for@$w;
&$_($Oz)for@$T3;
&$_($Qz)for@$Rz;
&$_($Xz)for@$i7;
&$_($hA)for@$w;
&$_($kA)for@$T3;
&$_($pA)for@$w;
&$_($tA)for@$w;
&$_($wA)for@$T3;
&$_($AA)for@$w;
&$_($DA)for@$T3;
&$_($FA)for@$GA;
&$_($LA)for@$i7;
&$_($TA)for@$UA;
&$_($ZA)for@$i7;
&$_($kB)for@$lB;
&$_($qB)for@$i7;
&$_($yB)for@$zB;
&$_($TB)for@$UB;
&$_($WB)for@$zB;
&$_($dC)for@$w;
&$_($hC)for@$w;
&$_($lC)for@$w;
&$_($pC)for@$w;
&$_($tC)for@$w;
&$_($vC)for@$wC;
ni->run(@ARGV);
__DATA__
