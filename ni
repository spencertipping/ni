#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/mio#;
$P=q#
    my $mio = ni("ni:/fabric/mio")->new;
    my $channel1 = $mio->channel;
    my $channel2 = $mio->channel;
    $channel1->write("8MB data" x 1000000);
    $channel2->write("short string");
    $mio->into_sync($socket_or_something);#;
$Q=[$f,$P];
$R=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel.#;
$S=[$i,$R];
$T=[$Q,$S];
$U=q#/fabric/mio#;
$V=bless({$e,$T,$D,$U},$F);
$W=q#ni.doc:/io#;
$X=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Y=[$i,$X];
$Z=[$Y];
$c1=q#/io#;
$d1=bless({$e,$Z,$D,$c1},$F);
$e1=q#ni.doc:/io/buffer#;
$f1=q#
    my $buf = ni("ni:/io/buffer")->new(1048576);
    $buf->write("foo")#;
$g1=[$f,$f1];
$h1=[$g1];
$i1=q#/io/buffer#;
$j1=bless({$e,$h1,$D,$i1},$F);
$k1=q#ni.doc:/io/cat#;
$l1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$m1=[$f,$l1];
$n1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$o1=[$i,$n1];
$p1=[];
$q1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[$m1,$o1,$s1];
$u1=q#/io/cat#;
$v1=bless({$e,$t1,$D,$u1},$F);
$w1=q#ni.doc:/io/exec#;
$x1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$y1=[$f,$x1];
$z1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$A1=[$i,$z1];
$B1=[];
$C1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$D1=bless({$o,$B1,$q,$C1,$s,$t},$u);
$E1=[$n,$D1];
$F1=[$y1,$A1,$E1];
$G1=q#/io/exec#;
$H1=bless({$e,$F1,$D,$G1},$F);
$I1=q#ni.doc:/io/pid#;
$J1=[];
$K1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[$M1,$Q1,$U1];
$W1=q#/io/pid#;
$X1=bless({$e,$V1,$D,$W1},$F);
$Y1=q#ni.doc:/lib#;
$Z1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$c2=[$i,$Z1];
$d2=[$c2];
$e2=q#/lib#;
$f2=bless({$e,$d2,$D,$e2},$F);
$g2=q#ni.doc:/lib/doc#;
$h2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$i2=[$f,$h2];
$j2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$k2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$l2=[];
$m2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$n2=bless({$o,$l2,$q,$m2,$s,$t},$u);
$o2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$p2=[];
$q2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$r2=bless({$o,$p2,$q,$q2,$s,$t},$u);
$s2=[$i,$j2,$k2,$n,$n2,$o2,$n,$r2];
$t2=[$i2,$s2];
$u2=q#/lib/doc#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni.doc:/semantic#;
$x2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$y2=[$i,$x2];
$z2=[$y2];
$A2=q#/semantic#;
$B2=bless({$e,$z2,$D,$A2},$F);
$C2=q#ni:/class#;
$D2=q#applied_to#;
$E2=q#class#;
$F2=q#class.c#;
$G2=q#fabric/mio.c#;
$H2=q#fabric/rmi.c#;
$I2=q#io/buffer.c#;
$J2=q#io/cat.c#;
$K2=q#io/exec.c#;
$L2=q#io/fd.c#;
$M2=q#io/file.c#;
$N2=q#io/null.c#;
$O2=q#io/object.c#;
$P2=q#io/pid.c#;
$Q2=q#io/str.c#;
$R2=q#io/transfer.c#;
$S2=q#io/transfer_sync.c#;
$T2=q#lib/behavior.c#;
$U2=q#lib/branch.c#;
$V2=q#lib/dataslice.c#;
$W2=q#lib/doc.c#;
$X2=q#lib/fn.c#;
$Y2=q#lib/image.c#;
$Z2=q#lib/ni.c#;
$c3=q#lib/quote_simple.c#;
$d3=q#lib/slice.c#;
$e3=q#lib/tag.c#;
$f3=q#lib/test_value.c#;
$g3=q#metaclass.c#;
$h3=q#module.c#;
$i3=q#object.c#;
$j3=q#semantic/dimension#;
$k3=q#semantic/dimension.c#;
$l3=q#semantic/task.c#;
$m3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1};
$n3=q#slices#;
$o3=q#metaclass#;
$p3=q#module#;
$q3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$o3,1,$g3,1,$p3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1};
$r3=q#/module#;
$s3=q#/lib/perlbranch.b#;
$t3={};
$u3=q#ctor#;
$v3=undef;
$w3=q#dtor#;
$x3=q#methods#;
$y3=q#add#;
$z3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$A3=bless({$q,$z3,$s,$t},$u);
$B3=q#apply#;
$C3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$D3=bless({$q,$C3,$s,$t},$u);
$E3={$y3,$A3,$B3,$D3};
$F3=q#/lib/branch.b#;
$G3=q#lib/slice#;
$H3=bless({$D2,$t3,$u3,$v3,$w3,$v3,$x3,$E3,$D,$F3},$G3);
$I3=q#lib/branch#;
$J3=q#lib/slice::ctors#;
$K3={};
$L3=q#my $s = shift; ni->def($s->name, $s)#;
$M3=bless({$q,$L3,$s,$t},$u);
$N3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$O3=bless({$q,$N3,$s,$t},$u);
$P3={$D,$O3};
$Q3=q#/lib/named.b#;
$R3=bless({$D2,$K3,$u3,$M3,$w3,$v3,$x3,$P3,$D,$Q3},$G3);
$S3=q#lib/tag#;
$T3={};
$U3=q#namespace#;
$V3=q#'ni'#;
$W3=bless({$q,$V3,$s,$t},$u);
$X3={$U3,$W3};
$Y3=q#/lib/named_in_ni.b#;
$Z3=bless({$D2,$T3,$u3,$v3,$w3,$v3,$x3,$X3,$D,$Y3},$G3);
$c4={};
$d4=q#package#;
$e4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$f4=bless({$q,$e4,$s,$t},$u);
$g4={$d4,$f4};
$h4=q#/lib/namespaced.b#;
$i4=bless({$D2,$c4,$u3,$v3,$w3,$v3,$x3,$g4,$D,$h4},$G3);
$j4={};
$k4=q#resolve#;
$l4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$m4=bless({$q,$l4,$s,$t},$u);
$n4={$k4,$m4};
$o4=q#/lib/resolver.b#;
$p4=bless({$D2,$j4,$u3,$v3,$w3,$v3,$x3,$n4,$D,$o4},$G3);
$q4=[$H3,$R3,$Z3,$i4,$p4];
$r4=bless({$D,$s3,$n3,$q4},$S3);
$s4=q#lib/tag::ctors#;
$t4={};
$u4=q#my $s = shift; $s->apply($s->package)#;
$v4=bless({$q,$u4,$s,$t},$u);
$w4=q#instantiate#;
$x4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$y4=bless({$q,$x4,$s,$t},$u);
$z4={$w4,$y4};
$A4=q#/lib/class_init.b#;
$B4=bless({$D2,$t4,$u3,$v4,$w3,$v3,$x3,$z4,$D,$A4},$G3);
$C4=q#fabric/mio#;
$D4=q#fabric/rmi#;
$E4=q#io/buffer#;
$F4=q#io/cat#;
$G4=q#io/exec#;
$H4=q#io/fd#;
$I4=q#io/file#;
$J4=q#io/null#;
$K4=q#io/object#;
$L4=q#io/pid#;
$M4=q#io/str#;
$N4=q#io/transfer#;
$O4=q#io/transfer_sync#;
$P4=q#lib/behavior#;
$Q4=q#lib/dataslice#;
$R4=q#lib/image#;
$S4=q#lib/ni#;
$T4=q#lib/quote_simple#;
$U4=q#lib/test_value#;
$V4=q#object#;
$W4=q#semantic/task#;
$X4={$E2,1,$F2,1,$C4,1,$G2,1,$D4,1,$H2,1,$E4,1,$I2,1,$F4,1,$J2,1,$G4,1,$K2,1,$H4,1,$L2,1,$I4,1,$M2,1,$J4,1,$N2,1,$K4,1,$O2,1,$L4,1,$P2,1,$M4,1,$Q2,1,$N4,1,$R2,1,$O4,1,$S2,1,$P4,1,$T2,1,$I3,1,$U2,1,$Q4,1,$V2,1,$F,1,$W2,1,$u,1,$X2,1,$R4,1,$Y2,1,$S4,1,$Z2,1,$T4,1,$c3,1,$G3,1,$d3,1,$S3,1,$e3,1,$U4,1,$f3,1,$o3,1,$g3,1,$p3,1,$h3,1,$V4,1,$i3,1,$j3,1,$k3,1,$W4,1,$l3,1};
$Y4=q#/object#;
$Z4={};
$c5=q#ni 'ni:/' . ref shift#;
$d5=bless({$q,$c5,$s,$t},$u);
$e5={$E2,$d5};
$f5=q#/lib/instance.b#;
$g5=bless({$D2,$Z4,$u3,$v3,$w3,$v3,$x3,$e5,$D,$f5},$G3);
$h5=[$g5];
$i5=bless({$D2,$X4,$D,$Y4,$n3,$h5},$i3);
$j5=q#object.c::ctors#;
$k5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$P4,1,$T2,1,$I3,1,$U2,1,$Q4,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$G3,1,$d3,1,$S3,1,$e3,1,$f3,1,$o3,1,$g3,1,$p3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1};
$l5=q#/lib/behavior#;
$m5={};
$n5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$o5=bless({$q,$n5,$s,$t},$u);
$p5={$e,$o5};
$q5=q#/lib/documentable.b#;
$r5=bless({$D2,$m5,$u3,$v3,$w3,$v3,$x3,$p5,$D,$q5},$G3);
$s5=[$i5,$r5];
$t5=bless({$D2,$k5,$D,$l5,$n3,$s5},$T2);
$u5=q#lib/behavior.c::ctors#;
$v5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$I3,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$o3,1,$g3,1,$p3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1};
$w5=q#/lib/definition.b#;
$x5={};
$y5=q#def#;
$z5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$A5=bless({$q,$z5,$s,$t},$u);
$B5={$y5,$A5};
$C5=q#/lib/definition_def.b#;
$D5=bless({$D2,$x5,$u3,$v3,$w3,$v3,$x3,$B5,$D,$C5},$G3);
$E5={};
$F5=q#ro#;
$G5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$H5=bless({$q,$G5,$s,$t},$u);
$I5=q#rw#;
$J5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$K5=bless({$q,$J5,$s,$t},$u);
$L5={$F5,$H5,$I5,$K5};
$M5=q#/lib/accessor.b#;
$N5=bless({$D2,$E5,$u3,$v3,$w3,$v3,$x3,$L5,$D,$M5},$G3);
$O5={};
$P5=q#(""#;
$Q5=q#shift->name#;
$R5=bless({$q,$Q5,$s,$t},$u);
$S5={$P5,$R5};
$T5=q#/lib/name_as_string.b#;
$U5=bless({$D2,$O5,$u3,$v3,$w3,$v3,$x3,$S5,$D,$T5},$G3);
$V5={};
$W5=q#(eq#;
$X5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$Y5=bless({$q,$X5,$s,$t},$u);
$Z5={$W5,$Y5};
$c6=q#/lib/ref_eq.b#;
$d6=bless({$D2,$V5,$u3,$v3,$w3,$v3,$x3,$Z5,$D,$c6},$G3);
$e6={};
$f6=q#defdata#;
$g6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$h6=bless({$q,$g6,$s,$t},$u);
$i6={$f6,$h6};
$j6=q#/lib/definition_defdata.b#;
$k6=bless({$D2,$e6,$u3,$v3,$w3,$v3,$x3,$i6,$D,$j6},$G3);
$l6=[$D5,$N5,$U5,$d6,$k6];
$m6=bless({$D2,$v5,$D,$w5,$n3,$l6},$I3);
$n6=q#lib/branch::ctors#;
$o6=[$r4,$B4,$i5,$t5,$m6];
$p6=bless({$D2,$q3,$D,$r3,$n3,$o6},$h3);
$q6=q#module.c::ctors#;
$r6={};
$s6=q#DESTROY#;
$t6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$u6=bless({$q,$t6,$s,$t},$u);
$v6=q#new#;
$w6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$x6=bless({$q,$w6,$s,$t},$u);
$y6={$s6,$u6,$v6,$x6};
$z6=q#/lib/instantiable.b#;
$A6=bless({$D2,$r6,$x3,$y6,$D,$z6},$G3);
$B6={};
$C6=q#child#;
$D6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$E6=bless({$q,$D6,$s,$t},$u);
$F6={$C6,$E6};
$G6=q#/lib/subclass.b#;
$H6=bless({$D2,$B6,$u3,$v3,$w3,$v3,$x3,$F6,$D,$G6},$G3);
$I6=[$p6,$A6,$B4,$p6,$H6];
$J6=bless({$D2,$m3,$D,$E,$n3,$I6},$F2);
$K6=q#class.c::ctors#;
$L6=q#ni:/class.c#;
$M6={$F2,1,$k3,1};
$N6=q#/class.c#;
$O6={$F2,1,$h3,1,$k3,1};
$P6=q#/module.c#;
$Q6={$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$h3,1,$i3,1,$k3,1,$l3,1};
$R6=q#/object.c#;
$S6=[$J6];
$T6=bless({$D2,$Q6,$D,$R6,$n3,$S6},$o3);
$U6=q#metaclass::ctors#;
$V6={$F2,1,$T2,1,$U2,1,$V2,1,$d3,1,$e3,1,$h3,1,$k3,1};
$W6=q#/lib/behavior.c#;
$X6=[$T6];
$Y6=bless({$D2,$V6,$D,$W6,$n3,$X6},$o3);
$Z6=[$T6,$A6,$Y6];
$c7=bless({$D2,$O6,$D,$P6,$n3,$Z6},$o3);
$d7=[$c7];
$e7=bless({$D2,$M6,$D,$N6,$n3,$d7},$o3);
$f7=q#ni:/fabric/mio#;
$g7={$C4,1};
$h7={$C4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1};
$i7=q#/io/object#;
$j7={};
$k7=q#(bool#;
$l7=[];
$m7=bless({$o,$l7,$q,1,$s,$t},$u);
$n7={$k7,$m7};
$o7=q#/io/object_ops.b#;
$p7=bless({$D2,$j7,$u3,$v3,$w3,$v3,$x3,$n7,$D,$o7},$G3);
$q7={};
$r7=q#die#;
$s7=[];
$t7=q#shift; die join " ", @_#;
$u7=bless({$o,$s7,$q,$t7,$s,$t},$u);
$v7=q#io_check#;
$w7=[];
$x7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$y7=bless({$o,$w7,$q,$x7,$s,$t},$u);
$z7=q#io_check_defined#;
$A7=[];
$B7=q#shift->io_check(sub {defined shift}, @_)#;
$C7=bless({$o,$A7,$q,$B7,$s,$t},$u);
$D7=q#io_check_true#;
$E7=[];
$F7=q#shift->io_check(sub {shift}, @_)#;
$G7=bless({$o,$E7,$q,$F7,$s,$t},$u);
$H7={$r7,$u7,$v7,$y7,$z7,$C7,$D7,$G7};
$I7=q#/io/object_checks.b#;
$J7=bless({$D2,$q7,$u3,$v3,$w3,$v3,$x3,$H7,$D,$I7},$G3);
$K7={};
$L7=q#(+#;
$M7=[];
$N7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$O7=bless({$o,$M7,$q,$N7,$s,$t},$u);
$P7={$L7,$O7};
$Q7=q#/io/object_constructors.b#;
$R7=bless({$D2,$K7,$u3,$v3,$w3,$v3,$x3,$P7,$D,$Q7},$G3);
$S7={};
$T7=q#read_all#;
$U7=[];
$V7=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$W7=bless({$o,$U7,$q,$V7,$s,$t},$u);
$X7={$T7,$W7};
$Y7=q#/io/object_memory.b#;
$Z7=bless({$D2,$S7,$u3,$v3,$w3,$v3,$x3,$X7,$D,$Y7},$G3);
$c8={};
$d8=q#into_sync#;
$e8=[];
$f8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$g8=bless({$o,$e8,$q,$f8,$s,$t},$u);
$h8={$d8,$g8};
$i8=q#/io/object_transfer_sync.b#;
$j8=bless({$D2,$c8,$u3,$v3,$w3,$v3,$x3,$h8,$D,$i8},$G3);
$k8=[$i5,$p7,$J7,$R7,$Z7,$j8,$j8];
$l8=bless({$D2,$h7,$D,$i7,$n3,$k8},$O2);
$m8=q#io/object.c::ctors#;
$n8={};
$o8=q#io#;
$p8=[];
$q8=q#shift->{'io'}#;
$r8=bless({$o,$p8,$q,$q8,$s,$t},$u);
$s8=q#packet_size#;
$t8=[];
$u8=q#shift->{'packet_size'}#;
$v8=bless({$o,$t8,$q,$u8,$s,$t},$u);
$w8={$o8,$r8,$s8,$v8};
$x8=q#/fabric/mio_ro.b#;
$y8=bless({$D2,$n8,$u3,$v3,$w3,$v3,$x3,$w8,$D,$x8},$G3);
$z8={};
$A8=[];
$B8=q#my ($self, $io, %args) = @_;
+{io          => $io,
  packet_size => $args{packet_size} || 32768,
  channel_id  => 0,
  channels    => {}};#;
$C8=bless({$o,$A8,$q,$B8,$s,$t},$u);
$D8={$w4,$C8};
$E8=q#/fabric/mio_init.b#;
$F8=bless({$D2,$z8,$u3,$v3,$w3,$v3,$x3,$D8,$D,$E8},$G3);
$G8={};
$H8=q#data_packet#;
$I8=[];
$J8=q#my $self      = shift;
my $stream_id = shift;
pack 'NN/a', $stream_id, $_[0];#;
$K8=bless({$o,$I8,$q,$J8,$s,$t},$u);
$L8=q#eof_packet#;
$M8=[];
$N8=q#my ($self, $stream_id) = @_;
pack 'NN', $stream_id, 0;#;
$O8=bless({$o,$M8,$q,$N8,$s,$t},$u);
$P8={$H8,$K8,$L8,$O8};
$Q8=q#/fabric/mio_packet.b#;
$R8=bless({$D2,$G8,$u3,$v3,$w3,$v3,$x3,$P8,$D,$Q8},$G3);
$S8=[$l8,$y8,$F8,$R8];
$T8=bless({$D2,$g7,$D,$U,$n3,$S8},$G2);
$U8=q#fabric/mio.c::ctors#;
$V8=q#ni:/fabric/mio.c#;
$W8={$G2,1};
$X8=q#/fabric/mio.c#;
$Y8={$G2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1};
$Z8=q#/io/object.c#;
$c9=[$T6];
$d9=bless({$D2,$Y8,$D,$Z8,$n3,$c9},$o3);
$e9=[$d9];
$f9=bless({$D2,$W8,$D,$X8,$n3,$e9},$o3);
$g9=q#ni:/fabric/mio_init.b#;
$h9=q#ni:/fabric/mio_packet.b#;
$i9=q#ni:/fabric/mio_ro.b#;
$j9=q#ni:/fabric/rmi#;
$k9={$D4,1};
$l9=q#/fabric/rmi#;
$m9={};
$n9=[];
$o9=q#my ($class, $io, $quote) = @_;#;
$p9=bless({$o,$n9,$q,$o9,$s,$t},$u);
$q9={$w4,$p9};
$r9=q#/fabric/rmi_init.b#;
$s9=bless({$D2,$m9,$u3,$v3,$w3,$v3,$x3,$q9,$D,$r9},$G3);
$t9=[$i5,$s9];
$u9=bless({$D2,$k9,$D,$l9,$n3,$t9},$H2);
$v9=q#fabric/rmi.c::ctors#;
$w9=q#ni:/fabric/rmi.c#;
$x9={$H2,1};
$y9=q#/fabric/rmi.c#;
$z9=[$T6];
$A9=bless({$D2,$x9,$D,$y9,$n3,$z9},$o3);
$B9=q#ni:/fabric/rmi_init.b#;
$C9=q#ni:/io/buffer#;
$D9={$E4,1};
$E9={};
$F9=[];
$G9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$H9=bless({$o,$F9,$q,$G9,$s,$t},$u);
$I9={$w4,$H9};
$J9=q#/io/buffer_init.b#;
$K9=bless({$D2,$E9,$u3,$v3,$w3,$v3,$x3,$I9,$D,$J9},$G3);
$L9={};
$M9=q#read#;
$N9=[];
$O9=bless({$o,$N9,$q,$t,$s,$t},$u);
$P9=q#write#;
$Q9=[];
$R9=bless({$o,$Q9,$q,$t,$s,$t},$u);
$S9={$M9,$O9,$P9,$R9};
$T9=q#/io/buffer_io.b#;
$U9=bless({$D2,$L9,$u3,$v3,$w3,$v3,$x3,$S9,$D,$T9},$G3);
$V9=[$l8,$K9,$U9];
$W9=bless({$D2,$D9,$D,$i1,$n3,$V9},$I2);
$X9=q#io/buffer.c::ctors#;
$Y9=q#ni:/io/buffer.c#;
$Z9={$I2,1};
$ca=q#/io/buffer.c#;
$da=[$d9];
$ea=bless({$D2,$Z9,$D,$ca,$n3,$da},$o3);
$fa=q#ni:/io/buffer_init.b#;
$ga=q#ni:/io/buffer_io.b#;
$ha=q#ni:/io/cat#;
$ia={$F4,1};
$ja={};
$ka=[];
$la=q#shift; +{fs => [@_]}#;
$ma=bless({$o,$ka,$q,$la,$s,$t},$u);
$na={$w4,$ma};
$oa=q#/io/cat_init.b#;
$pa=bless({$D2,$ja,$u3,$v3,$w3,$v3,$x3,$na,$D,$oa},$G3);
$qa={};
$ra=[];
$sa=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$ta=bless({$o,$ra,$q,$sa,$s,$t},$u);
$ua={$M9,$ta};
$va=q#/io/cat_read.b#;
$wa=bless({$D2,$qa,$u3,$v3,$w3,$v3,$x3,$ua,$D,$va},$G3);
$xa=[$l8,$pa,$wa];
$ya=bless({$D2,$ia,$D,$u1,$n3,$xa},$J2);
$za=q#io/cat.c::ctors#;
$Aa=q#ni:/io/cat.c#;
$Ba={$J2,1};
$Ca=q#/io/cat.c#;
$Da=[$d9];
$Ea=bless({$D2,$Ba,$D,$Ca,$n3,$Da},$o3);
$Fa=q#ni:/io/cat_init.b#;
$Ga=q#ni:/io/cat_read.b#;
$Ha=q#ni:/io/exec#;
$Ia={$G4,1};
$Ja={};
$Ka=q#argv#;
$La=[];
$Ma=q#shift->{'argv'}#;
$Na=bless({$o,$La,$q,$Ma,$s,$t},$u);
$Oa={$Ka,$Na};
$Pa=q#/io/exec_ro.b#;
$Qa=bless({$D2,$Ja,$u3,$v3,$w3,$v3,$x3,$Oa,$D,$Pa},$G3);
$Ra={};
$Sa=[];
$Ta=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va={$w4,$Ua};
$Wa=q#/io/exec_init.b#;
$Xa=bless({$D2,$Ra,$u3,$v3,$w3,$v3,$x3,$Va,$D,$Wa},$G3);
$Ya={};
$Za=q#connect#;
$cb=[];
$db=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q#in_pipe#;
$gb=[];
$hb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb=q#out_pipe#;
$kb=[];
$lb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q#setup_stdio#;
$ob=[];
$pb=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb={$Za,$eb,$fb,$ib,$jb,$mb,$nb,$qb};
$sb=q#/io/exec_io_setup.b#;
$tb=bless({$D2,$Ya,$u3,$v3,$w3,$v3,$x3,$rb,$D,$sb},$G3);
$ub={};
$vb=q#binds_fd#;
$wb=[];
$xb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$yb=bless({$o,$wb,$q,$xb,$s,$t},$u);
$zb=q#fd#;
$Ab=[];
$Bb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q#stderr#;
$Eb=[];
$Fb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q#stdin#;
$Ib=[];
$Jb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb=q#stdout#;
$Mb=[];
$Nb=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb={$vb,$yb,$zb,$Cb,$Db,$Gb,$Hb,$Kb,$Lb,$Ob};
$Qb=q#/io/exec_io_accessors.b#;
$Rb=bless({$D2,$ub,$u3,$v3,$w3,$v3,$x3,$Pb,$D,$Qb},$G3);
$Sb={};
$Tb=q#env#;
$Ub=[];
$Vb=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb={$Tb,$Wb};
$Yb=q#/io/exec_env.b#;
$Zb=bless({$D2,$Sb,$u3,$v3,$w3,$v3,$x3,$Xb,$D,$Yb},$G3);
$cc={};
$dc=q#exec#;
$ec=[];
$fc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$gc=bless({$o,$ec,$q,$fc,$s,$t},$u);
$hc=q#fork#;
$ic=[];
$jc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$kc=bless({$o,$ic,$q,$jc,$s,$t},$u);
$lc=q#move_fds#;
$mc=[];
$nc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$oc=bless({$o,$mc,$q,$nc,$s,$t},$u);
$pc={$dc,$gc,$hc,$kc,$lc,$oc};
$qc=q#/io/exec_fork.b#;
$rc=bless({$D2,$cc,$u3,$v3,$w3,$v3,$x3,$pc,$D,$qc},$G3);
$sc=[$l8,$Qa,$Xa,$tb,$Rb,$Zb,$rc];
$tc=bless({$D2,$Ia,$D,$G1,$n3,$sc},$K2);
$uc=q#io/exec.c::ctors#;
$vc=q#ni:/io/exec.c#;
$wc={$K2,1};
$xc=q#/io/exec.c#;
$yc=[$d9];
$zc=bless({$D2,$wc,$D,$xc,$n3,$yc},$o3);
$Ac=q#ni:/io/exec_env.b#;
$Bc=q#ni:/io/exec_fork.b#;
$Cc=q#ni:/io/exec_init.b#;
$Dc=q#ni:/io/exec_io_accessors.b#;
$Ec=q#ni:/io/exec_io_setup.b#;
$Fc=q#ni:/io/exec_ro.b#;
$Gc=q#ni:/io/fd#;
$Hc={$H4,1};
$Ic=q#/io/fd#;
$Jc={};
$Kc=[];
$Lc=q#shift->{'fd'}#;
$Mc=bless({$o,$Kc,$q,$Lc,$s,$t},$u);
$Nc={$zb,$Mc};
$Oc=q#/io/fd_readers.b#;
$Pc=bless({$D2,$Jc,$u3,$v3,$w3,$v3,$x3,$Nc,$D,$Oc},$G3);
$Qc={};
$Rc=[];
$Sc=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Tc=bless({$o,$Rc,$q,$Sc,$s,$t},$u);
$Uc={$w4,$Tc};
$Vc=q#/io/fd_init.b#;
$Wc=bless({$D2,$Qc,$u3,$v3,$w3,$v3,$x3,$Uc,$D,$Vc},$G3);
$Xc={};
$Yc=q#be#;
$Zc=[];
$cd=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$dd=bless({$o,$Zc,$q,$cd,$s,$t},$u);
$ed={$Yc,$dd};
$fd=q#/io/fd_shell.b#;
$gd=bless({$D2,$Xc,$u3,$v3,$w3,$v3,$x3,$ed,$D,$fd},$G3);
$hd={};
$id=q#cloexec#;
$jd=[];
$kd=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$ld=bless({$o,$jd,$q,$kd,$s,$t},$u);
$md=q#fcntl_flag#;
$nd=[];
$od=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$pd=bless({$o,$nd,$q,$od,$s,$t},$u);
$qd=q#nonblock#;
$rd=[];
$sd=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$td=bless({$o,$rd,$q,$sd,$s,$t},$u);
$ud={$id,$ld,$md,$pd,$qd,$td};
$vd=q#/io/fd_fcntl.b#;
$wd=bless({$D2,$hd,$u3,$v3,$w3,$v3,$x3,$ud,$D,$vd},$G3);
$xd={};
$yd=[];
$zd=q#shift->close#;
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=q#close#;
$Cd=[];
$Dd=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd={$Bd,$Ed};
$Gd=q#/io/fd_gc.b#;
$Hd=bless({$D2,$xd,$u3,$v3,$w3,$Ad,$x3,$Fd,$D,$Gd},$G3);
$Id={};
$Jd=[];
$Kd=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Ld=bless({$o,$Jd,$q,$Kd,$s,$t},$u);
$Md=[];
$Nd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Od=bless({$o,$Md,$q,$Nd,$s,$t},$u);
$Pd={$M9,$Ld,$P9,$Od};
$Qd=q#/io/fd_perlio.b#;
$Rd=bless({$D2,$Id,$u3,$v3,$w3,$v3,$x3,$Pd,$D,$Qd},$G3);
$Sd=[$l8,$Pc,$Wc,$gd,$wd,$Hd,$Rd];
$Td=bless({$D2,$Hc,$D,$Ic,$n3,$Sd},$L2);
$Ud=q#io/fd.c::ctors#;
$Vd=q#ni:/io/fd.c#;
$Wd={$L2,1};
$Xd=q#/io/fd.c#;
$Yd=[$d9];
$Zd=bless({$D2,$Wd,$D,$Xd,$n3,$Yd},$o3);
$ce=q#ni:/io/fd_fcntl.b#;
$de=q#ni:/io/fd_gc.b#;
$ee=q#ni:/io/fd_init.b#;
$fe=q#ni:/io/fd_perlio.b#;
$ge=q#ni:/io/fd_readers.b#;
$he=q#ni:/io/fd_shell.b#;
$ie=q#ni:/io/file#;
$je={$I4,1};
$ke=q#/io/file#;
$le={};
$me=[];
$ne=q#shift->{'name'}#;
$oe=bless({$o,$me,$q,$ne,$s,$t},$u);
$pe={$D,$oe};
$qe=q#/io/file_readers.b#;
$re=bless({$D2,$le,$u3,$v3,$w3,$v3,$x3,$pe,$D,$qe},$G3);
$se={};
$te=q#mode#;
$ue=[];
$ve=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$we=bless({$o,$ue,$q,$ve,$s,$t},$u);
$xe={$te,$we};
$ye=q#/io/file_accessors.b#;
$ze=bless({$D2,$se,$u3,$v3,$w3,$v3,$x3,$xe,$D,$ye},$G3);
$Ae={};
$Be=[];
$Ce=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$De=bless({$o,$Be,$q,$Ce,$s,$t},$u);
$Ee={$w4,$De};
$Fe=q#/io/file_init.b#;
$Ge=bless({$D2,$Ae,$u3,$v3,$w3,$v3,$x3,$Ee,$D,$Fe},$G3);
$He={};
$Ie=q#r#;
$Je=[];
$Ke=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Le=bless({$o,$Je,$q,$Ke,$s,$t},$u);
$Me=[];
$Ne=q#shift->r->read(@_)#;
$Oe=bless({$o,$Me,$q,$Ne,$s,$t},$u);
$Pe=q#w#;
$Qe=[];
$Re=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Se=bless({$o,$Qe,$q,$Re,$s,$t},$u);
$Te=[];
$Ue=q#shift->w->write(@_)#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We={$Ie,$Le,$M9,$Oe,$Pe,$Se,$P9,$Ve};
$Xe=q#/io/file_io.b#;
$Ye=bless({$D2,$He,$u3,$v3,$w3,$v3,$x3,$We,$D,$Xe},$G3);
$Ze=[$l8,$re,$ze,$Ge,$Ye];
$cf=bless({$D2,$je,$D,$ke,$n3,$Ze},$M2);
$df=q#io/file.c::ctors#;
$ef=q#ni:/io/file.c#;
$ff={$M2,1};
$gf=q#/io/file.c#;
$hf=[$d9];
$if=bless({$D2,$ff,$D,$gf,$n3,$hf},$o3);
$jf=q#ni:/io/file_accessors.b#;
$kf=q#ni:/io/file_init.b#;
$lf=q#ni:/io/file_io.b#;
$mf=q#ni:/io/file_readers.b#;
$nf=q#ni:/io/named_io_fns.b#;
$of={};
$pf=q#fcntl#;
$qf=[];
$rf=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$sf=bless({$o,$qf,$q,$rf,$s,$t},$u);
$tf=[];
$uf=q#CORE::fork#;
$vf=bless({$o,$tf,$q,$uf,$s,$t},$u);
$wf=q#open2#;
$xf=[];
$yf=q#CORE::open $_[0], $_[1]#;
$zf=bless({$o,$xf,$q,$yf,$s,$t},$u);
$Af=q#waitpid#;
$Bf=[];
$Cf=q#CORE::waitpid $_[0], $_[1]#;
$Df=bless({$o,$Bf,$q,$Cf,$s,$t},$u);
$Ef={$pf,$sf,$hc,$vf,$wf,$zf,$Af,$Df};
$Ff=q#/io/named_io_fns.b#;
$Gf=bless({$D2,$of,$u3,$v3,$w3,$v3,$x3,$Ef,$D,$Ff},$G3);
$Hf=q#main#;
$If=q#ni:/io/null#;
$Jf={$J4,1};
$Kf=q#/io/null#;
$Lf={};
$Mf=[];
$Nf=q#+{fd => undef}#;
$Of=bless({$o,$Mf,$q,$Nf,$s,$t},$u);
$Pf={$w4,$Of};
$Qf=q#/io/null_init.b#;
$Rf=bless({$D2,$Lf,$u3,$v3,$w3,$v3,$x3,$Pf,$D,$Qf},$G3);
$Sf={};
$Tf=[];
$Uf=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Vf=bless({$o,$Tf,$q,$Uf,$s,$t},$u);
$Wf=[];
$Xf=q#shift->fd->read(@_)#;
$Yf=bless({$o,$Wf,$q,$Xf,$s,$t},$u);
$Zf=[];
$cg=q#shift->fd->write(@_)#;
$dg=bless({$o,$Zf,$q,$cg,$s,$t},$u);
$eg={$zb,$Vf,$M9,$Yf,$P9,$dg};
$fg=q#/io/null_io.b#;
$gg=bless({$D2,$Sf,$u3,$v3,$w3,$v3,$x3,$eg,$D,$fg},$G3);
$hg=[$l8,$Rf,$gg];
$ig=bless({$D2,$Jf,$D,$Kf,$n3,$hg},$N2);
$jg=q#io/null.c::ctors#;
$kg=q#ni:/io/null.c#;
$lg={$N2,1};
$mg=q#/io/null.c#;
$ng=[$d9];
$og=bless({$D2,$lg,$D,$mg,$n3,$ng},$o3);
$pg=q#ni:/io/null_init.b#;
$qg=q#ni:/io/null_io.b#;
$rg=q#ni:/io/object#;
$sg=q#ni:/io/object.c#;
$tg=q#ni:/io/object_checks.b#;
$ug=q#ni:/io/object_constructors.b#;
$vg=q#ni:/io/object_memory.b#;
$wg=q#ni:/io/object_ops.b#;
$xg=q#ni:/io/object_transfer_sync.b#;
$yg=q#ni:/io/pid#;
$zg={$L4,1};
$Ag={};
$Bg=q#pid#;
$Cg=[];
$Dg=q#shift->{'pid'}#;
$Eg=bless({$o,$Cg,$q,$Dg,$s,$t},$u);
$Fg=q#status#;
$Gg=[];
$Hg=q#shift->{'status'}#;
$Ig=bless({$o,$Gg,$q,$Hg,$s,$t},$u);
$Jg={$Bg,$Eg,$Fg,$Ig};
$Kg=q#/io/pid_readers.b#;
$Lg=bless({$D2,$Ag,$u3,$v3,$w3,$v3,$x3,$Jg,$D,$Kg},$G3);
$Mg={};
$Ng=[];
$Og=q#shift->await#;
$Pg=bless({$o,$Ng,$q,$Og,$s,$t},$u);
$Qg=[];
$Rg=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Sg=bless({$o,$Qg,$q,$Rg,$s,$t},$u);
$Tg={$w4,$Sg};
$Ug=q#/io/pid_init.b#;
$Vg=bless({$D2,$Mg,$u3,$v3,$w3,$Pg,$x3,$Tg,$D,$Ug},$G3);
$Wg={};
$Xg=q#await#;
$Yg=[];
$Zg=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$ch=bless({$o,$Yg,$q,$Zg,$s,$t},$u);
$dh=q#running#;
$eh=[];
$fh=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$gh=bless({$o,$eh,$q,$fh,$s,$t},$u);
$hh={$Xg,$ch,$dh,$gh};
$ih=q#/io/pid_wait.b#;
$jh=bless({$D2,$Wg,$u3,$v3,$w3,$v3,$x3,$hh,$D,$ih},$G3);
$kh={};
$lh=[];
$mh=q#shift->stdout->read(@_)#;
$nh=bless({$o,$lh,$q,$mh,$s,$t},$u);
$oh=[];
$ph=q#shift->stdin->write(@_)#;
$qh=bless({$o,$oh,$q,$ph,$s,$t},$u);
$rh={$M9,$nh,$P9,$qh};
$sh=q#/io/pid_io.b#;
$th=bless({$D2,$kh,$u3,$v3,$w3,$v3,$x3,$rh,$D,$sh},$G3);
$uh={};
$vh=[];
$wh=q#$_[0]->{external_fds}{$_[1]}#;
$xh=bless({$o,$vh,$q,$wh,$s,$t},$u);
$yh=[];
$zh=q#shift->fd(2)#;
$Ah=bless({$o,$yh,$q,$zh,$s,$t},$u);
$Bh=[];
$Ch=q#shift->fd(0)#;
$Dh=bless({$o,$Bh,$q,$Ch,$s,$t},$u);
$Eh=[];
$Fh=q#shift->fd(1)#;
$Gh=bless({$o,$Eh,$q,$Fh,$s,$t},$u);
$Hh={$zb,$xh,$Db,$Ah,$Hb,$Dh,$Lb,$Gh};
$Ih=q#/io/pid_accessors.b#;
$Jh=bless({$D2,$uh,$u3,$v3,$w3,$v3,$x3,$Hh,$D,$Ih},$G3);
$Kh=[$l8,$Lg,$Vg,$jh,$th,$Jh];
$Lh=bless({$D2,$zg,$D,$W1,$n3,$Kh},$P2);
$Mh=q#io/pid.c::ctors#;
$Nh=q#ni:/io/pid.c#;
$Oh={$P2,1};
$Ph=q#/io/pid.c#;
$Qh=[$d9];
$Rh=bless({$D2,$Oh,$D,$Ph,$n3,$Qh},$o3);
$Sh=q#ni:/io/pid_accessors.b#;
$Th=q#ni:/io/pid_init.b#;
$Uh=q#ni:/io/pid_io.b#;
$Vh=q#ni:/io/pid_readers.b#;
$Wh=q#ni:/io/pid_wait.b#;
$Xh=q#ni:/io/str#;
$Yh={$M4,1};
$Zh=q#/io/str#;
$ci={};
$di=q#data#;
$ei=[];
$fi=q#shift->{'data'}#;
$gi=bless({$o,$ei,$q,$fi,$s,$t},$u);
$hi=q#end#;
$ii=[];
$ji=q#shift->{'end'}#;
$ki=bless({$o,$ii,$q,$ji,$s,$t},$u);
$li=q#start#;
$mi=[];
$ni=q#shift->{'start'}#;
$oi=bless({$o,$mi,$q,$ni,$s,$t},$u);
$pi={$di,$gi,$hi,$ki,$li,$oi};
$qi=q#/io/str_ro.b#;
$ri=bless({$D2,$ci,$u3,$v3,$w3,$v3,$x3,$pi,$D,$qi},$G3);
$si={};
$ti=[];
$ui=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$vi=bless({$o,$ti,$q,$ui,$s,$t},$u);
$wi={$w4,$vi};
$xi=q#/io/str_init.b#;
$yi=bless({$D2,$si,$u3,$v3,$w3,$v3,$x3,$wi,$D,$xi},$G3);
$zi={};
$Ai=[];
$Bi=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Ci=bless({$o,$Ai,$q,$Bi,$s,$t},$u);
$Di=q#remaining#;
$Ei=[];
$Fi=q#my $self = shift; $$self{end} - $$self{start}#;
$Gi=bless({$o,$Ei,$q,$Fi,$s,$t},$u);
$Hi=[];
$Ii=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Ji=bless({$o,$Hi,$q,$Ii,$s,$t},$u);
$Ki={$M9,$Ci,$Di,$Gi,$P9,$Ji};
$Li=q#/io/str_io.b#;
$Mi=bless({$D2,$zi,$u3,$v3,$w3,$v3,$x3,$Ki,$D,$Li},$G3);
$Ni=[$l8,$ri,$yi,$Mi];
$Oi=bless({$D2,$Yh,$D,$Zh,$n3,$Ni},$Q2);
$Pi=q#io/str.c::ctors#;
$Qi=q#ni:/io/str.c#;
$Ri={$Q2,1};
$Si=q#/io/str.c#;
$Ti=[$d9];
$Ui=bless({$D2,$Ri,$D,$Si,$n3,$Ti},$o3);
$Vi=q#ni:/io/str_init.b#;
$Wi=q#ni:/io/str_io.b#;
$Xi=q#ni:/io/str_ro.b#;
$Yi=q#ni:/io/transfer#;
$Zi={$N4,1,$O4,1};
$cj=q#/io/transfer#;
$dj={$N4,1,$O4,1,$W4,1};
$ej=q#/semantic/task#;
$fj={};
$gj=q#outcome#;
$hj=[];
$ij=q#shift->{'outcome'}#;
$jj=bless({$o,$hj,$q,$ij,$s,$t},$u);
$kj={$gj,$jj};
$lj=q#/semantic/task_ro.b#;
$mj=bless({$D2,$fj,$u3,$v3,$w3,$v3,$x3,$kj,$D,$lj},$G3);
$nj={};
$oj=q#failure#;
$pj=[];
$qj=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$rj=bless({$o,$pj,$q,$qj,$s,$t},$u);
$sj=q#success#;
$tj=[];
$uj=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$vj=bless({$o,$tj,$q,$uj,$s,$t},$u);
$wj={$oj,$rj,$sj,$vj};
$xj=q#/semantic/task_outcome.b#;
$yj=bless({$D2,$nj,$u3,$v3,$w3,$v3,$x3,$wj,$D,$xj},$G3);
$zj=[$i5,$mj,$yj];
$Aj=bless({$D2,$dj,$D,$ej,$n3,$zj},$l3);
$Bj=q#semantic/task.c::ctors#;
$Cj={};
$Dj=[];
$Ej=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Fj=bless({$o,$Dj,$q,$Ej,$s,$t},$u);
$Gj=[];
$Hj=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Ij=bless({$o,$Gj,$q,$Hj,$s,$t},$u);
$Jj=[];
$Kj=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Lj=bless({$o,$Jj,$q,$Kj,$s,$t},$u);
$Mj={$M9,$Ij,$P9,$Lj};
$Nj=q#/io/transfer_io_interop.b#;
$Oj=bless({$D2,$Cj,$u3,$Fj,$w3,$v3,$x3,$Mj,$D,$Nj},$G3);
$Pj=[$Aj,$Oj];
$Qj=bless({$D2,$Zi,$D,$cj,$n3,$Pj},$R2);
$Rj=q#io/transfer.c::ctors#;
$Sj=q#ni:/io/transfer.c#;
$Tj={$R2,1,$S2,1};
$Uj=q#/io/transfer.c#;
$Vj={$R2,1,$S2,1,$l3,1};
$Wj=q#/semantic/task.c#;
$Xj=[$T6];
$Yj=bless({$D2,$Vj,$D,$Wj,$n3,$Xj},$o3);
$Zj={};
$ck=[];
$dk=q#my $self = shift;
ni('ni:/io/object')->def("/io/object_transfer_$1.b",
  "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\\@_)->run})
if $self->name =~ /transfer_(\\w+)$/;#;
$ek=bless({$o,$ck,$q,$dk,$s,$t},$u);
$fk={};
$gk=q#/io/transfer.c_into.b#;
$hk=bless({$D2,$Zj,$u3,$ek,$w3,$v3,$x3,$fk,$D,$gk},$G3);
$ik=[$Yj,$hk];
$jk=bless({$D2,$Tj,$D,$Uj,$n3,$ik},$o3);
$kk=q#ni:/io/transfer.c_into.b#;
$lk=q#ni:/io/transfer_io_interop.b#;
$mk=q#ni:/io/transfer_sync#;
$nk={$O4,1};
$ok=q#/io/transfer_sync#;
$pk={};
$qk=[];
$rk=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk={$w4,$sk};
$uk=q#/io/transfer_sync_init.b#;
$vk=bless({$D2,$pk,$u3,$v3,$w3,$v3,$x3,$tk,$D,$uk},$G3);
$wk={};
$xk=q#run#;
$yk=[];
$zk=q#my $self = shift;
my $buf;
while ($self->read($buf, 32768)) {
  my $n = $self->write($buf);
  $self->failure($!) unless defined $n;
  while ($n < length $buf) {
    my $n0 = $self->write(substr $buf, $n);
    $self->failure($!) unless defined $n0;
    $n += $n0;
  }
}
$self->success;#;
$Ak=bless({$o,$yk,$q,$zk,$s,$t},$u);
$Bk={$xk,$Ak};
$Ck=q#/io/transfer_sync_run.b#;
$Dk=bless({$D2,$wk,$u3,$v3,$w3,$v3,$x3,$Bk,$D,$Ck},$G3);
$Ek=[$Qj,$vk,$Dk];
$Fk=bless({$D2,$nk,$D,$ok,$n3,$Ek},$S2);
$Gk=q#io/transfer_sync.c::ctors#;
$Hk=q#ni:/io/transfer_sync.c#;
$Ik={$S2,1};
$Jk=q#/io/transfer_sync.c#;
$Kk=[$jk];
$Lk=bless({$D2,$Ik,$D,$Jk,$n3,$Kk},$o3);
$Mk=q#ni:/io/transfer_sync_init.b#;
$Nk=q#ni:/io/transfer_sync_run.b#;
$Ok=q#ni:/lib/accessor.b#;
$Pk=q#ni:/lib/behavior#;
$Qk=q#ni:/lib/behavior.c#;
$Rk=q#ni:/lib/branch#;
$Sk={$I3,1};
$Tk=q#/lib/branch#;
$Uk={};
$Vk=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Wk=bless({$q,$Vk,$s,$t},$u);
$Xk={$w4,$Wk};
$Yk=q#/lib/branch_init.b#;
$Zk=bless({$D2,$Uk,$u3,$v3,$w3,$v3,$x3,$Xk,$D,$Yk},$G3);
$cl=[$t5,$R3,$H3,$Zk,$m6];
$dl=bless({$D2,$Sk,$D,$Tk,$n3,$cl},$U2);
$el=q#lib/branch.c::ctors#;
$fl=q#ni:/lib/branch.b#;
$gl=q#ni:/lib/branch.c#;
$hl={$U2,1};
$il=q#/lib/branch.c#;
$jl=[$Y6];
$kl=bless({$D2,$hl,$D,$il,$n3,$jl},$o3);
$ll=q#ni:/lib/branch_init.b#;
$ml=q#ni:/lib/class_init.b#;
$nl=q#ni:/lib/dataslice#;
$ol={$Q4,1};
$pl=q#/lib/dataslice#;
$ql={};
$rl=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$sl=bless({$q,$rl,$s,$t},$u);
$tl={$w4,$sl};
$ul=q#/lib/dataslice_init.b#;
$vl=bless({$D2,$ql,$u3,$v3,$w3,$v3,$x3,$tl,$D,$ul},$G3);
$wl={};
$xl=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$yl=bless({$q,$xl,$s,$t},$u);
$zl={$B3,$yl};
$Al=q#/lib/dataslice_apply.b#;
$Bl=bless({$D2,$wl,$u3,$v3,$w3,$v3,$x3,$zl,$D,$Al},$G3);
$Cl=[$t5,$vl,$Bl];
$Dl=bless({$D2,$ol,$D,$pl,$n3,$Cl},$V2);
$El=q#lib/dataslice.c::ctors#;
$Fl=q#ni:/lib/dataslice.c#;
$Gl={$V2,1};
$Hl=q#/lib/dataslice.c#;
$Il=[$Y6];
$Jl=bless({$D2,$Gl,$D,$Hl,$n3,$Il},$o3);
$Kl=q#ni:/lib/dataslice_apply.b#;
$Ll=q#ni:/lib/dataslice_init.b#;
$Ml=q#ni:/lib/definition.b#;
$Nl=q#ni:/lib/definition_def.b#;
$Ol=q#ni:/lib/definition_defdata.b#;
$Pl=q#ni:/lib/doc#;
$Ql={$F,1};
$Rl={};
$Sl=q#shift; +{name => shift, doc => []}#;
$Tl=bless({$q,$Sl,$s,$t},$u);
$Ul={$w4,$Tl};
$Vl=q#/lib/doc_init.b#;
$Wl=bless({$D2,$Rl,$u3,$v3,$w3,$v3,$x3,$Ul,$D,$Vl},$G3);
$Xl={};
$Yl=q#'ni.doc'#;
$Zl=bless({$q,$Yl,$s,$t},$u);
$cm={$U3,$Zl};
$dm=q#/lib/doc_namespace.b#;
$em=bless({$D2,$Xl,$u3,$v3,$w3,$v3,$x3,$cm,$D,$dm},$G3);
$fm={};
$gm=q#AUTOLOAD#;
$hm=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$im=bless({$q,$hm,$s,$t},$u);
$jm={$gm,$im};
$km=q#/lib/doc_define.b#;
$lm=bless({$D2,$fm,$u3,$v3,$w3,$v3,$x3,$jm,$D,$km},$G3);
$mm={};
$nm=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$om=bless({$q,$nm,$s,$t},$u);
$pm=q#tests#;
$qm=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$rm=bless({$q,$qm,$s,$t},$u);
$sm={$n,$om,$pm,$rm};
$tm=q#/lib/doc_test.b#;
$um=bless({$D2,$mm,$u3,$v3,$w3,$v3,$x3,$sm,$D,$tm},$G3);
$vm=[$i5,$R3,$Wl,$em,$lm,$um];
$wm=bless({$D2,$Ql,$D,$u2,$n3,$vm},$W2);
$xm=q#lib/doc.c::ctors#;
$ym=q#ni:/lib/doc.c#;
$zm={$W2,1};
$Am=q#/lib/doc.c#;
$Bm=[$T6];
$Cm=bless({$D2,$zm,$D,$Am,$n3,$Bm},$o3);
$Dm=q#ni:/lib/doc_define.b#;
$Em=q#ni:/lib/doc_init.b#;
$Fm=q#ni:/lib/doc_namespace.b#;
$Gm=q#ni:/lib/doc_test.b#;
$Hm=q#ni:/lib/documentable.b#;
$Im=q#ni:/lib/fn#;
$Jm={$u,1};
$Km=q#/lib/fn#;
$Lm={};
$Mm=q#shift->compile#;
$Nm=bless({$q,$Mm,$s,$t},$u);
$Om=q#compile#;
$Pm=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Qm=bless({$q,$Pm,$s,$t},$u);
$Rm=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Sm=bless({$q,$Rm,$s,$t},$u);
$Tm={$Om,$Qm,$w4,$Sm};
$Um=q#/lib/fn_init.b#;
$Vm=bless({$D2,$Lm,$u3,$Nm,$w3,$v3,$x3,$Tm,$D,$Um},$G3);
$Wm={};
$Xm=[];
$Ym=q#shift->{'annotations'}#;
$Zm=bless({$o,$Xm,$q,$Ym,$s,$t},$u);
$cn=[];
$dn=q#shift->{'code'}#;
$en=bless({$o,$cn,$q,$dn,$s,$t},$u);
$fn=q#fn#;
$gn=[];
$hn=q#shift->{'fn'}#;
$in=bless({$o,$gn,$q,$hn,$s,$t},$u);
$jn={$o,$Zm,$q,$en,$fn,$in};
$kn=q#/lib/fn_ro.b#;
$ln=bless({$D2,$Wm,$u3,$v3,$w3,$v3,$x3,$jn,$D,$kn},$G3);
$mn={};
$nn=[];
$on=q#shift->{code}#;
$pn=bless({$o,$nn,$q,$on,$s,$t},$u);
$qn=[];
$rn=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$sn=bless({$o,$qn,$q,$rn,$s,$t},$u);
$tn={$P5,$pn,$W5,$sn};
$un=q#/lib/fn_ops.b#;
$vn=bless({$D2,$mn,$u3,$v3,$w3,$v3,$x3,$tn,$D,$un},$G3);
$wn={};
$xn=q#serialize#;
$yn=[];
$zn=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$An=bless({$o,$yn,$q,$zn,$s,$t},$u);
$Bn={$xn,$An};
$Cn=q#/lib/fn_serialize.b#;
$Dn=bless({$D2,$wn,$u3,$v3,$w3,$v3,$x3,$Bn,$D,$Cn},$G3);
$En=[$i5,$A6,$Vm,$ln,$vn,$Dn];
$Fn=bless({$D2,$Jm,$D,$Km,$n3,$En},$X2);
$Gn=q#lib/fn.c::ctors#;
$Hn=q#ni:/lib/fn.c#;
$In={$X2,1};
$Jn=q#/lib/fn.c#;
$Kn=[$T6];
$Ln=bless({$D2,$In,$D,$Jn,$n3,$Kn},$o3);
$Mn=q#ni:/lib/fn_init.b#;
$Nn=q#ni:/lib/fn_ops.b#;
$On=q#ni:/lib/fn_ro.b#;
$Pn=q#ni:/lib/fn_serialize.b#;
$Qn=q#ni:/lib/gensym_generator_compact.b#;
$Rn={};
$Sn=q#gensym#;
$Tn=[];
$Un=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn={$Sn,$Vn};
$Xn=q#/lib/gensym_generator_compact.b#;
$Yn=bless({$D2,$Rn,$u3,$v3,$w3,$v3,$x3,$Wn,$D,$Xn},$G3);
$Zn=q#ni:/lib/global_static_test.b#;
$co={};
$do=q#now#;
$eo=[];
$fo=q#ni('ni:/lib/test_value')->new(shift)#;
$go=q#($)#;
$ho=bless({$o,$eo,$q,$fo,$s,$go},$u);
$io={$do,$ho};
$jo=q#/lib/global_static_test.b#;
$ko=bless({$D2,$co,$u3,$v3,$w3,$v3,$x3,$io,$D,$jo},$G3);
$lo=q#ni:/lib/image#;
$mo={$R4,1};
$no=q#/lib/image#;
$oo={};
$po=[];
$qo=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so={$w4,$ro};
$to=q#/lib/image_init.b#;
$uo=bless({$D2,$oo,$u3,$v3,$w3,$v3,$x3,$so,$D,$to},$G3);
$vo={};
$wo=q#address#;
$xo=[];
$yo=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$zo=bless({$o,$xo,$q,$yo,$s,$t},$u);
$Ao=q#allocate_gensym#;
$Bo=[];
$Co=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Do=bless({$o,$Bo,$q,$Co,$s,$t},$u);
$Eo=q#boot_side_effect#;
$Fo=[];
$Go=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ho=bless({$o,$Fo,$q,$Go,$s,$t},$u);
$Io=q#circular_links#;
$Jo=[];
$Ko=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Lo=bless({$o,$Jo,$q,$Ko,$s,$t},$u);
$Mo=q#finalizer#;
$No=[];
$Oo=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Po=bless({$o,$No,$q,$Oo,$s,$t},$u);
$Qo=q#quote#;
$Ro=[];
$So=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$To=bless({$o,$Ro,$q,$So,$s,$t},$u);
$Uo=q#reconstruction#;
$Vo=[];
$Wo=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Xo=bless({$o,$Vo,$q,$Wo,$s,$t},$u);
$Yo=q#side_effect#;
$Zo=[];
$cp=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$dp=bless({$o,$Zo,$q,$cp,$s,$t},$u);
$ep=[];
$fp=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$gp=bless({$o,$ep,$q,$fp,$s,$t},$u);
$hp={$wo,$zo,$Ao,$Do,$Eo,$Ho,$Io,$Lo,$Mo,$Po,$Qo,$To,$Uo,$Xo,$Yo,$dp,$P9,$gp};
$ip=q#/lib/image_quoting.b#;
$jp=bless({$D2,$vo,$u3,$v3,$w3,$v3,$x3,$hp,$D,$ip},$G3);
$kp={};
$lp=q#quote_code#;
$mp=[];
$np=q#shift->die('cannot quote perl CODE refs', shift)#;
$op=bless({$o,$mp,$q,$np,$s,$t},$u);
$pp={$lp,$op};
$qp=q#/lib/quote_code_fail.b#;
$rp=bless({$D2,$kp,$u3,$v3,$w3,$v3,$x3,$pp,$D,$qp},$G3);
$sp={};
$tp=q#quote_array#;
$up=[];
$vp=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$wp=bless({$o,$up,$q,$vp,$s,$t},$u);
$xp=q#quote_hash#;
$yp=[];
$zp=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Ap=bless({$o,$yp,$q,$zp,$s,$t},$u);
$Bp=q#quote_scalar#;
$Cp=[];
$Dp=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Ep=bless({$o,$Cp,$q,$Dp,$s,$t},$u);
$Fp=q#quote_scalar_ref#;
$Gp=[];
$Hp=q#'\\\\' . shift->quote(${$_[0]})#;
$Ip=bless({$o,$Gp,$q,$Hp,$s,$t},$u);
$Jp=q#quote_value#;
$Kp=[];
$Lp=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Mp=bless({$o,$Kp,$q,$Lp,$s,$t},$u);
$Np={$tp,$wp,$xp,$Ap,$Bp,$Ep,$Fp,$Ip,$Jp,$Mp};
$Op=q#/lib/quote_values.b#;
$Pp=bless({$D2,$sp,$u3,$v3,$w3,$v3,$x3,$Np,$D,$Op},$G3);
$Qp={};
$Rp=q#quote_blessed#;
$Sp=[];
$Tp=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Up=bless({$o,$Sp,$q,$Tp,$s,$t},$u);
$Vp=q#quote_class#;
$Wp=[];
$Xp=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Yp=bless({$o,$Wp,$q,$Xp,$s,$t},$u);
$Zp=q#quote_object#;
$cq=[];
$dq=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$eq=bless({$o,$cq,$q,$dq,$s,$t},$u);
$fq={$Rp,$Up,$Vp,$Yp,$Zp,$eq};
$gq=q#/lib/quote_objects.b#;
$hq=bless({$D2,$Qp,$u3,$v3,$w3,$v3,$x3,$fq,$D,$gq},$G3);
$iq={};
$jq=q#circular_arrayref#;
$kq=[];
$lq=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$mq=bless({$o,$kq,$q,$lq,$s,$t},$u);
$nq=q#circular_hashref#;
$oq=[];
$pq=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$qq=bless({$o,$oq,$q,$pq,$s,$t},$u);
$rq=q#is_circular#;
$sq=[];
$tq=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$uq=bless({$o,$sq,$q,$tq,$s,$t},$u);
$vq={$jq,$mq,$nq,$qq,$rq,$uq};
$wq=q#/lib/quote_circular_addressed.b#;
$xq=bless({$D2,$iq,$u3,$v3,$w3,$v3,$x3,$vq,$D,$wq},$G3);
$yq=[$i5,$uo,$jp,$rp,$Pp,$hq,$xq,$Yn];
$zq=bless({$D2,$mo,$D,$no,$n3,$yq},$Y2);
$Aq=q#lib/image.c::ctors#;
$Bq=q#ni:/lib/image.c#;
$Cq={$Y2,1};
$Dq=q#/lib/image.c#;
$Eq=[$T6];
$Fq=bless({$D2,$Cq,$D,$Dq,$n3,$Eq},$o3);
$Gq=q#ni:/lib/image_init.b#;
$Hq=q#ni:/lib/image_quoting.b#;
$Iq=q#ni:/lib/instance.b#;
$Jq=q#ni:/lib/instantiable.b#;
$Kq=q#ni:/lib/json.b#;
$Lq={};
$Mq=q#json_decode#;
$Nq=[];
$Oq=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Pq=bless({$o,$Nq,$q,$Oq,$s,$go},$u);
$Qq=q#json_encode#;
$Rq=[];
$Sq=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Tq=bless({$o,$Rq,$q,$Sq,$s,$go},$u);
$Uq=q#json_escape#;
$Vq=[];
$Wq=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Xq=bless({$o,$Vq,$q,$Wq,$s,$go},$u);
$Yq=q#json_unescape#;
$Zq=[];
$cr=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$dr=bless({$o,$Zq,$q,$cr,$s,$go},$u);
$er=q#json_unescape_one#;
$fr=[];
$gr=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$hr=bless({$o,$fr,$q,$gr,$s,$go},$u);
$ir={$Mq,$Pq,$Qq,$Tq,$Uq,$Xq,$Yq,$dr,$er,$hr};
$jr=q#/lib/json.b#;
$kr=bless({$D2,$Lq,$u3,$v3,$w3,$v3,$x3,$ir,$D,$jr},$G3);
$lr=q#ni#;
$mr=q#ni:/lib/name_as_string.b#;
$nr=q#ni:/lib/named.b#;
$or=q#ni:/lib/named_in_ni.b#;
$pr=q#ni:/lib/namespaced.b#;
$qr=q#ni:/lib/ni#;
$rr={$S4,1};
$sr=q#/lib/ni#;
$tr={};
$ur=q#extend#;
$vr=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$wr=bless({$q,$vr,$s,$t},$u);
$xr=q#is_mutable#;
$yr=q#$0 ne "-" && -w $0#;
$zr=bless({$q,$yr,$s,$t},$u);
$Ar=q#modify#;
$Br=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Cr=bless({$q,$Br,$s,$t},$u);
$Dr={$ur,$wr,$xr,$zr,$Ar,$Cr};
$Er=q#/lib/ni_self.b#;
$Fr=bless({$D2,$tr,$u3,$v3,$w3,$v3,$x3,$Dr,$D,$Er},$G3);
$Gr={};
$Hr=q#--internal/+=#;
$Ir=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Jr=bless({$q,$Ir,$s,$t},$u);
$Kr=q#--internal/eval#;
$Lr=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Mr=bless({$q,$Lr,$s,$t},$u);
$Nr=q#--internal/image#;
$Or=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Pr=bless({$q,$Or,$s,$t},$u);
$Qr=q#--internal/test#;
$Rr=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Sr=bless({$q,$Rr,$s,$t},$u);
$Tr=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Ur=bless({$q,$Tr,$s,$t},$u);
$Vr={$Hr,$Jr,$Kr,$Mr,$Nr,$Pr,$Qr,$Sr,$xk,$Ur};
$Wr=q#/lib/ni_main.b#;
$Xr=bless({$D2,$Gr,$u3,$v3,$w3,$v3,$x3,$Vr,$D,$Wr},$G3);
$Yr={};
$Zr=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$cs=bless({$q,$Zr,$s,$t},$u);
$ds=q#resolver_for#;
$es=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$fs=bless({$q,$es,$s,$t},$u);
$gs={$k4,$cs,$ds,$fs};
$hs=q#/lib/ni_resolver.b#;
$is=bless({$D2,$Yr,$u3,$v3,$w3,$v3,$x3,$gs,$D,$hs},$G3);
$js={};
$ks=q#exists#;
$ls=q#exists $_[0]->{named}{$_[1]}#;
$ms=bless({$q,$ls,$s,$t},$u);
$ns=q#quoted#;
$os=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$ps=bless({$q,$os,$s,$t},$u);
$qs={$ks,$ms,$ns,$ps};
$rs=q#/lib/ni_image.b#;
$ss=bless({$D2,$js,$u3,$v3,$w3,$v3,$x3,$qs,$D,$rs},$G3);
$ts=[$i5,$Fr,$Xr,$is,$ss];
$us=bless({$D2,$rr,$D,$sr,$n3,$ts},$Z2);
$vs=q#lib/ni.c::ctors#;
$ws=q#ni:/lib/ni.c#;
$xs={$Z2,1};
$ys=q#/lib/ni.c#;
$zs=[$T6];
$As=bless({$D2,$xs,$D,$ys,$n3,$zs},$o3);
$Bs=q#ni:/lib/ni_image.b#;
$Cs=q#ni:/lib/ni_main.b#;
$Ds=q#ni:/lib/ni_resolver.b#;
$Es=q#ni:/lib/ni_self.b#;
$Fs=q#ni:/lib/ni_static_util.b#;
$Gs={};
$Hs=q#abbrev#;
$Is=[];
$Js=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Ks=bless({$o,$Is,$q,$Js,$s,$t},$u);
$Ls=q#dor#;
$Ms=[];
$Ns=q#defined $_[0] ? $_[0] : $_[1]#;
$Os=bless({$o,$Ms,$q,$Ns,$s,$t},$u);
$Ps=q#indent#;
$Qs=[];
$Rs=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Ss=bless({$o,$Qs,$q,$Rs,$s,$t},$u);
$Ts=q#max#;
$Us=[];
$Vs=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Ws=bless({$o,$Us,$q,$Vs,$s,$t},$u);
$Xs=q#maxstr#;
$Ys=[];
$Zs=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$ct=bless({$o,$Ys,$q,$Zs,$s,$t},$u);
$dt=q#mean#;
$et=[];
$ft=q#sum(@_) / (@_ || 1)#;
$gt=bless({$o,$et,$q,$ft,$s,$t},$u);
$ht=q#min#;
$it=[];
$jt=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$kt=bless({$o,$it,$q,$jt,$s,$t},$u);
$lt=q#minstr#;
$mt=[];
$nt=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$ot=bless({$o,$mt,$q,$nt,$s,$t},$u);
$pt=q#sgr#;
$qt=[];
$rt=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$st=bless({$o,$qt,$q,$rt,$s,$t},$u);
$tt=q#sr#;
$ut=[];
$vt=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$wt=bless({$o,$ut,$q,$vt,$s,$t},$u);
$xt=q#sum#;
$yt=[];
$zt=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$At=bless({$o,$yt,$q,$zt,$s,$t},$u);
$Bt=q#swap#;
$Ct=[];
$Dt=q#@_[0, 1] = @_[1, 0]#;
$Et=bless({$o,$Ct,$q,$Dt,$s,$t},$u);
$Ft={$Hs,$Ks,$Ls,$Os,$Ps,$Ss,$Ts,$Ws,$Xs,$ct,$dt,$gt,$ht,$kt,$lt,$ot,$pt,$st,$tt,$wt,$xt,$At,$Bt,$Et};
$Gt=q#/lib/ni_static_util.b#;
$Ht=bless({$D2,$Gs,$u3,$v3,$w3,$v3,$x3,$Ft,$D,$Gt},$G3);
$It=q#ni:/lib/perlbranch.b#;
$Jt=q#ni:/lib/quote_circular_addressed.b#;
$Kt=q#ni:/lib/quote_code_fail.b#;
$Lt=q#ni:/lib/quote_objects.b#;
$Mt=q#ni:/lib/quote_simple#;
$Nt={$T4,1};
$Ot=q#/lib/quote_simple#;
$Pt={};
$Qt=[];
$Rt=q#+{}#;
$St=bless({$o,$Qt,$q,$Rt,$s,$t},$u);
$Tt={$w4,$St};
$Ut=q#/lib/quote_simple_init.b#;
$Vt=bless({$D2,$Pt,$u3,$v3,$w3,$v3,$x3,$Tt,$D,$Ut},$G3);
$Wt={};
$Xt=[];
$Yt=bless({$o,$Xt,$q,0,$s,$t},$u);
$Zt=[];
$cu=q#shift->quote_value(shift)#;
$du=bless({$o,$Zt,$q,$cu,$s,$t},$u);
$eu={$rq,$Yt,$Qo,$du};
$fu=q#/lib/quote_simple_quote.b#;
$gu=bless({$D2,$Wt,$u3,$v3,$w3,$v3,$x3,$eu,$D,$fu},$G3);
$hu=[$i5,$Vt,$gu,$rp,$Pp,$hq];
$iu=bless({$D2,$Nt,$D,$Ot,$n3,$hu},$c3);
$ju=q#lib/quote_simple.c::ctors#;
$ku=q#ni:/lib/quote_simple.c#;
$lu={$c3,1};
$mu=q#/lib/quote_simple.c#;
$nu=[$T6];
$ou=bless({$D2,$lu,$D,$mu,$n3,$nu},$o3);
$pu=q#ni:/lib/quote_simple_init.b#;
$qu=q#ni:/lib/quote_simple_quote.b#;
$ru=q#ni:/lib/quote_values.b#;
$su=q#ni:/lib/ref_eq.b#;
$tu=q#ni:/lib/resolver.b#;
$uu=q#ni:/lib/slice#;
$vu={$G3,1};
$wu=q#/lib/slice#;
$xu=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$yu=bless({$q,$xu,$s,$t},$u);
$zu=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Au=bless({$q,$zu,$s,$t},$u);
$Bu=q#lib/slice::apply#;
$Cu=q#lib/slice::apply_unsafe#;
$Du={};
$Eu=q#apply_unsafe#;
$Fu={$B3,$yu,$Eu,$Au};
$Gu=q#/lib/slice.b#;
$Hu=bless({$D2,$Du,$x3,$Fu,$D,$Gu},$G3);
$Iu={};
$Ju=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Ku=bless({$q,$Ju,$s,$t},$u);
$Lu={$w4,$Ku};
$Mu=q#/lib/slice_init.b#;
$Nu=bless({$D2,$Iu,$x3,$Lu,$D,$Mu},$G3);
$Ou={};
$Pu=[];
$Qu=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Ru=bless({$o,$Pu,$q,$Qu,$s,$t},$u);
$Su={$xn,$Ru};
$Tu=q#/lib/slice_serialize.b#;
$Uu=bless({$D2,$Ou,$u3,$v3,$w3,$v3,$x3,$Su,$D,$Tu},$G3);
$Vu=[$t5,$R3,$Hu,$Nu,$Uu];
$Wu=bless({$D2,$vu,$D,$wu,$n3,$Vu},$d3);
$Xu=q#lib/slice.c::ctors#;
$Yu=q#ni:/lib/slice.b#;
$Zu=q#ni:/lib/slice.c#;
$cv={$d3,1};
$dv=q#/lib/slice.c#;
$ev=[$Y6];
$fv=bless({$D2,$cv,$D,$dv,$n3,$ev},$o3);
$gv=q#ni:/lib/slice_init.b#;
$hv=q#ni:/lib/slice_serialize.b#;
$iv=q#ni:/lib/static_fn.b#;
$jv={};
$kv=[];
$lv=q#ni('ni:/lib/fn')->new(@_)#;
$mv=bless({$o,$kv,$q,$lv,$s,$go},$u);
$nv=q#fp#;
$ov=[];
$pv=q#($$)#;
$qv=bless({$o,$ov,$q,$lv,$s,$pv},$u);
$rv={$fn,$mv,$nv,$qv};
$sv=q#/lib/static_fn.b#;
$tv=bless({$D2,$jv,$u3,$v3,$w3,$v3,$x3,$rv,$D,$sv},$G3);
$uv=q#ni:/lib/subclass.b#;
$vv=q#ni:/lib/tag#;
$wv={$S3,1};
$xv=q#/lib/tag#;
$yv={};
$zv=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Av=bless({$q,$zv,$s,$t},$u);
$Bv={$B3,$Av};
$Cv=q#/lib/tag.b#;
$Dv=bless({$D2,$yv,$u3,$v3,$w3,$v3,$x3,$Bv,$D,$Cv},$G3);
$Ev={};
$Fv=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Gv=bless({$q,$Fv,$s,$t},$u);
$Hv={$w4,$Gv};
$Iv=q#/lib/tag_init.b#;
$Jv=bless({$D2,$Ev,$u3,$v3,$w3,$v3,$x3,$Hv,$D,$Iv},$G3);
$Kv=[$t5,$R3,$Dv,$Jv];
$Lv=bless({$D2,$wv,$D,$xv,$n3,$Kv},$e3);
$Mv=q#lib/tag.c::ctors#;
$Nv=q#ni:/lib/tag.b#;
$Ov=q#ni:/lib/tag.c#;
$Pv={$e3,1};
$Qv=q#/lib/tag.c#;
$Rv=[$Y6];
$Sv=bless({$D2,$Pv,$D,$Qv,$n3,$Rv},$o3);
$Tv=q#ni:/lib/tag_init.b#;
$Uv=q#ni:/lib/test_value#;
$Vv={$U4,1};
$Wv=q#/lib/test_value#;
$Xv={};
$Yv=[];
$Zv=q#\\$_[1]#;
$cw=bless({$o,$Yv,$q,$Zv,$s,$t},$u);
$dw={$w4,$cw};
$ew=q#/lib/test_value_init.b#;
$fw=bless({$D2,$Xv,$u3,$v3,$w3,$v3,$x3,$dw,$D,$ew},$G3);
$gw={};
$hw=q#(==#;
$iw=[];
$jw=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$kw=bless({$o,$iw,$q,$jw,$s,$t},$u);
$lw=q#diff#;
$mw=[];
$nw=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$ow=bless({$o,$mw,$q,$nw,$s,$t},$u);
$pw={$hw,$kw,$lw,$ow};
$qw=q#/lib/test_value_eq.b#;
$rw=bless({$D2,$gw,$u3,$v3,$w3,$v3,$x3,$pw,$D,$qw},$G3);
$sw={};
$tw=[];
$uw=q#ni::json_encode ${$_[0]}#;
$vw=bless({$o,$tw,$q,$uw,$s,$t},$u);
$ww={$P5,$vw};
$xw=q#/lib/test_value_str.b#;
$yw=bless({$D2,$sw,$u3,$v3,$w3,$v3,$x3,$ww,$D,$xw},$G3);
$zw=[$i5,$fw,$rw,$yw];
$Aw=bless({$D2,$Vv,$D,$Wv,$n3,$zw},$f3);
$Bw=q#lib/test_value.c::ctors#;
$Cw=q#ni:/lib/test_value.c#;
$Dw={$f3,1};
$Ew=q#/lib/test_value.c#;
$Fw=[$T6];
$Gw=bless({$D2,$Dw,$D,$Ew,$n3,$Fw},$o3);
$Hw=q#ni:/lib/test_value_eq.b#;
$Iw=q#ni:/lib/test_value_init.b#;
$Jw=q#ni:/lib/test_value_str.b#;
$Kw=q#ni:/metaclass#;
$Lw={$o3,1};
$Mw=q#/metaclass#;
$Nw=[$r4,$A6,$B4,$p6];
$Ow=bless({$D2,$Lw,$D,$Mw,$n3,$Nw},$g3);
$Pw=q#metaclass.c::ctors#;
$Qw=q#ni:/metaclass.c#;
$Rw={$g3,1};
$Sw=q#/metaclass.c#;
$Tw=[$J6];
$Uw=bless({$D2,$Rw,$D,$Sw,$n3,$Tw},$o3);
$Vw=q#ni:/module#;
$Ww=q#ni:/module.c#;
$Xw=q#ni:/object#;
$Yw=q#ni:/object.c#;
$Zw=q#ni:/semantic/dimension#;
$cx={$j3,1};
$dx=q#/semantic/dimension#;
$ex=[$J6];
$fx=bless({$D2,$cx,$D,$dx,$n3,$ex},$k3);
$gx=q#semantic/dimension.c::ctors#;
$hx=q#ni:/semantic/dimension.c#;
$ix={$k3,1};
$jx=q#/semantic/dimension.c#;
$kx=[$e7];
$lx=bless({$D2,$ix,$D,$jx,$n3,$kx},$o3);
$mx=q#ni:/semantic/task#;
$nx=q#ni:/semantic/task.c#;
$ox=q#ni:/semantic/task_outcome.b#;
$px=q#ni:/semantic/task_ro.b#;
$qx=q#ni:main#;
$rx={$Hf,1};
$sx=[$tv,$ko,$Gf];
$tx=bless({$D2,$rx,$D,$Hf,$n3,$sx},$p3);
$ux=q#module::ctors#;
$vx=q#ni:ni#;
$wx={$lr,1};
$xx={$lr,1};
$yx=q#json_escapes#;
$zx=q##;
$Ax=q#b#;
$Bx=q#	#;
$Cx=q#t#;
$Dx=q#
#;
$Ex=q#n#;
$Fx=q##;
$Gx=q#"#;
$Hx=q#/#;
$Ix=q#\\#;
$Jx={$zx,$Ax,$Bx,$Cx,$Dx,$Ex,$Fx,$Ie,$Gx,$Gx,$Hx,$Hx,$Ix,$Ix};
$Kx=q#json_unescapes#;
$Lx={$Gx,$Gx,$Hx,$Hx,$Ix,$Ix,$Ax,$zx,$Ex,$Dx,$Ie,$Fx,$Cx,$Bx};
$Mx={$yx,$Jx,$Kx,$Lx};
$Nx=q#/lib/json_data.b#;
$Ox=bless({$D2,$xx,$di,$Mx,$D,$Nx},$Q4);
$Px=q#lib/dataslice::ctors#;
$Qx=[$Ox,$kr,$Ht];
$Rx=bless({$D2,$wx,$D,$lr,$n3,$Qx},$p3);
$Sx={$d,$G,$I,$N,$O,$V,$W,$d1,$e1,$j1,$k1,$v1,$w1,$H1,$I1,$X1,$Y1,$f2,$g2,$v2,$w2,$B2,$C2,$J6,$L6,$e7,$f7,$T8,$V8,$f9,$g9,$F8,$h9,$R8,$i9,$y8,$j9,$u9,$w9,$A9,$B9,$s9,$C9,$W9,$Y9,$ea,$fa,$K9,$ga,$U9,$ha,$ya,$Aa,$Ea,$Fa,$pa,$Ga,$wa,$Ha,$tc,$vc,$zc,$Ac,$Zb,$Bc,$rc,$Cc,$Xa,$Dc,$Rb,$Ec,$tb,$Fc,$Qa,$Gc,$Td,$Vd,$Zd,$ce,$wd,$de,$Hd,$ee,$Wc,$fe,$Rd,$ge,$Pc,$he,$gd,$ie,$cf,$ef,$if,$jf,$ze,$kf,$Ge,$lf,$Ye,$mf,$re,$nf,$Gf,$If,$ig,$kg,$og,$pg,$Rf,$qg,$gg,$rg,$l8,$sg,$d9,$tg,$J7,$ug,$R7,$vg,$Z7,$wg,$p7,$xg,$j8,$yg,$Lh,$Nh,$Rh,$Sh,$Jh,$Th,$Vg,$Uh,$th,$Vh,$Lg,$Wh,$jh,$Xh,$Oi,$Qi,$Ui,$Vi,$yi,$Wi,$Mi,$Xi,$ri,$Yi,$Qj,$Sj,$jk,$kk,$hk,$lk,$Oj,$mk,$Fk,$Hk,$Lk,$Mk,$vk,$Nk,$Dk,$Ok,$N5,$Pk,$t5,$Qk,$Y6,$Rk,$dl,$fl,$H3,$gl,$kl,$ll,$Zk,$ml,$B4,$nl,$Dl,$Fl,$Jl,$Kl,$Bl,$Ll,$vl,$Ml,$m6,$Nl,$D5,$Ol,$k6,$Pl,$wm,$ym,$Cm,$Dm,$lm,$Em,$Wl,$Fm,$em,$Gm,$um,$Hm,$r5,$Im,$Fn,$Hn,$Ln,$Mn,$Vm,$Nn,$vn,$On,$ln,$Pn,$Dn,$Qn,$Yn,$Zn,$ko,$lo,$zq,$Bq,$Fq,$Gq,$uo,$Hq,$jp,$Iq,$g5,$Jq,$A6,$Kq,$kr,$mr,$U5,$nr,$R3,$or,$Z3,$pr,$i4,$qr,$us,$ws,$As,$Bs,$ss,$Cs,$Xr,$Ds,$is,$Es,$Fr,$Fs,$Ht,$It,$r4,$Jt,$xq,$Kt,$rp,$Lt,$hq,$Mt,$iu,$ku,$ou,$pu,$Vt,$qu,$gu,$ru,$Pp,$su,$d6,$tu,$p4,$uu,$Wu,$Yu,$Hu,$Zu,$fv,$gv,$Nu,$hv,$Uu,$iv,$tv,$uv,$H6,$vv,$Lv,$Nv,$Dv,$Ov,$Sv,$Tv,$Jv,$Uv,$Aw,$Cw,$Gw,$Hw,$rw,$Iw,$fw,$Jw,$yw,$Kw,$Ow,$Qw,$Uw,$Vw,$p6,$Ww,$c7,$Xw,$i5,$Yw,$T6,$Zw,$fx,$hx,$lx,$mx,$Aj,$nx,$Yj,$ox,$yj,$px,$mj,$qx,$tx,$vx,$Rx};
$Tx=q#resolvers#;
$Ux=[];
$Vx=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Wx=bless({$o,$Ux,$q,$Vx,$s,$t},$u);
$Xx=q#file#;
$Yx=[];
$Zx=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$cy=bless({$o,$Yx,$q,$Zx,$s,$t},$u);
$dy=q#null#;
$ey=[];
$fy=q#ni('ni:/io/null')->new#;
$gy=bless({$o,$ey,$q,$fy,$s,$t},$u);
$hy=q#sh#;
$iy=[];
$jy=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$ky=bless({$o,$iy,$q,$jy,$s,$t},$u);
$ly=q#str#;
$my=[];
$ny=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$oy=bless({$o,$my,$q,$ny,$s,$t},$u);
$py={$zb,$Wx,$Xx,$cy,$dy,$gy,$hy,$ky,$ly,$oy};
$qy=bless({$c,$Sx,$Tx,$py},$S4);
$ry=q#lib/ni::ctors#;
*$Cu=\&$Au;
*$Bu=\&$yu;
$H3->apply_unsafe($E2);
$H3->apply_unsafe($F2);
$H3->apply_unsafe($G2);
$H3->apply_unsafe($H2);
$H3->apply_unsafe($I2);
$H3->apply_unsafe($J2);
$H3->apply_unsafe($K2);
$H3->apply_unsafe($L2);
$H3->apply_unsafe($M2);
$H3->apply_unsafe($N2);
$H3->apply_unsafe($O2);
$H3->apply_unsafe($P2);
$H3->apply_unsafe($Q2);
$H3->apply_unsafe($R2);
$H3->apply_unsafe($S2);
$H3->apply_unsafe($T2);
$H3->apply_unsafe($I3);
$H3->apply_unsafe($U2);
$H3->apply_unsafe($V2);
$H3->apply_unsafe($W2);
$H3->apply_unsafe($X2);
$H3->apply_unsafe($Y2);
$H3->apply_unsafe($Z2);
$H3->apply_unsafe($c3);
$H3->apply_unsafe($d3);
$H3->apply_unsafe($e3);
$H3->apply_unsafe($f3);
$H3->apply_unsafe($o3);
$H3->apply_unsafe($g3);
$H3->apply_unsafe($p3);
$H3->apply_unsafe($h3);
$H3->apply_unsafe($i3);
$H3->apply_unsafe($j3);
$H3->apply_unsafe($k3);
$H3->apply_unsafe($l3);
$R3->apply_unsafe($E2);
$R3->apply_unsafe($F2);
$R3->apply_unsafe($G2);
$R3->apply_unsafe($H2);
$R3->apply_unsafe($I2);
$R3->apply_unsafe($J2);
$R3->apply_unsafe($K2);
$R3->apply_unsafe($L2);
$R3->apply_unsafe($M2);
$R3->apply_unsafe($N2);
$R3->apply_unsafe($O2);
$R3->apply_unsafe($P2);
$R3->apply_unsafe($Q2);
$R3->apply_unsafe($R2);
$R3->apply_unsafe($S2);
$R3->apply_unsafe($T2);
$R3->apply_unsafe($I3);
$R3->apply_unsafe($U2);
$R3->apply_unsafe($V2);
$R3->apply_unsafe($F);
$R3->apply_unsafe($W2);
$R3->apply_unsafe($X2);
$R3->apply_unsafe($Y2);
$R3->apply_unsafe($Z2);
$R3->apply_unsafe($c3);
$R3->apply_unsafe($G3);
$R3->apply_unsafe($d3);
$R3->apply_unsafe($S3);
$R3->apply_unsafe($e3);
$R3->apply_unsafe($f3);
$R3->apply_unsafe($o3);
$R3->apply_unsafe($g3);
$R3->apply_unsafe($p3);
$R3->apply_unsafe($h3);
$R3->apply_unsafe($i3);
$R3->apply_unsafe($j3);
$R3->apply_unsafe($k3);
$R3->apply_unsafe($l3);
$Z3->apply_unsafe($E2);
$Z3->apply_unsafe($F2);
$Z3->apply_unsafe($G2);
$Z3->apply_unsafe($H2);
$Z3->apply_unsafe($I2);
$Z3->apply_unsafe($J2);
$Z3->apply_unsafe($K2);
$Z3->apply_unsafe($L2);
$Z3->apply_unsafe($M2);
$Z3->apply_unsafe($N2);
$Z3->apply_unsafe($O2);
$Z3->apply_unsafe($P2);
$Z3->apply_unsafe($Q2);
$Z3->apply_unsafe($R2);
$Z3->apply_unsafe($S2);
$Z3->apply_unsafe($T2);
$Z3->apply_unsafe($I3);
$Z3->apply_unsafe($U2);
$Z3->apply_unsafe($V2);
$Z3->apply_unsafe($W2);
$Z3->apply_unsafe($X2);
$Z3->apply_unsafe($Y2);
$Z3->apply_unsafe($Z2);
$Z3->apply_unsafe($c3);
$Z3->apply_unsafe($G3);
$Z3->apply_unsafe($d3);
$Z3->apply_unsafe($S3);
$Z3->apply_unsafe($e3);
$Z3->apply_unsafe($f3);
$Z3->apply_unsafe($o3);
$Z3->apply_unsafe($g3);
$Z3->apply_unsafe($p3);
$Z3->apply_unsafe($h3);
$Z3->apply_unsafe($i3);
$Z3->apply_unsafe($j3);
$Z3->apply_unsafe($k3);
$Z3->apply_unsafe($l3);
$i4->apply_unsafe($E2);
$i4->apply_unsafe($F2);
$i4->apply_unsafe($G2);
$i4->apply_unsafe($H2);
$i4->apply_unsafe($I2);
$i4->apply_unsafe($J2);
$i4->apply_unsafe($K2);
$i4->apply_unsafe($L2);
$i4->apply_unsafe($M2);
$i4->apply_unsafe($N2);
$i4->apply_unsafe($O2);
$i4->apply_unsafe($P2);
$i4->apply_unsafe($Q2);
$i4->apply_unsafe($R2);
$i4->apply_unsafe($S2);
$i4->apply_unsafe($T2);
$i4->apply_unsafe($I3);
$i4->apply_unsafe($U2);
$i4->apply_unsafe($V2);
$i4->apply_unsafe($W2);
$i4->apply_unsafe($X2);
$i4->apply_unsafe($Y2);
$i4->apply_unsafe($Z2);
$i4->apply_unsafe($c3);
$i4->apply_unsafe($G3);
$i4->apply_unsafe($d3);
$i4->apply_unsafe($S3);
$i4->apply_unsafe($e3);
$i4->apply_unsafe($f3);
$i4->apply_unsafe($o3);
$i4->apply_unsafe($g3);
$i4->apply_unsafe($p3);
$i4->apply_unsafe($h3);
$i4->apply_unsafe($i3);
$i4->apply_unsafe($j3);
$i4->apply_unsafe($k3);
$i4->apply_unsafe($l3);
$p4->apply_unsafe($E2);
$p4->apply_unsafe($F2);
$p4->apply_unsafe($G2);
$p4->apply_unsafe($H2);
$p4->apply_unsafe($I2);
$p4->apply_unsafe($J2);
$p4->apply_unsafe($K2);
$p4->apply_unsafe($L2);
$p4->apply_unsafe($M2);
$p4->apply_unsafe($N2);
$p4->apply_unsafe($O2);
$p4->apply_unsafe($P2);
$p4->apply_unsafe($Q2);
$p4->apply_unsafe($R2);
$p4->apply_unsafe($S2);
$p4->apply_unsafe($T2);
$p4->apply_unsafe($I3);
$p4->apply_unsafe($U2);
$p4->apply_unsafe($V2);
$p4->apply_unsafe($W2);
$p4->apply_unsafe($X2);
$p4->apply_unsafe($Y2);
$p4->apply_unsafe($Z2);
$p4->apply_unsafe($c3);
$p4->apply_unsafe($d3);
$p4->apply_unsafe($S3);
$p4->apply_unsafe($e3);
$p4->apply_unsafe($f3);
$p4->apply_unsafe($o3);
$p4->apply_unsafe($g3);
$p4->apply_unsafe($p3);
$p4->apply_unsafe($h3);
$p4->apply_unsafe($i3);
$p4->apply_unsafe($j3);
$p4->apply_unsafe($k3);
$p4->apply_unsafe($l3);
$B4->apply_unsafe($E2);
$B4->apply_unsafe($F2);
$B4->apply_unsafe($G2);
$B4->apply_unsafe($H2);
$B4->apply_unsafe($I2);
$B4->apply_unsafe($J2);
$B4->apply_unsafe($K2);
$B4->apply_unsafe($L2);
$B4->apply_unsafe($M2);
$B4->apply_unsafe($N2);
$B4->apply_unsafe($O2);
$B4->apply_unsafe($P2);
$B4->apply_unsafe($Q2);
$B4->apply_unsafe($R2);
$B4->apply_unsafe($S2);
$B4->apply_unsafe($T2);
$B4->apply_unsafe($U2);
$B4->apply_unsafe($V2);
$B4->apply_unsafe($W2);
$B4->apply_unsafe($X2);
$B4->apply_unsafe($Y2);
$B4->apply_unsafe($Z2);
$B4->apply_unsafe($c3);
$B4->apply_unsafe($d3);
$B4->apply_unsafe($e3);
$B4->apply_unsafe($f3);
$B4->apply_unsafe($o3);
$B4->apply_unsafe($g3);
$B4->apply_unsafe($p3);
$B4->apply_unsafe($h3);
$B4->apply_unsafe($i3);
$B4->apply_unsafe($j3);
$B4->apply_unsafe($k3);
$B4->apply_unsafe($l3);
$g5->apply_unsafe($E2);
$g5->apply_unsafe($F2);
$g5->apply_unsafe($C4);
$g5->apply_unsafe($G2);
$g5->apply_unsafe($D4);
$g5->apply_unsafe($H2);
$g5->apply_unsafe($E4);
$g5->apply_unsafe($I2);
$g5->apply_unsafe($F4);
$g5->apply_unsafe($J2);
$g5->apply_unsafe($G4);
$g5->apply_unsafe($K2);
$g5->apply_unsafe($H4);
$g5->apply_unsafe($L2);
$g5->apply_unsafe($I4);
$g5->apply_unsafe($M2);
$g5->apply_unsafe($J4);
$g5->apply_unsafe($N2);
$g5->apply_unsafe($K4);
$g5->apply_unsafe($O2);
$g5->apply_unsafe($L4);
$g5->apply_unsafe($P2);
$g5->apply_unsafe($M4);
$g5->apply_unsafe($Q2);
$g5->apply_unsafe($N4);
$g5->apply_unsafe($R2);
$g5->apply_unsafe($O4);
$g5->apply_unsafe($S2);
$g5->apply_unsafe($P4);
$g5->apply_unsafe($T2);
$g5->apply_unsafe($I3);
$g5->apply_unsafe($U2);
$g5->apply_unsafe($Q4);
$g5->apply_unsafe($V2);
$g5->apply_unsafe($F);
$g5->apply_unsafe($W2);
$g5->apply_unsafe($u);
$g5->apply_unsafe($X2);
$g5->apply_unsafe($R4);
$g5->apply_unsafe($Y2);
$g5->apply_unsafe($S4);
$g5->apply_unsafe($Z2);
$g5->apply_unsafe($T4);
$g5->apply_unsafe($c3);
$g5->apply_unsafe($G3);
$g5->apply_unsafe($d3);
$g5->apply_unsafe($S3);
$g5->apply_unsafe($e3);
$g5->apply_unsafe($U4);
$g5->apply_unsafe($f3);
$g5->apply_unsafe($o3);
$g5->apply_unsafe($g3);
$g5->apply_unsafe($p3);
$g5->apply_unsafe($h3);
$g5->apply_unsafe($V4);
$g5->apply_unsafe($i3);
$g5->apply_unsafe($j3);
$g5->apply_unsafe($k3);
$g5->apply_unsafe($W4);
$g5->apply_unsafe($l3);
$r5->apply_unsafe($E2);
$r5->apply_unsafe($F2);
$r5->apply_unsafe($G2);
$r5->apply_unsafe($H2);
$r5->apply_unsafe($I2);
$r5->apply_unsafe($J2);
$r5->apply_unsafe($K2);
$r5->apply_unsafe($L2);
$r5->apply_unsafe($M2);
$r5->apply_unsafe($N2);
$r5->apply_unsafe($O2);
$r5->apply_unsafe($P2);
$r5->apply_unsafe($Q2);
$r5->apply_unsafe($R2);
$r5->apply_unsafe($S2);
$r5->apply_unsafe($P4);
$r5->apply_unsafe($T2);
$r5->apply_unsafe($I3);
$r5->apply_unsafe($U2);
$r5->apply_unsafe($Q4);
$r5->apply_unsafe($V2);
$r5->apply_unsafe($W2);
$r5->apply_unsafe($X2);
$r5->apply_unsafe($Y2);
$r5->apply_unsafe($Z2);
$r5->apply_unsafe($c3);
$r5->apply_unsafe($G3);
$r5->apply_unsafe($d3);
$r5->apply_unsafe($S3);
$r5->apply_unsafe($e3);
$r5->apply_unsafe($f3);
$r5->apply_unsafe($o3);
$r5->apply_unsafe($g3);
$r5->apply_unsafe($p3);
$r5->apply_unsafe($h3);
$r5->apply_unsafe($i3);
$r5->apply_unsafe($j3);
$r5->apply_unsafe($k3);
$r5->apply_unsafe($l3);
$D5->apply_unsafe($E2);
$D5->apply_unsafe($F2);
$D5->apply_unsafe($G2);
$D5->apply_unsafe($H2);
$D5->apply_unsafe($I2);
$D5->apply_unsafe($J2);
$D5->apply_unsafe($K2);
$D5->apply_unsafe($L2);
$D5->apply_unsafe($M2);
$D5->apply_unsafe($N2);
$D5->apply_unsafe($O2);
$D5->apply_unsafe($P2);
$D5->apply_unsafe($Q2);
$D5->apply_unsafe($R2);
$D5->apply_unsafe($S2);
$D5->apply_unsafe($T2);
$D5->apply_unsafe($I3);
$D5->apply_unsafe($U2);
$D5->apply_unsafe($V2);
$D5->apply_unsafe($W2);
$D5->apply_unsafe($X2);
$D5->apply_unsafe($Y2);
$D5->apply_unsafe($Z2);
$D5->apply_unsafe($c3);
$D5->apply_unsafe($d3);
$D5->apply_unsafe($e3);
$D5->apply_unsafe($f3);
$D5->apply_unsafe($o3);
$D5->apply_unsafe($g3);
$D5->apply_unsafe($p3);
$D5->apply_unsafe($h3);
$D5->apply_unsafe($i3);
$D5->apply_unsafe($j3);
$D5->apply_unsafe($k3);
$D5->apply_unsafe($l3);
$N5->apply_unsafe($E2);
$N5->apply_unsafe($F2);
$N5->apply_unsafe($G2);
$N5->apply_unsafe($H2);
$N5->apply_unsafe($I2);
$N5->apply_unsafe($J2);
$N5->apply_unsafe($K2);
$N5->apply_unsafe($L2);
$N5->apply_unsafe($M2);
$N5->apply_unsafe($N2);
$N5->apply_unsafe($O2);
$N5->apply_unsafe($P2);
$N5->apply_unsafe($Q2);
$N5->apply_unsafe($R2);
$N5->apply_unsafe($S2);
$N5->apply_unsafe($T2);
$N5->apply_unsafe($I3);
$N5->apply_unsafe($U2);
$N5->apply_unsafe($V2);
$N5->apply_unsafe($W2);
$N5->apply_unsafe($X2);
$N5->apply_unsafe($Y2);
$N5->apply_unsafe($Z2);
$N5->apply_unsafe($c3);
$N5->apply_unsafe($d3);
$N5->apply_unsafe($e3);
$N5->apply_unsafe($f3);
$N5->apply_unsafe($o3);
$N5->apply_unsafe($g3);
$N5->apply_unsafe($p3);
$N5->apply_unsafe($h3);
$N5->apply_unsafe($i3);
$N5->apply_unsafe($j3);
$N5->apply_unsafe($k3);
$N5->apply_unsafe($l3);
$U5->apply_unsafe($E2);
$U5->apply_unsafe($F2);
$U5->apply_unsafe($G2);
$U5->apply_unsafe($H2);
$U5->apply_unsafe($I2);
$U5->apply_unsafe($J2);
$U5->apply_unsafe($K2);
$U5->apply_unsafe($L2);
$U5->apply_unsafe($M2);
$U5->apply_unsafe($N2);
$U5->apply_unsafe($O2);
$U5->apply_unsafe($P2);
$U5->apply_unsafe($Q2);
$U5->apply_unsafe($R2);
$U5->apply_unsafe($S2);
$U5->apply_unsafe($T2);
$U5->apply_unsafe($I3);
$U5->apply_unsafe($U2);
$U5->apply_unsafe($V2);
$U5->apply_unsafe($W2);
$U5->apply_unsafe($X2);
$U5->apply_unsafe($Y2);
$U5->apply_unsafe($Z2);
$U5->apply_unsafe($c3);
$U5->apply_unsafe($d3);
$U5->apply_unsafe($e3);
$U5->apply_unsafe($f3);
$U5->apply_unsafe($o3);
$U5->apply_unsafe($g3);
$U5->apply_unsafe($p3);
$U5->apply_unsafe($h3);
$U5->apply_unsafe($i3);
$U5->apply_unsafe($j3);
$U5->apply_unsafe($k3);
$U5->apply_unsafe($l3);
$d6->apply_unsafe($E2);
$d6->apply_unsafe($F2);
$d6->apply_unsafe($G2);
$d6->apply_unsafe($H2);
$d6->apply_unsafe($I2);
$d6->apply_unsafe($J2);
$d6->apply_unsafe($K2);
$d6->apply_unsafe($L2);
$d6->apply_unsafe($M2);
$d6->apply_unsafe($N2);
$d6->apply_unsafe($O2);
$d6->apply_unsafe($P2);
$d6->apply_unsafe($Q2);
$d6->apply_unsafe($R2);
$d6->apply_unsafe($S2);
$d6->apply_unsafe($T2);
$d6->apply_unsafe($I3);
$d6->apply_unsafe($U2);
$d6->apply_unsafe($V2);
$d6->apply_unsafe($W2);
$d6->apply_unsafe($X2);
$d6->apply_unsafe($Y2);
$d6->apply_unsafe($Z2);
$d6->apply_unsafe($c3);
$d6->apply_unsafe($d3);
$d6->apply_unsafe($e3);
$d6->apply_unsafe($f3);
$d6->apply_unsafe($o3);
$d6->apply_unsafe($g3);
$d6->apply_unsafe($p3);
$d6->apply_unsafe($h3);
$d6->apply_unsafe($i3);
$d6->apply_unsafe($j3);
$d6->apply_unsafe($k3);
$d6->apply_unsafe($l3);
$k6->apply_unsafe($E2);
$k6->apply_unsafe($F2);
$k6->apply_unsafe($G2);
$k6->apply_unsafe($H2);
$k6->apply_unsafe($I2);
$k6->apply_unsafe($J2);
$k6->apply_unsafe($K2);
$k6->apply_unsafe($L2);
$k6->apply_unsafe($M2);
$k6->apply_unsafe($N2);
$k6->apply_unsafe($O2);
$k6->apply_unsafe($P2);
$k6->apply_unsafe($Q2);
$k6->apply_unsafe($R2);
$k6->apply_unsafe($S2);
$k6->apply_unsafe($T2);
$k6->apply_unsafe($I3);
$k6->apply_unsafe($U2);
$k6->apply_unsafe($V2);
$k6->apply_unsafe($W2);
$k6->apply_unsafe($X2);
$k6->apply_unsafe($Y2);
$k6->apply_unsafe($Z2);
$k6->apply_unsafe($c3);
$k6->apply_unsafe($d3);
$k6->apply_unsafe($e3);
$k6->apply_unsafe($f3);
$k6->apply_unsafe($o3);
$k6->apply_unsafe($g3);
$k6->apply_unsafe($p3);
$k6->apply_unsafe($h3);
$k6->apply_unsafe($i3);
$k6->apply_unsafe($j3);
$k6->apply_unsafe($k3);
$k6->apply_unsafe($l3);
$A6->apply_unsafe($E2);
$A6->apply_unsafe($F2);
$A6->apply_unsafe($G2);
$A6->apply_unsafe($H2);
$A6->apply_unsafe($I2);
$A6->apply_unsafe($J2);
$A6->apply_unsafe($K2);
$A6->apply_unsafe($L2);
$A6->apply_unsafe($M2);
$A6->apply_unsafe($N2);
$A6->apply_unsafe($O2);
$A6->apply_unsafe($P2);
$A6->apply_unsafe($Q2);
$A6->apply_unsafe($R2);
$A6->apply_unsafe($S2);
$A6->apply_unsafe($T2);
$A6->apply_unsafe($U2);
$A6->apply_unsafe($V2);
$A6->apply_unsafe($W2);
$A6->apply_unsafe($u);
$A6->apply_unsafe($X2);
$A6->apply_unsafe($Y2);
$A6->apply_unsafe($Z2);
$A6->apply_unsafe($c3);
$A6->apply_unsafe($G3);
$A6->apply_unsafe($d3);
$A6->apply_unsafe($S3);
$A6->apply_unsafe($e3);
$A6->apply_unsafe($f3);
$A6->apply_unsafe($o3);
$A6->apply_unsafe($g3);
$A6->apply_unsafe($h3);
$A6->apply_unsafe($i3);
$A6->apply_unsafe($j3);
$A6->apply_unsafe($k3);
$A6->apply_unsafe($l3);
$H6->apply_unsafe($E2);
$H6->apply_unsafe($F2);
$H6->apply_unsafe($G2);
$H6->apply_unsafe($H2);
$H6->apply_unsafe($I2);
$H6->apply_unsafe($J2);
$H6->apply_unsafe($K2);
$H6->apply_unsafe($L2);
$H6->apply_unsafe($M2);
$H6->apply_unsafe($N2);
$H6->apply_unsafe($O2);
$H6->apply_unsafe($P2);
$H6->apply_unsafe($Q2);
$H6->apply_unsafe($R2);
$H6->apply_unsafe($S2);
$H6->apply_unsafe($T2);
$H6->apply_unsafe($U2);
$H6->apply_unsafe($V2);
$H6->apply_unsafe($W2);
$H6->apply_unsafe($X2);
$H6->apply_unsafe($Y2);
$H6->apply_unsafe($Z2);
$H6->apply_unsafe($c3);
$H6->apply_unsafe($d3);
$H6->apply_unsafe($e3);
$H6->apply_unsafe($f3);
$H6->apply_unsafe($g3);
$H6->apply_unsafe($h3);
$H6->apply_unsafe($i3);
$H6->apply_unsafe($j3);
$H6->apply_unsafe($k3);
$H6->apply_unsafe($l3);
$p7->apply_unsafe($C4);
$p7->apply_unsafe($E4);
$p7->apply_unsafe($F4);
$p7->apply_unsafe($G4);
$p7->apply_unsafe($H4);
$p7->apply_unsafe($I4);
$p7->apply_unsafe($J4);
$p7->apply_unsafe($K4);
$p7->apply_unsafe($L4);
$p7->apply_unsafe($M4);
$J7->apply_unsafe($C4);
$J7->apply_unsafe($E4);
$J7->apply_unsafe($F4);
$J7->apply_unsafe($G4);
$J7->apply_unsafe($H4);
$J7->apply_unsafe($I4);
$J7->apply_unsafe($J4);
$J7->apply_unsafe($K4);
$J7->apply_unsafe($L4);
$J7->apply_unsafe($M4);
$R7->apply_unsafe($C4);
$R7->apply_unsafe($E4);
$R7->apply_unsafe($F4);
$R7->apply_unsafe($G4);
$R7->apply_unsafe($H4);
$R7->apply_unsafe($I4);
$R7->apply_unsafe($J4);
$R7->apply_unsafe($K4);
$R7->apply_unsafe($L4);
$R7->apply_unsafe($M4);
$Z7->apply_unsafe($C4);
$Z7->apply_unsafe($E4);
$Z7->apply_unsafe($F4);
$Z7->apply_unsafe($G4);
$Z7->apply_unsafe($H4);
$Z7->apply_unsafe($I4);
$Z7->apply_unsafe($J4);
$Z7->apply_unsafe($K4);
$Z7->apply_unsafe($L4);
$Z7->apply_unsafe($M4);
$j8->apply_unsafe($C4);
$j8->apply_unsafe($E4);
$j8->apply_unsafe($F4);
$j8->apply_unsafe($G4);
$j8->apply_unsafe($H4);
$j8->apply_unsafe($I4);
$j8->apply_unsafe($J4);
$j8->apply_unsafe($K4);
$j8->apply_unsafe($L4);
$j8->apply_unsafe($M4);
$y8->apply_unsafe($C4);
$F8->apply_unsafe($C4);
$R8->apply_unsafe($C4);
$s9->apply_unsafe($D4);
$K9->apply_unsafe($E4);
$U9->apply_unsafe($E4);
$pa->apply_unsafe($F4);
$wa->apply_unsafe($F4);
$Qa->apply_unsafe($G4);
$Xa->apply_unsafe($G4);
$tb->apply_unsafe($G4);
$Rb->apply_unsafe($G4);
$Zb->apply_unsafe($G4);
$rc->apply_unsafe($G4);
$Pc->apply_unsafe($H4);
$Wc->apply_unsafe($H4);
$gd->apply_unsafe($H4);
$wd->apply_unsafe($H4);
$Hd->apply_unsafe($H4);
$Rd->apply_unsafe($H4);
$re->apply_unsafe($I4);
$ze->apply_unsafe($I4);
$Ge->apply_unsafe($I4);
$Ye->apply_unsafe($I4);
$Gf->apply_unsafe($Hf);
$Rf->apply_unsafe($J4);
$gg->apply_unsafe($J4);
$Lg->apply_unsafe($L4);
$Vg->apply_unsafe($L4);
$jh->apply_unsafe($L4);
$th->apply_unsafe($L4);
$Jh->apply_unsafe($L4);
$ri->apply_unsafe($M4);
$yi->apply_unsafe($M4);
$Mi->apply_unsafe($M4);
$mj->apply_unsafe($N4);
$mj->apply_unsafe($O4);
$mj->apply_unsafe($W4);
$yj->apply_unsafe($N4);
$yj->apply_unsafe($O4);
$yj->apply_unsafe($W4);
$Oj->apply_unsafe($N4);
$Oj->apply_unsafe($O4);
$hk->apply_unsafe($R2);
$hk->apply_unsafe($S2);
$vk->apply_unsafe($O4);
$Dk->apply_unsafe($O4);
$Zk->apply_unsafe($I3);
$vl->apply_unsafe($Q4);
$Bl->apply_unsafe($Q4);
$Wl->apply_unsafe($F);
$em->apply_unsafe($F);
$lm->apply_unsafe($F);
$um->apply_unsafe($F);
$Vm->apply_unsafe($u);
$ln->apply_unsafe($u);
$vn->apply_unsafe($u);
$Dn->apply_unsafe($u);
$Yn->apply_unsafe($R4);
$ko->apply_unsafe($Hf);
$uo->apply_unsafe($R4);
$jp->apply_unsafe($R4);
$rp->apply_unsafe($R4);
$rp->apply_unsafe($T4);
$Pp->apply_unsafe($R4);
$Pp->apply_unsafe($T4);
$hq->apply_unsafe($R4);
$hq->apply_unsafe($T4);
$xq->apply_unsafe($R4);
$kr->apply_unsafe($lr);
$Fr->apply_unsafe($S4);
$Xr->apply_unsafe($S4);
$is->apply_unsafe($S4);
$ss->apply_unsafe($S4);
$Ht->apply_unsafe($lr);
$Vt->apply_unsafe($T4);
$gu->apply_unsafe($T4);
$Hu->apply_unsafe($G3);
$Nu->apply_unsafe($G3);
$Uu->apply_unsafe($G3);
$tv->apply_unsafe($Hf);
$Dv->apply_unsafe($S3);
$Jv->apply_unsafe($S3);
$fw->apply_unsafe($U4);
$rw->apply_unsafe($U4);
$yw->apply_unsafe($U4);
$ni::self=$qy;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$H;
&$_($d1)for@$H;
&$_($j1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$H;
&$_($D1)for@$w;
&$_($H1)for@$H;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$H;
&$_($f2)for@$H;
&$_($n2)for@$w;
&$_($r2)for@$w;
&$_($v2)for@$H;
&$_($B2)for@$H;
&$_($A3)for@$w;
&$_($D3)for@$w;
&$_($H3)for@$J3;
&$_($M3)for@$w;
&$_($O3)for@$w;
&$_($R3)for@$J3;
&$_($W3)for@$w;
&$_($Z3)for@$J3;
&$_($f4)for@$w;
&$_($i4)for@$J3;
&$_($m4)for@$w;
&$_($p4)for@$J3;
&$_($r4)for@$s4;
&$_($v4)for@$w;
&$_($y4)for@$w;
&$_($B4)for@$J3;
&$_($d5)for@$w;
&$_($g5)for@$J3;
&$_($i5)for@$j5;
&$_($o5)for@$w;
&$_($r5)for@$J3;
&$_($t5)for@$u5;
&$_($A5)for@$w;
&$_($D5)for@$J3;
&$_($H5)for@$w;
&$_($K5)for@$w;
&$_($N5)for@$J3;
&$_($R5)for@$w;
&$_($U5)for@$J3;
&$_($Y5)for@$w;
&$_($d6)for@$J3;
&$_($h6)for@$w;
&$_($k6)for@$J3;
&$_($m6)for@$n6;
&$_($p6)for@$q6;
&$_($u6)for@$w;
&$_($x6)for@$w;
&$_($A6)for@$J3;
&$_($E6)for@$w;
&$_($H6)for@$J3;
&$_($J6)for@$K6;
&$_($T6)for@$U6;
&$_($Y6)for@$U6;
&$_($c7)for@$U6;
&$_($e7)for@$U6;
&$_($m7)for@$w;
&$_($p7)for@$J3;
&$_($u7)for@$w;
&$_($y7)for@$w;
&$_($C7)for@$w;
&$_($G7)for@$w;
&$_($J7)for@$J3;
&$_($O7)for@$w;
&$_($R7)for@$J3;
&$_($W7)for@$w;
&$_($Z7)for@$J3;
&$_($g8)for@$w;
&$_($j8)for@$J3;
&$_($l8)for@$m8;
&$_($r8)for@$w;
&$_($v8)for@$w;
&$_($y8)for@$J3;
&$_($C8)for@$w;
&$_($F8)for@$J3;
&$_($K8)for@$w;
&$_($O8)for@$w;
&$_($R8)for@$J3;
&$_($T8)for@$U8;
&$_($d9)for@$U6;
&$_($f9)for@$U6;
&$_($p9)for@$w;
&$_($s9)for@$J3;
&$_($u9)for@$v9;
&$_($A9)for@$U6;
&$_($H9)for@$w;
&$_($K9)for@$J3;
&$_($O9)for@$w;
&$_($R9)for@$w;
&$_($U9)for@$J3;
&$_($W9)for@$X9;
&$_($ea)for@$U6;
&$_($ma)for@$w;
&$_($pa)for@$J3;
&$_($ta)for@$w;
&$_($wa)for@$J3;
&$_($ya)for@$za;
&$_($Ea)for@$U6;
&$_($Na)for@$w;
&$_($Qa)for@$J3;
&$_($Ua)for@$w;
&$_($Xa)for@$J3;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($tb)for@$J3;
&$_($yb)for@$w;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Ob)for@$w;
&$_($Rb)for@$J3;
&$_($Wb)for@$w;
&$_($Zb)for@$J3;
&$_($gc)for@$w;
&$_($kc)for@$w;
&$_($oc)for@$w;
&$_($rc)for@$J3;
&$_($tc)for@$uc;
&$_($zc)for@$U6;
&$_($Mc)for@$w;
&$_($Pc)for@$J3;
&$_($Tc)for@$w;
&$_($Wc)for@$J3;
&$_($dd)for@$w;
&$_($gd)for@$J3;
&$_($ld)for@$w;
&$_($pd)for@$w;
&$_($td)for@$w;
&$_($wd)for@$J3;
&$_($Ad)for@$w;
&$_($Ed)for@$w;
&$_($Hd)for@$J3;
&$_($Ld)for@$w;
&$_($Od)for@$w;
&$_($Rd)for@$J3;
&$_($Td)for@$Ud;
&$_($Zd)for@$U6;
&$_($oe)for@$w;
&$_($re)for@$J3;
&$_($we)for@$w;
&$_($ze)for@$J3;
&$_($De)for@$w;
&$_($Ge)for@$J3;
&$_($Le)for@$w;
&$_($Oe)for@$w;
&$_($Se)for@$w;
&$_($Ve)for@$w;
&$_($Ye)for@$J3;
&$_($cf)for@$df;
&$_($if)for@$U6;
&$_($sf)for@$w;
&$_($vf)for@$w;
&$_($zf)for@$w;
&$_($Df)for@$w;
&$_($Gf)for@$J3;
&$_($Of)for@$w;
&$_($Rf)for@$J3;
&$_($Vf)for@$w;
&$_($Yf)for@$w;
&$_($dg)for@$w;
&$_($gg)for@$J3;
&$_($ig)for@$jg;
&$_($og)for@$U6;
&$_($Eg)for@$w;
&$_($Ig)for@$w;
&$_($Lg)for@$J3;
&$_($Pg)for@$w;
&$_($Sg)for@$w;
&$_($Vg)for@$J3;
&$_($ch)for@$w;
&$_($gh)for@$w;
&$_($jh)for@$J3;
&$_($nh)for@$w;
&$_($qh)for@$w;
&$_($th)for@$J3;
&$_($xh)for@$w;
&$_($Ah)for@$w;
&$_($Dh)for@$w;
&$_($Gh)for@$w;
&$_($Jh)for@$J3;
&$_($Lh)for@$Mh;
&$_($Rh)for@$U6;
&$_($gi)for@$w;
&$_($ki)for@$w;
&$_($oi)for@$w;
&$_($ri)for@$J3;
&$_($vi)for@$w;
&$_($yi)for@$J3;
&$_($Ci)for@$w;
&$_($Gi)for@$w;
&$_($Ji)for@$w;
&$_($Mi)for@$J3;
&$_($Oi)for@$Pi;
&$_($Ui)for@$U6;
&$_($jj)for@$w;
&$_($mj)for@$J3;
&$_($rj)for@$w;
&$_($vj)for@$w;
&$_($yj)for@$J3;
&$_($Aj)for@$Bj;
&$_($Fj)for@$w;
&$_($Ij)for@$w;
&$_($Lj)for@$w;
&$_($Oj)for@$J3;
&$_($Qj)for@$Rj;
&$_($Yj)for@$U6;
&$_($ek)for@$w;
&$_($hk)for@$J3;
&$_($jk)for@$U6;
&$_($sk)for@$w;
&$_($vk)for@$J3;
&$_($Ak)for@$w;
&$_($Dk)for@$J3;
&$_($Fk)for@$Gk;
&$_($Lk)for@$U6;
&$_($Wk)for@$w;
&$_($Zk)for@$J3;
&$_($dl)for@$el;
&$_($kl)for@$U6;
&$_($sl)for@$w;
&$_($vl)for@$J3;
&$_($yl)for@$w;
&$_($Bl)for@$J3;
&$_($Dl)for@$El;
&$_($Jl)for@$U6;
&$_($Tl)for@$w;
&$_($Wl)for@$J3;
&$_($Zl)for@$w;
&$_($em)for@$J3;
&$_($im)for@$w;
&$_($lm)for@$J3;
&$_($om)for@$w;
&$_($rm)for@$w;
&$_($um)for@$J3;
&$_($wm)for@$xm;
&$_($Cm)for@$U6;
&$_($Nm)for@$w;
&$_($Qm)for@$w;
&$_($Sm)for@$w;
&$_($Vm)for@$J3;
&$_($Zm)for@$w;
&$_($en)for@$w;
&$_($in)for@$w;
&$_($ln)for@$J3;
&$_($pn)for@$w;
&$_($sn)for@$w;
&$_($vn)for@$J3;
&$_($An)for@$w;
&$_($Dn)for@$J3;
&$_($Fn)for@$Gn;
&$_($Ln)for@$U6;
&$_($Vn)for@$w;
&$_($Yn)for@$J3;
&$_($ho)for@$w;
&$_($ko)for@$J3;
&$_($ro)for@$w;
&$_($uo)for@$J3;
&$_($zo)for@$w;
&$_($Do)for@$w;
&$_($Ho)for@$w;
&$_($Lo)for@$w;
&$_($Po)for@$w;
&$_($To)for@$w;
&$_($Xo)for@$w;
&$_($dp)for@$w;
&$_($gp)for@$w;
&$_($jp)for@$J3;
&$_($op)for@$w;
&$_($rp)for@$J3;
&$_($wp)for@$w;
&$_($Ap)for@$w;
&$_($Ep)for@$w;
&$_($Ip)for@$w;
&$_($Mp)for@$w;
&$_($Pp)for@$J3;
&$_($Up)for@$w;
&$_($Yp)for@$w;
&$_($eq)for@$w;
&$_($hq)for@$J3;
&$_($mq)for@$w;
&$_($qq)for@$w;
&$_($uq)for@$w;
&$_($xq)for@$J3;
&$_($zq)for@$Aq;
&$_($Fq)for@$U6;
&$_($Pq)for@$w;
&$_($Tq)for@$w;
&$_($Xq)for@$w;
&$_($dr)for@$w;
&$_($hr)for@$w;
&$_($kr)for@$J3;
&$_($wr)for@$w;
&$_($zr)for@$w;
&$_($Cr)for@$w;
&$_($Fr)for@$J3;
&$_($Jr)for@$w;
&$_($Mr)for@$w;
&$_($Pr)for@$w;
&$_($Sr)for@$w;
&$_($Ur)for@$w;
&$_($Xr)for@$J3;
&$_($cs)for@$w;
&$_($fs)for@$w;
&$_($is)for@$J3;
&$_($ms)for@$w;
&$_($ps)for@$w;
&$_($ss)for@$J3;
&$_($us)for@$vs;
&$_($As)for@$U6;
&$_($Ks)for@$w;
&$_($Os)for@$w;
&$_($Ss)for@$w;
&$_($Ws)for@$w;
&$_($ct)for@$w;
&$_($gt)for@$w;
&$_($kt)for@$w;
&$_($ot)for@$w;
&$_($st)for@$w;
&$_($wt)for@$w;
&$_($At)for@$w;
&$_($Et)for@$w;
&$_($Ht)for@$J3;
&$_($St)for@$w;
&$_($Vt)for@$J3;
&$_($Yt)for@$w;
&$_($du)for@$w;
&$_($gu)for@$J3;
&$_($iu)for@$ju;
&$_($ou)for@$U6;
&$_($yu)for@$w;
&$_($Au)for@$w;
&$_($Hu)for@$J3;
&$_($Ku)for@$w;
&$_($Nu)for@$J3;
&$_($Ru)for@$w;
&$_($Uu)for@$J3;
&$_($Wu)for@$Xu;
&$_($fv)for@$U6;
&$_($mv)for@$w;
&$_($qv)for@$w;
&$_($tv)for@$J3;
&$_($Av)for@$w;
&$_($Dv)for@$J3;
&$_($Gv)for@$w;
&$_($Jv)for@$J3;
&$_($Lv)for@$Mv;
&$_($Sv)for@$U6;
&$_($cw)for@$w;
&$_($fw)for@$J3;
&$_($kw)for@$w;
&$_($ow)for@$w;
&$_($rw)for@$J3;
&$_($vw)for@$w;
&$_($yw)for@$J3;
&$_($Aw)for@$Bw;
&$_($Gw)for@$U6;
&$_($Ow)for@$Pw;
&$_($Uw)for@$U6;
&$_($fx)for@$gx;
&$_($lx)for@$U6;
&$_($tx)for@$ux;
&$_($Ox)for@$Px;
&$_($Rx)for@$ux;
&$_($Wx)for@$w;
&$_($cy)for@$w;
&$_($gy)for@$w;
&$_($ky)for@$w;
&$_($oy)for@$w;
&$_($qy)for@$ry;
ni->run(@ARGV);
__DATA__
