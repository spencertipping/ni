#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/mio#;
$P=q#
    my $mio = ni("ni:/fabric/mio")->new;
    my $channel1 = $mio->channel;
    my $channel2 = $mio->channel;
    $channel1->write("8MB data" x 1000000);
    $channel2->write("short string");
    $mio->into_sync($socket_or_something);#;
$Q=[$f,$P];
$R=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel.#;
$S=[$i,$R];
$T=[$Q,$S];
$U=q#/fabric/mio#;
$V=bless({$e,$T,$D,$U},$F);
$W=q#ni.doc:/io#;
$X=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Y=[$i,$X];
$Z=[$Y];
$c1=q#/io#;
$d1=bless({$e,$Z,$D,$c1},$F);
$e1=q#ni.doc:/io/buffer#;
$f1=q#
    my $buf = ni("ni:/io/buffer")->new(1048576);
    $buf->write("foo")#;
$g1=[$f,$f1];
$h1=[$g1];
$i1=q#/io/buffer#;
$j1=bless({$e,$h1,$D,$i1},$F);
$k1=q#ni.doc:/io/cat#;
$l1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$m1=[$f,$l1];
$n1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$o1=[$i,$n1];
$p1=[];
$q1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[$m1,$o1,$s1];
$u1=q#/io/cat#;
$v1=bless({$e,$t1,$D,$u1},$F);
$w1=q#ni.doc:/io/exec#;
$x1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$y1=[$f,$x1];
$z1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$A1=[$i,$z1];
$B1=[];
$C1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$D1=bless({$o,$B1,$q,$C1,$s,$t},$u);
$E1=[$n,$D1];
$F1=[$y1,$A1,$E1];
$G1=q#/io/exec#;
$H1=bless({$e,$F1,$D,$G1},$F);
$I1=q#ni.doc:/io/pid#;
$J1=[];
$K1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[$M1,$Q1,$U1];
$W1=q#/io/pid#;
$X1=bless({$e,$V1,$D,$W1},$F);
$Y1=q#ni.doc:/lib#;
$Z1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$c2=[$i,$Z1];
$d2=[$c2];
$e2=q#/lib#;
$f2=bless({$e,$d2,$D,$e2},$F);
$g2=q#ni.doc:/lib/doc#;
$h2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$i2=[$f,$h2];
$j2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$k2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$l2=[];
$m2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$n2=bless({$o,$l2,$q,$m2,$s,$t},$u);
$o2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$p2=[];
$q2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$r2=bless({$o,$p2,$q,$q2,$s,$t},$u);
$s2=[$i,$j2,$k2,$n,$n2,$o2,$n,$r2];
$t2=[$i2,$s2];
$u2=q#/lib/doc#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni:/class#;
$x2=q#applied_to#;
$y2=q#class#;
$z2=q#class.c#;
$A2=q#fabric/mio.c#;
$B2=q#fabric/rmi.c#;
$C2=q#io/buffer.c#;
$D2=q#io/cat.c#;
$E2=q#io/exec.c#;
$F2=q#io/fd.c#;
$G2=q#io/file.c#;
$H2=q#io/null.c#;
$I2=q#io/object.c#;
$J2=q#io/pid.c#;
$K2=q#io/str.c#;
$L2=q#io/transfer.c#;
$M2=q#io/transfer_sync.c#;
$N2=q#lib/behavior.c#;
$O2=q#lib/branch.c#;
$P2=q#lib/dataslice.c#;
$Q2=q#lib/doc.c#;
$R2=q#lib/fn.c#;
$S2=q#lib/image.c#;
$T2=q#lib/ni.c#;
$U2=q#lib/quote_simple.c#;
$V2=q#lib/slice.c#;
$W2=q#lib/tag.c#;
$X2=q#lib/test_value.c#;
$Y2=q#metaclass.c#;
$Z2=q#module.c#;
$c3=q#object.c#;
$d3={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1};
$e3=q#slices#;
$f3=q#metaclass#;
$g3=q#module#;
$h3={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$f3,1,$Y2,1,$g3,1,$Z2,1,$c3,1};
$i3=q#/module#;
$j3=q#/lib/perlbranch.b#;
$k3={};
$l3=q#ctor#;
$m3=undef;
$n3=q#dtor#;
$o3=q#methods#;
$p3=q#add#;
$q3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$r3=bless({$q,$q3,$s,$t},$u);
$s3=q#apply#;
$t3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$u3=bless({$q,$t3,$s,$t},$u);
$v3={$p3,$r3,$s3,$u3};
$w3=q#/lib/branch.b#;
$x3=q#lib/slice#;
$y3=bless({$x2,$k3,$l3,$m3,$n3,$m3,$o3,$v3,$D,$w3},$x3);
$z3=q#lib/branch#;
$A3=q#lib/slice::ctors#;
$B3={};
$C3=q#my $s = shift; ni->def($s->name, $s)#;
$D3=bless({$q,$C3,$s,$t},$u);
$E3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$F3=bless({$q,$E3,$s,$t},$u);
$G3={$D,$F3};
$H3=q#/lib/named.b#;
$I3=bless({$x2,$B3,$l3,$D3,$n3,$m3,$o3,$G3,$D,$H3},$x3);
$J3=q#lib/tag#;
$K3={};
$L3=q#namespace#;
$M3=q#'ni'#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3={$L3,$N3};
$P3=q#/lib/named_in_ni.b#;
$Q3=bless({$x2,$K3,$l3,$m3,$n3,$m3,$o3,$O3,$D,$P3},$x3);
$R3={};
$S3=q#package#;
$T3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$U3=bless({$q,$T3,$s,$t},$u);
$V3={$S3,$U3};
$W3=q#/lib/namespaced.b#;
$X3=bless({$x2,$R3,$l3,$m3,$n3,$m3,$o3,$V3,$D,$W3},$x3);
$Y3={};
$Z3=q#resolve#;
$c4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$d4=bless({$q,$c4,$s,$t},$u);
$e4={$Z3,$d4};
$f4=q#/lib/resolver.b#;
$g4=bless({$x2,$Y3,$l3,$m3,$n3,$m3,$o3,$e4,$D,$f4},$x3);
$h4=[$y3,$I3,$Q3,$X3,$g4];
$i4=bless({$D,$j3,$e3,$h4},$J3);
$j4=q#lib/tag::ctors#;
$k4={};
$l4=q#my $s = shift; $s->apply($s->package)#;
$m4=bless({$q,$l4,$s,$t},$u);
$n4=q#instantiate#;
$o4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$p4=bless({$q,$o4,$s,$t},$u);
$q4={$n4,$p4};
$r4=q#/lib/class_init.b#;
$s4=bless({$x2,$k4,$l3,$m4,$n3,$m3,$o3,$q4,$D,$r4},$x3);
$t4=q#fabric/mio#;
$u4=q#fabric/rmi#;
$v4=q#io/buffer#;
$w4=q#io/cat#;
$x4=q#io/exec#;
$y4=q#io/fd#;
$z4=q#io/file#;
$A4=q#io/null#;
$B4=q#io/object#;
$C4=q#io/pid#;
$D4=q#io/str#;
$E4=q#io/transfer#;
$F4=q#io/transfer_sync#;
$G4=q#lib/behavior#;
$H4=q#lib/dataslice#;
$I4=q#lib/image#;
$J4=q#lib/ni#;
$K4=q#lib/quote_simple#;
$L4=q#lib/test_value#;
$M4=q#object#;
$N4={$y2,1,$z2,1,$t4,1,$A2,1,$u4,1,$B2,1,$v4,1,$C2,1,$w4,1,$D2,1,$x4,1,$E2,1,$y4,1,$F2,1,$z4,1,$G2,1,$A4,1,$H2,1,$B4,1,$I2,1,$C4,1,$J2,1,$D4,1,$K2,1,$E4,1,$L2,1,$F4,1,$M2,1,$G4,1,$N2,1,$z3,1,$O2,1,$H4,1,$P2,1,$F,1,$Q2,1,$u,1,$R2,1,$I4,1,$S2,1,$J4,1,$T2,1,$K4,1,$U2,1,$x3,1,$V2,1,$J3,1,$W2,1,$L4,1,$X2,1,$f3,1,$Y2,1,$g3,1,$Z2,1,$M4,1,$c3,1};
$O4=q#/object#;
$P4={};
$Q4=q#ni 'ni:/' . ref shift#;
$R4=bless({$q,$Q4,$s,$t},$u);
$S4={$y2,$R4};
$T4=q#/lib/instance.b#;
$U4=bless({$x2,$P4,$l3,$m3,$n3,$m3,$o3,$S4,$D,$T4},$x3);
$V4=[$U4];
$W4=bless({$x2,$N4,$D,$O4,$e3,$V4},$c3);
$X4=q#object.c::ctors#;
$Y4={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$G4,1,$N2,1,$z3,1,$O2,1,$H4,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$x3,1,$V2,1,$J3,1,$W2,1,$X2,1,$f3,1,$Y2,1,$g3,1,$Z2,1,$c3,1};
$Z4=q#/lib/behavior#;
$c5={};
$d5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$e5=bless({$q,$d5,$s,$t},$u);
$f5={$e,$e5};
$g5=q#/lib/documentable.b#;
$h5=bless({$x2,$c5,$l3,$m3,$n3,$m3,$o3,$f5,$D,$g5},$x3);
$i5=[$W4,$h5];
$j5=bless({$x2,$Y4,$D,$Z4,$e3,$i5},$N2);
$k5=q#lib/behavior.c::ctors#;
$l5={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$z3,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$f3,1,$Y2,1,$g3,1,$Z2,1,$c3,1};
$m5=q#/lib/definition.b#;
$n5={};
$o5=q#def#;
$p5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$o5,$q5};
$s5=q#/lib/definition_def.b#;
$t5=bless({$x2,$n5,$l3,$m3,$n3,$m3,$o3,$r5,$D,$s5},$x3);
$u5={};
$v5=q#ro#;
$w5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$x5=bless({$q,$w5,$s,$t},$u);
$y5=q#rw#;
$z5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$A5=bless({$q,$z5,$s,$t},$u);
$B5={$v5,$x5,$y5,$A5};
$C5=q#/lib/accessor.b#;
$D5=bless({$x2,$u5,$l3,$m3,$n3,$m3,$o3,$B5,$D,$C5},$x3);
$E5={};
$F5=q#(""#;
$G5=q#shift->name#;
$H5=bless({$q,$G5,$s,$t},$u);
$I5={$F5,$H5};
$J5=q#/lib/name_as_string.b#;
$K5=bless({$x2,$E5,$l3,$m3,$n3,$m3,$o3,$I5,$D,$J5},$x3);
$L5={};
$M5=q#(eq#;
$N5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$O5=bless({$q,$N5,$s,$t},$u);
$P5={$M5,$O5};
$Q5=q#/lib/ref_eq.b#;
$R5=bless({$x2,$L5,$l3,$m3,$n3,$m3,$o3,$P5,$D,$Q5},$x3);
$S5={};
$T5=q#defdata#;
$U5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$V5=bless({$q,$U5,$s,$t},$u);
$W5={$T5,$V5};
$X5=q#/lib/definition_defdata.b#;
$Y5=bless({$x2,$S5,$l3,$m3,$n3,$m3,$o3,$W5,$D,$X5},$x3);
$Z5=[$t5,$D5,$K5,$R5,$Y5];
$c6=bless({$x2,$l5,$D,$m5,$e3,$Z5},$z3);
$d6=q#lib/branch::ctors#;
$e6=[$i4,$s4,$W4,$j5,$c6];
$f6=bless({$x2,$h3,$D,$i3,$e3,$e6},$Z2);
$g6=q#module.c::ctors#;
$h6={};
$i6=q#DESTROY#;
$j6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$k6=bless({$q,$j6,$s,$t},$u);
$l6=q#new#;
$m6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$n6=bless({$q,$m6,$s,$t},$u);
$o6={$i6,$k6,$l6,$n6};
$p6=q#/lib/instantiable.b#;
$q6=bless({$x2,$h6,$o3,$o6,$D,$p6},$x3);
$r6={};
$s6=q#child#;
$t6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$u6=bless({$q,$t6,$s,$t},$u);
$v6={$s6,$u6};
$w6=q#/lib/subclass.b#;
$x6=bless({$x2,$r6,$l3,$m3,$n3,$m3,$o3,$v6,$D,$w6},$x3);
$y6=[$f6,$q6,$s4,$f6,$x6];
$z6=bless({$x2,$d3,$D,$E,$e3,$y6},$z2);
$A6=q#class.c::ctors#;
$B6=q#ni:/class.c#;
$C6={$z2,1};
$D6=q#/class.c#;
$E6={$z2,1,$Z2,1};
$F6=q#/module.c#;
$G6={$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Z2,1,$c3,1};
$H6=q#/object.c#;
$I6=[$z6];
$J6=bless({$x2,$G6,$D,$H6,$e3,$I6},$f3);
$K6=q#metaclass::ctors#;
$L6={$z2,1,$N2,1,$O2,1,$P2,1,$V2,1,$W2,1,$Z2,1};
$M6=q#/lib/behavior.c#;
$N6=[$J6];
$O6=bless({$x2,$L6,$D,$M6,$e3,$N6},$f3);
$P6=[$J6,$q6,$O6];
$Q6=bless({$x2,$E6,$D,$F6,$e3,$P6},$f3);
$R6=[$Q6];
$S6=bless({$x2,$C6,$D,$D6,$e3,$R6},$f3);
$T6=q#ni:/fabric/mio#;
$U6={$t4,1};
$V6={$t4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1};
$W6=q#/io/object#;
$X6={};
$Y6=q#(bool#;
$Z6=[];
$c7=bless({$o,$Z6,$q,1,$s,$t},$u);
$d7={$Y6,$c7};
$e7=q#/io/object_ops.b#;
$f7=bless({$x2,$X6,$l3,$m3,$n3,$m3,$o3,$d7,$D,$e7},$x3);
$g7={};
$h7=q#die#;
$i7=[];
$j7=q#shift; die join " ", @_#;
$k7=bless({$o,$i7,$q,$j7,$s,$t},$u);
$l7=q#io_check#;
$m7=[];
$n7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$o7=bless({$o,$m7,$q,$n7,$s,$t},$u);
$p7=q#io_check_defined#;
$q7=[];
$r7=q#shift->io_check(sub {defined shift}, @_)#;
$s7=bless({$o,$q7,$q,$r7,$s,$t},$u);
$t7=q#io_check_true#;
$u7=[];
$v7=q#shift->io_check(sub {shift}, @_)#;
$w7=bless({$o,$u7,$q,$v7,$s,$t},$u);
$x7={$h7,$k7,$l7,$o7,$p7,$s7,$t7,$w7};
$y7=q#/io/object_checks.b#;
$z7=bless({$x2,$g7,$l3,$m3,$n3,$m3,$o3,$x7,$D,$y7},$x3);
$A7={};
$B7=q#(+#;
$C7=[];
$D7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$E7=bless({$o,$C7,$q,$D7,$s,$t},$u);
$F7={$B7,$E7};
$G7=q#/io/object_constructors.b#;
$H7=bless({$x2,$A7,$l3,$m3,$n3,$m3,$o3,$F7,$D,$G7},$x3);
$I7={};
$J7=q#read_all#;
$K7=[];
$L7=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$M7=bless({$o,$K7,$q,$L7,$s,$t},$u);
$N7={$J7,$M7};
$O7=q#/io/object_memory.b#;
$P7=bless({$x2,$I7,$l3,$m3,$n3,$m3,$o3,$N7,$D,$O7},$x3);
$Q7={};
$R7=q#into_sync#;
$S7=[];
$T7=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$U7=bless({$o,$S7,$q,$T7,$s,$t},$u);
$V7={$R7,$U7};
$W7=q#/io/object_transfer_sync.b#;
$X7=bless({$x2,$Q7,$l3,$m3,$n3,$m3,$o3,$V7,$D,$W7},$x3);
$Y7=[$W4,$f7,$z7,$H7,$P7,$X7,$X7];
$Z7=bless({$x2,$V6,$D,$W6,$e3,$Y7},$I2);
$c8=q#io/object.c::ctors#;
$d8={};
$e8=q#io#;
$f8=[];
$g8=q#shift->{'io'}#;
$h8=bless({$o,$f8,$q,$g8,$s,$t},$u);
$i8=q#packet_size#;
$j8=[];
$k8=q#shift->{'packet_size'}#;
$l8=bless({$o,$j8,$q,$k8,$s,$t},$u);
$m8={$e8,$h8,$i8,$l8};
$n8=q#/fabric/mio_ro.b#;
$o8=bless({$x2,$d8,$l3,$m3,$n3,$m3,$o3,$m8,$D,$n8},$x3);
$p8={};
$q8=[];
$r8=q#my ($self, $io, %args) = @_;
+{io          => $io,
  packet_size => $args{packet_size} || 32768,
  channel_id  => 0,
  channels    => {}};#;
$s8=bless({$o,$q8,$q,$r8,$s,$t},$u);
$t8={$n4,$s8};
$u8=q#/fabric/mio_init.b#;
$v8=bless({$x2,$p8,$l3,$m3,$n3,$m3,$o3,$t8,$D,$u8},$x3);
$w8={};
$x8=q#data_packet#;
$y8=[];
$z8=q#my $self      = shift;
my $stream_id = shift;
pack 'NN/a', $stream_id, $_[0];#;
$A8=bless({$o,$y8,$q,$z8,$s,$t},$u);
$B8=q#eof_packet#;
$C8=[];
$D8=q#my ($self, $stream_id) = @_;
pack 'NN', $stream_id, 0;#;
$E8=bless({$o,$C8,$q,$D8,$s,$t},$u);
$F8={$x8,$A8,$B8,$E8};
$G8=q#/fabric/mio_packet.b#;
$H8=bless({$x2,$w8,$l3,$m3,$n3,$m3,$o3,$F8,$D,$G8},$x3);
$I8=[$Z7,$o8,$v8,$H8];
$J8=bless({$x2,$U6,$D,$U,$e3,$I8},$A2);
$K8=q#fabric/mio.c::ctors#;
$L8=q#ni:/fabric/mio.c#;
$M8={$A2,1};
$N8=q#/fabric/mio.c#;
$O8={$A2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1};
$P8=q#/io/object.c#;
$Q8=[$J6];
$R8=bless({$x2,$O8,$D,$P8,$e3,$Q8},$f3);
$S8=[$R8];
$T8=bless({$x2,$M8,$D,$N8,$e3,$S8},$f3);
$U8=q#ni:/fabric/mio_init.b#;
$V8=q#ni:/fabric/mio_packet.b#;
$W8=q#ni:/fabric/mio_ro.b#;
$X8=q#ni:/fabric/rmi#;
$Y8={$u4,1};
$Z8=q#/fabric/rmi#;
$c9={};
$d9=[];
$e9=q#my ($class, $io, $quote) = @_;#;
$f9=bless({$o,$d9,$q,$e9,$s,$t},$u);
$g9={$n4,$f9};
$h9=q#/fabric/rmi_init.b#;
$i9=bless({$x2,$c9,$l3,$m3,$n3,$m3,$o3,$g9,$D,$h9},$x3);
$j9=[$W4,$i9];
$k9=bless({$x2,$Y8,$D,$Z8,$e3,$j9},$B2);
$l9=q#fabric/rmi.c::ctors#;
$m9=q#ni:/fabric/rmi.c#;
$n9={$B2,1};
$o9=q#/fabric/rmi.c#;
$p9=[$J6];
$q9=bless({$x2,$n9,$D,$o9,$e3,$p9},$f3);
$r9=q#ni:/fabric/rmi_init.b#;
$s9=q#ni:/io/buffer#;
$t9={$v4,1};
$u9={};
$v9=[];
$w9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9={$n4,$x9};
$z9=q#/io/buffer_init.b#;
$A9=bless({$x2,$u9,$l3,$m3,$n3,$m3,$o3,$y9,$D,$z9},$x3);
$B9={};
$C9=q#read#;
$D9=[];
$E9=bless({$o,$D9,$q,$t,$s,$t},$u);
$F9=q#write#;
$G9=[];
$H9=bless({$o,$G9,$q,$t,$s,$t},$u);
$I9={$C9,$E9,$F9,$H9};
$J9=q#/io/buffer_io.b#;
$K9=bless({$x2,$B9,$l3,$m3,$n3,$m3,$o3,$I9,$D,$J9},$x3);
$L9=[$Z7,$A9,$K9];
$M9=bless({$x2,$t9,$D,$i1,$e3,$L9},$C2);
$N9=q#io/buffer.c::ctors#;
$O9=q#ni:/io/buffer.c#;
$P9={$C2,1};
$Q9=q#/io/buffer.c#;
$R9=[$R8];
$S9=bless({$x2,$P9,$D,$Q9,$e3,$R9},$f3);
$T9=q#ni:/io/buffer_init.b#;
$U9=q#ni:/io/buffer_io.b#;
$V9=q#ni:/io/cat#;
$W9={$w4,1};
$X9={};
$Y9=[];
$Z9=q#shift; +{fs => [@_]}#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da={$n4,$ca};
$ea=q#/io/cat_init.b#;
$fa=bless({$x2,$X9,$l3,$m3,$n3,$m3,$o3,$da,$D,$ea},$x3);
$ga={};
$ha=[];
$ia=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$ja=bless({$o,$ha,$q,$ia,$s,$t},$u);
$ka={$C9,$ja};
$la=q#/io/cat_read.b#;
$ma=bless({$x2,$ga,$l3,$m3,$n3,$m3,$o3,$ka,$D,$la},$x3);
$na=[$Z7,$fa,$ma];
$oa=bless({$x2,$W9,$D,$u1,$e3,$na},$D2);
$pa=q#io/cat.c::ctors#;
$qa=q#ni:/io/cat.c#;
$ra={$D2,1};
$sa=q#/io/cat.c#;
$ta=[$R8];
$ua=bless({$x2,$ra,$D,$sa,$e3,$ta},$f3);
$va=q#ni:/io/cat_init.b#;
$wa=q#ni:/io/cat_read.b#;
$xa=q#ni:/io/exec#;
$ya={$x4,1};
$za={};
$Aa=q#argv#;
$Ba=[];
$Ca=q#shift->{'argv'}#;
$Da=bless({$o,$Ba,$q,$Ca,$s,$t},$u);
$Ea={$Aa,$Da};
$Fa=q#/io/exec_ro.b#;
$Ga=bless({$x2,$za,$l3,$m3,$n3,$m3,$o3,$Ea,$D,$Fa},$x3);
$Ha={};
$Ia=[];
$Ja=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Ka=bless({$o,$Ia,$q,$Ja,$s,$t},$u);
$La={$n4,$Ka};
$Ma=q#/io/exec_init.b#;
$Na=bless({$x2,$Ha,$l3,$m3,$n3,$m3,$o3,$La,$D,$Ma},$x3);
$Oa={};
$Pa=q#connect#;
$Qa=[];
$Ra=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta=q#in_pipe#;
$Ua=[];
$Va=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#out_pipe#;
$Ya=[];
$Za=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db=q#setup_stdio#;
$eb=[];
$fb=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb={$Pa,$Sa,$Ta,$Wa,$Xa,$cb,$db,$gb};
$ib=q#/io/exec_io_setup.b#;
$jb=bless({$x2,$Oa,$l3,$m3,$n3,$m3,$o3,$hb,$D,$ib},$x3);
$kb={};
$lb=q#binds_fd#;
$mb=[];
$nb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#fd#;
$qb=[];
$rb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#stderr#;
$ub=[];
$vb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#stdin#;
$yb=[];
$zb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb=q#stdout#;
$Cb=[];
$Db=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb={$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab,$Bb,$Eb};
$Gb=q#/io/exec_io_accessors.b#;
$Hb=bless({$x2,$kb,$l3,$m3,$n3,$m3,$o3,$Fb,$D,$Gb},$x3);
$Ib={};
$Jb=q#env#;
$Kb=[];
$Lb=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb={$Jb,$Mb};
$Ob=q#/io/exec_env.b#;
$Pb=bless({$x2,$Ib,$l3,$m3,$n3,$m3,$o3,$Nb,$D,$Ob},$x3);
$Qb={};
$Rb=q#exec#;
$Sb=[];
$Tb=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#fork#;
$Wb=[];
$Xb=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#move_fds#;
$cc=[];
$dc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc={$Rb,$Ub,$Vb,$Yb,$Zb,$ec};
$gc=q#/io/exec_fork.b#;
$hc=bless({$x2,$Qb,$l3,$m3,$n3,$m3,$o3,$fc,$D,$gc},$x3);
$ic=[$Z7,$Ga,$Na,$jb,$Hb,$Pb,$hc];
$jc=bless({$x2,$ya,$D,$G1,$e3,$ic},$E2);
$kc=q#io/exec.c::ctors#;
$lc=q#ni:/io/exec.c#;
$mc={$E2,1};
$nc=q#/io/exec.c#;
$oc=[$R8];
$pc=bless({$x2,$mc,$D,$nc,$e3,$oc},$f3);
$qc=q#ni:/io/exec_env.b#;
$rc=q#ni:/io/exec_fork.b#;
$sc=q#ni:/io/exec_init.b#;
$tc=q#ni:/io/exec_io_accessors.b#;
$uc=q#ni:/io/exec_io_setup.b#;
$vc=q#ni:/io/exec_ro.b#;
$wc=q#ni:/io/fd#;
$xc={$y4,1};
$yc=q#/io/fd#;
$zc={};
$Ac=[];
$Bc=q#shift->{'fd'}#;
$Cc=bless({$o,$Ac,$q,$Bc,$s,$t},$u);
$Dc={$pb,$Cc};
$Ec=q#/io/fd_readers.b#;
$Fc=bless({$x2,$zc,$l3,$m3,$n3,$m3,$o3,$Dc,$D,$Ec},$x3);
$Gc={};
$Hc=[];
$Ic=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Jc=bless({$o,$Hc,$q,$Ic,$s,$t},$u);
$Kc={$n4,$Jc};
$Lc=q#/io/fd_init.b#;
$Mc=bless({$x2,$Gc,$l3,$m3,$n3,$m3,$o3,$Kc,$D,$Lc},$x3);
$Nc={};
$Oc=q#be#;
$Pc=[];
$Qc=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$t},$u);
$Sc={$Oc,$Rc};
$Tc=q#/io/fd_shell.b#;
$Uc=bless({$x2,$Nc,$l3,$m3,$n3,$m3,$o3,$Sc,$D,$Tc},$x3);
$Vc={};
$Wc=q#cloexec#;
$Xc=[];
$Yc=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd=q#fcntl_flag#;
$dd=[];
$ed=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd=q#nonblock#;
$hd=[];
$id=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$Wc,$Zc,$cd,$fd,$gd,$jd};
$ld=q#/io/fd_fcntl.b#;
$md=bless({$x2,$Vc,$l3,$m3,$n3,$m3,$o3,$kd,$D,$ld},$x3);
$nd={};
$od=[];
$pd=q#shift->close#;
$qd=bless({$o,$od,$q,$pd,$s,$t},$u);
$rd=q#close#;
$sd=[];
$td=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$ud=bless({$o,$sd,$q,$td,$s,$t},$u);
$vd={$rd,$ud};
$wd=q#/io/fd_gc.b#;
$xd=bless({$x2,$nd,$l3,$m3,$n3,$qd,$o3,$vd,$D,$wd},$x3);
$yd={};
$zd=[];
$Ad=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Bd=bless({$o,$zd,$q,$Ad,$s,$t},$u);
$Cd=[];
$Dd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd={$C9,$Bd,$F9,$Ed};
$Gd=q#/io/fd_perlio.b#;
$Hd=bless({$x2,$yd,$l3,$m3,$n3,$m3,$o3,$Fd,$D,$Gd},$x3);
$Id=[$Z7,$Fc,$Mc,$Uc,$md,$xd,$Hd];
$Jd=bless({$x2,$xc,$D,$yc,$e3,$Id},$F2);
$Kd=q#io/fd.c::ctors#;
$Ld=q#ni:/io/fd.c#;
$Md={$F2,1};
$Nd=q#/io/fd.c#;
$Od=[$R8];
$Pd=bless({$x2,$Md,$D,$Nd,$e3,$Od},$f3);
$Qd=q#ni:/io/fd_fcntl.b#;
$Rd=q#ni:/io/fd_gc.b#;
$Sd=q#ni:/io/fd_init.b#;
$Td=q#ni:/io/fd_perlio.b#;
$Ud=q#ni:/io/fd_readers.b#;
$Vd=q#ni:/io/fd_shell.b#;
$Wd=q#ni:/io/file#;
$Xd={$z4,1};
$Yd=q#/io/file#;
$Zd={};
$ce=[];
$de=q#shift->{'name'}#;
$ee=bless({$o,$ce,$q,$de,$s,$t},$u);
$fe={$D,$ee};
$ge=q#/io/file_readers.b#;
$he=bless({$x2,$Zd,$l3,$m3,$n3,$m3,$o3,$fe,$D,$ge},$x3);
$ie={};
$je=q#mode#;
$ke=[];
$le=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$me=bless({$o,$ke,$q,$le,$s,$t},$u);
$ne={$je,$me};
$oe=q#/io/file_accessors.b#;
$pe=bless({$x2,$ie,$l3,$m3,$n3,$m3,$o3,$ne,$D,$oe},$x3);
$qe={};
$re=[];
$se=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$te=bless({$o,$re,$q,$se,$s,$t},$u);
$ue={$n4,$te};
$ve=q#/io/file_init.b#;
$we=bless({$x2,$qe,$l3,$m3,$n3,$m3,$o3,$ue,$D,$ve},$x3);
$xe={};
$ye=q#r#;
$ze=[];
$Ae=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Be=bless({$o,$ze,$q,$Ae,$s,$t},$u);
$Ce=[];
$De=q#shift->r->read(@_)#;
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe=q#w#;
$Ge=[];
$He=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Ie=bless({$o,$Ge,$q,$He,$s,$t},$u);
$Je=[];
$Ke=q#shift->w->write(@_)#;
$Le=bless({$o,$Je,$q,$Ke,$s,$t},$u);
$Me={$ye,$Be,$C9,$Ee,$Fe,$Ie,$F9,$Le};
$Ne=q#/io/file_io.b#;
$Oe=bless({$x2,$xe,$l3,$m3,$n3,$m3,$o3,$Me,$D,$Ne},$x3);
$Pe=[$Z7,$he,$pe,$we,$Oe];
$Qe=bless({$x2,$Xd,$D,$Yd,$e3,$Pe},$G2);
$Re=q#io/file.c::ctors#;
$Se=q#ni:/io/file.c#;
$Te={$G2,1};
$Ue=q#/io/file.c#;
$Ve=[$R8];
$We=bless({$x2,$Te,$D,$Ue,$e3,$Ve},$f3);
$Xe=q#ni:/io/file_accessors.b#;
$Ye=q#ni:/io/file_init.b#;
$Ze=q#ni:/io/file_io.b#;
$cf=q#ni:/io/file_readers.b#;
$df=q#ni:/io/named_io_fns.b#;
$ef={};
$ff=q#fcntl#;
$gf=[];
$hf=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$if=bless({$o,$gf,$q,$hf,$s,$t},$u);
$jf=[];
$kf=q#CORE::fork#;
$lf=bless({$o,$jf,$q,$kf,$s,$t},$u);
$mf=q#open2#;
$nf=[];
$of=q#CORE::open $_[0], $_[1]#;
$pf=bless({$o,$nf,$q,$of,$s,$t},$u);
$qf=q#waitpid#;
$rf=[];
$sf=q#CORE::waitpid $_[0], $_[1]#;
$tf=bless({$o,$rf,$q,$sf,$s,$t},$u);
$uf={$ff,$if,$Vb,$lf,$mf,$pf,$qf,$tf};
$vf=q#/io/named_io_fns.b#;
$wf=bless({$x2,$ef,$l3,$m3,$n3,$m3,$o3,$uf,$D,$vf},$x3);
$xf=q#main#;
$yf=q#ni:/io/null#;
$zf={$A4,1};
$Af=q#/io/null#;
$Bf={};
$Cf=[];
$Df=q#+{fd => undef}#;
$Ef=bless({$o,$Cf,$q,$Df,$s,$t},$u);
$Ff={$n4,$Ef};
$Gf=q#/io/null_init.b#;
$Hf=bless({$x2,$Bf,$l3,$m3,$n3,$m3,$o3,$Ff,$D,$Gf},$x3);
$If={};
$Jf=[];
$Kf=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Lf=bless({$o,$Jf,$q,$Kf,$s,$t},$u);
$Mf=[];
$Nf=q#shift->fd->read(@_)#;
$Of=bless({$o,$Mf,$q,$Nf,$s,$t},$u);
$Pf=[];
$Qf=q#shift->fd->write(@_)#;
$Rf=bless({$o,$Pf,$q,$Qf,$s,$t},$u);
$Sf={$pb,$Lf,$C9,$Of,$F9,$Rf};
$Tf=q#/io/null_io.b#;
$Uf=bless({$x2,$If,$l3,$m3,$n3,$m3,$o3,$Sf,$D,$Tf},$x3);
$Vf=[$Z7,$Hf,$Uf];
$Wf=bless({$x2,$zf,$D,$Af,$e3,$Vf},$H2);
$Xf=q#io/null.c::ctors#;
$Yf=q#ni:/io/null.c#;
$Zf={$H2,1};
$cg=q#/io/null.c#;
$dg=[$R8];
$eg=bless({$x2,$Zf,$D,$cg,$e3,$dg},$f3);
$fg=q#ni:/io/null_init.b#;
$gg=q#ni:/io/null_io.b#;
$hg=q#ni:/io/object#;
$ig=q#ni:/io/object.c#;
$jg=q#ni:/io/object_checks.b#;
$kg=q#ni:/io/object_constructors.b#;
$lg=q#ni:/io/object_memory.b#;
$mg=q#ni:/io/object_ops.b#;
$ng=q#ni:/io/object_transfer_sync.b#;
$og=q#ni:/io/pid#;
$pg={$C4,1};
$qg={};
$rg=q#pid#;
$sg=[];
$tg=q#shift->{'pid'}#;
$ug=bless({$o,$sg,$q,$tg,$s,$t},$u);
$vg=q#status#;
$wg=[];
$xg=q#shift->{'status'}#;
$yg=bless({$o,$wg,$q,$xg,$s,$t},$u);
$zg={$rg,$ug,$vg,$yg};
$Ag=q#/io/pid_readers.b#;
$Bg=bless({$x2,$qg,$l3,$m3,$n3,$m3,$o3,$zg,$D,$Ag},$x3);
$Cg={};
$Dg=[];
$Eg=q#shift->await#;
$Fg=bless({$o,$Dg,$q,$Eg,$s,$t},$u);
$Gg=[];
$Hg=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Ig=bless({$o,$Gg,$q,$Hg,$s,$t},$u);
$Jg={$n4,$Ig};
$Kg=q#/io/pid_init.b#;
$Lg=bless({$x2,$Cg,$l3,$m3,$n3,$Fg,$o3,$Jg,$D,$Kg},$x3);
$Mg={};
$Ng=q#await#;
$Og=[];
$Pg=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Qg=bless({$o,$Og,$q,$Pg,$s,$t},$u);
$Rg=q#running#;
$Sg=[];
$Tg=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Ug=bless({$o,$Sg,$q,$Tg,$s,$t},$u);
$Vg={$Ng,$Qg,$Rg,$Ug};
$Wg=q#/io/pid_wait.b#;
$Xg=bless({$x2,$Mg,$l3,$m3,$n3,$m3,$o3,$Vg,$D,$Wg},$x3);
$Yg={};
$Zg=[];
$ch=q#shift->stdout->read(@_)#;
$dh=bless({$o,$Zg,$q,$ch,$s,$t},$u);
$eh=[];
$fh=q#shift->stdin->write(@_)#;
$gh=bless({$o,$eh,$q,$fh,$s,$t},$u);
$hh={$C9,$dh,$F9,$gh};
$ih=q#/io/pid_io.b#;
$jh=bless({$x2,$Yg,$l3,$m3,$n3,$m3,$o3,$hh,$D,$ih},$x3);
$kh={};
$lh=[];
$mh=q#$_[0]->{external_fds}{$_[1]}#;
$nh=bless({$o,$lh,$q,$mh,$s,$t},$u);
$oh=[];
$ph=q#shift->fd(2)#;
$qh=bless({$o,$oh,$q,$ph,$s,$t},$u);
$rh=[];
$sh=q#shift->fd(0)#;
$th=bless({$o,$rh,$q,$sh,$s,$t},$u);
$uh=[];
$vh=q#shift->fd(1)#;
$wh=bless({$o,$uh,$q,$vh,$s,$t},$u);
$xh={$pb,$nh,$tb,$qh,$xb,$th,$Bb,$wh};
$yh=q#/io/pid_accessors.b#;
$zh=bless({$x2,$kh,$l3,$m3,$n3,$m3,$o3,$xh,$D,$yh},$x3);
$Ah=[$Z7,$Bg,$Lg,$Xg,$jh,$zh];
$Bh=bless({$x2,$pg,$D,$W1,$e3,$Ah},$J2);
$Ch=q#io/pid.c::ctors#;
$Dh=q#ni:/io/pid.c#;
$Eh={$J2,1};
$Fh=q#/io/pid.c#;
$Gh=[$R8];
$Hh=bless({$x2,$Eh,$D,$Fh,$e3,$Gh},$f3);
$Ih=q#ni:/io/pid_accessors.b#;
$Jh=q#ni:/io/pid_init.b#;
$Kh=q#ni:/io/pid_io.b#;
$Lh=q#ni:/io/pid_readers.b#;
$Mh=q#ni:/io/pid_wait.b#;
$Nh=q#ni:/io/str#;
$Oh={$D4,1};
$Ph=q#/io/str#;
$Qh={};
$Rh=q#data#;
$Sh=[];
$Th=q#shift->{'data'}#;
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh=q#end#;
$Wh=[];
$Xh=q#shift->{'end'}#;
$Yh=bless({$o,$Wh,$q,$Xh,$s,$t},$u);
$Zh=q#start#;
$ci=[];
$di=q#shift->{'start'}#;
$ei=bless({$o,$ci,$q,$di,$s,$t},$u);
$fi={$Rh,$Uh,$Vh,$Yh,$Zh,$ei};
$gi=q#/io/str_ro.b#;
$hi=bless({$x2,$Qh,$l3,$m3,$n3,$m3,$o3,$fi,$D,$gi},$x3);
$ii={};
$ji=[];
$ki=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$li=bless({$o,$ji,$q,$ki,$s,$t},$u);
$mi={$n4,$li};
$ni=q#/io/str_init.b#;
$oi=bless({$x2,$ii,$l3,$m3,$n3,$m3,$o3,$mi,$D,$ni},$x3);
$pi={};
$qi=[];
$ri=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$si=bless({$o,$qi,$q,$ri,$s,$t},$u);
$ti=q#remaining#;
$ui=[];
$vi=q#my $self = shift; $$self{end} - $$self{start}#;
$wi=bless({$o,$ui,$q,$vi,$s,$t},$u);
$xi=[];
$yi=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$zi=bless({$o,$xi,$q,$yi,$s,$t},$u);
$Ai={$C9,$si,$ti,$wi,$F9,$zi};
$Bi=q#/io/str_io.b#;
$Ci=bless({$x2,$pi,$l3,$m3,$n3,$m3,$o3,$Ai,$D,$Bi},$x3);
$Di=[$Z7,$hi,$oi,$Ci];
$Ei=bless({$x2,$Oh,$D,$Ph,$e3,$Di},$K2);
$Fi=q#io/str.c::ctors#;
$Gi=q#ni:/io/str.c#;
$Hi={$K2,1};
$Ii=q#/io/str.c#;
$Ji=[$R8];
$Ki=bless({$x2,$Hi,$D,$Ii,$e3,$Ji},$f3);
$Li=q#ni:/io/str_init.b#;
$Mi=q#ni:/io/str_io.b#;
$Ni=q#ni:/io/str_ro.b#;
$Oi=q#ni:/io/transfer#;
$Pi={$E4,1,$F4,1};
$Qi=q#/io/transfer#;
$Ri={};
$Si=[];
$Ti=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Ui=bless({$o,$Si,$q,$Ti,$s,$t},$u);
$Vi=[];
$Wi=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Xi=bless({$o,$Vi,$q,$Wi,$s,$t},$u);
$Yi=[];
$Zi=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$cj=bless({$o,$Yi,$q,$Zi,$s,$t},$u);
$dj={$C9,$Xi,$F9,$cj};
$ej=q#/io/transfer_io_interop.b#;
$fj=bless({$x2,$Ri,$l3,$Ui,$n3,$m3,$o3,$dj,$D,$ej},$x3);
$gj=[$W4,$fj];
$hj=bless({$x2,$Pi,$D,$Qi,$e3,$gj},$L2);
$ij=q#io/transfer.c::ctors#;
$jj=q#ni:/io/transfer.c#;
$kj={$L2,1,$M2,1};
$lj=q#/io/transfer.c#;
$mj={};
$nj=[];
$oj=q#my $self = shift;
ni('ni:/io/object')->def("/io/object_transfer_$1.b",
  "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\\@_)->run})
if $self->name =~ /transfer_(\\w+)$/;#;
$pj=bless({$o,$nj,$q,$oj,$s,$t},$u);
$qj={};
$rj=q#/io/transfer.c_into.b#;
$sj=bless({$x2,$mj,$l3,$pj,$n3,$m3,$o3,$qj,$D,$rj},$x3);
$tj=[$J6,$sj];
$uj=bless({$x2,$kj,$D,$lj,$e3,$tj},$f3);
$vj=q#ni:/io/transfer.c_into.b#;
$wj=q#ni:/io/transfer_io_interop.b#;
$xj=q#ni:/io/transfer_sync#;
$yj={$F4,1};
$zj=q#/io/transfer_sync#;
$Aj={};
$Bj=[];
$Cj=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Dj=bless({$o,$Bj,$q,$Cj,$s,$t},$u);
$Ej={$n4,$Dj};
$Fj=q#/io/transfer_sync_init.b#;
$Gj=bless({$x2,$Aj,$l3,$m3,$n3,$m3,$o3,$Ej,$D,$Fj},$x3);
$Hj={};
$Ij=q#run#;
$Jj=[];
$Kj=q#my $self = shift;
my $buf;
while ($self->read($buf, 32768)) {
  my $n = $self->write($buf);
  $self->die($!) unless defined $n;
  while ($n < length $buf) {
    my $n0 = $self->write(substr $buf, $n);
    $self->die($!) unless defined $n0;
    $n += $n0;
  }
}
$self;#;
$Lj=bless({$o,$Jj,$q,$Kj,$s,$t},$u);
$Mj={$Ij,$Lj};
$Nj=q#/io/transfer_sync_run.b#;
$Oj=bless({$x2,$Hj,$l3,$m3,$n3,$m3,$o3,$Mj,$D,$Nj},$x3);
$Pj=[$hj,$Gj,$Oj];
$Qj=bless({$x2,$yj,$D,$zj,$e3,$Pj},$M2);
$Rj=q#io/transfer_sync.c::ctors#;
$Sj=q#ni:/io/transfer_sync.c#;
$Tj={$M2,1};
$Uj=q#/io/transfer_sync.c#;
$Vj=[$uj];
$Wj=bless({$x2,$Tj,$D,$Uj,$e3,$Vj},$f3);
$Xj=q#ni:/io/transfer_sync_init.b#;
$Yj=q#ni:/io/transfer_sync_run.b#;
$Zj=q#ni:/lib/accessor.b#;
$ck=q#ni:/lib/behavior#;
$dk=q#ni:/lib/behavior.c#;
$ek=q#ni:/lib/branch#;
$fk={$z3,1};
$gk=q#/lib/branch#;
$hk={};
$ik=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$jk=bless({$q,$ik,$s,$t},$u);
$kk={$n4,$jk};
$lk=q#/lib/branch_init.b#;
$mk=bless({$x2,$hk,$l3,$m3,$n3,$m3,$o3,$kk,$D,$lk},$x3);
$nk=[$j5,$I3,$y3,$mk,$c6];
$ok=bless({$x2,$fk,$D,$gk,$e3,$nk},$O2);
$pk=q#lib/branch.c::ctors#;
$qk=q#ni:/lib/branch.b#;
$rk=q#ni:/lib/branch.c#;
$sk={$O2,1};
$tk=q#/lib/branch.c#;
$uk=[$O6];
$vk=bless({$x2,$sk,$D,$tk,$e3,$uk},$f3);
$wk=q#ni:/lib/branch_init.b#;
$xk=q#ni:/lib/class_init.b#;
$yk=q#ni:/lib/dataslice#;
$zk={$H4,1};
$Ak=q#/lib/dataslice#;
$Bk={};
$Ck=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Dk=bless({$q,$Ck,$s,$t},$u);
$Ek={$n4,$Dk};
$Fk=q#/lib/dataslice_init.b#;
$Gk=bless({$x2,$Bk,$l3,$m3,$n3,$m3,$o3,$Ek,$D,$Fk},$x3);
$Hk={};
$Ik=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Jk=bless({$q,$Ik,$s,$t},$u);
$Kk={$s3,$Jk};
$Lk=q#/lib/dataslice_apply.b#;
$Mk=bless({$x2,$Hk,$l3,$m3,$n3,$m3,$o3,$Kk,$D,$Lk},$x3);
$Nk=[$j5,$Gk,$Mk];
$Ok=bless({$x2,$zk,$D,$Ak,$e3,$Nk},$P2);
$Pk=q#lib/dataslice.c::ctors#;
$Qk=q#ni:/lib/dataslice.c#;
$Rk={$P2,1};
$Sk=q#/lib/dataslice.c#;
$Tk=[$O6];
$Uk=bless({$x2,$Rk,$D,$Sk,$e3,$Tk},$f3);
$Vk=q#ni:/lib/dataslice_apply.b#;
$Wk=q#ni:/lib/dataslice_init.b#;
$Xk=q#ni:/lib/definition.b#;
$Yk=q#ni:/lib/definition_def.b#;
$Zk=q#ni:/lib/definition_defdata.b#;
$cl=q#ni:/lib/doc#;
$dl={$F,1};
$el={};
$fl=q#shift; +{name => shift, doc => []}#;
$gl=bless({$q,$fl,$s,$t},$u);
$hl={$n4,$gl};
$il=q#/lib/doc_init.b#;
$jl=bless({$x2,$el,$l3,$m3,$n3,$m3,$o3,$hl,$D,$il},$x3);
$kl={};
$ll=q#'ni.doc'#;
$ml=bless({$q,$ll,$s,$t},$u);
$nl={$L3,$ml};
$ol=q#/lib/doc_namespace.b#;
$pl=bless({$x2,$kl,$l3,$m3,$n3,$m3,$o3,$nl,$D,$ol},$x3);
$ql={};
$rl=q#AUTOLOAD#;
$sl=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$tl=bless({$q,$sl,$s,$t},$u);
$ul={$rl,$tl};
$vl=q#/lib/doc_define.b#;
$wl=bless({$x2,$ql,$l3,$m3,$n3,$m3,$o3,$ul,$D,$vl},$x3);
$xl={};
$yl=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$zl=bless({$q,$yl,$s,$t},$u);
$Al=q#tests#;
$Bl=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Cl=bless({$q,$Bl,$s,$t},$u);
$Dl={$n,$zl,$Al,$Cl};
$El=q#/lib/doc_test.b#;
$Fl=bless({$x2,$xl,$l3,$m3,$n3,$m3,$o3,$Dl,$D,$El},$x3);
$Gl=[$W4,$I3,$jl,$pl,$wl,$Fl];
$Hl=bless({$x2,$dl,$D,$u2,$e3,$Gl},$Q2);
$Il=q#lib/doc.c::ctors#;
$Jl=q#ni:/lib/doc.c#;
$Kl={$Q2,1};
$Ll=q#/lib/doc.c#;
$Ml=[$J6];
$Nl=bless({$x2,$Kl,$D,$Ll,$e3,$Ml},$f3);
$Ol=q#ni:/lib/doc_define.b#;
$Pl=q#ni:/lib/doc_init.b#;
$Ql=q#ni:/lib/doc_namespace.b#;
$Rl=q#ni:/lib/doc_test.b#;
$Sl=q#ni:/lib/documentable.b#;
$Tl=q#ni:/lib/fn#;
$Ul={$u,1};
$Vl=q#/lib/fn#;
$Wl={};
$Xl=q#shift->compile#;
$Yl=bless({$q,$Xl,$s,$t},$u);
$Zl=q#compile#;
$cm=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$dm=bless({$q,$cm,$s,$t},$u);
$em=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$fm=bless({$q,$em,$s,$t},$u);
$gm={$Zl,$dm,$n4,$fm};
$hm=q#/lib/fn_init.b#;
$im=bless({$x2,$Wl,$l3,$Yl,$n3,$m3,$o3,$gm,$D,$hm},$x3);
$jm={};
$km=[];
$lm=q#shift->{'annotations'}#;
$mm=bless({$o,$km,$q,$lm,$s,$t},$u);
$nm=[];
$om=q#shift->{'code'}#;
$pm=bless({$o,$nm,$q,$om,$s,$t},$u);
$qm=q#fn#;
$rm=[];
$sm=q#shift->{'fn'}#;
$tm=bless({$o,$rm,$q,$sm,$s,$t},$u);
$um={$o,$mm,$q,$pm,$qm,$tm};
$vm=q#/lib/fn_ro.b#;
$wm=bless({$x2,$jm,$l3,$m3,$n3,$m3,$o3,$um,$D,$vm},$x3);
$xm={};
$ym=[];
$zm=q#shift->{code}#;
$Am=bless({$o,$ym,$q,$zm,$s,$t},$u);
$Bm=[];
$Cm=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Dm=bless({$o,$Bm,$q,$Cm,$s,$t},$u);
$Em={$F5,$Am,$M5,$Dm};
$Fm=q#/lib/fn_ops.b#;
$Gm=bless({$x2,$xm,$l3,$m3,$n3,$m3,$o3,$Em,$D,$Fm},$x3);
$Hm={};
$Im=q#serialize#;
$Jm=[];
$Km=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Lm=bless({$o,$Jm,$q,$Km,$s,$t},$u);
$Mm={$Im,$Lm};
$Nm=q#/lib/fn_serialize.b#;
$Om=bless({$x2,$Hm,$l3,$m3,$n3,$m3,$o3,$Mm,$D,$Nm},$x3);
$Pm=[$W4,$q6,$im,$wm,$Gm,$Om];
$Qm=bless({$x2,$Ul,$D,$Vl,$e3,$Pm},$R2);
$Rm=q#lib/fn.c::ctors#;
$Sm=q#ni:/lib/fn.c#;
$Tm={$R2,1};
$Um=q#/lib/fn.c#;
$Vm=[$J6];
$Wm=bless({$x2,$Tm,$D,$Um,$e3,$Vm},$f3);
$Xm=q#ni:/lib/fn_init.b#;
$Ym=q#ni:/lib/fn_ops.b#;
$Zm=q#ni:/lib/fn_ro.b#;
$cn=q#ni:/lib/fn_serialize.b#;
$dn=q#ni:/lib/gensym_generator_compact.b#;
$en={};
$fn=q#gensym#;
$gn=[];
$hn=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$in=bless({$o,$gn,$q,$hn,$s,$t},$u);
$jn={$fn,$in};
$kn=q#/lib/gensym_generator_compact.b#;
$ln=bless({$x2,$en,$l3,$m3,$n3,$m3,$o3,$jn,$D,$kn},$x3);
$mn=q#ni:/lib/global_static_test.b#;
$nn={};
$on=q#now#;
$pn=[];
$qn=q#ni('ni:/lib/test_value')->new(shift)#;
$rn=q#($)#;
$sn=bless({$o,$pn,$q,$qn,$s,$rn},$u);
$tn={$on,$sn};
$un=q#/lib/global_static_test.b#;
$vn=bless({$x2,$nn,$l3,$m3,$n3,$m3,$o3,$tn,$D,$un},$x3);
$wn=q#ni:/lib/image#;
$xn={$I4,1};
$yn=q#/lib/image#;
$zn={};
$An=[];
$Bn=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Cn=bless({$o,$An,$q,$Bn,$s,$t},$u);
$Dn={$n4,$Cn};
$En=q#/lib/image_init.b#;
$Fn=bless({$x2,$zn,$l3,$m3,$n3,$m3,$o3,$Dn,$D,$En},$x3);
$Gn={};
$Hn=q#address#;
$In=[];
$Jn=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Kn=bless({$o,$In,$q,$Jn,$s,$t},$u);
$Ln=q#allocate_gensym#;
$Mn=[];
$Nn=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$On=bless({$o,$Mn,$q,$Nn,$s,$t},$u);
$Pn=q#boot_side_effect#;
$Qn=[];
$Rn=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Sn=bless({$o,$Qn,$q,$Rn,$s,$t},$u);
$Tn=q#circular_links#;
$Un=[];
$Vn=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Wn=bless({$o,$Un,$q,$Vn,$s,$t},$u);
$Xn=q#finalizer#;
$Yn=[];
$Zn=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$co=bless({$o,$Yn,$q,$Zn,$s,$t},$u);
$do=q#quote#;
$eo=[];
$fo=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$go=bless({$o,$eo,$q,$fo,$s,$t},$u);
$ho=q#reconstruction#;
$io=[];
$jo=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$ko=bless({$o,$io,$q,$jo,$s,$t},$u);
$lo=q#side_effect#;
$mo=[];
$no=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$oo=bless({$o,$mo,$q,$no,$s,$t},$u);
$po=[];
$qo=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so={$Hn,$Kn,$Ln,$On,$Pn,$Sn,$Tn,$Wn,$Xn,$co,$do,$go,$ho,$ko,$lo,$oo,$F9,$ro};
$to=q#/lib/image_quoting.b#;
$uo=bless({$x2,$Gn,$l3,$m3,$n3,$m3,$o3,$so,$D,$to},$x3);
$vo={};
$wo=q#quote_code#;
$xo=[];
$yo=q#shift->die('cannot quote perl CODE refs', shift)#;
$zo=bless({$o,$xo,$q,$yo,$s,$t},$u);
$Ao={$wo,$zo};
$Bo=q#/lib/quote_code_fail.b#;
$Co=bless({$x2,$vo,$l3,$m3,$n3,$m3,$o3,$Ao,$D,$Bo},$x3);
$Do={};
$Eo=q#quote_array#;
$Fo=[];
$Go=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Ho=bless({$o,$Fo,$q,$Go,$s,$t},$u);
$Io=q#quote_hash#;
$Jo=[];
$Ko=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Lo=bless({$o,$Jo,$q,$Ko,$s,$t},$u);
$Mo=q#quote_scalar#;
$No=[];
$Oo=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Po=bless({$o,$No,$q,$Oo,$s,$t},$u);
$Qo=q#quote_scalar_ref#;
$Ro=[];
$So=q#'\\\\' . shift->quote(${$_[0]})#;
$To=bless({$o,$Ro,$q,$So,$s,$t},$u);
$Uo=q#quote_value#;
$Vo=[];
$Wo=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Xo=bless({$o,$Vo,$q,$Wo,$s,$t},$u);
$Yo={$Eo,$Ho,$Io,$Lo,$Mo,$Po,$Qo,$To,$Uo,$Xo};
$Zo=q#/lib/quote_values.b#;
$cp=bless({$x2,$Do,$l3,$m3,$n3,$m3,$o3,$Yo,$D,$Zo},$x3);
$dp={};
$ep=q#quote_blessed#;
$fp=[];
$gp=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$hp=bless({$o,$fp,$q,$gp,$s,$t},$u);
$ip=q#quote_class#;
$jp=[];
$kp=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$lp=bless({$o,$jp,$q,$kp,$s,$t},$u);
$mp=q#quote_object#;
$np=[];
$op=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$pp=bless({$o,$np,$q,$op,$s,$t},$u);
$qp={$ep,$hp,$ip,$lp,$mp,$pp};
$rp=q#/lib/quote_objects.b#;
$sp=bless({$x2,$dp,$l3,$m3,$n3,$m3,$o3,$qp,$D,$rp},$x3);
$tp={};
$up=q#circular_arrayref#;
$vp=[];
$wp=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$xp=bless({$o,$vp,$q,$wp,$s,$t},$u);
$yp=q#circular_hashref#;
$zp=[];
$Ap=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Bp=bless({$o,$zp,$q,$Ap,$s,$t},$u);
$Cp=q#is_circular#;
$Dp=[];
$Ep=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Fp=bless({$o,$Dp,$q,$Ep,$s,$t},$u);
$Gp={$up,$xp,$yp,$Bp,$Cp,$Fp};
$Hp=q#/lib/quote_circular_addressed.b#;
$Ip=bless({$x2,$tp,$l3,$m3,$n3,$m3,$o3,$Gp,$D,$Hp},$x3);
$Jp=[$W4,$Fn,$uo,$Co,$cp,$sp,$Ip,$ln];
$Kp=bless({$x2,$xn,$D,$yn,$e3,$Jp},$S2);
$Lp=q#lib/image.c::ctors#;
$Mp=q#ni:/lib/image.c#;
$Np={$S2,1};
$Op=q#/lib/image.c#;
$Pp=[$J6];
$Qp=bless({$x2,$Np,$D,$Op,$e3,$Pp},$f3);
$Rp=q#ni:/lib/image_init.b#;
$Sp=q#ni:/lib/image_quoting.b#;
$Tp=q#ni:/lib/instance.b#;
$Up=q#ni:/lib/instantiable.b#;
$Vp=q#ni:/lib/json.b#;
$Wp={};
$Xp=q#json_decode#;
$Yp=[];
$Zp=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$cq=bless({$o,$Yp,$q,$Zp,$s,$rn},$u);
$dq=q#json_encode#;
$eq=[];
$fq=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$gq=bless({$o,$eq,$q,$fq,$s,$rn},$u);
$hq=q#json_escape#;
$iq=[];
$jq=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$kq=bless({$o,$iq,$q,$jq,$s,$rn},$u);
$lq=q#json_unescape#;
$mq=[];
$nq=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$oq=bless({$o,$mq,$q,$nq,$s,$rn},$u);
$pq=q#json_unescape_one#;
$qq=[];
$rq=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$sq=bless({$o,$qq,$q,$rq,$s,$rn},$u);
$tq={$Xp,$cq,$dq,$gq,$hq,$kq,$lq,$oq,$pq,$sq};
$uq=q#/lib/json.b#;
$vq=bless({$x2,$Wp,$l3,$m3,$n3,$m3,$o3,$tq,$D,$uq},$x3);
$wq=q#ni#;
$xq=q#ni:/lib/name_as_string.b#;
$yq=q#ni:/lib/named.b#;
$zq=q#ni:/lib/named_in_ni.b#;
$Aq=q#ni:/lib/namespaced.b#;
$Bq=q#ni:/lib/ni#;
$Cq={$J4,1};
$Dq=q#/lib/ni#;
$Eq={};
$Fq=q#extend#;
$Gq=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Hq=bless({$q,$Gq,$s,$t},$u);
$Iq=q#is_mutable#;
$Jq=q#$0 ne "-" && -w $0#;
$Kq=bless({$q,$Jq,$s,$t},$u);
$Lq=q#modify#;
$Mq=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Nq=bless({$q,$Mq,$s,$t},$u);
$Oq={$Fq,$Hq,$Iq,$Kq,$Lq,$Nq};
$Pq=q#/lib/ni_self.b#;
$Qq=bless({$x2,$Eq,$l3,$m3,$n3,$m3,$o3,$Oq,$D,$Pq},$x3);
$Rq={};
$Sq=q#--internal/+=#;
$Tq=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Uq=bless({$q,$Tq,$s,$t},$u);
$Vq=q#--internal/eval#;
$Wq=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Xq=bless({$q,$Wq,$s,$t},$u);
$Yq=q#--internal/image#;
$Zq=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$cr=bless({$q,$Zq,$s,$t},$u);
$dr=q#--internal/test#;
$er=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$fr=bless({$q,$er,$s,$t},$u);
$gr=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$hr=bless({$q,$gr,$s,$t},$u);
$ir={$Sq,$Uq,$Vq,$Xq,$Yq,$cr,$dr,$fr,$Ij,$hr};
$jr=q#/lib/ni_main.b#;
$kr=bless({$x2,$Rq,$l3,$m3,$n3,$m3,$o3,$ir,$D,$jr},$x3);
$lr={};
$mr=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$nr=bless({$q,$mr,$s,$t},$u);
$or=q#resolver_for#;
$pr=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$qr=bless({$q,$pr,$s,$t},$u);
$rr={$Z3,$nr,$or,$qr};
$sr=q#/lib/ni_resolver.b#;
$tr=bless({$x2,$lr,$l3,$m3,$n3,$m3,$o3,$rr,$D,$sr},$x3);
$ur={};
$vr=q#exists#;
$wr=q#exists $_[0]->{named}{$_[1]}#;
$xr=bless({$q,$wr,$s,$t},$u);
$yr=q#quoted#;
$zr=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Ar=bless({$q,$zr,$s,$t},$u);
$Br={$vr,$xr,$yr,$Ar};
$Cr=q#/lib/ni_image.b#;
$Dr=bless({$x2,$ur,$l3,$m3,$n3,$m3,$o3,$Br,$D,$Cr},$x3);
$Er=[$W4,$Qq,$kr,$tr,$Dr];
$Fr=bless({$x2,$Cq,$D,$Dq,$e3,$Er},$T2);
$Gr=q#lib/ni.c::ctors#;
$Hr=q#ni:/lib/ni.c#;
$Ir={$T2,1};
$Jr=q#/lib/ni.c#;
$Kr=[$J6];
$Lr=bless({$x2,$Ir,$D,$Jr,$e3,$Kr},$f3);
$Mr=q#ni:/lib/ni_image.b#;
$Nr=q#ni:/lib/ni_main.b#;
$Or=q#ni:/lib/ni_resolver.b#;
$Pr=q#ni:/lib/ni_self.b#;
$Qr=q#ni:/lib/ni_static_util.b#;
$Rr={};
$Sr=q#abbrev#;
$Tr=[];
$Ur=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Vr=bless({$o,$Tr,$q,$Ur,$s,$t},$u);
$Wr=q#dor#;
$Xr=[];
$Yr=q#defined $_[0] ? $_[0] : $_[1]#;
$Zr=bless({$o,$Xr,$q,$Yr,$s,$t},$u);
$cs=q#indent#;
$ds=[];
$es=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$fs=bless({$o,$ds,$q,$es,$s,$t},$u);
$gs=q#max#;
$hs=[];
$is=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$js=bless({$o,$hs,$q,$is,$s,$t},$u);
$ks=q#maxstr#;
$ls=[];
$ms=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$ns=bless({$o,$ls,$q,$ms,$s,$t},$u);
$os=q#mean#;
$ps=[];
$qs=q#sum(@_) / (@_ || 1)#;
$rs=bless({$o,$ps,$q,$qs,$s,$t},$u);
$ss=q#min#;
$ts=[];
$us=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$vs=bless({$o,$ts,$q,$us,$s,$t},$u);
$ws=q#minstr#;
$xs=[];
$ys=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$zs=bless({$o,$xs,$q,$ys,$s,$t},$u);
$As=q#sgr#;
$Bs=[];
$Cs=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Ds=bless({$o,$Bs,$q,$Cs,$s,$t},$u);
$Es=q#sr#;
$Fs=[];
$Gs=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Hs=bless({$o,$Fs,$q,$Gs,$s,$t},$u);
$Is=q#sum#;
$Js=[];
$Ks=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Ls=bless({$o,$Js,$q,$Ks,$s,$t},$u);
$Ms=q#swap#;
$Ns=[];
$Os=q#@_[0, 1] = @_[1, 0]#;
$Ps=bless({$o,$Ns,$q,$Os,$s,$t},$u);
$Qs={$Sr,$Vr,$Wr,$Zr,$cs,$fs,$gs,$js,$ks,$ns,$os,$rs,$ss,$vs,$ws,$zs,$As,$Ds,$Es,$Hs,$Is,$Ls,$Ms,$Ps};
$Rs=q#/lib/ni_static_util.b#;
$Ss=bless({$x2,$Rr,$l3,$m3,$n3,$m3,$o3,$Qs,$D,$Rs},$x3);
$Ts=q#ni:/lib/perlbranch.b#;
$Us=q#ni:/lib/quote_circular_addressed.b#;
$Vs=q#ni:/lib/quote_code_fail.b#;
$Ws=q#ni:/lib/quote_objects.b#;
$Xs=q#ni:/lib/quote_simple#;
$Ys={$K4,1};
$Zs=q#/lib/quote_simple#;
$ct={};
$dt=[];
$et=q#+{}#;
$ft=bless({$o,$dt,$q,$et,$s,$t},$u);
$gt={$n4,$ft};
$ht=q#/lib/quote_simple_init.b#;
$it=bless({$x2,$ct,$l3,$m3,$n3,$m3,$o3,$gt,$D,$ht},$x3);
$jt={};
$kt=[];
$lt=bless({$o,$kt,$q,0,$s,$t},$u);
$mt=[];
$nt=q#shift->quote_value(shift)#;
$ot=bless({$o,$mt,$q,$nt,$s,$t},$u);
$pt={$Cp,$lt,$do,$ot};
$qt=q#/lib/quote_simple_quote.b#;
$rt=bless({$x2,$jt,$l3,$m3,$n3,$m3,$o3,$pt,$D,$qt},$x3);
$st=[$W4,$it,$rt,$Co,$cp,$sp];
$tt=bless({$x2,$Ys,$D,$Zs,$e3,$st},$U2);
$ut=q#lib/quote_simple.c::ctors#;
$vt=q#ni:/lib/quote_simple.c#;
$wt={$U2,1};
$xt=q#/lib/quote_simple.c#;
$yt=[$J6];
$zt=bless({$x2,$wt,$D,$xt,$e3,$yt},$f3);
$At=q#ni:/lib/quote_simple_init.b#;
$Bt=q#ni:/lib/quote_simple_quote.b#;
$Ct=q#ni:/lib/quote_values.b#;
$Dt=q#ni:/lib/ref_eq.b#;
$Et=q#ni:/lib/resolver.b#;
$Ft=q#ni:/lib/slice#;
$Gt={$x3,1};
$Ht=q#/lib/slice#;
$It=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Jt=bless({$q,$It,$s,$t},$u);
$Kt=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Lt=bless({$q,$Kt,$s,$t},$u);
$Mt=q#lib/slice::apply#;
$Nt=q#lib/slice::apply_unsafe#;
$Ot={};
$Pt=q#apply_unsafe#;
$Qt={$s3,$Jt,$Pt,$Lt};
$Rt=q#/lib/slice.b#;
$St=bless({$x2,$Ot,$o3,$Qt,$D,$Rt},$x3);
$Tt={};
$Ut=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Vt=bless({$q,$Ut,$s,$t},$u);
$Wt={$n4,$Vt};
$Xt=q#/lib/slice_init.b#;
$Yt=bless({$x2,$Tt,$o3,$Wt,$D,$Xt},$x3);
$Zt={};
$cu=[];
$du=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$eu=bless({$o,$cu,$q,$du,$s,$t},$u);
$fu={$Im,$eu};
$gu=q#/lib/slice_serialize.b#;
$hu=bless({$x2,$Zt,$l3,$m3,$n3,$m3,$o3,$fu,$D,$gu},$x3);
$iu=[$j5,$I3,$St,$Yt,$hu];
$ju=bless({$x2,$Gt,$D,$Ht,$e3,$iu},$V2);
$ku=q#lib/slice.c::ctors#;
$lu=q#ni:/lib/slice.b#;
$mu=q#ni:/lib/slice.c#;
$nu={$V2,1};
$ou=q#/lib/slice.c#;
$pu=[$O6];
$qu=bless({$x2,$nu,$D,$ou,$e3,$pu},$f3);
$ru=q#ni:/lib/slice_init.b#;
$su=q#ni:/lib/slice_serialize.b#;
$tu=q#ni:/lib/static_fn.b#;
$uu={};
$vu=[];
$wu=q#ni('ni:/lib/fn')->new(@_)#;
$xu=bless({$o,$vu,$q,$wu,$s,$rn},$u);
$yu=q#fp#;
$zu=[];
$Au=q#($$)#;
$Bu=bless({$o,$zu,$q,$wu,$s,$Au},$u);
$Cu={$qm,$xu,$yu,$Bu};
$Du=q#/lib/static_fn.b#;
$Eu=bless({$x2,$uu,$l3,$m3,$n3,$m3,$o3,$Cu,$D,$Du},$x3);
$Fu=q#ni:/lib/subclass.b#;
$Gu=q#ni:/lib/tag#;
$Hu={$J3,1};
$Iu=q#/lib/tag#;
$Ju={};
$Ku=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Lu=bless({$q,$Ku,$s,$t},$u);
$Mu={$s3,$Lu};
$Nu=q#/lib/tag.b#;
$Ou=bless({$x2,$Ju,$l3,$m3,$n3,$m3,$o3,$Mu,$D,$Nu},$x3);
$Pu={};
$Qu=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Ru=bless({$q,$Qu,$s,$t},$u);
$Su={$n4,$Ru};
$Tu=q#/lib/tag_init.b#;
$Uu=bless({$x2,$Pu,$l3,$m3,$n3,$m3,$o3,$Su,$D,$Tu},$x3);
$Vu=[$j5,$I3,$Ou,$Uu];
$Wu=bless({$x2,$Hu,$D,$Iu,$e3,$Vu},$W2);
$Xu=q#lib/tag.c::ctors#;
$Yu=q#ni:/lib/tag.b#;
$Zu=q#ni:/lib/tag.c#;
$cv={$W2,1};
$dv=q#/lib/tag.c#;
$ev=[$O6];
$fv=bless({$x2,$cv,$D,$dv,$e3,$ev},$f3);
$gv=q#ni:/lib/tag_init.b#;
$hv=q#ni:/lib/test_value#;
$iv={$L4,1};
$jv=q#/lib/test_value#;
$kv={};
$lv=[];
$mv=q#\\$_[1]#;
$nv=bless({$o,$lv,$q,$mv,$s,$t},$u);
$ov={$n4,$nv};
$pv=q#/lib/test_value_init.b#;
$qv=bless({$x2,$kv,$l3,$m3,$n3,$m3,$o3,$ov,$D,$pv},$x3);
$rv={};
$sv=q#(==#;
$tv=[];
$uv=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$vv=bless({$o,$tv,$q,$uv,$s,$t},$u);
$wv=q#diff#;
$xv=[];
$yv=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$zv=bless({$o,$xv,$q,$yv,$s,$t},$u);
$Av={$sv,$vv,$wv,$zv};
$Bv=q#/lib/test_value_eq.b#;
$Cv=bless({$x2,$rv,$l3,$m3,$n3,$m3,$o3,$Av,$D,$Bv},$x3);
$Dv={};
$Ev=[];
$Fv=q#ni::json_encode ${$_[0]}#;
$Gv=bless({$o,$Ev,$q,$Fv,$s,$t},$u);
$Hv={$F5,$Gv};
$Iv=q#/lib/test_value_str.b#;
$Jv=bless({$x2,$Dv,$l3,$m3,$n3,$m3,$o3,$Hv,$D,$Iv},$x3);
$Kv=[$W4,$qv,$Cv,$Jv];
$Lv=bless({$x2,$iv,$D,$jv,$e3,$Kv},$X2);
$Mv=q#lib/test_value.c::ctors#;
$Nv=q#ni:/lib/test_value.c#;
$Ov={$X2,1};
$Pv=q#/lib/test_value.c#;
$Qv=[$J6];
$Rv=bless({$x2,$Ov,$D,$Pv,$e3,$Qv},$f3);
$Sv=q#ni:/lib/test_value_eq.b#;
$Tv=q#ni:/lib/test_value_init.b#;
$Uv=q#ni:/lib/test_value_str.b#;
$Vv=q#ni:/metaclass#;
$Wv={$f3,1};
$Xv=q#/metaclass#;
$Yv=[$i4,$q6,$s4,$f6];
$Zv=bless({$x2,$Wv,$D,$Xv,$e3,$Yv},$Y2);
$cw=q#metaclass.c::ctors#;
$dw=q#ni:/metaclass.c#;
$ew={$Y2,1};
$fw=q#/metaclass.c#;
$gw=[$z6];
$hw=bless({$x2,$ew,$D,$fw,$e3,$gw},$f3);
$iw=q#ni:/module#;
$jw=q#ni:/module.c#;
$kw=q#ni:/object#;
$lw=q#ni:/object.c#;
$mw=q#ni:main#;
$nw={$xf,1};
$ow=[$Eu,$vn,$wf];
$pw=bless({$x2,$nw,$D,$xf,$e3,$ow},$g3);
$qw=q#module::ctors#;
$rw=q#ni:ni#;
$sw={$wq,1};
$tw={$wq,1};
$uw=q#json_escapes#;
$vw=q##;
$ww=q#b#;
$xw=q#	#;
$yw=q#t#;
$zw=q#
#;
$Aw=q#n#;
$Bw=q##;
$Cw=q#"#;
$Dw=q#/#;
$Ew=q#\\#;
$Fw={$vw,$ww,$xw,$yw,$zw,$Aw,$Bw,$ye,$Cw,$Cw,$Dw,$Dw,$Ew,$Ew};
$Gw=q#json_unescapes#;
$Hw={$Cw,$Cw,$Dw,$Dw,$Ew,$Ew,$ww,$vw,$Aw,$zw,$ye,$Bw,$yw,$xw};
$Iw={$uw,$Fw,$Gw,$Hw};
$Jw=q#/lib/json_data.b#;
$Kw=bless({$x2,$tw,$Rh,$Iw,$D,$Jw},$H4);
$Lw=q#lib/dataslice::ctors#;
$Mw=[$Kw,$vq,$Ss];
$Nw=bless({$x2,$sw,$D,$wq,$e3,$Mw},$g3);
$Ow={$d,$G,$I,$N,$O,$V,$W,$d1,$e1,$j1,$k1,$v1,$w1,$H1,$I1,$X1,$Y1,$f2,$g2,$v2,$w2,$z6,$B6,$S6,$T6,$J8,$L8,$T8,$U8,$v8,$V8,$H8,$W8,$o8,$X8,$k9,$m9,$q9,$r9,$i9,$s9,$M9,$O9,$S9,$T9,$A9,$U9,$K9,$V9,$oa,$qa,$ua,$va,$fa,$wa,$ma,$xa,$jc,$lc,$pc,$qc,$Pb,$rc,$hc,$sc,$Na,$tc,$Hb,$uc,$jb,$vc,$Ga,$wc,$Jd,$Ld,$Pd,$Qd,$md,$Rd,$xd,$Sd,$Mc,$Td,$Hd,$Ud,$Fc,$Vd,$Uc,$Wd,$Qe,$Se,$We,$Xe,$pe,$Ye,$we,$Ze,$Oe,$cf,$he,$df,$wf,$yf,$Wf,$Yf,$eg,$fg,$Hf,$gg,$Uf,$hg,$Z7,$ig,$R8,$jg,$z7,$kg,$H7,$lg,$P7,$mg,$f7,$ng,$X7,$og,$Bh,$Dh,$Hh,$Ih,$zh,$Jh,$Lg,$Kh,$jh,$Lh,$Bg,$Mh,$Xg,$Nh,$Ei,$Gi,$Ki,$Li,$oi,$Mi,$Ci,$Ni,$hi,$Oi,$hj,$jj,$uj,$vj,$sj,$wj,$fj,$xj,$Qj,$Sj,$Wj,$Xj,$Gj,$Yj,$Oj,$Zj,$D5,$ck,$j5,$dk,$O6,$ek,$ok,$qk,$y3,$rk,$vk,$wk,$mk,$xk,$s4,$yk,$Ok,$Qk,$Uk,$Vk,$Mk,$Wk,$Gk,$Xk,$c6,$Yk,$t5,$Zk,$Y5,$cl,$Hl,$Jl,$Nl,$Ol,$wl,$Pl,$jl,$Ql,$pl,$Rl,$Fl,$Sl,$h5,$Tl,$Qm,$Sm,$Wm,$Xm,$im,$Ym,$Gm,$Zm,$wm,$cn,$Om,$dn,$ln,$mn,$vn,$wn,$Kp,$Mp,$Qp,$Rp,$Fn,$Sp,$uo,$Tp,$U4,$Up,$q6,$Vp,$vq,$xq,$K5,$yq,$I3,$zq,$Q3,$Aq,$X3,$Bq,$Fr,$Hr,$Lr,$Mr,$Dr,$Nr,$kr,$Or,$tr,$Pr,$Qq,$Qr,$Ss,$Ts,$i4,$Us,$Ip,$Vs,$Co,$Ws,$sp,$Xs,$tt,$vt,$zt,$At,$it,$Bt,$rt,$Ct,$cp,$Dt,$R5,$Et,$g4,$Ft,$ju,$lu,$St,$mu,$qu,$ru,$Yt,$su,$hu,$tu,$Eu,$Fu,$x6,$Gu,$Wu,$Yu,$Ou,$Zu,$fv,$gv,$Uu,$hv,$Lv,$Nv,$Rv,$Sv,$Cv,$Tv,$qv,$Uv,$Jv,$Vv,$Zv,$dw,$hw,$iw,$f6,$jw,$Q6,$kw,$W4,$lw,$J6,$mw,$pw,$rw,$Nw};
$Pw=q#resolvers#;
$Qw=[];
$Rw=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Sw=bless({$o,$Qw,$q,$Rw,$s,$t},$u);
$Tw=q#file#;
$Uw=[];
$Vw=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Ww=bless({$o,$Uw,$q,$Vw,$s,$t},$u);
$Xw=q#null#;
$Yw=[];
$Zw=q#ni('ni:/io/null')->new#;
$cx=bless({$o,$Yw,$q,$Zw,$s,$t},$u);
$dx=q#sh#;
$ex=[];
$fx=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$gx=bless({$o,$ex,$q,$fx,$s,$t},$u);
$hx=q#str#;
$ix=[];
$jx=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$kx=bless({$o,$ix,$q,$jx,$s,$t},$u);
$lx={$pb,$Sw,$Tw,$Ww,$Xw,$cx,$dx,$gx,$hx,$kx};
$mx=bless({$c,$Ow,$Pw,$lx},$J4);
$nx=q#lib/ni::ctors#;
*$Nt=\&$Lt;
*$Mt=\&$Jt;
$y3->apply_unsafe($y2);
$y3->apply_unsafe($z2);
$y3->apply_unsafe($A2);
$y3->apply_unsafe($B2);
$y3->apply_unsafe($C2);
$y3->apply_unsafe($D2);
$y3->apply_unsafe($E2);
$y3->apply_unsafe($F2);
$y3->apply_unsafe($G2);
$y3->apply_unsafe($H2);
$y3->apply_unsafe($I2);
$y3->apply_unsafe($J2);
$y3->apply_unsafe($K2);
$y3->apply_unsafe($L2);
$y3->apply_unsafe($M2);
$y3->apply_unsafe($N2);
$y3->apply_unsafe($z3);
$y3->apply_unsafe($O2);
$y3->apply_unsafe($P2);
$y3->apply_unsafe($Q2);
$y3->apply_unsafe($R2);
$y3->apply_unsafe($S2);
$y3->apply_unsafe($T2);
$y3->apply_unsafe($U2);
$y3->apply_unsafe($V2);
$y3->apply_unsafe($W2);
$y3->apply_unsafe($X2);
$y3->apply_unsafe($f3);
$y3->apply_unsafe($Y2);
$y3->apply_unsafe($g3);
$y3->apply_unsafe($Z2);
$y3->apply_unsafe($c3);
$I3->apply_unsafe($y2);
$I3->apply_unsafe($z2);
$I3->apply_unsafe($A2);
$I3->apply_unsafe($B2);
$I3->apply_unsafe($C2);
$I3->apply_unsafe($D2);
$I3->apply_unsafe($E2);
$I3->apply_unsafe($F2);
$I3->apply_unsafe($G2);
$I3->apply_unsafe($H2);
$I3->apply_unsafe($I2);
$I3->apply_unsafe($J2);
$I3->apply_unsafe($K2);
$I3->apply_unsafe($L2);
$I3->apply_unsafe($M2);
$I3->apply_unsafe($N2);
$I3->apply_unsafe($z3);
$I3->apply_unsafe($O2);
$I3->apply_unsafe($P2);
$I3->apply_unsafe($F);
$I3->apply_unsafe($Q2);
$I3->apply_unsafe($R2);
$I3->apply_unsafe($S2);
$I3->apply_unsafe($T2);
$I3->apply_unsafe($U2);
$I3->apply_unsafe($x3);
$I3->apply_unsafe($V2);
$I3->apply_unsafe($J3);
$I3->apply_unsafe($W2);
$I3->apply_unsafe($X2);
$I3->apply_unsafe($f3);
$I3->apply_unsafe($Y2);
$I3->apply_unsafe($g3);
$I3->apply_unsafe($Z2);
$I3->apply_unsafe($c3);
$Q3->apply_unsafe($y2);
$Q3->apply_unsafe($z2);
$Q3->apply_unsafe($A2);
$Q3->apply_unsafe($B2);
$Q3->apply_unsafe($C2);
$Q3->apply_unsafe($D2);
$Q3->apply_unsafe($E2);
$Q3->apply_unsafe($F2);
$Q3->apply_unsafe($G2);
$Q3->apply_unsafe($H2);
$Q3->apply_unsafe($I2);
$Q3->apply_unsafe($J2);
$Q3->apply_unsafe($K2);
$Q3->apply_unsafe($L2);
$Q3->apply_unsafe($M2);
$Q3->apply_unsafe($N2);
$Q3->apply_unsafe($z3);
$Q3->apply_unsafe($O2);
$Q3->apply_unsafe($P2);
$Q3->apply_unsafe($Q2);
$Q3->apply_unsafe($R2);
$Q3->apply_unsafe($S2);
$Q3->apply_unsafe($T2);
$Q3->apply_unsafe($U2);
$Q3->apply_unsafe($x3);
$Q3->apply_unsafe($V2);
$Q3->apply_unsafe($J3);
$Q3->apply_unsafe($W2);
$Q3->apply_unsafe($X2);
$Q3->apply_unsafe($f3);
$Q3->apply_unsafe($Y2);
$Q3->apply_unsafe($g3);
$Q3->apply_unsafe($Z2);
$Q3->apply_unsafe($c3);
$X3->apply_unsafe($y2);
$X3->apply_unsafe($z2);
$X3->apply_unsafe($A2);
$X3->apply_unsafe($B2);
$X3->apply_unsafe($C2);
$X3->apply_unsafe($D2);
$X3->apply_unsafe($E2);
$X3->apply_unsafe($F2);
$X3->apply_unsafe($G2);
$X3->apply_unsafe($H2);
$X3->apply_unsafe($I2);
$X3->apply_unsafe($J2);
$X3->apply_unsafe($K2);
$X3->apply_unsafe($L2);
$X3->apply_unsafe($M2);
$X3->apply_unsafe($N2);
$X3->apply_unsafe($z3);
$X3->apply_unsafe($O2);
$X3->apply_unsafe($P2);
$X3->apply_unsafe($Q2);
$X3->apply_unsafe($R2);
$X3->apply_unsafe($S2);
$X3->apply_unsafe($T2);
$X3->apply_unsafe($U2);
$X3->apply_unsafe($x3);
$X3->apply_unsafe($V2);
$X3->apply_unsafe($J3);
$X3->apply_unsafe($W2);
$X3->apply_unsafe($X2);
$X3->apply_unsafe($f3);
$X3->apply_unsafe($Y2);
$X3->apply_unsafe($g3);
$X3->apply_unsafe($Z2);
$X3->apply_unsafe($c3);
$g4->apply_unsafe($y2);
$g4->apply_unsafe($z2);
$g4->apply_unsafe($A2);
$g4->apply_unsafe($B2);
$g4->apply_unsafe($C2);
$g4->apply_unsafe($D2);
$g4->apply_unsafe($E2);
$g4->apply_unsafe($F2);
$g4->apply_unsafe($G2);
$g4->apply_unsafe($H2);
$g4->apply_unsafe($I2);
$g4->apply_unsafe($J2);
$g4->apply_unsafe($K2);
$g4->apply_unsafe($L2);
$g4->apply_unsafe($M2);
$g4->apply_unsafe($N2);
$g4->apply_unsafe($z3);
$g4->apply_unsafe($O2);
$g4->apply_unsafe($P2);
$g4->apply_unsafe($Q2);
$g4->apply_unsafe($R2);
$g4->apply_unsafe($S2);
$g4->apply_unsafe($T2);
$g4->apply_unsafe($U2);
$g4->apply_unsafe($V2);
$g4->apply_unsafe($J3);
$g4->apply_unsafe($W2);
$g4->apply_unsafe($X2);
$g4->apply_unsafe($f3);
$g4->apply_unsafe($Y2);
$g4->apply_unsafe($g3);
$g4->apply_unsafe($Z2);
$g4->apply_unsafe($c3);
$s4->apply_unsafe($y2);
$s4->apply_unsafe($z2);
$s4->apply_unsafe($A2);
$s4->apply_unsafe($B2);
$s4->apply_unsafe($C2);
$s4->apply_unsafe($D2);
$s4->apply_unsafe($E2);
$s4->apply_unsafe($F2);
$s4->apply_unsafe($G2);
$s4->apply_unsafe($H2);
$s4->apply_unsafe($I2);
$s4->apply_unsafe($J2);
$s4->apply_unsafe($K2);
$s4->apply_unsafe($L2);
$s4->apply_unsafe($M2);
$s4->apply_unsafe($N2);
$s4->apply_unsafe($O2);
$s4->apply_unsafe($P2);
$s4->apply_unsafe($Q2);
$s4->apply_unsafe($R2);
$s4->apply_unsafe($S2);
$s4->apply_unsafe($T2);
$s4->apply_unsafe($U2);
$s4->apply_unsafe($V2);
$s4->apply_unsafe($W2);
$s4->apply_unsafe($X2);
$s4->apply_unsafe($f3);
$s4->apply_unsafe($Y2);
$s4->apply_unsafe($g3);
$s4->apply_unsafe($Z2);
$s4->apply_unsafe($c3);
$U4->apply_unsafe($y2);
$U4->apply_unsafe($z2);
$U4->apply_unsafe($t4);
$U4->apply_unsafe($A2);
$U4->apply_unsafe($u4);
$U4->apply_unsafe($B2);
$U4->apply_unsafe($v4);
$U4->apply_unsafe($C2);
$U4->apply_unsafe($w4);
$U4->apply_unsafe($D2);
$U4->apply_unsafe($x4);
$U4->apply_unsafe($E2);
$U4->apply_unsafe($y4);
$U4->apply_unsafe($F2);
$U4->apply_unsafe($z4);
$U4->apply_unsafe($G2);
$U4->apply_unsafe($A4);
$U4->apply_unsafe($H2);
$U4->apply_unsafe($B4);
$U4->apply_unsafe($I2);
$U4->apply_unsafe($C4);
$U4->apply_unsafe($J2);
$U4->apply_unsafe($D4);
$U4->apply_unsafe($K2);
$U4->apply_unsafe($E4);
$U4->apply_unsafe($L2);
$U4->apply_unsafe($F4);
$U4->apply_unsafe($M2);
$U4->apply_unsafe($G4);
$U4->apply_unsafe($N2);
$U4->apply_unsafe($z3);
$U4->apply_unsafe($O2);
$U4->apply_unsafe($H4);
$U4->apply_unsafe($P2);
$U4->apply_unsafe($F);
$U4->apply_unsafe($Q2);
$U4->apply_unsafe($u);
$U4->apply_unsafe($R2);
$U4->apply_unsafe($I4);
$U4->apply_unsafe($S2);
$U4->apply_unsafe($J4);
$U4->apply_unsafe($T2);
$U4->apply_unsafe($K4);
$U4->apply_unsafe($U2);
$U4->apply_unsafe($x3);
$U4->apply_unsafe($V2);
$U4->apply_unsafe($J3);
$U4->apply_unsafe($W2);
$U4->apply_unsafe($L4);
$U4->apply_unsafe($X2);
$U4->apply_unsafe($f3);
$U4->apply_unsafe($Y2);
$U4->apply_unsafe($g3);
$U4->apply_unsafe($Z2);
$U4->apply_unsafe($M4);
$U4->apply_unsafe($c3);
$h5->apply_unsafe($y2);
$h5->apply_unsafe($z2);
$h5->apply_unsafe($A2);
$h5->apply_unsafe($B2);
$h5->apply_unsafe($C2);
$h5->apply_unsafe($D2);
$h5->apply_unsafe($E2);
$h5->apply_unsafe($F2);
$h5->apply_unsafe($G2);
$h5->apply_unsafe($H2);
$h5->apply_unsafe($I2);
$h5->apply_unsafe($J2);
$h5->apply_unsafe($K2);
$h5->apply_unsafe($L2);
$h5->apply_unsafe($M2);
$h5->apply_unsafe($G4);
$h5->apply_unsafe($N2);
$h5->apply_unsafe($z3);
$h5->apply_unsafe($O2);
$h5->apply_unsafe($H4);
$h5->apply_unsafe($P2);
$h5->apply_unsafe($Q2);
$h5->apply_unsafe($R2);
$h5->apply_unsafe($S2);
$h5->apply_unsafe($T2);
$h5->apply_unsafe($U2);
$h5->apply_unsafe($x3);
$h5->apply_unsafe($V2);
$h5->apply_unsafe($J3);
$h5->apply_unsafe($W2);
$h5->apply_unsafe($X2);
$h5->apply_unsafe($f3);
$h5->apply_unsafe($Y2);
$h5->apply_unsafe($g3);
$h5->apply_unsafe($Z2);
$h5->apply_unsafe($c3);
$t5->apply_unsafe($y2);
$t5->apply_unsafe($z2);
$t5->apply_unsafe($A2);
$t5->apply_unsafe($B2);
$t5->apply_unsafe($C2);
$t5->apply_unsafe($D2);
$t5->apply_unsafe($E2);
$t5->apply_unsafe($F2);
$t5->apply_unsafe($G2);
$t5->apply_unsafe($H2);
$t5->apply_unsafe($I2);
$t5->apply_unsafe($J2);
$t5->apply_unsafe($K2);
$t5->apply_unsafe($L2);
$t5->apply_unsafe($M2);
$t5->apply_unsafe($N2);
$t5->apply_unsafe($z3);
$t5->apply_unsafe($O2);
$t5->apply_unsafe($P2);
$t5->apply_unsafe($Q2);
$t5->apply_unsafe($R2);
$t5->apply_unsafe($S2);
$t5->apply_unsafe($T2);
$t5->apply_unsafe($U2);
$t5->apply_unsafe($V2);
$t5->apply_unsafe($W2);
$t5->apply_unsafe($X2);
$t5->apply_unsafe($f3);
$t5->apply_unsafe($Y2);
$t5->apply_unsafe($g3);
$t5->apply_unsafe($Z2);
$t5->apply_unsafe($c3);
$D5->apply_unsafe($y2);
$D5->apply_unsafe($z2);
$D5->apply_unsafe($A2);
$D5->apply_unsafe($B2);
$D5->apply_unsafe($C2);
$D5->apply_unsafe($D2);
$D5->apply_unsafe($E2);
$D5->apply_unsafe($F2);
$D5->apply_unsafe($G2);
$D5->apply_unsafe($H2);
$D5->apply_unsafe($I2);
$D5->apply_unsafe($J2);
$D5->apply_unsafe($K2);
$D5->apply_unsafe($L2);
$D5->apply_unsafe($M2);
$D5->apply_unsafe($N2);
$D5->apply_unsafe($z3);
$D5->apply_unsafe($O2);
$D5->apply_unsafe($P2);
$D5->apply_unsafe($Q2);
$D5->apply_unsafe($R2);
$D5->apply_unsafe($S2);
$D5->apply_unsafe($T2);
$D5->apply_unsafe($U2);
$D5->apply_unsafe($V2);
$D5->apply_unsafe($W2);
$D5->apply_unsafe($X2);
$D5->apply_unsafe($f3);
$D5->apply_unsafe($Y2);
$D5->apply_unsafe($g3);
$D5->apply_unsafe($Z2);
$D5->apply_unsafe($c3);
$K5->apply_unsafe($y2);
$K5->apply_unsafe($z2);
$K5->apply_unsafe($A2);
$K5->apply_unsafe($B2);
$K5->apply_unsafe($C2);
$K5->apply_unsafe($D2);
$K5->apply_unsafe($E2);
$K5->apply_unsafe($F2);
$K5->apply_unsafe($G2);
$K5->apply_unsafe($H2);
$K5->apply_unsafe($I2);
$K5->apply_unsafe($J2);
$K5->apply_unsafe($K2);
$K5->apply_unsafe($L2);
$K5->apply_unsafe($M2);
$K5->apply_unsafe($N2);
$K5->apply_unsafe($z3);
$K5->apply_unsafe($O2);
$K5->apply_unsafe($P2);
$K5->apply_unsafe($Q2);
$K5->apply_unsafe($R2);
$K5->apply_unsafe($S2);
$K5->apply_unsafe($T2);
$K5->apply_unsafe($U2);
$K5->apply_unsafe($V2);
$K5->apply_unsafe($W2);
$K5->apply_unsafe($X2);
$K5->apply_unsafe($f3);
$K5->apply_unsafe($Y2);
$K5->apply_unsafe($g3);
$K5->apply_unsafe($Z2);
$K5->apply_unsafe($c3);
$R5->apply_unsafe($y2);
$R5->apply_unsafe($z2);
$R5->apply_unsafe($A2);
$R5->apply_unsafe($B2);
$R5->apply_unsafe($C2);
$R5->apply_unsafe($D2);
$R5->apply_unsafe($E2);
$R5->apply_unsafe($F2);
$R5->apply_unsafe($G2);
$R5->apply_unsafe($H2);
$R5->apply_unsafe($I2);
$R5->apply_unsafe($J2);
$R5->apply_unsafe($K2);
$R5->apply_unsafe($L2);
$R5->apply_unsafe($M2);
$R5->apply_unsafe($N2);
$R5->apply_unsafe($z3);
$R5->apply_unsafe($O2);
$R5->apply_unsafe($P2);
$R5->apply_unsafe($Q2);
$R5->apply_unsafe($R2);
$R5->apply_unsafe($S2);
$R5->apply_unsafe($T2);
$R5->apply_unsafe($U2);
$R5->apply_unsafe($V2);
$R5->apply_unsafe($W2);
$R5->apply_unsafe($X2);
$R5->apply_unsafe($f3);
$R5->apply_unsafe($Y2);
$R5->apply_unsafe($g3);
$R5->apply_unsafe($Z2);
$R5->apply_unsafe($c3);
$Y5->apply_unsafe($y2);
$Y5->apply_unsafe($z2);
$Y5->apply_unsafe($A2);
$Y5->apply_unsafe($B2);
$Y5->apply_unsafe($C2);
$Y5->apply_unsafe($D2);
$Y5->apply_unsafe($E2);
$Y5->apply_unsafe($F2);
$Y5->apply_unsafe($G2);
$Y5->apply_unsafe($H2);
$Y5->apply_unsafe($I2);
$Y5->apply_unsafe($J2);
$Y5->apply_unsafe($K2);
$Y5->apply_unsafe($L2);
$Y5->apply_unsafe($M2);
$Y5->apply_unsafe($N2);
$Y5->apply_unsafe($z3);
$Y5->apply_unsafe($O2);
$Y5->apply_unsafe($P2);
$Y5->apply_unsafe($Q2);
$Y5->apply_unsafe($R2);
$Y5->apply_unsafe($S2);
$Y5->apply_unsafe($T2);
$Y5->apply_unsafe($U2);
$Y5->apply_unsafe($V2);
$Y5->apply_unsafe($W2);
$Y5->apply_unsafe($X2);
$Y5->apply_unsafe($f3);
$Y5->apply_unsafe($Y2);
$Y5->apply_unsafe($g3);
$Y5->apply_unsafe($Z2);
$Y5->apply_unsafe($c3);
$q6->apply_unsafe($y2);
$q6->apply_unsafe($z2);
$q6->apply_unsafe($A2);
$q6->apply_unsafe($B2);
$q6->apply_unsafe($C2);
$q6->apply_unsafe($D2);
$q6->apply_unsafe($E2);
$q6->apply_unsafe($F2);
$q6->apply_unsafe($G2);
$q6->apply_unsafe($H2);
$q6->apply_unsafe($I2);
$q6->apply_unsafe($J2);
$q6->apply_unsafe($K2);
$q6->apply_unsafe($L2);
$q6->apply_unsafe($M2);
$q6->apply_unsafe($N2);
$q6->apply_unsafe($O2);
$q6->apply_unsafe($P2);
$q6->apply_unsafe($Q2);
$q6->apply_unsafe($u);
$q6->apply_unsafe($R2);
$q6->apply_unsafe($S2);
$q6->apply_unsafe($T2);
$q6->apply_unsafe($U2);
$q6->apply_unsafe($x3);
$q6->apply_unsafe($V2);
$q6->apply_unsafe($J3);
$q6->apply_unsafe($W2);
$q6->apply_unsafe($X2);
$q6->apply_unsafe($f3);
$q6->apply_unsafe($Y2);
$q6->apply_unsafe($Z2);
$q6->apply_unsafe($c3);
$x6->apply_unsafe($y2);
$x6->apply_unsafe($z2);
$x6->apply_unsafe($A2);
$x6->apply_unsafe($B2);
$x6->apply_unsafe($C2);
$x6->apply_unsafe($D2);
$x6->apply_unsafe($E2);
$x6->apply_unsafe($F2);
$x6->apply_unsafe($G2);
$x6->apply_unsafe($H2);
$x6->apply_unsafe($I2);
$x6->apply_unsafe($J2);
$x6->apply_unsafe($K2);
$x6->apply_unsafe($L2);
$x6->apply_unsafe($M2);
$x6->apply_unsafe($N2);
$x6->apply_unsafe($O2);
$x6->apply_unsafe($P2);
$x6->apply_unsafe($Q2);
$x6->apply_unsafe($R2);
$x6->apply_unsafe($S2);
$x6->apply_unsafe($T2);
$x6->apply_unsafe($U2);
$x6->apply_unsafe($V2);
$x6->apply_unsafe($W2);
$x6->apply_unsafe($X2);
$x6->apply_unsafe($Y2);
$x6->apply_unsafe($Z2);
$x6->apply_unsafe($c3);
$f7->apply_unsafe($t4);
$f7->apply_unsafe($v4);
$f7->apply_unsafe($w4);
$f7->apply_unsafe($x4);
$f7->apply_unsafe($y4);
$f7->apply_unsafe($z4);
$f7->apply_unsafe($A4);
$f7->apply_unsafe($B4);
$f7->apply_unsafe($C4);
$f7->apply_unsafe($D4);
$z7->apply_unsafe($t4);
$z7->apply_unsafe($v4);
$z7->apply_unsafe($w4);
$z7->apply_unsafe($x4);
$z7->apply_unsafe($y4);
$z7->apply_unsafe($z4);
$z7->apply_unsafe($A4);
$z7->apply_unsafe($B4);
$z7->apply_unsafe($C4);
$z7->apply_unsafe($D4);
$H7->apply_unsafe($t4);
$H7->apply_unsafe($v4);
$H7->apply_unsafe($w4);
$H7->apply_unsafe($x4);
$H7->apply_unsafe($y4);
$H7->apply_unsafe($z4);
$H7->apply_unsafe($A4);
$H7->apply_unsafe($B4);
$H7->apply_unsafe($C4);
$H7->apply_unsafe($D4);
$P7->apply_unsafe($t4);
$P7->apply_unsafe($v4);
$P7->apply_unsafe($w4);
$P7->apply_unsafe($x4);
$P7->apply_unsafe($y4);
$P7->apply_unsafe($z4);
$P7->apply_unsafe($A4);
$P7->apply_unsafe($B4);
$P7->apply_unsafe($C4);
$P7->apply_unsafe($D4);
$X7->apply_unsafe($t4);
$X7->apply_unsafe($v4);
$X7->apply_unsafe($w4);
$X7->apply_unsafe($x4);
$X7->apply_unsafe($y4);
$X7->apply_unsafe($z4);
$X7->apply_unsafe($A4);
$X7->apply_unsafe($B4);
$X7->apply_unsafe($C4);
$X7->apply_unsafe($D4);
$o8->apply_unsafe($t4);
$v8->apply_unsafe($t4);
$H8->apply_unsafe($t4);
$i9->apply_unsafe($u4);
$A9->apply_unsafe($v4);
$K9->apply_unsafe($v4);
$fa->apply_unsafe($w4);
$ma->apply_unsafe($w4);
$Ga->apply_unsafe($x4);
$Na->apply_unsafe($x4);
$jb->apply_unsafe($x4);
$Hb->apply_unsafe($x4);
$Pb->apply_unsafe($x4);
$hc->apply_unsafe($x4);
$Fc->apply_unsafe($y4);
$Mc->apply_unsafe($y4);
$Uc->apply_unsafe($y4);
$md->apply_unsafe($y4);
$xd->apply_unsafe($y4);
$Hd->apply_unsafe($y4);
$he->apply_unsafe($z4);
$pe->apply_unsafe($z4);
$we->apply_unsafe($z4);
$Oe->apply_unsafe($z4);
$wf->apply_unsafe($xf);
$Hf->apply_unsafe($A4);
$Uf->apply_unsafe($A4);
$Bg->apply_unsafe($C4);
$Lg->apply_unsafe($C4);
$Xg->apply_unsafe($C4);
$jh->apply_unsafe($C4);
$zh->apply_unsafe($C4);
$hi->apply_unsafe($D4);
$oi->apply_unsafe($D4);
$Ci->apply_unsafe($D4);
$fj->apply_unsafe($E4);
$fj->apply_unsafe($F4);
$sj->apply_unsafe($L2);
$sj->apply_unsafe($M2);
$Gj->apply_unsafe($F4);
$Oj->apply_unsafe($F4);
$mk->apply_unsafe($z3);
$Gk->apply_unsafe($H4);
$Mk->apply_unsafe($H4);
$jl->apply_unsafe($F);
$pl->apply_unsafe($F);
$wl->apply_unsafe($F);
$Fl->apply_unsafe($F);
$im->apply_unsafe($u);
$wm->apply_unsafe($u);
$Gm->apply_unsafe($u);
$Om->apply_unsafe($u);
$ln->apply_unsafe($I4);
$vn->apply_unsafe($xf);
$Fn->apply_unsafe($I4);
$uo->apply_unsafe($I4);
$Co->apply_unsafe($I4);
$Co->apply_unsafe($K4);
$cp->apply_unsafe($I4);
$cp->apply_unsafe($K4);
$sp->apply_unsafe($I4);
$sp->apply_unsafe($K4);
$Ip->apply_unsafe($I4);
$vq->apply_unsafe($wq);
$Qq->apply_unsafe($J4);
$kr->apply_unsafe($J4);
$tr->apply_unsafe($J4);
$Dr->apply_unsafe($J4);
$Ss->apply_unsafe($wq);
$it->apply_unsafe($K4);
$rt->apply_unsafe($K4);
$St->apply_unsafe($x3);
$Yt->apply_unsafe($x3);
$hu->apply_unsafe($x3);
$Eu->apply_unsafe($xf);
$Ou->apply_unsafe($J3);
$Uu->apply_unsafe($J3);
$qv->apply_unsafe($L4);
$Cv->apply_unsafe($L4);
$Jv->apply_unsafe($L4);
$ni::self=$mx;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$H;
&$_($d1)for@$H;
&$_($j1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$H;
&$_($D1)for@$w;
&$_($H1)for@$H;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$H;
&$_($f2)for@$H;
&$_($n2)for@$w;
&$_($r2)for@$w;
&$_($v2)for@$H;
&$_($r3)for@$w;
&$_($u3)for@$w;
&$_($y3)for@$A3;
&$_($D3)for@$w;
&$_($F3)for@$w;
&$_($I3)for@$A3;
&$_($N3)for@$w;
&$_($Q3)for@$A3;
&$_($U3)for@$w;
&$_($X3)for@$A3;
&$_($d4)for@$w;
&$_($g4)for@$A3;
&$_($i4)for@$j4;
&$_($m4)for@$w;
&$_($p4)for@$w;
&$_($s4)for@$A3;
&$_($R4)for@$w;
&$_($U4)for@$A3;
&$_($W4)for@$X4;
&$_($e5)for@$w;
&$_($h5)for@$A3;
&$_($j5)for@$k5;
&$_($q5)for@$w;
&$_($t5)for@$A3;
&$_($x5)for@$w;
&$_($A5)for@$w;
&$_($D5)for@$A3;
&$_($H5)for@$w;
&$_($K5)for@$A3;
&$_($O5)for@$w;
&$_($R5)for@$A3;
&$_($V5)for@$w;
&$_($Y5)for@$A3;
&$_($c6)for@$d6;
&$_($f6)for@$g6;
&$_($k6)for@$w;
&$_($n6)for@$w;
&$_($q6)for@$A3;
&$_($u6)for@$w;
&$_($x6)for@$A3;
&$_($z6)for@$A6;
&$_($J6)for@$K6;
&$_($O6)for@$K6;
&$_($Q6)for@$K6;
&$_($S6)for@$K6;
&$_($c7)for@$w;
&$_($f7)for@$A3;
&$_($k7)for@$w;
&$_($o7)for@$w;
&$_($s7)for@$w;
&$_($w7)for@$w;
&$_($z7)for@$A3;
&$_($E7)for@$w;
&$_($H7)for@$A3;
&$_($M7)for@$w;
&$_($P7)for@$A3;
&$_($U7)for@$w;
&$_($X7)for@$A3;
&$_($Z7)for@$c8;
&$_($h8)for@$w;
&$_($l8)for@$w;
&$_($o8)for@$A3;
&$_($s8)for@$w;
&$_($v8)for@$A3;
&$_($A8)for@$w;
&$_($E8)for@$w;
&$_($H8)for@$A3;
&$_($J8)for@$K8;
&$_($R8)for@$K6;
&$_($T8)for@$K6;
&$_($f9)for@$w;
&$_($i9)for@$A3;
&$_($k9)for@$l9;
&$_($q9)for@$K6;
&$_($x9)for@$w;
&$_($A9)for@$A3;
&$_($E9)for@$w;
&$_($H9)for@$w;
&$_($K9)for@$A3;
&$_($M9)for@$N9;
&$_($S9)for@$K6;
&$_($ca)for@$w;
&$_($fa)for@$A3;
&$_($ja)for@$w;
&$_($ma)for@$A3;
&$_($oa)for@$pa;
&$_($ua)for@$K6;
&$_($Da)for@$w;
&$_($Ga)for@$A3;
&$_($Ka)for@$w;
&$_($Na)for@$A3;
&$_($Sa)for@$w;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($gb)for@$w;
&$_($jb)for@$A3;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Eb)for@$w;
&$_($Hb)for@$A3;
&$_($Mb)for@$w;
&$_($Pb)for@$A3;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($hc)for@$A3;
&$_($jc)for@$kc;
&$_($pc)for@$K6;
&$_($Cc)for@$w;
&$_($Fc)for@$A3;
&$_($Jc)for@$w;
&$_($Mc)for@$A3;
&$_($Rc)for@$w;
&$_($Uc)for@$A3;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($jd)for@$w;
&$_($md)for@$A3;
&$_($qd)for@$w;
&$_($ud)for@$w;
&$_($xd)for@$A3;
&$_($Bd)for@$w;
&$_($Ed)for@$w;
&$_($Hd)for@$A3;
&$_($Jd)for@$Kd;
&$_($Pd)for@$K6;
&$_($ee)for@$w;
&$_($he)for@$A3;
&$_($me)for@$w;
&$_($pe)for@$A3;
&$_($te)for@$w;
&$_($we)for@$A3;
&$_($Be)for@$w;
&$_($Ee)for@$w;
&$_($Ie)for@$w;
&$_($Le)for@$w;
&$_($Oe)for@$A3;
&$_($Qe)for@$Re;
&$_($We)for@$K6;
&$_($if)for@$w;
&$_($lf)for@$w;
&$_($pf)for@$w;
&$_($tf)for@$w;
&$_($wf)for@$A3;
&$_($Ef)for@$w;
&$_($Hf)for@$A3;
&$_($Lf)for@$w;
&$_($Of)for@$w;
&$_($Rf)for@$w;
&$_($Uf)for@$A3;
&$_($Wf)for@$Xf;
&$_($eg)for@$K6;
&$_($ug)for@$w;
&$_($yg)for@$w;
&$_($Bg)for@$A3;
&$_($Fg)for@$w;
&$_($Ig)for@$w;
&$_($Lg)for@$A3;
&$_($Qg)for@$w;
&$_($Ug)for@$w;
&$_($Xg)for@$A3;
&$_($dh)for@$w;
&$_($gh)for@$w;
&$_($jh)for@$A3;
&$_($nh)for@$w;
&$_($qh)for@$w;
&$_($th)for@$w;
&$_($wh)for@$w;
&$_($zh)for@$A3;
&$_($Bh)for@$Ch;
&$_($Hh)for@$K6;
&$_($Uh)for@$w;
&$_($Yh)for@$w;
&$_($ei)for@$w;
&$_($hi)for@$A3;
&$_($li)for@$w;
&$_($oi)for@$A3;
&$_($si)for@$w;
&$_($wi)for@$w;
&$_($zi)for@$w;
&$_($Ci)for@$A3;
&$_($Ei)for@$Fi;
&$_($Ki)for@$K6;
&$_($Ui)for@$w;
&$_($Xi)for@$w;
&$_($cj)for@$w;
&$_($fj)for@$A3;
&$_($hj)for@$ij;
&$_($pj)for@$w;
&$_($sj)for@$A3;
&$_($uj)for@$K6;
&$_($Dj)for@$w;
&$_($Gj)for@$A3;
&$_($Lj)for@$w;
&$_($Oj)for@$A3;
&$_($Qj)for@$Rj;
&$_($Wj)for@$K6;
&$_($jk)for@$w;
&$_($mk)for@$A3;
&$_($ok)for@$pk;
&$_($vk)for@$K6;
&$_($Dk)for@$w;
&$_($Gk)for@$A3;
&$_($Jk)for@$w;
&$_($Mk)for@$A3;
&$_($Ok)for@$Pk;
&$_($Uk)for@$K6;
&$_($gl)for@$w;
&$_($jl)for@$A3;
&$_($ml)for@$w;
&$_($pl)for@$A3;
&$_($tl)for@$w;
&$_($wl)for@$A3;
&$_($zl)for@$w;
&$_($Cl)for@$w;
&$_($Fl)for@$A3;
&$_($Hl)for@$Il;
&$_($Nl)for@$K6;
&$_($Yl)for@$w;
&$_($dm)for@$w;
&$_($fm)for@$w;
&$_($im)for@$A3;
&$_($mm)for@$w;
&$_($pm)for@$w;
&$_($tm)for@$w;
&$_($wm)for@$A3;
&$_($Am)for@$w;
&$_($Dm)for@$w;
&$_($Gm)for@$A3;
&$_($Lm)for@$w;
&$_($Om)for@$A3;
&$_($Qm)for@$Rm;
&$_($Wm)for@$K6;
&$_($in)for@$w;
&$_($ln)for@$A3;
&$_($sn)for@$w;
&$_($vn)for@$A3;
&$_($Cn)for@$w;
&$_($Fn)for@$A3;
&$_($Kn)for@$w;
&$_($On)for@$w;
&$_($Sn)for@$w;
&$_($Wn)for@$w;
&$_($co)for@$w;
&$_($go)for@$w;
&$_($ko)for@$w;
&$_($oo)for@$w;
&$_($ro)for@$w;
&$_($uo)for@$A3;
&$_($zo)for@$w;
&$_($Co)for@$A3;
&$_($Ho)for@$w;
&$_($Lo)for@$w;
&$_($Po)for@$w;
&$_($To)for@$w;
&$_($Xo)for@$w;
&$_($cp)for@$A3;
&$_($hp)for@$w;
&$_($lp)for@$w;
&$_($pp)for@$w;
&$_($sp)for@$A3;
&$_($xp)for@$w;
&$_($Bp)for@$w;
&$_($Fp)for@$w;
&$_($Ip)for@$A3;
&$_($Kp)for@$Lp;
&$_($Qp)for@$K6;
&$_($cq)for@$w;
&$_($gq)for@$w;
&$_($kq)for@$w;
&$_($oq)for@$w;
&$_($sq)for@$w;
&$_($vq)for@$A3;
&$_($Hq)for@$w;
&$_($Kq)for@$w;
&$_($Nq)for@$w;
&$_($Qq)for@$A3;
&$_($Uq)for@$w;
&$_($Xq)for@$w;
&$_($cr)for@$w;
&$_($fr)for@$w;
&$_($hr)for@$w;
&$_($kr)for@$A3;
&$_($nr)for@$w;
&$_($qr)for@$w;
&$_($tr)for@$A3;
&$_($xr)for@$w;
&$_($Ar)for@$w;
&$_($Dr)for@$A3;
&$_($Fr)for@$Gr;
&$_($Lr)for@$K6;
&$_($Vr)for@$w;
&$_($Zr)for@$w;
&$_($fs)for@$w;
&$_($js)for@$w;
&$_($ns)for@$w;
&$_($rs)for@$w;
&$_($vs)for@$w;
&$_($zs)for@$w;
&$_($Ds)for@$w;
&$_($Hs)for@$w;
&$_($Ls)for@$w;
&$_($Ps)for@$w;
&$_($Ss)for@$A3;
&$_($ft)for@$w;
&$_($it)for@$A3;
&$_($lt)for@$w;
&$_($ot)for@$w;
&$_($rt)for@$A3;
&$_($tt)for@$ut;
&$_($zt)for@$K6;
&$_($Jt)for@$w;
&$_($Lt)for@$w;
&$_($St)for@$A3;
&$_($Vt)for@$w;
&$_($Yt)for@$A3;
&$_($eu)for@$w;
&$_($hu)for@$A3;
&$_($ju)for@$ku;
&$_($qu)for@$K6;
&$_($xu)for@$w;
&$_($Bu)for@$w;
&$_($Eu)for@$A3;
&$_($Lu)for@$w;
&$_($Ou)for@$A3;
&$_($Ru)for@$w;
&$_($Uu)for@$A3;
&$_($Wu)for@$Xu;
&$_($fv)for@$K6;
&$_($nv)for@$w;
&$_($qv)for@$A3;
&$_($vv)for@$w;
&$_($zv)for@$w;
&$_($Cv)for@$A3;
&$_($Gv)for@$w;
&$_($Jv)for@$A3;
&$_($Lv)for@$Mv;
&$_($Rv)for@$K6;
&$_($Zv)for@$cw;
&$_($hw)for@$K6;
&$_($pw)for@$qw;
&$_($Kw)for@$Lw;
&$_($Nw)for@$qw;
&$_($Sw)for@$w;
&$_($Ww)for@$w;
&$_($cx)for@$w;
&$_($gx)for@$w;
&$_($kx)for@$w;
&$_($mx)for@$nx;
ni->run(@ARGV);
__DATA__
