#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/rmi#;
$P=[];
$Q=q#/fabric/rmi#;
$R=bless({$e,$P,$D,$Q},$F);
$S=q#ni.doc:/io#;
$T=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$U=[$i,$T];
$V=[$U];
$W=q#/io#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/io/buffer#;
$Z=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$c1=[$f,$Z];
$d1=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$e1=[$i,$d1];
$f1=[];
$g1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q#/io/buffer#;
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q#ni.doc:/io/cat#;
$n1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$o1=[$f,$n1];
$p1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$q1=[$i,$p1];
$r1=[];
$s1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$o1,$q1,$u1];
$w1=q#/io/cat#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/io/exec#;
$z1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$A1=[$f,$z1];
$B1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$C1=[$i,$B1];
$D1=[];
$E1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$A1,$C1,$G1];
$I1=q#/io/exec#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/io/mio#;
$L1=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$M1=[$f,$L1];
$N1=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$O1=q#

      #;
$P1=[$i,$N1,$O1];
$Q1=[$M1,$P1];
$R1=q#/io/mio#;
$S1=bless({$e,$Q1,$D,$R1},$F);
$T1=q#ni.doc:/io/mio_channel#;
$U1=q#
    #;
$V1=[$i,$U1];
$W1=[$V1];
$X1=q#/io/mio_channel#;
$Y1=bless({$e,$W1,$D,$X1},$F);
$Z1=q#ni.doc:/io/pid#;
$c2=[];
$d2=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$e2=bless({$o,$c2,$q,$d2,$s,$t},$u);
$f2=[$n,$e2];
$g2=[];
$h2=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$i2=bless({$o,$g2,$q,$h2,$s,$t},$u);
$j2=[$n,$i2];
$k2=[];
$l2=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$m2=bless({$o,$k2,$q,$l2,$s,$t},$u);
$n2=[$n,$m2];
$o2=[$f2,$j2,$n2];
$p2=q#/io/pid#;
$q2=bless({$e,$o2,$D,$p2},$F);
$r2=q#ni.doc:/lib#;
$s2=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$t2=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$u2=[$i,$s2,$t2];
$v2=[$u2];
$w2=q#/lib#;
$x2=bless({$e,$v2,$D,$w2},$F);
$y2=q#ni.doc:/lib/doc#;
$z2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$A2=[$f,$z2];
$B2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$C2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$D2=[];
$E2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$F2=bless({$o,$D2,$q,$E2,$s,$t},$u);
$G2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$H2=[];
$I2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$J2=bless({$o,$H2,$q,$I2,$s,$t},$u);
$K2=[$i,$B2,$C2,$n,$F2,$G2,$n,$J2];
$L2=[$A2,$K2];
$M2=q#/lib/doc#;
$N2=bless({$e,$L2,$D,$M2},$F);
$O2=q#ni.doc:/lib/image#;
$P2=q#
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         \# TODO#;
$Q2=[$f,$P2];
$R2=q#Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.#;
$S2=[$i,$R2];
$T2=[$Q2,$S2];
$U2=q#/lib/image#;
$V2=bless({$e,$T2,$D,$U2},$F);
$W2=q#ni.doc:/lib/ni#;
$X2=q#my $value = ni->resolve($name);
               my $value = ni($name);   \# alias for ni->resolve($name)
               my $self  = ni;#;
$Y2=[$f,$X2];
$Z2=q#The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.#;
$c3=[$i,$Z2];
$d3=[$Y2,$c3];
$e3=q#/lib/ni#;
$f3=bless({$e,$d3,$D,$e3},$F);
$g3=q#ni.doc:/lib/quote_simple#;
$h3=q#A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.#;
$i3=[$i,$h3];
$j3=[];
$k3=q#my $q = ni('ni:/lib/quote_simple')->new;
now $q->quote([1,2,3]) == "[1,2,3]";
now $q->quote({foo => 1, bar => [1, 2]}) == "{q\#bar\#,[1,2],q\#foo\#,1}";#;
$l3=bless({$o,$j3,$q,$k3,$s,$t},$u);
$m3=[$n,$l3];
$n3=[$i3,$m3];
$o3=q#/lib/quote_simple#;
$p3=bless({$e,$n3,$D,$o3},$F);
$q3=q#ni.doc:/semantic#;
$r3=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$s3=[$i,$r3];
$t3=[$s3];
$u3=q#/semantic#;
$v3=bless({$e,$t3,$D,$u3},$F);
$w3=q#ni:/class#;
$x3=q#applied_to#;
$y3=q#class#;
$z3=q#class.c#;
$A3=q#fabric/rmi.c#;
$B3=q#io/buffer.c#;
$C3=q#io/cat.c#;
$D3=q#io/exec.c#;
$E3=q#io/fd.c#;
$F3=q#io/file.c#;
$G3=q#io/mio.c#;
$H3=q#io/mio_channel.c#;
$I3=q#io/null.c#;
$J3=q#io/object.c#;
$K3=q#io/pid.c#;
$L3=q#io/str.c#;
$M3=q#io/transfer.c#;
$N3=q#io/transfer_async.c#;
$O3=q#io/transfer_sync.c#;
$P3=q#lib/behavior.c#;
$Q3=q#lib/branch.c#;
$R3=q#lib/dataslice.c#;
$S3=q#lib/doc.c#;
$T3=q#lib/fn.c#;
$U3=q#lib/image.c#;
$V3=q#lib/ni.c#;
$W3=q#lib/quote_simple.c#;
$X3=q#lib/slice.c#;
$Y3=q#lib/tag.c#;
$Z3=q#lib/test_value.c#;
$c4=q#metaclass.c#;
$d4=q#module.c#;
$e4=q#object.c#;
$f4=q#semantic/dimension#;
$g4=q#semantic/dimension.c#;
$h4=q#semantic/task.c#;
$i4={$y3,1,$z3,1,$A3,1,$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$Q3,1,$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1,$Z3,1,$c4,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1};
$j4=q#slices#;
$k4=q#metaclass#;
$l4=q#module#;
$m4={$y3,1,$z3,1,$A3,1,$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$Q3,1,$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1,$Z3,1,$k4,1,$c4,1,$l4,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1};
$n4=q#/module#;
$o4=q#/lib/perlbranch.b#;
$p4={};
$q4=q#ctor#;
$r4=undef;
$s4=q#dtor#;
$t4=q#methods#;
$u4=q#add#;
$v4=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4=q#apply#;
$y4=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$z4=bless({$q,$y4,$s,$t},$u);
$A4={$u4,$w4,$x4,$z4};
$B4=q#/lib/branch.b#;
$C4=q#lib/slice#;
$D4=bless({$x3,$p4,$q4,$r4,$s4,$r4,$t4,$A4,$D,$B4},$C4);
$E4=q#lib/branch#;
$F4=q#lib/slice::ctors#;
$G4={};
$H4=q#my $s = shift; ni->def($s->name, $s)#;
$I4=bless({$q,$H4,$s,$t},$u);
$J4=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$K4=bless({$q,$J4,$s,$t},$u);
$L4={$D,$K4};
$M4=q#/lib/named.b#;
$N4=bless({$x3,$G4,$q4,$I4,$s4,$r4,$t4,$L4,$D,$M4},$C4);
$O4=q#lib/tag#;
$P4={};
$Q4=q#namespace#;
$R4=q#'ni'#;
$S4=bless({$q,$R4,$s,$t},$u);
$T4={$Q4,$S4};
$U4=q#/lib/named_in_ni.b#;
$V4=bless({$x3,$P4,$q4,$r4,$s4,$r4,$t4,$T4,$D,$U4},$C4);
$W4={};
$X4=q#package#;
$Y4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$Z4=bless({$q,$Y4,$s,$t},$u);
$c5={$X4,$Z4};
$d5=q#/lib/namespaced.b#;
$e5=bless({$x3,$W4,$q4,$r4,$s4,$r4,$t4,$c5,$D,$d5},$C4);
$f5={};
$g5=q#resolve#;
$h5=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$i5=bless({$q,$h5,$s,$t},$u);
$j5={$g5,$i5};
$k5=q#/lib/resolver.b#;
$l5=bless({$x3,$f5,$q4,$r4,$s4,$r4,$t4,$j5,$D,$k5},$C4);
$m5=[$D4,$N4,$V4,$e5,$l5];
$n5=bless({$D,$o4,$j4,$m5},$O4);
$o5=q#lib/tag::ctors#;
$p5={};
$q5=q#my $s = shift; $s->apply($s->package)#;
$r5=bless({$q,$q5,$s,$t},$u);
$s5=q#instantiate#;
$t5=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$u5=bless({$q,$t5,$s,$t},$u);
$v5={$s5,$u5};
$w5=q#/lib/class_init.b#;
$x5=bless({$x3,$p5,$q4,$r5,$s4,$r4,$t4,$v5,$D,$w5},$C4);
$y5=q#fabric/rmi#;
$z5=q#io/buffer#;
$A5=q#io/cat#;
$B5=q#io/exec#;
$C5=q#io/fd#;
$D5=q#io/file#;
$E5=q#io/mio#;
$F5=q#io/mio_channel#;
$G5=q#io/null#;
$H5=q#io/object#;
$I5=q#io/pid#;
$J5=q#io/str#;
$K5=q#io/transfer#;
$L5=q#io/transfer_async#;
$M5=q#io/transfer_sync#;
$N5=q#lib/behavior#;
$O5=q#lib/dataslice#;
$P5=q#lib/image#;
$Q5=q#lib/ni#;
$R5=q#lib/quote_simple#;
$S5=q#lib/test_value#;
$T5=q#object#;
$U5=q#semantic/task#;
$V5={$y3,1,$z3,1,$y5,1,$A3,1,$z5,1,$B3,1,$A5,1,$C3,1,$B5,1,$D3,1,$C5,1,$E3,1,$D5,1,$F3,1,$E5,1,$G3,1,$F5,1,$H3,1,$G5,1,$I3,1,$H5,1,$J3,1,$I5,1,$K3,1,$J5,1,$L3,1,$K5,1,$M3,1,$L5,1,$N3,1,$M5,1,$O3,1,$N5,1,$P3,1,$E4,1,$Q3,1,$O5,1,$R3,1,$F,1,$S3,1,$u,1,$T3,1,$P5,1,$U3,1,$Q5,1,$V3,1,$R5,1,$W3,1,$C4,1,$X3,1,$O4,1,$Y3,1,$S5,1,$Z3,1,$k4,1,$c4,1,$l4,1,$d4,1,$T5,1,$e4,1,$f4,1,$g4,1,$U5,1,$h4,1};
$W5=q#/object#;
$X5={};
$Y5=q#ni 'ni:/' . ref shift#;
$Z5=bless({$q,$Y5,$s,$t},$u);
$c6={$y3,$Z5};
$d6=q#/lib/instance.b#;
$e6=bless({$x3,$X5,$q4,$r4,$s4,$r4,$t4,$c6,$D,$d6},$C4);
$f6=[$e6];
$g6=bless({$x3,$V5,$D,$W5,$j4,$f6},$e4);
$h6=q#object.c::ctors#;
$i6={$y3,1,$z3,1,$A3,1,$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$N5,1,$P3,1,$E4,1,$Q3,1,$O5,1,$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$C4,1,$X3,1,$O4,1,$Y3,1,$Z3,1,$k4,1,$c4,1,$l4,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1};
$j6=q#/lib/behavior#;
$k6={};
$l6=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$m6=bless({$q,$l6,$s,$t},$u);
$n6={$e,$m6};
$o6=q#/lib/documentable.b#;
$p6=bless({$x3,$k6,$q4,$r4,$s4,$r4,$t4,$n6,$D,$o6},$C4);
$q6=[$g6,$p6];
$r6=bless({$x3,$i6,$D,$j6,$j4,$q6},$P3);
$s6=q#lib/behavior.c::ctors#;
$t6={$y3,1,$z3,1,$A3,1,$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$E4,1,$Q3,1,$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1,$Z3,1,$k4,1,$c4,1,$l4,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1};
$u6=q#/lib/definition.b#;
$v6={};
$w6=q#def#;
$x6=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$y6=bless({$q,$x6,$s,$t},$u);
$z6={$w6,$y6};
$A6=q#/lib/definition_def.b#;
$B6=bless({$x3,$v6,$q4,$r4,$s4,$r4,$t4,$z6,$D,$A6},$C4);
$C6={};
$D6=q#ro#;
$E6=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$F6=bless({$q,$E6,$s,$t},$u);
$G6=q#rw#;
$H6=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$I6=bless({$q,$H6,$s,$t},$u);
$J6={$D6,$F6,$G6,$I6};
$K6=q#/lib/accessor.b#;
$L6=bless({$x3,$C6,$q4,$r4,$s4,$r4,$t4,$J6,$D,$K6},$C4);
$M6={};
$N6=q#(""#;
$O6=q#shift->name#;
$P6=bless({$q,$O6,$s,$t},$u);
$Q6={$N6,$P6};
$R6=q#/lib/name_as_string.b#;
$S6=bless({$x3,$M6,$q4,$r4,$s4,$r4,$t4,$Q6,$D,$R6},$C4);
$T6={};
$U6=q#(eq#;
$V6=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$W6=bless({$q,$V6,$s,$t},$u);
$X6={$U6,$W6};
$Y6=q#/lib/ref_eq.b#;
$Z6=bless({$x3,$T6,$q4,$r4,$s4,$r4,$t4,$X6,$D,$Y6},$C4);
$c7={};
$d7=q#defdata#;
$e7=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$f7=bless({$q,$e7,$s,$t},$u);
$g7={$d7,$f7};
$h7=q#/lib/definition_defdata.b#;
$i7=bless({$x3,$c7,$q4,$r4,$s4,$r4,$t4,$g7,$D,$h7},$C4);
$j7=[$B6,$L6,$S6,$Z6,$i7];
$k7=bless({$x3,$t6,$D,$u6,$j4,$j7},$E4);
$l7=q#lib/branch::ctors#;
$m7=[$n5,$x5,$g6,$r6,$k7];
$n7=bless({$x3,$m4,$D,$n4,$j4,$m7},$d4);
$o7=q#module.c::ctors#;
$p7={};
$q7=q#DESTROY#;
$r7=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$s7=bless({$q,$r7,$s,$t},$u);
$t7=q#new#;
$u7=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$v7=bless({$q,$u7,$s,$t},$u);
$w7={$q7,$s7,$t7,$v7};
$x7=q#/lib/instantiable.b#;
$y7=bless({$x3,$p7,$t4,$w7,$D,$x7},$C4);
$z7={};
$A7=q#child#;
$B7=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$C7=bless({$q,$B7,$s,$t},$u);
$D7={$A7,$C7};
$E7=q#/lib/subclass.b#;
$F7=bless({$x3,$z7,$q4,$r4,$s4,$r4,$t4,$D7,$D,$E7},$C4);
$G7=[$n7,$y7,$x5,$n7,$F7];
$H7=bless({$x3,$i4,$D,$E,$j4,$G7},$z3);
$I7=q#class.c::ctors#;
$J7=q#ni:/class.c#;
$K7={$z3,1,$g4,1};
$L7=q#/class.c#;
$M7={$z3,1,$d4,1,$g4,1};
$N7=q#/module.c#;
$O7={$z3,1,$A3,1,$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$Q3,1,$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1,$Z3,1,$d4,1,$e4,1,$g4,1,$h4,1};
$P7=q#/object.c#;
$Q7=[$H7];
$R7=bless({$x3,$O7,$D,$P7,$j4,$Q7},$k4);
$S7=q#metaclass::ctors#;
$T7={$z3,1,$P3,1,$Q3,1,$R3,1,$X3,1,$Y3,1,$d4,1,$g4,1};
$U7=q#/lib/behavior.c#;
$V7=[$R7];
$W7=bless({$x3,$T7,$D,$U7,$j4,$V7},$k4);
$X7=[$R7,$y7,$W7];
$Y7=bless({$x3,$M7,$D,$N7,$j4,$X7},$k4);
$Z7=[$Y7];
$c8=bless({$x3,$K7,$D,$L7,$j4,$Z7},$k4);
$d8=q#ni:/fabric/rmi#;
$e8={$y5,1};
$f8={};
$g8=[];
$h8=q#my ($class, $io, $quote) = @_;#;
$i8=bless({$o,$g8,$q,$h8,$s,$t},$u);
$j8={$s5,$i8};
$k8=q#/fabric/rmi_init.b#;
$l8=bless({$x3,$f8,$q4,$r4,$s4,$r4,$t4,$j8,$D,$k8},$C4);
$m8=[$g6,$l8];
$n8=bless({$x3,$e8,$D,$Q,$j4,$m8},$A3);
$o8=q#fabric/rmi.c::ctors#;
$p8=q#ni:/fabric/rmi.c#;
$q8={$A3,1};
$r8=q#/fabric/rmi.c#;
$s8=[$R7];
$t8=bless({$x3,$q8,$D,$r8,$j4,$s8},$k4);
$u8=q#ni:/fabric/rmi_init.b#;
$v8=q#ni:/io/buffer#;
$w8={$z5,1};
$x8={$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1};
$y8=q#/io/object#;
$z8={};
$A8=q#(bool#;
$B8=[];
$C8=bless({$o,$B8,$q,1,$s,$t},$u);
$D8={$A8,$C8};
$E8=q#/io/object_ops.b#;
$F8=bless({$x3,$z8,$q4,$r4,$s4,$r4,$t4,$D8,$D,$E8},$C4);
$G8={};
$H8=q#die#;
$I8=[];
$J8=q#shift; die join " ", @_#;
$K8=bless({$o,$I8,$q,$J8,$s,$t},$u);
$L8=q#io_check#;
$M8=[];
$N8=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$O8=bless({$o,$M8,$q,$N8,$s,$t},$u);
$P8=q#io_check_defined#;
$Q8=[];
$R8=q#shift->io_check(sub {defined shift}, @_)#;
$S8=bless({$o,$Q8,$q,$R8,$s,$t},$u);
$T8=q#io_check_true#;
$U8=[];
$V8=q#shift->io_check(sub {shift}, @_)#;
$W8=bless({$o,$U8,$q,$V8,$s,$t},$u);
$X8={$H8,$K8,$L8,$O8,$P8,$S8,$T8,$W8};
$Y8=q#/io/object_checks.b#;
$Z8=bless({$x3,$G8,$q4,$r4,$s4,$r4,$t4,$X8,$D,$Y8},$C4);
$c9={};
$d9=q#(+#;
$e9=[];
$f9=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$g9=bless({$o,$e9,$q,$f9,$s,$t},$u);
$h9={$d9,$g9};
$i9=q#/io/object_constructors.b#;
$j9=bless({$x3,$c9,$q4,$r4,$s4,$r4,$t4,$h9,$D,$i9},$C4);
$k9={};
$l9=q#read_all#;
$m9=[];
$n9=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$o9=bless({$o,$m9,$q,$n9,$s,$t},$u);
$p9=q#write_all#;
$q9=[];
$r9=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_async($self);#;
$s9=bless({$o,$q9,$q,$r9,$s,$t},$u);
$t9={$l9,$o9,$p9,$s9};
$u9=q#/io/object_memory.b#;
$v9=bless({$x3,$k9,$q4,$r4,$s4,$r4,$t4,$t9,$D,$u9},$C4);
$w9={};
$x9=q#connect_sync#;
$y9=[];
$z9=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$A9=bless({$o,$y9,$q,$z9,$s,$t},$u);
$B9=q#into_sync#;
$C9=[];
$D9=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$E9=bless({$o,$C9,$q,$D9,$s,$t},$u);
$F9={$x9,$A9,$B9,$E9};
$G9=q#/io/object_transfer_sync.b#;
$H9=bless({$x3,$w9,$q4,$r4,$s4,$r4,$t4,$F9,$D,$G9},$C4);
$I9={};
$J9=q#connect_async#;
$K9=[];
$L9=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$M9=bless({$o,$K9,$q,$L9,$s,$t},$u);
$N9=q#into_async#;
$O9=[];
$P9=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$Q9=bless({$o,$O9,$q,$P9,$s,$t},$u);
$R9={$J9,$M9,$N9,$Q9};
$S9=q#/io/object_transfer_async.b#;
$T9=bless({$x3,$I9,$q4,$r4,$s4,$r4,$t4,$R9,$D,$S9},$C4);
$U9=[$g6,$F8,$Z8,$j9,$v9,$H9,$T9,$T9,$H9];
$V9=bless({$x3,$x8,$D,$y8,$j4,$U9},$J3);
$W9=q#io/object.c::ctors#;
$X9={};
$Y9=[];
$Z9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da={$s5,$ca};
$ea=q#/io/buffer_init.b#;
$fa=bless({$x3,$X9,$q4,$r4,$s4,$r4,$t4,$da,$D,$ea},$C4);
$ga={};
$ha=q#read#;
$ia=[];
$ja=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$ka=bless({$o,$ia,$q,$ja,$s,$t},$u);
$la=q#read_capacity#;
$ma=[];
$na=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$oa=bless({$o,$ma,$q,$na,$s,$t},$u);
$pa=q#write#;
$qa=[];
$ra=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta=q#write_capacity#;
$ua=[];
$va=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa={$ha,$ka,$la,$oa,$pa,$sa,$ta,$wa};
$ya=q#/io/buffer_io.b#;
$za=bless({$x3,$ga,$q4,$r4,$s4,$r4,$t4,$xa,$D,$ya},$C4);
$Aa=[$V9,$fa,$za];
$Ba=bless({$x3,$w8,$D,$k1,$j4,$Aa},$B3);
$Ca=q#io/buffer.c::ctors#;
$Da=q#ni:/io/buffer.c#;
$Ea={$B3,1};
$Fa=q#/io/buffer.c#;
$Ga={$B3,1,$C3,1,$D3,1,$E3,1,$F3,1,$G3,1,$H3,1,$I3,1,$J3,1,$K3,1,$L3,1};
$Ha=q#/io/object.c#;
$Ia={};
$Ja=q#def_transfer_method#;
$Ka=[];
$La=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na={$Ja,$Ma};
$Oa=q#/io/object.c_transfer_def.b#;
$Pa=bless({$x3,$Ia,$q4,$r4,$s4,$r4,$t4,$Na,$D,$Oa},$C4);
$Qa=[$R7,$Pa];
$Ra=bless({$x3,$Ga,$D,$Ha,$j4,$Qa},$k4);
$Sa=[$Ra];
$Ta=bless({$x3,$Ea,$D,$Fa,$j4,$Sa},$k4);
$Ua=q#ni:/io/buffer_init.b#;
$Va=q#ni:/io/buffer_io.b#;
$Wa=q#ni:/io/cat#;
$Xa={$A5,1};
$Ya={};
$Za=[];
$cb=q#shift; +{fs => [@_]}#;
$db=bless({$o,$Za,$q,$cb,$s,$t},$u);
$eb={$s5,$db};
$fb=q#/io/cat_init.b#;
$gb=bless({$x3,$Ya,$q4,$r4,$s4,$r4,$t4,$eb,$D,$fb},$C4);
$hb={};
$ib=[];
$jb=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb={$ha,$kb};
$mb=q#/io/cat_read.b#;
$nb=bless({$x3,$hb,$q4,$r4,$s4,$r4,$t4,$lb,$D,$mb},$C4);
$ob=[$V9,$gb,$nb];
$pb=bless({$x3,$Xa,$D,$w1,$j4,$ob},$C3);
$qb=q#io/cat.c::ctors#;
$rb=q#ni:/io/cat.c#;
$sb={$C3,1};
$tb=q#/io/cat.c#;
$ub=[$Ra];
$vb=bless({$x3,$sb,$D,$tb,$j4,$ub},$k4);
$wb=q#ni:/io/cat_init.b#;
$xb=q#ni:/io/cat_read.b#;
$yb=q#ni:/io/exec#;
$zb={$B5,1};
$Ab={};
$Bb=q#argv#;
$Cb=[];
$Db=q#shift->{'argv'}#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb={$Bb,$Eb};
$Gb=q#/io/exec_ro.b#;
$Hb=bless({$x3,$Ab,$q4,$r4,$s4,$r4,$t4,$Fb,$D,$Gb},$C4);
$Ib={};
$Jb=[];
$Kb=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Lb=bless({$o,$Jb,$q,$Kb,$s,$t},$u);
$Mb={$s5,$Lb};
$Nb=q#/io/exec_init.b#;
$Ob=bless({$x3,$Ib,$q4,$r4,$s4,$r4,$t4,$Mb,$D,$Nb},$C4);
$Pb={};
$Qb=q#connect#;
$Rb=[];
$Sb=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Tb=bless({$o,$Rb,$q,$Sb,$s,$t},$u);
$Ub=q#in_pipe#;
$Vb=[];
$Wb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Xb=bless({$o,$Vb,$q,$Wb,$s,$t},$u);
$Yb=q#out_pipe#;
$Zb=[];
$cc=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$dc=bless({$o,$Zb,$q,$cc,$s,$t},$u);
$ec=q#setup_stdio#;
$fc=[];
$gc=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$hc=bless({$o,$fc,$q,$gc,$s,$t},$u);
$ic={$Qb,$Tb,$Ub,$Xb,$Yb,$dc,$ec,$hc};
$jc=q#/io/exec_io_setup.b#;
$kc=bless({$x3,$Pb,$q4,$r4,$s4,$r4,$t4,$ic,$D,$jc},$C4);
$lc={};
$mc=q#binds_fd#;
$nc=[];
$oc=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$pc=bless({$o,$nc,$q,$oc,$s,$t},$u);
$qc=q#fd#;
$rc=[];
$sc=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$tc=bless({$o,$rc,$q,$sc,$s,$t},$u);
$uc=q#stderr#;
$vc=[];
$wc=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$xc=bless({$o,$vc,$q,$wc,$s,$t},$u);
$yc=q#stdin#;
$zc=[];
$Ac=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Bc=bless({$o,$zc,$q,$Ac,$s,$t},$u);
$Cc=q#stdout#;
$Dc=[];
$Ec=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Fc=bless({$o,$Dc,$q,$Ec,$s,$t},$u);
$Gc={$mc,$pc,$qc,$tc,$uc,$xc,$yc,$Bc,$Cc,$Fc};
$Hc=q#/io/exec_io_accessors.b#;
$Ic=bless({$x3,$lc,$q4,$r4,$s4,$r4,$t4,$Gc,$D,$Hc},$C4);
$Jc={};
$Kc=q#env#;
$Lc=[];
$Mc=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$t},$u);
$Oc={$Kc,$Nc};
$Pc=q#/io/exec_env.b#;
$Qc=bless({$x3,$Jc,$q4,$r4,$s4,$r4,$t4,$Oc,$D,$Pc},$C4);
$Rc={};
$Sc=q#exec#;
$Tc=[];
$Uc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$t},$u);
$Wc=q#fork#;
$Xc=[];
$Yc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd=q#move_fds#;
$dd=[];
$ed=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd={$Sc,$Vc,$Wc,$Zc,$cd,$fd};
$hd=q#/io/exec_fork.b#;
$id=bless({$x3,$Rc,$q4,$r4,$s4,$r4,$t4,$gd,$D,$hd},$C4);
$jd=[$V9,$Hb,$Ob,$kc,$Ic,$Qc,$id];
$kd=bless({$x3,$zb,$D,$I1,$j4,$jd},$D3);
$ld=q#io/exec.c::ctors#;
$md=q#ni:/io/exec.c#;
$nd={$D3,1};
$od=q#/io/exec.c#;
$pd=[$Ra];
$qd=bless({$x3,$nd,$D,$od,$j4,$pd},$k4);
$rd=q#ni:/io/exec_env.b#;
$sd=q#ni:/io/exec_fork.b#;
$td=q#ni:/io/exec_init.b#;
$ud=q#ni:/io/exec_io_accessors.b#;
$vd=q#ni:/io/exec_io_setup.b#;
$wd=q#ni:/io/exec_ro.b#;
$xd=q#ni:/io/fd#;
$yd={$C5,1};
$zd=q#/io/fd#;
$Ad={};
$Bd=[];
$Cd=q#shift->{'fd'}#;
$Dd=bless({$o,$Bd,$q,$Cd,$s,$t},$u);
$Ed={$qc,$Dd};
$Fd=q#/io/fd_readers.b#;
$Gd=bless({$x3,$Ad,$q4,$r4,$s4,$r4,$t4,$Ed,$D,$Fd},$C4);
$Hd={};
$Id=[];
$Jd=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Kd=bless({$o,$Id,$q,$Jd,$s,$t},$u);
$Ld={$s5,$Kd};
$Md=q#/io/fd_init.b#;
$Nd=bless({$x3,$Hd,$q4,$r4,$s4,$r4,$t4,$Ld,$D,$Md},$C4);
$Od={};
$Pd=q#be#;
$Qd=[];
$Rd=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Sd=bless({$o,$Qd,$q,$Rd,$s,$t},$u);
$Td={$Pd,$Sd};
$Ud=q#/io/fd_shell.b#;
$Vd=bless({$x3,$Od,$q4,$r4,$s4,$r4,$t4,$Td,$D,$Ud},$C4);
$Wd={};
$Xd=q#cloexec#;
$Yd=[];
$Zd=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$ce=bless({$o,$Yd,$q,$Zd,$s,$t},$u);
$de=q#fcntl_flag#;
$ee=[];
$fe=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$ge=bless({$o,$ee,$q,$fe,$s,$t},$u);
$he=q#nonblock#;
$ie=[];
$je=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$ke=bless({$o,$ie,$q,$je,$s,$t},$u);
$le={$Xd,$ce,$de,$ge,$he,$ke};
$me=q#/io/fd_fcntl.b#;
$ne=bless({$x3,$Wd,$q4,$r4,$s4,$r4,$t4,$le,$D,$me},$C4);
$oe={};
$pe=[];
$qe=q#shift->close#;
$re=bless({$o,$pe,$q,$qe,$s,$t},$u);
$se=q#close#;
$te=[];
$ue=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$ve=bless({$o,$te,$q,$ue,$s,$t},$u);
$we={$se,$ve};
$xe=q#/io/fd_gc.b#;
$ye=bless({$x3,$oe,$q4,$r4,$s4,$re,$t4,$we,$D,$xe},$C4);
$ze={};
$Ae=[];
$Be=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$Ce=bless({$o,$Ae,$q,$Be,$s,$t},$u);
$De=[];
$Ee=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge={$ha,$Ce,$pa,$Fe};
$He=q#/io/fd_perlio.b#;
$Ie=bless({$x3,$ze,$q4,$r4,$s4,$r4,$t4,$Ge,$D,$He},$C4);
$Je=[$V9,$Gd,$Nd,$Vd,$ne,$ye,$Ie];
$Ke=bless({$x3,$yd,$D,$zd,$j4,$Je},$E3);
$Le=q#io/fd.c::ctors#;
$Me=q#ni:/io/fd.c#;
$Ne={$E3,1};
$Oe=q#/io/fd.c#;
$Pe=[$Ra];
$Qe=bless({$x3,$Ne,$D,$Oe,$j4,$Pe},$k4);
$Re=q#ni:/io/fd_fcntl.b#;
$Se=q#ni:/io/fd_gc.b#;
$Te=q#ni:/io/fd_init.b#;
$Ue=q#ni:/io/fd_perlio.b#;
$Ve=q#ni:/io/fd_readers.b#;
$We=q#ni:/io/fd_shell.b#;
$Xe=q#ni:/io/file#;
$Ye={$D5,1};
$Ze=q#/io/file#;
$cf={};
$df=[];
$ef=q#shift->{'name'}#;
$ff=bless({$o,$df,$q,$ef,$s,$t},$u);
$gf={$D,$ff};
$hf=q#/io/file_readers.b#;
$if=bless({$x3,$cf,$q4,$r4,$s4,$r4,$t4,$gf,$D,$hf},$C4);
$jf={};
$kf=q#mode#;
$lf=[];
$mf=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$nf=bless({$o,$lf,$q,$mf,$s,$t},$u);
$of={$kf,$nf};
$pf=q#/io/file_accessors.b#;
$qf=bless({$x3,$jf,$q4,$r4,$s4,$r4,$t4,$of,$D,$pf},$C4);
$rf={};
$sf=[];
$tf=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$uf=bless({$o,$sf,$q,$tf,$s,$t},$u);
$vf={$s5,$uf};
$wf=q#/io/file_init.b#;
$xf=bless({$x3,$rf,$q4,$r4,$s4,$r4,$t4,$vf,$D,$wf},$C4);
$yf={};
$zf=[];
$Af=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Bf=bless({$o,$zf,$q,$Af,$s,$t},$u);
$Cf=q#r#;
$Df=[];
$Ef=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=[];
$Hf=q#shift->r->read(@_)#;
$If=bless({$o,$Gf,$q,$Hf,$s,$t},$u);
$Jf=q#w#;
$Kf=[];
$Lf=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Mf=bless({$o,$Kf,$q,$Lf,$s,$t},$u);
$Nf=[];
$Of=q#shift->w->write(@_)#;
$Pf=bless({$o,$Nf,$q,$Of,$s,$t},$u);
$Qf={$se,$Bf,$Cf,$Ff,$ha,$If,$Jf,$Mf,$pa,$Pf};
$Rf=q#/io/file_io.b#;
$Sf=bless({$x3,$yf,$q4,$r4,$s4,$r4,$t4,$Qf,$D,$Rf},$C4);
$Tf=[$V9,$if,$qf,$xf,$Sf];
$Uf=bless({$x3,$Ye,$D,$Ze,$j4,$Tf},$F3);
$Vf=q#io/file.c::ctors#;
$Wf=q#ni:/io/file.c#;
$Xf={$F3,1};
$Yf=q#/io/file.c#;
$Zf=[$Ra];
$cg=bless({$x3,$Xf,$D,$Yf,$j4,$Zf},$k4);
$dg=q#ni:/io/file_accessors.b#;
$eg=q#ni:/io/file_init.b#;
$fg=q#ni:/io/file_io.b#;
$gg=q#ni:/io/file_readers.b#;
$hg=q#ni:/io/mio#;
$ig={$E5,1};
$jg={};
$kg=q#io#;
$lg=[];
$mg=q#shift->{'io'}#;
$ng=bless({$o,$lg,$q,$mg,$s,$t},$u);
$og=q#packet_size#;
$pg=[];
$qg=q#shift->{'packet_size'}#;
$rg=bless({$o,$pg,$q,$qg,$s,$t},$u);
$sg={$kg,$ng,$og,$rg};
$tg=q#/io/mio_ro.b#;
$ug=bless({$x3,$jg,$q4,$r4,$s4,$r4,$t4,$sg,$D,$tg},$C4);
$vg={};
$wg=[];
$xg=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$yg=bless({$o,$wg,$q,$xg,$s,$t},$u);
$zg={$s5,$yg};
$Ag=q#/io/mio_init.b#;
$Bg=bless({$x3,$vg,$q4,$r4,$s4,$r4,$t4,$zg,$D,$Ag},$C4);
$Cg={};
$Dg=q#next_sender#;
$Eg=[];
$Fg=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$Gg=bless({$o,$Eg,$q,$Fg,$s,$t},$u);
$Hg={$Dg,$Gg};
$Ig=q#/io/mio_rr_scheduler.b#;
$Jg=bless({$x3,$Cg,$q4,$r4,$s4,$r4,$t4,$Hg,$D,$Ig},$C4);
$Kg={};
$Lg=[];
$Mg=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$Ng=bless({$o,$Lg,$q,$Mg,$s,$t},$u);
$Og=[];
$Pg=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$Qg=bless({$o,$Og,$q,$Pg,$s,$t},$u);
$Rg=[];
$Sg=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
\# TODO#;
$Tg=bless({$o,$Rg,$q,$Sg,$s,$t},$u);
$Ug={$se,$Ng,$ha,$Qg,$pa,$Tg};
$Vg=q#/io/mio_io.b#;
$Wg=bless({$x3,$Kg,$q4,$r4,$s4,$r4,$t4,$Ug,$D,$Vg},$C4);
$Xg={};
$Yg=q#channel#;
$Zg=[];
$ch=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$dh=bless({$o,$Zg,$q,$ch,$s,$t},$u);
$eh=q#channels#;
$fh=[];
$gh=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$hh=bless({$o,$fh,$q,$gh,$s,$t},$u);
$ih=q#unchannel#;
$jh=[];
$kh=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$lh=bless({$o,$jh,$q,$kh,$s,$t},$u);
$mh={$Yg,$dh,$eh,$hh,$ih,$lh};
$nh=q#/io/mio_channel.b#;
$oh=bless({$x3,$Xg,$q4,$r4,$s4,$r4,$t4,$mh,$D,$nh},$C4);
$ph=[$V9,$ug,$Bg,$Jg,$Wg,$oh];
$qh=bless({$x3,$ig,$D,$R1,$j4,$ph},$G3);
$rh=q#io/mio.c::ctors#;
$sh=q#ni:/io/mio.c#;
$th={$G3,1};
$uh=q#/io/mio.c#;
$vh=[$Ra];
$wh=bless({$x3,$th,$D,$uh,$j4,$vh},$k4);
$xh=q#ni:/io/mio_channel#;
$yh={$F5,1};
$zh={};
$Ah=q#capacity#;
$Bh=[];
$Ch=q#shift->{'capacity'}#;
$Dh=bless({$o,$Bh,$q,$Ch,$s,$t},$u);
$Eh=q#id#;
$Fh=[];
$Gh=q#shift->{'id'}#;
$Hh=bless({$o,$Fh,$q,$Gh,$s,$t},$u);
$Ih=q#mio#;
$Jh=[];
$Kh=q#shift->{'mio'}#;
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh={$Ah,$Dh,$Eh,$Hh,$Ih,$Lh};
$Nh=q#/io/mio_channel_ro.b#;
$Oh=bless({$x3,$zh,$q4,$r4,$s4,$r4,$t4,$Mh,$D,$Nh},$C4);
$Ph={};
$Qh=[];
$Rh=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Sh=bless({$o,$Qh,$q,$Rh,$s,$t},$u);
$Th={$s5,$Sh};
$Uh=q#/io/mio_channel_init.b#;
$Vh=bless({$x3,$Ph,$q4,$r4,$s4,$r4,$t4,$Th,$D,$Uh},$C4);
$Wh={};
$Xh=[];
$Yh=bless({$o,$Xh,$q,$qe,$s,$t},$u);
$Zh={};
$ci=q#/io/mio_channel_lifecycle.b#;
$di=bless({$x3,$Wh,$q4,$r4,$s4,$Yh,$t4,$Zh,$D,$ci},$C4);
$ei={};
$fi=[];
$gi=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$hi=bless({$o,$fi,$q,$gi,$s,$t},$u);
$ii=[];
$ji=q#shift->{read_buffer} ->read(@_)#;
$ki=bless({$o,$ii,$q,$ji,$s,$t},$u);
$li=[];
$mi=q#shift->{write_buffer}->write(@_)#;
$ni=bless({$o,$li,$q,$mi,$s,$t},$u);
$oi={$se,$hi,$ha,$ki,$pa,$ni};
$pi=q#/io/mio_channel_io.b#;
$qi=bless({$x3,$ei,$q4,$r4,$s4,$r4,$t4,$oi,$D,$pi},$C4);
$ri=[$V9,$Oh,$Vh,$di,$qi];
$si=bless({$x3,$yh,$D,$X1,$j4,$ri},$H3);
$ti=q#io/mio_channel.c::ctors#;
$ui=q#ni:/io/mio_channel.b#;
$vi=q#ni:/io/mio_channel.c#;
$wi={$H3,1};
$xi=q#/io/mio_channel.c#;
$yi=[$Ra];
$zi=bless({$x3,$wi,$D,$xi,$j4,$yi},$k4);
$Ai=q#ni:/io/mio_channel_init.b#;
$Bi=q#ni:/io/mio_channel_io.b#;
$Ci=q#ni:/io/mio_channel_lifecycle.b#;
$Di=q#ni:/io/mio_channel_ro.b#;
$Ei=q#ni:/io/mio_init.b#;
$Fi=q#ni:/io/mio_io.b#;
$Gi=q#ni:/io/mio_ro.b#;
$Hi=q#ni:/io/mio_rr_scheduler.b#;
$Ii=q#ni:/io/named_io_fns.b#;
$Ji={};
$Ki=q#fcntl#;
$Li=[];
$Mi=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Ni=bless({$o,$Li,$q,$Mi,$s,$t},$u);
$Oi=[];
$Pi=q#CORE::fork#;
$Qi=bless({$o,$Oi,$q,$Pi,$s,$t},$u);
$Ri=q#open2#;
$Si=[];
$Ti=q#CORE::open $_[0], $_[1]#;
$Ui=bless({$o,$Si,$q,$Ti,$s,$t},$u);
$Vi=q#waitpid#;
$Wi=[];
$Xi=q#CORE::waitpid $_[0], $_[1]#;
$Yi=bless({$o,$Wi,$q,$Xi,$s,$t},$u);
$Zi={$Ki,$Ni,$Wc,$Qi,$Ri,$Ui,$Vi,$Yi};
$cj=q#/io/named_io_fns.b#;
$dj=bless({$x3,$Ji,$q4,$r4,$s4,$r4,$t4,$Zi,$D,$cj},$C4);
$ej=q#main#;
$fj=q#ni:/io/null#;
$gj={$G5,1};
$hj=q#/io/null#;
$ij={};
$jj=[];
$kj=q#+{fd => undef}#;
$lj=bless({$o,$jj,$q,$kj,$s,$t},$u);
$mj={$s5,$lj};
$nj=q#/io/null_init.b#;
$oj=bless({$x3,$ij,$q4,$r4,$s4,$r4,$t4,$mj,$D,$nj},$C4);
$pj={};
$qj=[];
$rj=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$sj=bless({$o,$qj,$q,$rj,$s,$t},$u);
$tj=[];
$uj=q#shift->fd->read(@_)#;
$vj=bless({$o,$tj,$q,$uj,$s,$t},$u);
$wj=[];
$xj=q#shift->fd->write(@_)#;
$yj=bless({$o,$wj,$q,$xj,$s,$t},$u);
$zj={$qc,$sj,$ha,$vj,$pa,$yj};
$Aj=q#/io/null_io.b#;
$Bj=bless({$x3,$pj,$q4,$r4,$s4,$r4,$t4,$zj,$D,$Aj},$C4);
$Cj=[$V9,$oj,$Bj];
$Dj=bless({$x3,$gj,$D,$hj,$j4,$Cj},$I3);
$Ej=q#io/null.c::ctors#;
$Fj=q#ni:/io/null.c#;
$Gj={$I3,1};
$Hj=q#/io/null.c#;
$Ij=[$Ra];
$Jj=bless({$x3,$Gj,$D,$Hj,$j4,$Ij},$k4);
$Kj=q#ni:/io/null_init.b#;
$Lj=q#ni:/io/null_io.b#;
$Mj=q#ni:/io/object#;
$Nj=q#ni:/io/object.c#;
$Oj=q#ni:/io/object.c_transfer_def.b#;
$Pj=q#ni:/io/object_checks.b#;
$Qj=q#ni:/io/object_constructors.b#;
$Rj=q#ni:/io/object_memory.b#;
$Sj=q#ni:/io/object_ops.b#;
$Tj=q#ni:/io/object_transfer_async.b#;
$Uj=q#ni:/io/object_transfer_sync.b#;
$Vj=q#ni:/io/pid#;
$Wj={$I5,1};
$Xj={};
$Yj=q#pid#;
$Zj=[];
$ck=q#shift->{'pid'}#;
$dk=bless({$o,$Zj,$q,$ck,$s,$t},$u);
$ek=q#status#;
$fk=[];
$gk=q#shift->{'status'}#;
$hk=bless({$o,$fk,$q,$gk,$s,$t},$u);
$ik={$Yj,$dk,$ek,$hk};
$jk=q#/io/pid_readers.b#;
$kk=bless({$x3,$Xj,$q4,$r4,$s4,$r4,$t4,$ik,$D,$jk},$C4);
$lk={};
$mk=[];
$nk=q#shift->await#;
$ok=bless({$o,$mk,$q,$nk,$s,$t},$u);
$pk=[];
$qk=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$rk=bless({$o,$pk,$q,$qk,$s,$t},$u);
$sk={$s5,$rk};
$tk=q#/io/pid_init.b#;
$uk=bless({$x3,$lk,$q4,$r4,$s4,$ok,$t4,$sk,$D,$tk},$C4);
$vk={};
$wk=q#await#;
$xk=[];
$yk=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$zk=bless({$o,$xk,$q,$yk,$s,$t},$u);
$Ak=q#running#;
$Bk=[];
$Ck=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Dk=bless({$o,$Bk,$q,$Ck,$s,$t},$u);
$Ek={$wk,$zk,$Ak,$Dk};
$Fk=q#/io/pid_wait.b#;
$Gk=bless({$x3,$vk,$q4,$r4,$s4,$r4,$t4,$Ek,$D,$Fk},$C4);
$Hk={};
$Ik=[];
$Jk=q#shift->stdout->read(@_)#;
$Kk=bless({$o,$Ik,$q,$Jk,$s,$t},$u);
$Lk=[];
$Mk=q#shift->stdin->write(@_)#;
$Nk=bless({$o,$Lk,$q,$Mk,$s,$t},$u);
$Ok={$ha,$Kk,$pa,$Nk};
$Pk=q#/io/pid_io.b#;
$Qk=bless({$x3,$Hk,$q4,$r4,$s4,$r4,$t4,$Ok,$D,$Pk},$C4);
$Rk={};
$Sk=[];
$Tk=q#$_[0]->{external_fds}{$_[1]}#;
$Uk=bless({$o,$Sk,$q,$Tk,$s,$t},$u);
$Vk=[];
$Wk=q#shift->fd(2)#;
$Xk=bless({$o,$Vk,$q,$Wk,$s,$t},$u);
$Yk=[];
$Zk=q#shift->fd(0)#;
$cl=bless({$o,$Yk,$q,$Zk,$s,$t},$u);
$dl=[];
$el=q#shift->fd(1)#;
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl={$qc,$Uk,$uc,$Xk,$yc,$cl,$Cc,$fl};
$hl=q#/io/pid_accessors.b#;
$il=bless({$x3,$Rk,$q4,$r4,$s4,$r4,$t4,$gl,$D,$hl},$C4);
$jl=[$V9,$kk,$uk,$Gk,$Qk,$il];
$kl=bless({$x3,$Wj,$D,$p2,$j4,$jl},$K3);
$ll=q#io/pid.c::ctors#;
$ml=q#ni:/io/pid.c#;
$nl={$K3,1};
$ol=q#/io/pid.c#;
$pl=[$Ra];
$ql=bless({$x3,$nl,$D,$ol,$j4,$pl},$k4);
$rl=q#ni:/io/pid_accessors.b#;
$sl=q#ni:/io/pid_init.b#;
$tl=q#ni:/io/pid_io.b#;
$ul=q#ni:/io/pid_readers.b#;
$vl=q#ni:/io/pid_wait.b#;
$wl=q#ni:/io/str#;
$xl={$J5,1};
$yl=q#/io/str#;
$zl={};
$Al=q#data#;
$Bl=[];
$Cl=q#shift->{'data'}#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El=q#end#;
$Fl=[];
$Gl=q#shift->{'end'}#;
$Hl=bless({$o,$Fl,$q,$Gl,$s,$t},$u);
$Il=q#start#;
$Jl=[];
$Kl=q#shift->{'start'}#;
$Ll=bless({$o,$Jl,$q,$Kl,$s,$t},$u);
$Ml={$Al,$Dl,$El,$Hl,$Il,$Ll};
$Nl=q#/io/str_ro.b#;
$Ol=bless({$x3,$zl,$q4,$r4,$s4,$r4,$t4,$Ml,$D,$Nl},$C4);
$Pl={};
$Ql=[];
$Rl=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Sl=bless({$o,$Ql,$q,$Rl,$s,$t},$u);
$Tl={$s5,$Sl};
$Ul=q#/io/str_init.b#;
$Vl=bless({$x3,$Pl,$q4,$r4,$s4,$r4,$t4,$Tl,$D,$Ul},$C4);
$Wl={};
$Xl=[];
$Yl=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Zl=bless({$o,$Xl,$q,$Yl,$s,$t},$u);
$cm=q#remaining#;
$dm=[];
$em=q#my $self = shift; $$self{end} - $$self{start}#;
$fm=bless({$o,$dm,$q,$em,$s,$t},$u);
$gm=[];
$hm=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$im=bless({$o,$gm,$q,$hm,$s,$t},$u);
$jm={$ha,$Zl,$cm,$fm,$pa,$im};
$km=q#/io/str_io.b#;
$lm=bless({$x3,$Wl,$q4,$r4,$s4,$r4,$t4,$jm,$D,$km},$C4);
$mm=[$V9,$Ol,$Vl,$lm];
$nm=bless({$x3,$xl,$D,$yl,$j4,$mm},$L3);
$om=q#io/str.c::ctors#;
$pm=q#ni:/io/str.c#;
$qm={$L3,1};
$rm=q#/io/str.c#;
$sm=[$Ra];
$tm=bless({$x3,$qm,$D,$rm,$j4,$sm},$k4);
$um=q#ni:/io/str_init.b#;
$vm=q#ni:/io/str_io.b#;
$wm=q#ni:/io/str_ro.b#;
$xm=q#ni:/io/transfer#;
$ym={$K5,1,$L5,1,$M5,1};
$zm=q#/io/transfer#;
$Am={$K5,1,$L5,1,$M5,1,$U5,1};
$Bm=q#/semantic/task#;
$Cm={};
$Dm=q#outcome#;
$Em=[];
$Fm=q#shift->{'outcome'}#;
$Gm=bless({$o,$Em,$q,$Fm,$s,$t},$u);
$Hm={$Dm,$Gm};
$Im=q#/semantic/task_ro.b#;
$Jm=bless({$x3,$Cm,$q4,$r4,$s4,$r4,$t4,$Hm,$D,$Im},$C4);
$Km={};
$Lm=q#failure#;
$Mm=[];
$Nm=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Om=bless({$o,$Mm,$q,$Nm,$s,$t},$u);
$Pm=q#success#;
$Qm=[];
$Rm=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Sm=bless({$o,$Qm,$q,$Rm,$s,$t},$u);
$Tm={$Lm,$Om,$Pm,$Sm};
$Um=q#/semantic/task_outcome.b#;
$Vm=bless({$x3,$Km,$q4,$r4,$s4,$r4,$t4,$Tm,$D,$Um},$C4);
$Wm=[$g6,$Jm,$Vm];
$Xm=bless({$x3,$Am,$D,$Bm,$j4,$Wm},$h4);
$Ym=q#semantic/task.c::ctors#;
$Zm={};
$cn=[];
$dn=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$en=bless({$o,$cn,$q,$dn,$s,$t},$u);
$fn=[];
$gn=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$hn=bless({$o,$fn,$q,$gn,$s,$t},$u);
$in=[];
$jn=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$kn=bless({$o,$in,$q,$jn,$s,$t},$u);
$ln={$ha,$hn,$pa,$kn};
$mn=q#/io/transfer_io_interop.b#;
$nn=bless({$x3,$Zm,$q4,$en,$s4,$r4,$t4,$ln,$D,$mn},$C4);
$on={};
$pn=q#pressure#;
$qn=[];
$rn=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$sn=bless({$o,$qn,$q,$rn,$s,$t},$u);
$tn=q#read_limit_throughput#;
$un=[];
$vn=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$wn=bless({$o,$un,$q,$vn,$s,$t},$u);
$xn=q#throughput#;
$yn=[];
$zn=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$An=bless({$o,$yn,$q,$zn,$s,$t},$u);
$Bn=q#write_limit_throughput#;
$Cn=[];
$Dn=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$En=bless({$o,$Cn,$q,$Dn,$s,$t},$u);
$Fn={$pn,$sn,$tn,$wn,$xn,$An,$Bn,$En};
$Gn=q#/io/transfer_io_measurement.b#;
$Hn=bless({$x3,$on,$q4,$r4,$s4,$r4,$t4,$Fn,$D,$Gn},$C4);
$In=[$Xm,$nn,$Hn];
$Jn=bless({$x3,$ym,$D,$zm,$j4,$In},$M3);
$Kn=q#io/transfer.c::ctors#;
$Ln=q#ni:/io/transfer.c#;
$Mn={$M3,1,$N3,1,$O3,1};
$Nn=q#/io/transfer.c#;
$On={$M3,1,$N3,1,$O3,1,$h4,1};
$Pn=q#/semantic/task.c#;
$Qn=[$R7];
$Rn=bless({$x3,$On,$D,$Pn,$j4,$Qn},$k4);
$Sn={};
$Tn=[];
$Un=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn={};
$Xn=q#/io/transfer.c_into.b#;
$Yn=bless({$x3,$Sn,$q4,$Vn,$s4,$r4,$t4,$Wn,$D,$Xn},$C4);
$Zn=[$Rn,$Yn];
$co=bless({$x3,$Mn,$D,$Nn,$j4,$Zn},$k4);
$do=q#ni:/io/transfer.c_into.b#;
$eo=q#ni:/io/transfer_async#;
$fo={$L5,1};
$go=q#/io/transfer_async#;
$ho={};
$io=q#dest_io#;
$jo=[];
$ko=q#shift->{'dest_io'}#;
$lo=bless({$o,$jo,$q,$ko,$s,$t},$u);
$mo=[];
$no=bless({$o,$mo,$q,$Gh,$s,$t},$u);
$oo=q#source_io#;
$po=[];
$qo=q#shift->{'source_io'}#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so={$io,$lo,$Eh,$no,$oo,$ro};
$to=q#/io/transfer_async_ro.b#;
$uo=bless({$x3,$ho,$q4,$r4,$s4,$r4,$t4,$so,$D,$to},$C4);
$vo={};
$wo=[];
$xo=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$yo=bless({$o,$wo,$q,$xo,$s,$t},$u);
$zo={$s5,$yo};
$Ao=q#/io/transfer_async_init.b#;
$Bo=bless({$x3,$vo,$q4,$r4,$s4,$r4,$t4,$zo,$D,$Ao},$C4);
$Co={};
$Do=[];
$Eo=q#ni('ni:/io/transfer_async')->track(shift)#;
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go=[];
$Ho=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo={};
$Ko=q#/io/transfer_async_lifecycle.b#;
$Lo=bless({$x3,$Co,$q4,$Fo,$s4,$Io,$t4,$Jo,$D,$Ko},$C4);
$Mo={};
$No=q#run#;
$Oo=[];
$Po=q#shift#;
$Qo=bless({$o,$Oo,$q,$Po,$s,$t},$u);
$Ro=q#run_async#;
$So=[];
$To=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Uo=bless({$o,$So,$q,$To,$s,$t},$u);
$Vo={$No,$Qo,$Ro,$Uo};
$Wo=q#/io/transfer_async_run.b#;
$Xo=bless({$x3,$Mo,$q4,$r4,$s4,$r4,$t4,$Vo,$D,$Wo},$C4);
$Yo=[$Jn,$uo,$Bo,$Lo,$Xo];
$Zo=q#tracked_transfers#;
$cp={};
$dp=bless({$x3,$fo,$D,$go,$j4,$Yo,$Zo,$cp},$N3);
$ep=q#io/transfer_async.c::ctors#;
$fp=q#ni:/io/transfer_async.c#;
$gp={$N3,1};
$hp=q#/io/transfer_async.c#;
$ip={};
$jp=[];
$kp=q#shift->{tracked_transfers} = {}#;
$lp=bless({$o,$jp,$q,$kp,$s,$t},$u);
$mp=q#track#;
$np=[];
$op=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$pp=bless({$o,$np,$q,$op,$s,$t},$u);
$qp=q#untrack#;
$rp=[];
$sp=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$tp=bless({$o,$rp,$q,$sp,$s,$t},$u);
$up={$mp,$pp,$qp,$tp};
$vp=q#/io/transfer_async.c_tracker.b#;
$wp=bless({$x3,$ip,$q4,$lp,$s4,$r4,$t4,$up,$D,$vp},$C4);
$xp=[$co,$wp];
$yp=bless({$x3,$gp,$D,$hp,$j4,$xp},$k4);
$zp=q#ni:/io/transfer_async.c_tracker.b#;
$Ap=q#ni:/io/transfer_async_init.b#;
$Bp=q#ni:/io/transfer_async_lifecycle.b#;
$Cp=q#ni:/io/transfer_async_ro.b#;
$Dp=q#ni:/io/transfer_async_run.b#;
$Ep=q#ni:/io/transfer_io_interop.b#;
$Fp=q#ni:/io/transfer_io_measurement.b#;
$Gp=q#ni:/io/transfer_sync#;
$Hp={$M5,1};
$Ip=q#/io/transfer_sync#;
$Jp={};
$Kp=[];
$Lp=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Mp=bless({$o,$Kp,$q,$Lp,$s,$t},$u);
$Np={$s5,$Mp};
$Op=q#/io/transfer_sync_init.b#;
$Pp=bless({$x3,$Jp,$q4,$r4,$s4,$r4,$t4,$Np,$D,$Op},$C4);
$Qp={};
$Rp=[];
$Sp=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Tp=bless({$o,$Rp,$q,$Sp,$s,$t},$u);
$Up={$No,$Tp};
$Vp=q#/io/transfer_sync_run.b#;
$Wp=bless({$x3,$Qp,$q4,$r4,$s4,$r4,$t4,$Up,$D,$Vp},$C4);
$Xp=[$Jn,$Pp,$Wp];
$Yp=bless({$x3,$Hp,$D,$Ip,$j4,$Xp},$O3);
$Zp=q#io/transfer_sync.c::ctors#;
$cq=q#ni:/io/transfer_sync.c#;
$dq={$O3,1};
$eq=q#/io/transfer_sync.c#;
$fq=[$co];
$gq=bless({$x3,$dq,$D,$eq,$j4,$fq},$k4);
$hq=q#ni:/io/transfer_sync_init.b#;
$iq=q#ni:/io/transfer_sync_run.b#;
$jq=q#ni:/lib/accessor.b#;
$kq=q#ni:/lib/behavior#;
$lq=q#ni:/lib/behavior.c#;
$mq=q#ni:/lib/branch#;
$nq={$E4,1};
$oq=q#/lib/branch#;
$pq={};
$qq=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$rq=bless({$q,$qq,$s,$t},$u);
$sq={$s5,$rq};
$tq=q#/lib/branch_init.b#;
$uq=bless({$x3,$pq,$q4,$r4,$s4,$r4,$t4,$sq,$D,$tq},$C4);
$vq=[$r6,$N4,$D4,$uq,$k7];
$wq=bless({$x3,$nq,$D,$oq,$j4,$vq},$Q3);
$xq=q#lib/branch.c::ctors#;
$yq=q#ni:/lib/branch.b#;
$zq=q#ni:/lib/branch.c#;
$Aq={$Q3,1};
$Bq=q#/lib/branch.c#;
$Cq=[$W7];
$Dq=bless({$x3,$Aq,$D,$Bq,$j4,$Cq},$k4);
$Eq=q#ni:/lib/branch_init.b#;
$Fq=q#ni:/lib/class_init.b#;
$Gq=q#ni:/lib/dataslice#;
$Hq={$O5,1};
$Iq=q#/lib/dataslice#;
$Jq={};
$Kq=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Lq=bless({$q,$Kq,$s,$t},$u);
$Mq={$s5,$Lq};
$Nq=q#/lib/dataslice_init.b#;
$Oq=bless({$x3,$Jq,$q4,$r4,$s4,$r4,$t4,$Mq,$D,$Nq},$C4);
$Pq={};
$Qq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Rq=bless({$q,$Qq,$s,$t},$u);
$Sq={$x4,$Rq};
$Tq=q#/lib/dataslice_apply.b#;
$Uq=bless({$x3,$Pq,$q4,$r4,$s4,$r4,$t4,$Sq,$D,$Tq},$C4);
$Vq=[$r6,$Oq,$Uq];
$Wq=bless({$x3,$Hq,$D,$Iq,$j4,$Vq},$R3);
$Xq=q#lib/dataslice.c::ctors#;
$Yq=q#ni:/lib/dataslice.c#;
$Zq={$R3,1};
$cr=q#/lib/dataslice.c#;
$dr=[$W7];
$er=bless({$x3,$Zq,$D,$cr,$j4,$dr},$k4);
$fr=q#ni:/lib/dataslice_apply.b#;
$gr=q#ni:/lib/dataslice_init.b#;
$hr=q#ni:/lib/definition.b#;
$ir=q#ni:/lib/definition_def.b#;
$jr=q#ni:/lib/definition_defdata.b#;
$kr=q#ni:/lib/doc#;
$lr={$F,1};
$mr={};
$nr=q#shift; +{name => shift, doc => []}#;
$or=bless({$q,$nr,$s,$t},$u);
$pr={$s5,$or};
$qr=q#/lib/doc_init.b#;
$rr=bless({$x3,$mr,$q4,$r4,$s4,$r4,$t4,$pr,$D,$qr},$C4);
$sr={};
$tr=q#'ni.doc'#;
$ur=bless({$q,$tr,$s,$t},$u);
$vr={$Q4,$ur};
$wr=q#/lib/doc_namespace.b#;
$xr=bless({$x3,$sr,$q4,$r4,$s4,$r4,$t4,$vr,$D,$wr},$C4);
$yr={};
$zr=q#AUTOLOAD#;
$Ar=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Br=bless({$q,$Ar,$s,$t},$u);
$Cr={$zr,$Br};
$Dr=q#/lib/doc_define.b#;
$Er=bless({$x3,$yr,$q4,$r4,$s4,$r4,$t4,$Cr,$D,$Dr},$C4);
$Fr={};
$Gr=q#shift->referent#;
$Hr=bless({$q,$Gr,$s,$t},$u);
$Ir=q#referent#;
$Jr=q#ni 'ni:' . shift->{name}#;
$Kr=bless({$q,$Jr,$s,$t},$u);
$Lr={$El,$Hr,$Ir,$Kr};
$Mr=q#/lib/doc_end.b#;
$Nr=bless({$x3,$Fr,$q4,$r4,$s4,$r4,$t4,$Lr,$D,$Mr},$C4);
$Or={};
$Pr=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Qr=bless({$q,$Pr,$s,$t},$u);
$Rr=q#tests#;
$Sr=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Tr=bless({$q,$Sr,$s,$t},$u);
$Ur={$n,$Qr,$Rr,$Tr};
$Vr=q#/lib/doc_test.b#;
$Wr=bless({$x3,$Or,$q4,$r4,$s4,$r4,$t4,$Ur,$D,$Vr},$C4);
$Xr=[$g6,$N4,$rr,$xr,$Er,$Nr,$Wr];
$Yr=bless({$x3,$lr,$D,$M2,$j4,$Xr},$S3);
$Zr=q#lib/doc.c::ctors#;
$cs=q#ni:/lib/doc.c#;
$ds={$S3,1};
$es=q#/lib/doc.c#;
$fs=[$R7];
$gs=bless({$x3,$ds,$D,$es,$j4,$fs},$k4);
$hs=q#ni:/lib/doc_define.b#;
$is=q#ni:/lib/doc_end.b#;
$js=q#ni:/lib/doc_init.b#;
$ks=q#ni:/lib/doc_namespace.b#;
$ls=q#ni:/lib/doc_test.b#;
$ms=q#ni:/lib/documentable.b#;
$ns=q#ni:/lib/fn#;
$os={$u,1};
$ps=q#/lib/fn#;
$qs={};
$rs=q#shift->compile#;
$ss=bless({$q,$rs,$s,$t},$u);
$ts=q#compile#;
$us=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$vs=bless({$q,$us,$s,$t},$u);
$ws=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$xs=bless({$q,$ws,$s,$t},$u);
$ys={$ts,$vs,$s5,$xs};
$zs=q#/lib/fn_init.b#;
$As=bless({$x3,$qs,$q4,$ss,$s4,$r4,$t4,$ys,$D,$zs},$C4);
$Bs={};
$Cs=[];
$Ds=q#shift->{'annotations'}#;
$Es=bless({$o,$Cs,$q,$Ds,$s,$t},$u);
$Fs=[];
$Gs=q#shift->{'code'}#;
$Hs=bless({$o,$Fs,$q,$Gs,$s,$t},$u);
$Is=q#fn#;
$Js=[];
$Ks=q#shift->{'fn'}#;
$Ls=bless({$o,$Js,$q,$Ks,$s,$t},$u);
$Ms={$o,$Es,$q,$Hs,$Is,$Ls};
$Ns=q#/lib/fn_ro.b#;
$Os=bless({$x3,$Bs,$q4,$r4,$s4,$r4,$t4,$Ms,$D,$Ns},$C4);
$Ps={};
$Qs=[];
$Rs=q#shift->{code}#;
$Ss=bless({$o,$Qs,$q,$Rs,$s,$t},$u);
$Ts=[];
$Us=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Vs=bless({$o,$Ts,$q,$Us,$s,$t},$u);
$Ws={$N6,$Ss,$U6,$Vs};
$Xs=q#/lib/fn_ops.b#;
$Ys=bless({$x3,$Ps,$q4,$r4,$s4,$r4,$t4,$Ws,$D,$Xs},$C4);
$Zs={};
$ct=q#serialize#;
$dt=[];
$et=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$ft=bless({$o,$dt,$q,$et,$s,$t},$u);
$gt={$ct,$ft};
$ht=q#/lib/fn_serialize.b#;
$it=bless({$x3,$Zs,$q4,$r4,$s4,$r4,$t4,$gt,$D,$ht},$C4);
$jt=[$g6,$y7,$As,$Os,$Ys,$it];
$kt=bless({$x3,$os,$D,$ps,$j4,$jt},$T3);
$lt=q#lib/fn.c::ctors#;
$mt=q#ni:/lib/fn.c#;
$nt={$T3,1};
$ot=q#/lib/fn.c#;
$pt=[$R7];
$qt=bless({$x3,$nt,$D,$ot,$j4,$pt},$k4);
$rt=q#ni:/lib/fn_init.b#;
$st=q#ni:/lib/fn_ops.b#;
$tt=q#ni:/lib/fn_ro.b#;
$ut=q#ni:/lib/fn_serialize.b#;
$vt=q#ni:/lib/gensym_generator_compact.b#;
$wt={};
$xt=q#gensym#;
$yt=[];
$zt=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$At=bless({$o,$yt,$q,$zt,$s,$t},$u);
$Bt={$xt,$At};
$Ct=q#/lib/gensym_generator_compact.b#;
$Dt=bless({$x3,$wt,$q4,$r4,$s4,$r4,$t4,$Bt,$D,$Ct},$C4);
$Et=q#ni:/lib/global_static_test.b#;
$Ft={};
$Gt=q#now#;
$Ht=[];
$It=q#ni('ni:/lib/test_value')->new(shift)#;
$Jt=q#($)#;
$Kt=bless({$o,$Ht,$q,$It,$s,$Jt},$u);
$Lt={$Gt,$Kt};
$Mt=q#/lib/global_static_test.b#;
$Nt=bless({$x3,$Ft,$q4,$r4,$s4,$r4,$t4,$Lt,$D,$Mt},$C4);
$Ot=q#ni:/lib/image#;
$Pt={$P5,1};
$Qt={};
$Rt=[];
$St=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Tt=bless({$o,$Rt,$q,$St,$s,$t},$u);
$Ut={$s5,$Tt};
$Vt=q#/lib/image_init.b#;
$Wt=bless({$x3,$Qt,$q4,$r4,$s4,$r4,$t4,$Ut,$D,$Vt},$C4);
$Xt={};
$Yt=q#address#;
$Zt=[];
$cu=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$du=bless({$o,$Zt,$q,$cu,$s,$t},$u);
$eu=q#allocate_gensym#;
$fu=[];
$gu=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$hu=bless({$o,$fu,$q,$gu,$s,$t},$u);
$iu=q#boot_side_effect#;
$ju=[];
$ku=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$lu=bless({$o,$ju,$q,$ku,$s,$t},$u);
$mu=q#circular_links#;
$nu=[];
$ou=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$pu=bless({$o,$nu,$q,$ou,$s,$t},$u);
$qu=q#finalizer#;
$ru=[];
$su=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$tu=bless({$o,$ru,$q,$su,$s,$t},$u);
$uu=q#quote#;
$vu=[];
$wu=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$xu=bless({$o,$vu,$q,$wu,$s,$t},$u);
$yu=q#reconstruction#;
$zu=[];
$Au=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Bu=bless({$o,$zu,$q,$Au,$s,$t},$u);
$Cu=q#side_effect#;
$Du=[];
$Eu=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Fu=bless({$o,$Du,$q,$Eu,$s,$t},$u);
$Gu=[];
$Hu=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Iu=bless({$o,$Gu,$q,$Hu,$s,$t},$u);
$Ju={$Yt,$du,$eu,$hu,$iu,$lu,$mu,$pu,$qu,$tu,$uu,$xu,$yu,$Bu,$Cu,$Fu,$pa,$Iu};
$Ku=q#/lib/image_quoting.b#;
$Lu=bless({$x3,$Xt,$q4,$r4,$s4,$r4,$t4,$Ju,$D,$Ku},$C4);
$Mu={};
$Nu=q#quote_code#;
$Ou=[];
$Pu=q#shift->die('cannot quote perl CODE refs', shift)#;
$Qu=bless({$o,$Ou,$q,$Pu,$s,$t},$u);
$Ru={$Nu,$Qu};
$Su=q#/lib/quote_code_fail.b#;
$Tu=bless({$x3,$Mu,$q4,$r4,$s4,$r4,$t4,$Ru,$D,$Su},$C4);
$Uu={};
$Vu=q#quote_array#;
$Wu=[];
$Xu=q#local $_;
my ($self, $v) = @_;
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Yu=bless({$o,$Wu,$q,$Xu,$s,$t},$u);
$Zu=q#quote_hash#;
$cv=[];
$dv=q#local $_;
my ($self, $v) = @_;
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$ev=bless({$o,$cv,$q,$dv,$s,$t},$u);
$fv=q#quote_scalar#;
$gv=[];
$hv=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$iv=bless({$o,$gv,$q,$hv,$s,$t},$u);
$jv=q#quote_scalar_ref#;
$kv=[];
$lv=q#'\\\\' . shift->quote(${$_[0]})#;
$mv=bless({$o,$kv,$q,$lv,$s,$t},$u);
$nv=q#quote_value#;
$ov=[];
$pv=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$qv=bless({$o,$ov,$q,$pv,$s,$t},$u);
$rv={$Vu,$Yu,$Zu,$ev,$fv,$iv,$jv,$mv,$nv,$qv};
$sv=q#/lib/quote_values.b#;
$tv=bless({$x3,$Uu,$q4,$r4,$s4,$r4,$t4,$rv,$D,$sv},$C4);
$uv={};
$vv=q#quote_blessed#;
$wv=[];
$xv=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$yv=bless({$o,$wv,$q,$xv,$s,$t},$u);
$zv=q#quote_class#;
$Av=[];
$Bv=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Cv=bless({$o,$Av,$q,$Bv,$s,$t},$u);
$Dv=q#quote_object#;
$Ev=[];
$Fv=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . '::ctors') . ';')
  if @{ref($_[0]) . '::ctors'};
$q;#;
$Gv=bless({$o,$Ev,$q,$Fv,$s,$t},$u);
$Hv={$vv,$yv,$zv,$Cv,$Dv,$Gv};
$Iv=q#/lib/quote_objects.b#;
$Jv=bless({$x3,$uv,$q4,$r4,$s4,$r4,$t4,$Hv,$D,$Iv},$C4);
$Kv={};
$Lv=q#circular_arrayref#;
$Mv=[];
$Nv=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Ov=bless({$o,$Mv,$q,$Nv,$s,$t},$u);
$Pv=q#circular_hashref#;
$Qv=[];
$Rv=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Sv=bless({$o,$Qv,$q,$Rv,$s,$t},$u);
$Tv=q#is_circular#;
$Uv=[];
$Vv=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Wv=bless({$o,$Uv,$q,$Vv,$s,$t},$u);
$Xv={$Lv,$Ov,$Pv,$Sv,$Tv,$Wv};
$Yv=q#/lib/quote_circular_addressed.b#;
$Zv=bless({$x3,$Kv,$q4,$r4,$s4,$r4,$t4,$Xv,$D,$Yv},$C4);
$cw=[$g6,$Wt,$Lu,$Tu,$tv,$Jv,$Zv,$Dt];
$dw=bless({$x3,$Pt,$D,$U2,$j4,$cw},$U3);
$ew=q#lib/image.c::ctors#;
$fw=q#ni:/lib/image.c#;
$gw={$U3,1};
$hw=q#/lib/image.c#;
$iw=[$R7];
$jw=bless({$x3,$gw,$D,$hw,$j4,$iw},$k4);
$kw=q#ni:/lib/image_init.b#;
$lw=q#ni:/lib/image_quoting.b#;
$mw=q#ni:/lib/instance.b#;
$nw=q#ni:/lib/instantiable.b#;
$ow=q#ni:/lib/json.b#;
$pw={};
$qw=q#json_decode#;
$rw=[];
$sw=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$tw=bless({$o,$rw,$q,$sw,$s,$Jt},$u);
$uw=q#json_encode#;
$vw=[];
$ww=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$xw=bless({$o,$vw,$q,$ww,$s,$Jt},$u);
$yw=q#json_escape#;
$zw=[];
$Aw=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Bw=bless({$o,$zw,$q,$Aw,$s,$Jt},$u);
$Cw=q#json_unescape#;
$Dw=[];
$Ew=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Fw=bless({$o,$Dw,$q,$Ew,$s,$Jt},$u);
$Gw=q#json_unescape_one#;
$Hw=[];
$Iw=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Jw=bless({$o,$Hw,$q,$Iw,$s,$Jt},$u);
$Kw={$qw,$tw,$uw,$xw,$yw,$Bw,$Cw,$Fw,$Gw,$Jw};
$Lw=q#/lib/json.b#;
$Mw=bless({$x3,$pw,$q4,$r4,$s4,$r4,$t4,$Kw,$D,$Lw},$C4);
$Nw=q#ni#;
$Ow=q#ni:/lib/name_as_string.b#;
$Pw=q#ni:/lib/named.b#;
$Qw=q#ni:/lib/named_in_ni.b#;
$Rw=q#ni:/lib/namespaced.b#;
$Sw=q#ni:/lib/ni#;
$Tw={$Q5,1};
$Uw={};
$Vw=q#extend#;
$Ww=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Xw=bless({$q,$Ww,$s,$t},$u);
$Yw=q#is_mutable#;
$Zw=q#$0 ne '-' && -w $0#;
$cx=bless({$q,$Zw,$s,$t},$u);
$dx=q#modify#;
$ex=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$fx=bless({$q,$ex,$s,$t},$u);
$gx={$Vw,$Xw,$Yw,$cx,$dx,$fx};
$hx=q#/lib/ni_self.b#;
$ix=bless({$x3,$Uw,$q4,$r4,$s4,$r4,$t4,$gx,$D,$hx},$C4);
$jx={};
$kx=q#--internal/+=#;
$lx=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$mx=bless({$q,$lx,$s,$t},$u);
$nx=q#--internal/eval#;
$ox=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$px=bless({$q,$ox,$s,$t},$u);
$qx=q#--internal/image#;
$rx=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$sx=bless({$q,$rx,$s,$t},$u);
$tx=q#--internal/test#;
$ux=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$vx=bless({$q,$ux,$s,$t},$u);
$wx=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$xx=bless({$q,$wx,$s,$t},$u);
$yx={$kx,$mx,$nx,$px,$qx,$sx,$tx,$vx,$No,$xx};
$zx=q#/lib/ni_main.b#;
$Ax=bless({$x3,$jx,$q4,$r4,$s4,$r4,$t4,$yx,$D,$zx},$C4);
$Bx={};
$Cx=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Dx=bless({$q,$Cx,$s,$t},$u);
$Ex=q#resolver_for#;
$Fx=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Gx=bless({$q,$Fx,$s,$t},$u);
$Hx={$g5,$Dx,$Ex,$Gx};
$Ix=q#/lib/ni_resolver.b#;
$Jx=bless({$x3,$Bx,$q4,$r4,$s4,$r4,$t4,$Hx,$D,$Ix},$C4);
$Kx={};
$Lx=q#exists#;
$Mx=q#exists $_[0]->{named}{$_[1]}#;
$Nx=bless({$q,$Mx,$s,$t},$u);
$Ox=q#quoted#;
$Px=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Qx=bless({$q,$Px,$s,$t},$u);
$Rx={$Lx,$Nx,$Ox,$Qx};
$Sx=q#/lib/ni_image.b#;
$Tx=bless({$x3,$Kx,$q4,$r4,$s4,$r4,$t4,$Rx,$D,$Sx},$C4);
$Ux=[$g6,$ix,$Ax,$Jx,$Tx];
$Vx=bless({$x3,$Tw,$D,$e3,$j4,$Ux},$V3);
$Wx=q#lib/ni.c::ctors#;
$Xx=q#ni:/lib/ni.c#;
$Yx={$V3,1};
$Zx=q#/lib/ni.c#;
$cy=[$R7];
$dy=bless({$x3,$Yx,$D,$Zx,$j4,$cy},$k4);
$ey=q#ni:/lib/ni_image.b#;
$fy=q#ni:/lib/ni_main.b#;
$gy=q#ni:/lib/ni_resolver.b#;
$hy=q#ni:/lib/ni_self.b#;
$iy=q#ni:/lib/ni_static_util.b#;
$jy={};
$ky=q#abbrev#;
$ly=[];
$my=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$ny=bless({$o,$ly,$q,$my,$s,$t},$u);
$oy=q#dor#;
$py=[];
$qy=q#defined $_[0] ? $_[0] : $_[1]#;
$ry=bless({$o,$py,$q,$qy,$s,$t},$u);
$sy=q#indent#;
$ty=[];
$uy=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$vy=bless({$o,$ty,$q,$uy,$s,$t},$u);
$wy=q#max#;
$xy=[];
$yy=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$zy=bless({$o,$xy,$q,$yy,$s,$t},$u);
$Ay=q#maxstr#;
$By=[];
$Cy=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Dy=bless({$o,$By,$q,$Cy,$s,$t},$u);
$Ey=q#mean#;
$Fy=[];
$Gy=q#sum(@_) / (@_ || 1)#;
$Hy=bless({$o,$Fy,$q,$Gy,$s,$t},$u);
$Iy=q#min#;
$Jy=[];
$Ky=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Ly=bless({$o,$Jy,$q,$Ky,$s,$t},$u);
$My=q#minstr#;
$Ny=[];
$Oy=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Py=bless({$o,$Ny,$q,$Oy,$s,$t},$u);
$Qy=q#sgr#;
$Ry=[];
$Sy=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Ty=bless({$o,$Ry,$q,$Sy,$s,$t},$u);
$Uy=q#sr#;
$Vy=[];
$Wy=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Xy=bless({$o,$Vy,$q,$Wy,$s,$t},$u);
$Yy=q#sum#;
$Zy=[];
$cz=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$dz=bless({$o,$Zy,$q,$cz,$s,$t},$u);
$ez=q#swap#;
$fz=[];
$gz=q#@_[0, 1] = @_[1, 0]#;
$hz=bless({$o,$fz,$q,$gz,$s,$t},$u);
$iz={$ky,$ny,$oy,$ry,$sy,$vy,$wy,$zy,$Ay,$Dy,$Ey,$Hy,$Iy,$Ly,$My,$Py,$Qy,$Ty,$Uy,$Xy,$Yy,$dz,$ez,$hz};
$jz=q#/lib/ni_static_util.b#;
$kz=bless({$x3,$jy,$q4,$r4,$s4,$r4,$t4,$iz,$D,$jz},$C4);
$lz=q#ni:/lib/perlbranch.b#;
$mz=q#ni:/lib/quote_circular_addressed.b#;
$nz=q#ni:/lib/quote_code_fail.b#;
$oz=q#ni:/lib/quote_objects.b#;
$pz=q#ni:/lib/quote_simple#;
$qz={$R5,1};
$rz={};
$sz=[];
$tz=q#+{}#;
$uz=bless({$o,$sz,$q,$tz,$s,$t},$u);
$vz={$s5,$uz};
$wz=q#/lib/quote_simple_init.b#;
$xz=bless({$x3,$rz,$q4,$r4,$s4,$r4,$t4,$vz,$D,$wz},$C4);
$yz={};
$zz=[];
$Az=bless({$o,$zz,$q,0,$s,$t},$u);
$Bz=[];
$Cz=q#shift->quote_value(shift)#;
$Dz=bless({$o,$Bz,$q,$Cz,$s,$t},$u);
$Ez={$Tv,$Az,$uu,$Dz};
$Fz=q#/lib/quote_simple_quote.b#;
$Gz=bless({$x3,$yz,$q4,$r4,$s4,$r4,$t4,$Ez,$D,$Fz},$C4);
$Hz=[$g6,$xz,$Gz,$Tu,$tv,$Jv];
$Iz=bless({$x3,$qz,$D,$o3,$j4,$Hz},$W3);
$Jz=q#lib/quote_simple.c::ctors#;
$Kz=q#ni:/lib/quote_simple.c#;
$Lz={$W3,1};
$Mz=q#/lib/quote_simple.c#;
$Nz=[$R7];
$Oz=bless({$x3,$Lz,$D,$Mz,$j4,$Nz},$k4);
$Pz=q#ni:/lib/quote_simple_init.b#;
$Qz=q#ni:/lib/quote_simple_quote.b#;
$Rz=q#ni:/lib/quote_values.b#;
$Sz=q#ni:/lib/ref_eq.b#;
$Tz=q#ni:/lib/resolver.b#;
$Uz=q#ni:/lib/slice#;
$Vz={$C4,1};
$Wz=q#/lib/slice#;
$Xz=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Yz=bless({$q,$Xz,$s,$t},$u);
$Zz=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$cA=bless({$q,$Zz,$s,$t},$u);
$dA=q#lib/slice::apply#;
$eA=q#lib/slice::apply_unsafe#;
$fA={};
$gA=q#apply_unsafe#;
$hA={$x4,$Yz,$gA,$cA};
$iA=q#/lib/slice.b#;
$jA=bless({$x3,$fA,$t4,$hA,$D,$iA},$C4);
$kA={};
$lA=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$mA=bless({$q,$lA,$s,$t},$u);
$nA={$s5,$mA};
$oA=q#/lib/slice_init.b#;
$pA=bless({$x3,$kA,$t4,$nA,$D,$oA},$C4);
$qA={};
$rA=[];
$sA=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$tA=bless({$o,$rA,$q,$sA,$s,$t},$u);
$uA={$ct,$tA};
$vA=q#/lib/slice_serialize.b#;
$wA=bless({$x3,$qA,$q4,$r4,$s4,$r4,$t4,$uA,$D,$vA},$C4);
$xA=[$r6,$N4,$jA,$pA,$wA];
$yA=bless({$x3,$Vz,$D,$Wz,$j4,$xA},$X3);
$zA=q#lib/slice.c::ctors#;
$AA=q#ni:/lib/slice.b#;
$BA=q#ni:/lib/slice.c#;
$CA={$X3,1};
$DA=q#/lib/slice.c#;
$EA=[$W7];
$FA=bless({$x3,$CA,$D,$DA,$j4,$EA},$k4);
$GA=q#ni:/lib/slice_init.b#;
$HA=q#ni:/lib/slice_serialize.b#;
$IA=q#ni:/lib/static_fn.b#;
$JA={};
$KA=[];
$LA=q#ni('ni:/lib/fn')->new(@_)#;
$MA=bless({$o,$KA,$q,$LA,$s,$Jt},$u);
$NA=q#fp#;
$OA=[];
$PA=q#($$)#;
$QA=bless({$o,$OA,$q,$LA,$s,$PA},$u);
$RA={$Is,$MA,$NA,$QA};
$SA=q#/lib/static_fn.b#;
$TA=bless({$x3,$JA,$q4,$r4,$s4,$r4,$t4,$RA,$D,$SA},$C4);
$UA=q#ni:/lib/subclass.b#;
$VA=q#ni:/lib/tag#;
$WA={$O4,1};
$XA=q#/lib/tag#;
$YA={};
$ZA=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$cB=bless({$q,$ZA,$s,$t},$u);
$dB={$x4,$cB};
$eB=q#/lib/tag.b#;
$fB=bless({$x3,$YA,$q4,$r4,$s4,$r4,$t4,$dB,$D,$eB},$C4);
$gB={};
$hB=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$iB=bless({$q,$hB,$s,$t},$u);
$jB={$s5,$iB};
$kB=q#/lib/tag_init.b#;
$lB=bless({$x3,$gB,$q4,$r4,$s4,$r4,$t4,$jB,$D,$kB},$C4);
$mB=[$r6,$N4,$fB,$lB];
$nB=bless({$x3,$WA,$D,$XA,$j4,$mB},$Y3);
$oB=q#lib/tag.c::ctors#;
$pB=q#ni:/lib/tag.b#;
$qB=q#ni:/lib/tag.c#;
$rB={$Y3,1};
$sB=q#/lib/tag.c#;
$tB=[$W7];
$uB=bless({$x3,$rB,$D,$sB,$j4,$tB},$k4);
$vB=q#ni:/lib/tag_init.b#;
$wB=q#ni:/lib/test_value#;
$xB={$S5,1};
$yB=q#/lib/test_value#;
$zB={};
$AB=[];
$BB=q#\\$_[1]#;
$CB=bless({$o,$AB,$q,$BB,$s,$t},$u);
$DB={$s5,$CB};
$EB=q#/lib/test_value_init.b#;
$FB=bless({$x3,$zB,$q4,$r4,$s4,$r4,$t4,$DB,$D,$EB},$C4);
$GB={};
$HB=q#(==#;
$IB=[];
$JB=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$KB=bless({$o,$IB,$q,$JB,$s,$t},$u);
$LB=q#diff#;
$MB=[];
$NB=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]}
    unless !defined($lhs) && !defined($rhs) || $lhs eq $rhs;
}
return undef;#;
$OB=bless({$o,$MB,$q,$NB,$s,$t},$u);
$PB={$HB,$KB,$LB,$OB};
$QB=q#/lib/test_value_eq.b#;
$RB=bless({$x3,$GB,$q4,$r4,$s4,$r4,$t4,$PB,$D,$QB},$C4);
$SB={};
$TB=[];
$UB=q#ni::json_encode ${$_[0]}#;
$VB=bless({$o,$TB,$q,$UB,$s,$t},$u);
$WB={$N6,$VB};
$XB=q#/lib/test_value_str.b#;
$YB=bless({$x3,$SB,$q4,$r4,$s4,$r4,$t4,$WB,$D,$XB},$C4);
$ZB=[$g6,$FB,$RB,$YB];
$cC=bless({$x3,$xB,$D,$yB,$j4,$ZB},$Z3);
$dC=q#lib/test_value.c::ctors#;
$eC=q#ni:/lib/test_value.c#;
$fC={$Z3,1};
$gC=q#/lib/test_value.c#;
$hC=[$R7];
$iC=bless({$x3,$fC,$D,$gC,$j4,$hC},$k4);
$jC=q#ni:/lib/test_value_eq.b#;
$kC=q#ni:/lib/test_value_init.b#;
$lC=q#ni:/lib/test_value_str.b#;
$mC=q#ni:/metaclass#;
$nC={$k4,1};
$oC=q#/metaclass#;
$pC=[$n5,$y7,$x5,$n7];
$qC=bless({$x3,$nC,$D,$oC,$j4,$pC},$c4);
$rC=q#metaclass.c::ctors#;
$sC=q#ni:/metaclass.c#;
$tC={$c4,1};
$uC=q#/metaclass.c#;
$vC=[$H7];
$wC=bless({$x3,$tC,$D,$uC,$j4,$vC},$k4);
$xC=q#ni:/module#;
$yC=q#ni:/module.c#;
$zC=q#ni:/object#;
$AC=q#ni:/object.c#;
$BC=q#ni:/semantic/dimension#;
$CC={$f4,1};
$DC=q#/semantic/dimension#;
$EC=[$H7];
$FC=bless({$x3,$CC,$D,$DC,$j4,$EC},$g4);
$GC=q#semantic/dimension.c::ctors#;
$HC=q#ni:/semantic/dimension.c#;
$IC={$g4,1};
$JC=q#/semantic/dimension.c#;
$KC=[$c8];
$LC=bless({$x3,$IC,$D,$JC,$j4,$KC},$k4);
$MC=q#ni:/semantic/task#;
$NC=q#ni:/semantic/task.c#;
$OC=q#ni:/semantic/task_outcome.b#;
$PC=q#ni:/semantic/task_ro.b#;
$QC=q#ni:main#;
$RC={$ej,1};
$SC=[$TA,$Nt,$dj];
$TC=bless({$x3,$RC,$D,$ej,$j4,$SC},$l4);
$UC=q#module::ctors#;
$VC=q#ni:ni#;
$WC={$Nw,1};
$XC={$Nw,1};
$YC=q#json_escapes#;
$ZC=q##;
$cD=q#b#;
$dD=q#	#;
$eD=q#t#;
$fD=q#
#;
$gD=q#n#;
$hD=q##;
$iD=q#"#;
$jD=q#/#;
$kD=q#\\#;
$lD={$ZC,$cD,$dD,$eD,$fD,$gD,$hD,$Cf,$iD,$iD,$jD,$jD,$kD,$kD};
$mD=q#json_unescapes#;
$nD={$iD,$iD,$jD,$jD,$kD,$kD,$cD,$ZC,$gD,$fD,$Cf,$hD,$eD,$dD};
$oD={$YC,$lD,$mD,$nD};
$pD=q#/lib/json_data.b#;
$qD=bless({$x3,$XC,$Al,$oD,$D,$pD},$O5);
$rD=[$qD,$Mw,$kz];
$sD=bless({$x3,$WC,$D,$Nw,$j4,$rD},$l4);
$tD={$d,$G,$I,$N,$O,$R,$S,$X,$Y,$l1,$m1,$x1,$y1,$J1,$K1,$S1,$T1,$Y1,$Z1,$q2,$r2,$x2,$y2,$N2,$O2,$V2,$W2,$f3,$g3,$p3,$q3,$v3,$w3,$H7,$J7,$c8,$d8,$n8,$p8,$t8,$u8,$l8,$v8,$Ba,$Da,$Ta,$Ua,$fa,$Va,$za,$Wa,$pb,$rb,$vb,$wb,$gb,$xb,$nb,$yb,$kd,$md,$qd,$rd,$Qc,$sd,$id,$td,$Ob,$ud,$Ic,$vd,$kc,$wd,$Hb,$xd,$Ke,$Me,$Qe,$Re,$ne,$Se,$ye,$Te,$Nd,$Ue,$Ie,$Ve,$Gd,$We,$Vd,$Xe,$Uf,$Wf,$cg,$dg,$qf,$eg,$xf,$fg,$Sf,$gg,$if,$hg,$qh,$sh,$wh,$xh,$si,$ui,$oh,$vi,$zi,$Ai,$Vh,$Bi,$qi,$Ci,$di,$Di,$Oh,$Ei,$Bg,$Fi,$Wg,$Gi,$ug,$Hi,$Jg,$Ii,$dj,$fj,$Dj,$Fj,$Jj,$Kj,$oj,$Lj,$Bj,$Mj,$V9,$Nj,$Ra,$Oj,$Pa,$Pj,$Z8,$Qj,$j9,$Rj,$v9,$Sj,$F8,$Tj,$T9,$Uj,$H9,$Vj,$kl,$ml,$ql,$rl,$il,$sl,$uk,$tl,$Qk,$ul,$kk,$vl,$Gk,$wl,$nm,$pm,$tm,$um,$Vl,$vm,$lm,$wm,$Ol,$xm,$Jn,$Ln,$co,$do,$Yn,$eo,$dp,$fp,$yp,$zp,$wp,$Ap,$Bo,$Bp,$Lo,$Cp,$uo,$Dp,$Xo,$Ep,$nn,$Fp,$Hn,$Gp,$Yp,$cq,$gq,$hq,$Pp,$iq,$Wp,$jq,$L6,$kq,$r6,$lq,$W7,$mq,$wq,$yq,$D4,$zq,$Dq,$Eq,$uq,$Fq,$x5,$Gq,$Wq,$Yq,$er,$fr,$Uq,$gr,$Oq,$hr,$k7,$ir,$B6,$jr,$i7,$kr,$Yr,$cs,$gs,$hs,$Er,$is,$Nr,$js,$rr,$ks,$xr,$ls,$Wr,$ms,$p6,$ns,$kt,$mt,$qt,$rt,$As,$st,$Ys,$tt,$Os,$ut,$it,$vt,$Dt,$Et,$Nt,$Ot,$dw,$fw,$jw,$kw,$Wt,$lw,$Lu,$mw,$e6,$nw,$y7,$ow,$Mw,$Ow,$S6,$Pw,$N4,$Qw,$V4,$Rw,$e5,$Sw,$Vx,$Xx,$dy,$ey,$Tx,$fy,$Ax,$gy,$Jx,$hy,$ix,$iy,$kz,$lz,$n5,$mz,$Zv,$nz,$Tu,$oz,$Jv,$pz,$Iz,$Kz,$Oz,$Pz,$xz,$Qz,$Gz,$Rz,$tv,$Sz,$Z6,$Tz,$l5,$Uz,$yA,$AA,$jA,$BA,$FA,$GA,$pA,$HA,$wA,$IA,$TA,$UA,$F7,$VA,$nB,$pB,$fB,$qB,$uB,$vB,$lB,$wB,$cC,$eC,$iC,$jC,$RB,$kC,$FB,$lC,$YB,$mC,$qC,$sC,$wC,$xC,$n7,$yC,$Y7,$zC,$g6,$AC,$R7,$BC,$FC,$HC,$LC,$MC,$Xm,$NC,$Rn,$OC,$Vm,$PC,$Jm,$QC,$TC,$VC,$sD};
$uD=q#resolvers#;
$vD=[];
$wD=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$xD=bless({$o,$vD,$q,$wD,$s,$t},$u);
$yD=q#file#;
$zD=[];
$AD=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$BD=bless({$o,$zD,$q,$AD,$s,$t},$u);
$CD=q#null#;
$DD=[];
$ED=q#ni('ni:/io/null')->new#;
$FD=bless({$o,$DD,$q,$ED,$s,$t},$u);
$GD=q#sh#;
$HD=[];
$ID=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$JD=bless({$o,$HD,$q,$ID,$s,$t},$u);
$KD=q#str#;
$LD=[];
$MD=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$ND=bless({$o,$LD,$q,$MD,$s,$t},$u);
$OD={$qc,$xD,$yD,$BD,$CD,$FD,$GD,$JD,$KD,$ND};
$PD=bless({$c,$tD,$uD,$OD},$Q5);
*$eA=\&$cA;
*$dA=\&$Yz;
$D4->apply_unsafe($y3);
$D4->apply_unsafe($z3);
$D4->apply_unsafe($A3);
$D4->apply_unsafe($B3);
$D4->apply_unsafe($C3);
$D4->apply_unsafe($D3);
$D4->apply_unsafe($E3);
$D4->apply_unsafe($F3);
$D4->apply_unsafe($G3);
$D4->apply_unsafe($H3);
$D4->apply_unsafe($I3);
$D4->apply_unsafe($J3);
$D4->apply_unsafe($K3);
$D4->apply_unsafe($L3);
$D4->apply_unsafe($M3);
$D4->apply_unsafe($N3);
$D4->apply_unsafe($O3);
$D4->apply_unsafe($P3);
$D4->apply_unsafe($E4);
$D4->apply_unsafe($Q3);
$D4->apply_unsafe($R3);
$D4->apply_unsafe($S3);
$D4->apply_unsafe($T3);
$D4->apply_unsafe($U3);
$D4->apply_unsafe($V3);
$D4->apply_unsafe($W3);
$D4->apply_unsafe($X3);
$D4->apply_unsafe($Y3);
$D4->apply_unsafe($Z3);
$D4->apply_unsafe($k4);
$D4->apply_unsafe($c4);
$D4->apply_unsafe($l4);
$D4->apply_unsafe($d4);
$D4->apply_unsafe($e4);
$D4->apply_unsafe($f4);
$D4->apply_unsafe($g4);
$D4->apply_unsafe($h4);
$N4->apply_unsafe($y3);
$N4->apply_unsafe($z3);
$N4->apply_unsafe($A3);
$N4->apply_unsafe($B3);
$N4->apply_unsafe($C3);
$N4->apply_unsafe($D3);
$N4->apply_unsafe($E3);
$N4->apply_unsafe($F3);
$N4->apply_unsafe($G3);
$N4->apply_unsafe($H3);
$N4->apply_unsafe($I3);
$N4->apply_unsafe($J3);
$N4->apply_unsafe($K3);
$N4->apply_unsafe($L3);
$N4->apply_unsafe($M3);
$N4->apply_unsafe($N3);
$N4->apply_unsafe($O3);
$N4->apply_unsafe($P3);
$N4->apply_unsafe($E4);
$N4->apply_unsafe($Q3);
$N4->apply_unsafe($R3);
$N4->apply_unsafe($F);
$N4->apply_unsafe($S3);
$N4->apply_unsafe($T3);
$N4->apply_unsafe($U3);
$N4->apply_unsafe($V3);
$N4->apply_unsafe($W3);
$N4->apply_unsafe($C4);
$N4->apply_unsafe($X3);
$N4->apply_unsafe($O4);
$N4->apply_unsafe($Y3);
$N4->apply_unsafe($Z3);
$N4->apply_unsafe($k4);
$N4->apply_unsafe($c4);
$N4->apply_unsafe($l4);
$N4->apply_unsafe($d4);
$N4->apply_unsafe($e4);
$N4->apply_unsafe($f4);
$N4->apply_unsafe($g4);
$N4->apply_unsafe($h4);
$V4->apply_unsafe($y3);
$V4->apply_unsafe($z3);
$V4->apply_unsafe($A3);
$V4->apply_unsafe($B3);
$V4->apply_unsafe($C3);
$V4->apply_unsafe($D3);
$V4->apply_unsafe($E3);
$V4->apply_unsafe($F3);
$V4->apply_unsafe($G3);
$V4->apply_unsafe($H3);
$V4->apply_unsafe($I3);
$V4->apply_unsafe($J3);
$V4->apply_unsafe($K3);
$V4->apply_unsafe($L3);
$V4->apply_unsafe($M3);
$V4->apply_unsafe($N3);
$V4->apply_unsafe($O3);
$V4->apply_unsafe($P3);
$V4->apply_unsafe($E4);
$V4->apply_unsafe($Q3);
$V4->apply_unsafe($R3);
$V4->apply_unsafe($S3);
$V4->apply_unsafe($T3);
$V4->apply_unsafe($U3);
$V4->apply_unsafe($V3);
$V4->apply_unsafe($W3);
$V4->apply_unsafe($C4);
$V4->apply_unsafe($X3);
$V4->apply_unsafe($O4);
$V4->apply_unsafe($Y3);
$V4->apply_unsafe($Z3);
$V4->apply_unsafe($k4);
$V4->apply_unsafe($c4);
$V4->apply_unsafe($l4);
$V4->apply_unsafe($d4);
$V4->apply_unsafe($e4);
$V4->apply_unsafe($f4);
$V4->apply_unsafe($g4);
$V4->apply_unsafe($h4);
$e5->apply_unsafe($y3);
$e5->apply_unsafe($z3);
$e5->apply_unsafe($A3);
$e5->apply_unsafe($B3);
$e5->apply_unsafe($C3);
$e5->apply_unsafe($D3);
$e5->apply_unsafe($E3);
$e5->apply_unsafe($F3);
$e5->apply_unsafe($G3);
$e5->apply_unsafe($H3);
$e5->apply_unsafe($I3);
$e5->apply_unsafe($J3);
$e5->apply_unsafe($K3);
$e5->apply_unsafe($L3);
$e5->apply_unsafe($M3);
$e5->apply_unsafe($N3);
$e5->apply_unsafe($O3);
$e5->apply_unsafe($P3);
$e5->apply_unsafe($E4);
$e5->apply_unsafe($Q3);
$e5->apply_unsafe($R3);
$e5->apply_unsafe($S3);
$e5->apply_unsafe($T3);
$e5->apply_unsafe($U3);
$e5->apply_unsafe($V3);
$e5->apply_unsafe($W3);
$e5->apply_unsafe($C4);
$e5->apply_unsafe($X3);
$e5->apply_unsafe($O4);
$e5->apply_unsafe($Y3);
$e5->apply_unsafe($Z3);
$e5->apply_unsafe($k4);
$e5->apply_unsafe($c4);
$e5->apply_unsafe($l4);
$e5->apply_unsafe($d4);
$e5->apply_unsafe($e4);
$e5->apply_unsafe($f4);
$e5->apply_unsafe($g4);
$e5->apply_unsafe($h4);
$l5->apply_unsafe($y3);
$l5->apply_unsafe($z3);
$l5->apply_unsafe($A3);
$l5->apply_unsafe($B3);
$l5->apply_unsafe($C3);
$l5->apply_unsafe($D3);
$l5->apply_unsafe($E3);
$l5->apply_unsafe($F3);
$l5->apply_unsafe($G3);
$l5->apply_unsafe($H3);
$l5->apply_unsafe($I3);
$l5->apply_unsafe($J3);
$l5->apply_unsafe($K3);
$l5->apply_unsafe($L3);
$l5->apply_unsafe($M3);
$l5->apply_unsafe($N3);
$l5->apply_unsafe($O3);
$l5->apply_unsafe($P3);
$l5->apply_unsafe($E4);
$l5->apply_unsafe($Q3);
$l5->apply_unsafe($R3);
$l5->apply_unsafe($S3);
$l5->apply_unsafe($T3);
$l5->apply_unsafe($U3);
$l5->apply_unsafe($V3);
$l5->apply_unsafe($W3);
$l5->apply_unsafe($X3);
$l5->apply_unsafe($O4);
$l5->apply_unsafe($Y3);
$l5->apply_unsafe($Z3);
$l5->apply_unsafe($k4);
$l5->apply_unsafe($c4);
$l5->apply_unsafe($l4);
$l5->apply_unsafe($d4);
$l5->apply_unsafe($e4);
$l5->apply_unsafe($f4);
$l5->apply_unsafe($g4);
$l5->apply_unsafe($h4);
$x5->apply_unsafe($y3);
$x5->apply_unsafe($z3);
$x5->apply_unsafe($A3);
$x5->apply_unsafe($B3);
$x5->apply_unsafe($C3);
$x5->apply_unsafe($D3);
$x5->apply_unsafe($E3);
$x5->apply_unsafe($F3);
$x5->apply_unsafe($G3);
$x5->apply_unsafe($H3);
$x5->apply_unsafe($I3);
$x5->apply_unsafe($J3);
$x5->apply_unsafe($K3);
$x5->apply_unsafe($L3);
$x5->apply_unsafe($M3);
$x5->apply_unsafe($N3);
$x5->apply_unsafe($O3);
$x5->apply_unsafe($P3);
$x5->apply_unsafe($Q3);
$x5->apply_unsafe($R3);
$x5->apply_unsafe($S3);
$x5->apply_unsafe($T3);
$x5->apply_unsafe($U3);
$x5->apply_unsafe($V3);
$x5->apply_unsafe($W3);
$x5->apply_unsafe($X3);
$x5->apply_unsafe($Y3);
$x5->apply_unsafe($Z3);
$x5->apply_unsafe($k4);
$x5->apply_unsafe($c4);
$x5->apply_unsafe($l4);
$x5->apply_unsafe($d4);
$x5->apply_unsafe($e4);
$x5->apply_unsafe($f4);
$x5->apply_unsafe($g4);
$x5->apply_unsafe($h4);
$e6->apply_unsafe($y3);
$e6->apply_unsafe($z3);
$e6->apply_unsafe($y5);
$e6->apply_unsafe($A3);
$e6->apply_unsafe($z5);
$e6->apply_unsafe($B3);
$e6->apply_unsafe($A5);
$e6->apply_unsafe($C3);
$e6->apply_unsafe($B5);
$e6->apply_unsafe($D3);
$e6->apply_unsafe($C5);
$e6->apply_unsafe($E3);
$e6->apply_unsafe($D5);
$e6->apply_unsafe($F3);
$e6->apply_unsafe($E5);
$e6->apply_unsafe($G3);
$e6->apply_unsafe($F5);
$e6->apply_unsafe($H3);
$e6->apply_unsafe($G5);
$e6->apply_unsafe($I3);
$e6->apply_unsafe($H5);
$e6->apply_unsafe($J3);
$e6->apply_unsafe($I5);
$e6->apply_unsafe($K3);
$e6->apply_unsafe($J5);
$e6->apply_unsafe($L3);
$e6->apply_unsafe($K5);
$e6->apply_unsafe($M3);
$e6->apply_unsafe($L5);
$e6->apply_unsafe($N3);
$e6->apply_unsafe($M5);
$e6->apply_unsafe($O3);
$e6->apply_unsafe($N5);
$e6->apply_unsafe($P3);
$e6->apply_unsafe($E4);
$e6->apply_unsafe($Q3);
$e6->apply_unsafe($O5);
$e6->apply_unsafe($R3);
$e6->apply_unsafe($F);
$e6->apply_unsafe($S3);
$e6->apply_unsafe($u);
$e6->apply_unsafe($T3);
$e6->apply_unsafe($P5);
$e6->apply_unsafe($U3);
$e6->apply_unsafe($Q5);
$e6->apply_unsafe($V3);
$e6->apply_unsafe($R5);
$e6->apply_unsafe($W3);
$e6->apply_unsafe($C4);
$e6->apply_unsafe($X3);
$e6->apply_unsafe($O4);
$e6->apply_unsafe($Y3);
$e6->apply_unsafe($S5);
$e6->apply_unsafe($Z3);
$e6->apply_unsafe($k4);
$e6->apply_unsafe($c4);
$e6->apply_unsafe($l4);
$e6->apply_unsafe($d4);
$e6->apply_unsafe($T5);
$e6->apply_unsafe($e4);
$e6->apply_unsafe($f4);
$e6->apply_unsafe($g4);
$e6->apply_unsafe($U5);
$e6->apply_unsafe($h4);
$p6->apply_unsafe($y3);
$p6->apply_unsafe($z3);
$p6->apply_unsafe($A3);
$p6->apply_unsafe($B3);
$p6->apply_unsafe($C3);
$p6->apply_unsafe($D3);
$p6->apply_unsafe($E3);
$p6->apply_unsafe($F3);
$p6->apply_unsafe($G3);
$p6->apply_unsafe($H3);
$p6->apply_unsafe($I3);
$p6->apply_unsafe($J3);
$p6->apply_unsafe($K3);
$p6->apply_unsafe($L3);
$p6->apply_unsafe($M3);
$p6->apply_unsafe($N3);
$p6->apply_unsafe($O3);
$p6->apply_unsafe($N5);
$p6->apply_unsafe($P3);
$p6->apply_unsafe($E4);
$p6->apply_unsafe($Q3);
$p6->apply_unsafe($O5);
$p6->apply_unsafe($R3);
$p6->apply_unsafe($S3);
$p6->apply_unsafe($T3);
$p6->apply_unsafe($U3);
$p6->apply_unsafe($V3);
$p6->apply_unsafe($W3);
$p6->apply_unsafe($C4);
$p6->apply_unsafe($X3);
$p6->apply_unsafe($O4);
$p6->apply_unsafe($Y3);
$p6->apply_unsafe($Z3);
$p6->apply_unsafe($k4);
$p6->apply_unsafe($c4);
$p6->apply_unsafe($l4);
$p6->apply_unsafe($d4);
$p6->apply_unsafe($e4);
$p6->apply_unsafe($f4);
$p6->apply_unsafe($g4);
$p6->apply_unsafe($h4);
$B6->apply_unsafe($y3);
$B6->apply_unsafe($z3);
$B6->apply_unsafe($A3);
$B6->apply_unsafe($B3);
$B6->apply_unsafe($C3);
$B6->apply_unsafe($D3);
$B6->apply_unsafe($E3);
$B6->apply_unsafe($F3);
$B6->apply_unsafe($G3);
$B6->apply_unsafe($H3);
$B6->apply_unsafe($I3);
$B6->apply_unsafe($J3);
$B6->apply_unsafe($K3);
$B6->apply_unsafe($L3);
$B6->apply_unsafe($M3);
$B6->apply_unsafe($N3);
$B6->apply_unsafe($O3);
$B6->apply_unsafe($P3);
$B6->apply_unsafe($E4);
$B6->apply_unsafe($Q3);
$B6->apply_unsafe($R3);
$B6->apply_unsafe($S3);
$B6->apply_unsafe($T3);
$B6->apply_unsafe($U3);
$B6->apply_unsafe($V3);
$B6->apply_unsafe($W3);
$B6->apply_unsafe($X3);
$B6->apply_unsafe($Y3);
$B6->apply_unsafe($Z3);
$B6->apply_unsafe($k4);
$B6->apply_unsafe($c4);
$B6->apply_unsafe($l4);
$B6->apply_unsafe($d4);
$B6->apply_unsafe($e4);
$B6->apply_unsafe($f4);
$B6->apply_unsafe($g4);
$B6->apply_unsafe($h4);
$L6->apply_unsafe($y3);
$L6->apply_unsafe($z3);
$L6->apply_unsafe($A3);
$L6->apply_unsafe($B3);
$L6->apply_unsafe($C3);
$L6->apply_unsafe($D3);
$L6->apply_unsafe($E3);
$L6->apply_unsafe($F3);
$L6->apply_unsafe($G3);
$L6->apply_unsafe($H3);
$L6->apply_unsafe($I3);
$L6->apply_unsafe($J3);
$L6->apply_unsafe($K3);
$L6->apply_unsafe($L3);
$L6->apply_unsafe($M3);
$L6->apply_unsafe($N3);
$L6->apply_unsafe($O3);
$L6->apply_unsafe($P3);
$L6->apply_unsafe($E4);
$L6->apply_unsafe($Q3);
$L6->apply_unsafe($R3);
$L6->apply_unsafe($S3);
$L6->apply_unsafe($T3);
$L6->apply_unsafe($U3);
$L6->apply_unsafe($V3);
$L6->apply_unsafe($W3);
$L6->apply_unsafe($X3);
$L6->apply_unsafe($Y3);
$L6->apply_unsafe($Z3);
$L6->apply_unsafe($k4);
$L6->apply_unsafe($c4);
$L6->apply_unsafe($l4);
$L6->apply_unsafe($d4);
$L6->apply_unsafe($e4);
$L6->apply_unsafe($f4);
$L6->apply_unsafe($g4);
$L6->apply_unsafe($h4);
$S6->apply_unsafe($y3);
$S6->apply_unsafe($z3);
$S6->apply_unsafe($A3);
$S6->apply_unsafe($B3);
$S6->apply_unsafe($C3);
$S6->apply_unsafe($D3);
$S6->apply_unsafe($E3);
$S6->apply_unsafe($F3);
$S6->apply_unsafe($G3);
$S6->apply_unsafe($H3);
$S6->apply_unsafe($I3);
$S6->apply_unsafe($J3);
$S6->apply_unsafe($K3);
$S6->apply_unsafe($L3);
$S6->apply_unsafe($M3);
$S6->apply_unsafe($N3);
$S6->apply_unsafe($O3);
$S6->apply_unsafe($P3);
$S6->apply_unsafe($E4);
$S6->apply_unsafe($Q3);
$S6->apply_unsafe($R3);
$S6->apply_unsafe($S3);
$S6->apply_unsafe($T3);
$S6->apply_unsafe($U3);
$S6->apply_unsafe($V3);
$S6->apply_unsafe($W3);
$S6->apply_unsafe($X3);
$S6->apply_unsafe($Y3);
$S6->apply_unsafe($Z3);
$S6->apply_unsafe($k4);
$S6->apply_unsafe($c4);
$S6->apply_unsafe($l4);
$S6->apply_unsafe($d4);
$S6->apply_unsafe($e4);
$S6->apply_unsafe($f4);
$S6->apply_unsafe($g4);
$S6->apply_unsafe($h4);
$Z6->apply_unsafe($y3);
$Z6->apply_unsafe($z3);
$Z6->apply_unsafe($A3);
$Z6->apply_unsafe($B3);
$Z6->apply_unsafe($C3);
$Z6->apply_unsafe($D3);
$Z6->apply_unsafe($E3);
$Z6->apply_unsafe($F3);
$Z6->apply_unsafe($G3);
$Z6->apply_unsafe($H3);
$Z6->apply_unsafe($I3);
$Z6->apply_unsafe($J3);
$Z6->apply_unsafe($K3);
$Z6->apply_unsafe($L3);
$Z6->apply_unsafe($M3);
$Z6->apply_unsafe($N3);
$Z6->apply_unsafe($O3);
$Z6->apply_unsafe($P3);
$Z6->apply_unsafe($E4);
$Z6->apply_unsafe($Q3);
$Z6->apply_unsafe($R3);
$Z6->apply_unsafe($S3);
$Z6->apply_unsafe($T3);
$Z6->apply_unsafe($U3);
$Z6->apply_unsafe($V3);
$Z6->apply_unsafe($W3);
$Z6->apply_unsafe($X3);
$Z6->apply_unsafe($Y3);
$Z6->apply_unsafe($Z3);
$Z6->apply_unsafe($k4);
$Z6->apply_unsafe($c4);
$Z6->apply_unsafe($l4);
$Z6->apply_unsafe($d4);
$Z6->apply_unsafe($e4);
$Z6->apply_unsafe($f4);
$Z6->apply_unsafe($g4);
$Z6->apply_unsafe($h4);
$i7->apply_unsafe($y3);
$i7->apply_unsafe($z3);
$i7->apply_unsafe($A3);
$i7->apply_unsafe($B3);
$i7->apply_unsafe($C3);
$i7->apply_unsafe($D3);
$i7->apply_unsafe($E3);
$i7->apply_unsafe($F3);
$i7->apply_unsafe($G3);
$i7->apply_unsafe($H3);
$i7->apply_unsafe($I3);
$i7->apply_unsafe($J3);
$i7->apply_unsafe($K3);
$i7->apply_unsafe($L3);
$i7->apply_unsafe($M3);
$i7->apply_unsafe($N3);
$i7->apply_unsafe($O3);
$i7->apply_unsafe($P3);
$i7->apply_unsafe($E4);
$i7->apply_unsafe($Q3);
$i7->apply_unsafe($R3);
$i7->apply_unsafe($S3);
$i7->apply_unsafe($T3);
$i7->apply_unsafe($U3);
$i7->apply_unsafe($V3);
$i7->apply_unsafe($W3);
$i7->apply_unsafe($X3);
$i7->apply_unsafe($Y3);
$i7->apply_unsafe($Z3);
$i7->apply_unsafe($k4);
$i7->apply_unsafe($c4);
$i7->apply_unsafe($l4);
$i7->apply_unsafe($d4);
$i7->apply_unsafe($e4);
$i7->apply_unsafe($f4);
$i7->apply_unsafe($g4);
$i7->apply_unsafe($h4);
$y7->apply_unsafe($y3);
$y7->apply_unsafe($z3);
$y7->apply_unsafe($A3);
$y7->apply_unsafe($B3);
$y7->apply_unsafe($C3);
$y7->apply_unsafe($D3);
$y7->apply_unsafe($E3);
$y7->apply_unsafe($F3);
$y7->apply_unsafe($G3);
$y7->apply_unsafe($H3);
$y7->apply_unsafe($I3);
$y7->apply_unsafe($J3);
$y7->apply_unsafe($K3);
$y7->apply_unsafe($L3);
$y7->apply_unsafe($M3);
$y7->apply_unsafe($N3);
$y7->apply_unsafe($O3);
$y7->apply_unsafe($P3);
$y7->apply_unsafe($Q3);
$y7->apply_unsafe($R3);
$y7->apply_unsafe($S3);
$y7->apply_unsafe($u);
$y7->apply_unsafe($T3);
$y7->apply_unsafe($U3);
$y7->apply_unsafe($V3);
$y7->apply_unsafe($W3);
$y7->apply_unsafe($C4);
$y7->apply_unsafe($X3);
$y7->apply_unsafe($O4);
$y7->apply_unsafe($Y3);
$y7->apply_unsafe($Z3);
$y7->apply_unsafe($k4);
$y7->apply_unsafe($c4);
$y7->apply_unsafe($d4);
$y7->apply_unsafe($e4);
$y7->apply_unsafe($f4);
$y7->apply_unsafe($g4);
$y7->apply_unsafe($h4);
$F7->apply_unsafe($y3);
$F7->apply_unsafe($z3);
$F7->apply_unsafe($A3);
$F7->apply_unsafe($B3);
$F7->apply_unsafe($C3);
$F7->apply_unsafe($D3);
$F7->apply_unsafe($E3);
$F7->apply_unsafe($F3);
$F7->apply_unsafe($G3);
$F7->apply_unsafe($H3);
$F7->apply_unsafe($I3);
$F7->apply_unsafe($J3);
$F7->apply_unsafe($K3);
$F7->apply_unsafe($L3);
$F7->apply_unsafe($M3);
$F7->apply_unsafe($N3);
$F7->apply_unsafe($O3);
$F7->apply_unsafe($P3);
$F7->apply_unsafe($Q3);
$F7->apply_unsafe($R3);
$F7->apply_unsafe($S3);
$F7->apply_unsafe($T3);
$F7->apply_unsafe($U3);
$F7->apply_unsafe($V3);
$F7->apply_unsafe($W3);
$F7->apply_unsafe($X3);
$F7->apply_unsafe($Y3);
$F7->apply_unsafe($Z3);
$F7->apply_unsafe($c4);
$F7->apply_unsafe($d4);
$F7->apply_unsafe($e4);
$F7->apply_unsafe($f4);
$F7->apply_unsafe($g4);
$F7->apply_unsafe($h4);
$l8->apply_unsafe($y5);
$F8->apply_unsafe($z5);
$F8->apply_unsafe($A5);
$F8->apply_unsafe($B5);
$F8->apply_unsafe($C5);
$F8->apply_unsafe($D5);
$F8->apply_unsafe($E5);
$F8->apply_unsafe($F5);
$F8->apply_unsafe($G5);
$F8->apply_unsafe($H5);
$F8->apply_unsafe($I5);
$F8->apply_unsafe($J5);
$Z8->apply_unsafe($z5);
$Z8->apply_unsafe($A5);
$Z8->apply_unsafe($B5);
$Z8->apply_unsafe($C5);
$Z8->apply_unsafe($D5);
$Z8->apply_unsafe($E5);
$Z8->apply_unsafe($F5);
$Z8->apply_unsafe($G5);
$Z8->apply_unsafe($H5);
$Z8->apply_unsafe($I5);
$Z8->apply_unsafe($J5);
$j9->apply_unsafe($z5);
$j9->apply_unsafe($A5);
$j9->apply_unsafe($B5);
$j9->apply_unsafe($C5);
$j9->apply_unsafe($D5);
$j9->apply_unsafe($E5);
$j9->apply_unsafe($F5);
$j9->apply_unsafe($G5);
$j9->apply_unsafe($H5);
$j9->apply_unsafe($I5);
$j9->apply_unsafe($J5);
$v9->apply_unsafe($z5);
$v9->apply_unsafe($A5);
$v9->apply_unsafe($B5);
$v9->apply_unsafe($C5);
$v9->apply_unsafe($D5);
$v9->apply_unsafe($E5);
$v9->apply_unsafe($F5);
$v9->apply_unsafe($G5);
$v9->apply_unsafe($H5);
$v9->apply_unsafe($I5);
$v9->apply_unsafe($J5);
$H9->apply_unsafe($z5);
$H9->apply_unsafe($A5);
$H9->apply_unsafe($B5);
$H9->apply_unsafe($C5);
$H9->apply_unsafe($D5);
$H9->apply_unsafe($E5);
$H9->apply_unsafe($F5);
$H9->apply_unsafe($G5);
$H9->apply_unsafe($H5);
$H9->apply_unsafe($I5);
$H9->apply_unsafe($J5);
$T9->apply_unsafe($z5);
$T9->apply_unsafe($A5);
$T9->apply_unsafe($B5);
$T9->apply_unsafe($C5);
$T9->apply_unsafe($D5);
$T9->apply_unsafe($E5);
$T9->apply_unsafe($F5);
$T9->apply_unsafe($G5);
$T9->apply_unsafe($H5);
$T9->apply_unsafe($I5);
$T9->apply_unsafe($J5);
$fa->apply_unsafe($z5);
$za->apply_unsafe($z5);
$Pa->apply_unsafe($B3);
$Pa->apply_unsafe($C3);
$Pa->apply_unsafe($D3);
$Pa->apply_unsafe($E3);
$Pa->apply_unsafe($F3);
$Pa->apply_unsafe($G3);
$Pa->apply_unsafe($H3);
$Pa->apply_unsafe($I3);
$Pa->apply_unsafe($J3);
$Pa->apply_unsafe($K3);
$Pa->apply_unsafe($L3);
$gb->apply_unsafe($A5);
$nb->apply_unsafe($A5);
$Hb->apply_unsafe($B5);
$Ob->apply_unsafe($B5);
$kc->apply_unsafe($B5);
$Ic->apply_unsafe($B5);
$Qc->apply_unsafe($B5);
$id->apply_unsafe($B5);
$Gd->apply_unsafe($C5);
$Nd->apply_unsafe($C5);
$Vd->apply_unsafe($C5);
$ne->apply_unsafe($C5);
$ye->apply_unsafe($C5);
$Ie->apply_unsafe($C5);
$if->apply_unsafe($D5);
$qf->apply_unsafe($D5);
$xf->apply_unsafe($D5);
$Sf->apply_unsafe($D5);
$ug->apply_unsafe($E5);
$Bg->apply_unsafe($E5);
$Jg->apply_unsafe($E5);
$Wg->apply_unsafe($E5);
$oh->apply_unsafe($E5);
$Oh->apply_unsafe($F5);
$Vh->apply_unsafe($F5);
$di->apply_unsafe($F5);
$qi->apply_unsafe($F5);
$dj->apply_unsafe($ej);
$oj->apply_unsafe($G5);
$Bj->apply_unsafe($G5);
$kk->apply_unsafe($I5);
$uk->apply_unsafe($I5);
$Gk->apply_unsafe($I5);
$Qk->apply_unsafe($I5);
$il->apply_unsafe($I5);
$Ol->apply_unsafe($J5);
$Vl->apply_unsafe($J5);
$lm->apply_unsafe($J5);
$Jm->apply_unsafe($K5);
$Jm->apply_unsafe($L5);
$Jm->apply_unsafe($M5);
$Jm->apply_unsafe($U5);
$Vm->apply_unsafe($K5);
$Vm->apply_unsafe($L5);
$Vm->apply_unsafe($M5);
$Vm->apply_unsafe($U5);
$nn->apply_unsafe($K5);
$nn->apply_unsafe($L5);
$nn->apply_unsafe($M5);
$Hn->apply_unsafe($K5);
$Hn->apply_unsafe($L5);
$Hn->apply_unsafe($M5);
$Yn->apply_unsafe($M3);
$Yn->apply_unsafe($N3);
$Yn->apply_unsafe($O3);
$uo->apply_unsafe($L5);
$Bo->apply_unsafe($L5);
$Lo->apply_unsafe($L5);
$Xo->apply_unsafe($L5);
$wp->apply_unsafe($N3);
$Pp->apply_unsafe($M5);
$Wp->apply_unsafe($M5);
$uq->apply_unsafe($E4);
$Oq->apply_unsafe($O5);
$Uq->apply_unsafe($O5);
$rr->apply_unsafe($F);
$xr->apply_unsafe($F);
$Er->apply_unsafe($F);
$Nr->apply_unsafe($F);
$Wr->apply_unsafe($F);
$As->apply_unsafe($u);
$Os->apply_unsafe($u);
$Ys->apply_unsafe($u);
$it->apply_unsafe($u);
$Dt->apply_unsafe($P5);
$Nt->apply_unsafe($ej);
$Wt->apply_unsafe($P5);
$Lu->apply_unsafe($P5);
$Tu->apply_unsafe($P5);
$Tu->apply_unsafe($R5);
$tv->apply_unsafe($P5);
$tv->apply_unsafe($R5);
$Jv->apply_unsafe($P5);
$Jv->apply_unsafe($R5);
$Zv->apply_unsafe($P5);
$Mw->apply_unsafe($Nw);
$ix->apply_unsafe($Q5);
$Ax->apply_unsafe($Q5);
$Jx->apply_unsafe($Q5);
$Tx->apply_unsafe($Q5);
$kz->apply_unsafe($Nw);
$xz->apply_unsafe($R5);
$Gz->apply_unsafe($R5);
$jA->apply_unsafe($C4);
$pA->apply_unsafe($C4);
$wA->apply_unsafe($C4);
$TA->apply_unsafe($ej);
$fB->apply_unsafe($O4);
$lB->apply_unsafe($O4);
$FB->apply_unsafe($S5);
$RB->apply_unsafe($S5);
$YB->apply_unsafe($S5);
$ni::self=$PD;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($R)for@$H;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($S1)for@$H;
&$_($Y1)for@$H;
&$_($e2)for@$w;
&$_($i2)for@$w;
&$_($m2)for@$w;
&$_($q2)for@$H;
&$_($x2)for@$H;
&$_($F2)for@$w;
&$_($J2)for@$w;
&$_($N2)for@$H;
&$_($V2)for@$H;
&$_($f3)for@$H;
&$_($l3)for@$w;
&$_($p3)for@$H;
&$_($v3)for@$H;
&$_($w4)for@$w;
&$_($z4)for@$w;
&$_($D4)for@$F4;
&$_($I4)for@$w;
&$_($K4)for@$w;
&$_($N4)for@$F4;
&$_($S4)for@$w;
&$_($V4)for@$F4;
&$_($Z4)for@$w;
&$_($e5)for@$F4;
&$_($i5)for@$w;
&$_($l5)for@$F4;
&$_($n5)for@$o5;
&$_($r5)for@$w;
&$_($u5)for@$w;
&$_($x5)for@$F4;
&$_($Z5)for@$w;
&$_($e6)for@$F4;
&$_($g6)for@$h6;
&$_($m6)for@$w;
&$_($p6)for@$F4;
&$_($r6)for@$s6;
&$_($y6)for@$w;
&$_($B6)for@$F4;
&$_($F6)for@$w;
&$_($I6)for@$w;
&$_($L6)for@$F4;
&$_($P6)for@$w;
&$_($S6)for@$F4;
&$_($W6)for@$w;
&$_($Z6)for@$F4;
&$_($f7)for@$w;
&$_($i7)for@$F4;
&$_($k7)for@$l7;
&$_($n7)for@$o7;
&$_($s7)for@$w;
&$_($v7)for@$w;
&$_($y7)for@$F4;
&$_($C7)for@$w;
&$_($F7)for@$F4;
&$_($H7)for@$I7;
&$_($R7)for@$S7;
&$_($W7)for@$S7;
&$_($Y7)for@$S7;
&$_($c8)for@$S7;
&$_($i8)for@$w;
&$_($l8)for@$F4;
&$_($n8)for@$o8;
&$_($t8)for@$S7;
&$_($C8)for@$w;
&$_($F8)for@$F4;
&$_($K8)for@$w;
&$_($O8)for@$w;
&$_($S8)for@$w;
&$_($W8)for@$w;
&$_($Z8)for@$F4;
&$_($g9)for@$w;
&$_($j9)for@$F4;
&$_($o9)for@$w;
&$_($s9)for@$w;
&$_($v9)for@$F4;
&$_($A9)for@$w;
&$_($E9)for@$w;
&$_($H9)for@$F4;
&$_($M9)for@$w;
&$_($Q9)for@$w;
&$_($T9)for@$F4;
&$_($V9)for@$W9;
&$_($ca)for@$w;
&$_($fa)for@$F4;
&$_($ka)for@$w;
&$_($oa)for@$w;
&$_($sa)for@$w;
&$_($wa)for@$w;
&$_($za)for@$F4;
&$_($Ba)for@$Ca;
&$_($Ma)for@$w;
&$_($Pa)for@$F4;
&$_($Ra)for@$S7;
&$_($Ta)for@$S7;
&$_($db)for@$w;
&$_($gb)for@$F4;
&$_($kb)for@$w;
&$_($nb)for@$F4;
&$_($pb)for@$qb;
&$_($vb)for@$S7;
&$_($Eb)for@$w;
&$_($Hb)for@$F4;
&$_($Lb)for@$w;
&$_($Ob)for@$F4;
&$_($Tb)for@$w;
&$_($Xb)for@$w;
&$_($dc)for@$w;
&$_($hc)for@$w;
&$_($kc)for@$F4;
&$_($pc)for@$w;
&$_($tc)for@$w;
&$_($xc)for@$w;
&$_($Bc)for@$w;
&$_($Fc)for@$w;
&$_($Ic)for@$F4;
&$_($Nc)for@$w;
&$_($Qc)for@$F4;
&$_($Vc)for@$w;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($id)for@$F4;
&$_($kd)for@$ld;
&$_($qd)for@$S7;
&$_($Dd)for@$w;
&$_($Gd)for@$F4;
&$_($Kd)for@$w;
&$_($Nd)for@$F4;
&$_($Sd)for@$w;
&$_($Vd)for@$F4;
&$_($ce)for@$w;
&$_($ge)for@$w;
&$_($ke)for@$w;
&$_($ne)for@$F4;
&$_($re)for@$w;
&$_($ve)for@$w;
&$_($ye)for@$F4;
&$_($Ce)for@$w;
&$_($Fe)for@$w;
&$_($Ie)for@$F4;
&$_($Ke)for@$Le;
&$_($Qe)for@$S7;
&$_($ff)for@$w;
&$_($if)for@$F4;
&$_($nf)for@$w;
&$_($qf)for@$F4;
&$_($uf)for@$w;
&$_($xf)for@$F4;
&$_($Bf)for@$w;
&$_($Ff)for@$w;
&$_($If)for@$w;
&$_($Mf)for@$w;
&$_($Pf)for@$w;
&$_($Sf)for@$F4;
&$_($Uf)for@$Vf;
&$_($cg)for@$S7;
&$_($ng)for@$w;
&$_($rg)for@$w;
&$_($ug)for@$F4;
&$_($yg)for@$w;
&$_($Bg)for@$F4;
&$_($Gg)for@$w;
&$_($Jg)for@$F4;
&$_($Ng)for@$w;
&$_($Qg)for@$w;
&$_($Tg)for@$w;
&$_($Wg)for@$F4;
&$_($dh)for@$w;
&$_($hh)for@$w;
&$_($lh)for@$w;
&$_($oh)for@$F4;
&$_($qh)for@$rh;
&$_($wh)for@$S7;
&$_($Dh)for@$w;
&$_($Hh)for@$w;
&$_($Lh)for@$w;
&$_($Oh)for@$F4;
&$_($Sh)for@$w;
&$_($Vh)for@$F4;
&$_($Yh)for@$w;
&$_($di)for@$F4;
&$_($hi)for@$w;
&$_($ki)for@$w;
&$_($ni)for@$w;
&$_($qi)for@$F4;
&$_($si)for@$ti;
&$_($zi)for@$S7;
&$_($Ni)for@$w;
&$_($Qi)for@$w;
&$_($Ui)for@$w;
&$_($Yi)for@$w;
&$_($dj)for@$F4;
&$_($lj)for@$w;
&$_($oj)for@$F4;
&$_($sj)for@$w;
&$_($vj)for@$w;
&$_($yj)for@$w;
&$_($Bj)for@$F4;
&$_($Dj)for@$Ej;
&$_($Jj)for@$S7;
&$_($dk)for@$w;
&$_($hk)for@$w;
&$_($kk)for@$F4;
&$_($ok)for@$w;
&$_($rk)for@$w;
&$_($uk)for@$F4;
&$_($zk)for@$w;
&$_($Dk)for@$w;
&$_($Gk)for@$F4;
&$_($Kk)for@$w;
&$_($Nk)for@$w;
&$_($Qk)for@$F4;
&$_($Uk)for@$w;
&$_($Xk)for@$w;
&$_($cl)for@$w;
&$_($fl)for@$w;
&$_($il)for@$F4;
&$_($kl)for@$ll;
&$_($ql)for@$S7;
&$_($Dl)for@$w;
&$_($Hl)for@$w;
&$_($Ll)for@$w;
&$_($Ol)for@$F4;
&$_($Sl)for@$w;
&$_($Vl)for@$F4;
&$_($Zl)for@$w;
&$_($fm)for@$w;
&$_($im)for@$w;
&$_($lm)for@$F4;
&$_($nm)for@$om;
&$_($tm)for@$S7;
&$_($Gm)for@$w;
&$_($Jm)for@$F4;
&$_($Om)for@$w;
&$_($Sm)for@$w;
&$_($Vm)for@$F4;
&$_($Xm)for@$Ym;
&$_($en)for@$w;
&$_($hn)for@$w;
&$_($kn)for@$w;
&$_($nn)for@$F4;
&$_($sn)for@$w;
&$_($wn)for@$w;
&$_($An)for@$w;
&$_($En)for@$w;
&$_($Hn)for@$F4;
&$_($Jn)for@$Kn;
&$_($Rn)for@$S7;
&$_($Vn)for@$w;
&$_($Yn)for@$F4;
&$_($co)for@$S7;
&$_($lo)for@$w;
&$_($no)for@$w;
&$_($ro)for@$w;
&$_($uo)for@$F4;
&$_($yo)for@$w;
&$_($Bo)for@$F4;
&$_($Fo)for@$w;
&$_($Io)for@$w;
&$_($Lo)for@$F4;
&$_($Qo)for@$w;
&$_($Uo)for@$w;
&$_($Xo)for@$F4;
&$_($dp)for@$ep;
&$_($lp)for@$w;
&$_($pp)for@$w;
&$_($tp)for@$w;
&$_($wp)for@$F4;
&$_($yp)for@$S7;
&$_($Mp)for@$w;
&$_($Pp)for@$F4;
&$_($Tp)for@$w;
&$_($Wp)for@$F4;
&$_($Yp)for@$Zp;
&$_($gq)for@$S7;
&$_($rq)for@$w;
&$_($uq)for@$F4;
&$_($wq)for@$xq;
&$_($Dq)for@$S7;
&$_($Lq)for@$w;
&$_($Oq)for@$F4;
&$_($Rq)for@$w;
&$_($Uq)for@$F4;
&$_($Wq)for@$Xq;
&$_($er)for@$S7;
&$_($or)for@$w;
&$_($rr)for@$F4;
&$_($ur)for@$w;
&$_($xr)for@$F4;
&$_($Br)for@$w;
&$_($Er)for@$F4;
&$_($Hr)for@$w;
&$_($Kr)for@$w;
&$_($Nr)for@$F4;
&$_($Qr)for@$w;
&$_($Tr)for@$w;
&$_($Wr)for@$F4;
&$_($Yr)for@$Zr;
&$_($gs)for@$S7;
&$_($ss)for@$w;
&$_($vs)for@$w;
&$_($xs)for@$w;
&$_($As)for@$F4;
&$_($Es)for@$w;
&$_($Hs)for@$w;
&$_($Ls)for@$w;
&$_($Os)for@$F4;
&$_($Ss)for@$w;
&$_($Vs)for@$w;
&$_($Ys)for@$F4;
&$_($ft)for@$w;
&$_($it)for@$F4;
&$_($kt)for@$lt;
&$_($qt)for@$S7;
&$_($At)for@$w;
&$_($Dt)for@$F4;
&$_($Kt)for@$w;
&$_($Nt)for@$F4;
&$_($Tt)for@$w;
&$_($Wt)for@$F4;
&$_($du)for@$w;
&$_($hu)for@$w;
&$_($lu)for@$w;
&$_($pu)for@$w;
&$_($tu)for@$w;
&$_($xu)for@$w;
&$_($Bu)for@$w;
&$_($Fu)for@$w;
&$_($Iu)for@$w;
&$_($Lu)for@$F4;
&$_($Qu)for@$w;
&$_($Tu)for@$F4;
&$_($Yu)for@$w;
&$_($ev)for@$w;
&$_($iv)for@$w;
&$_($mv)for@$w;
&$_($qv)for@$w;
&$_($tv)for@$F4;
&$_($yv)for@$w;
&$_($Cv)for@$w;
&$_($Gv)for@$w;
&$_($Jv)for@$F4;
&$_($Ov)for@$w;
&$_($Sv)for@$w;
&$_($Wv)for@$w;
&$_($Zv)for@$F4;
&$_($dw)for@$ew;
&$_($jw)for@$S7;
&$_($tw)for@$w;
&$_($xw)for@$w;
&$_($Bw)for@$w;
&$_($Fw)for@$w;
&$_($Jw)for@$w;
&$_($Mw)for@$F4;
&$_($Xw)for@$w;
&$_($cx)for@$w;
&$_($fx)for@$w;
&$_($ix)for@$F4;
&$_($mx)for@$w;
&$_($px)for@$w;
&$_($sx)for@$w;
&$_($vx)for@$w;
&$_($xx)for@$w;
&$_($Ax)for@$F4;
&$_($Dx)for@$w;
&$_($Gx)for@$w;
&$_($Jx)for@$F4;
&$_($Nx)for@$w;
&$_($Qx)for@$w;
&$_($Tx)for@$F4;
&$_($Vx)for@$Wx;
&$_($dy)for@$S7;
&$_($ny)for@$w;
&$_($ry)for@$w;
&$_($vy)for@$w;
&$_($zy)for@$w;
&$_($Dy)for@$w;
&$_($Hy)for@$w;
&$_($Ly)for@$w;
&$_($Py)for@$w;
&$_($Ty)for@$w;
&$_($Xy)for@$w;
&$_($dz)for@$w;
&$_($hz)for@$w;
&$_($kz)for@$F4;
&$_($uz)for@$w;
&$_($xz)for@$F4;
&$_($Az)for@$w;
&$_($Dz)for@$w;
&$_($Gz)for@$F4;
&$_($Iz)for@$Jz;
&$_($Oz)for@$S7;
&$_($Yz)for@$w;
&$_($cA)for@$w;
&$_($jA)for@$F4;
&$_($mA)for@$w;
&$_($pA)for@$F4;
&$_($tA)for@$w;
&$_($wA)for@$F4;
&$_($yA)for@$zA;
&$_($FA)for@$S7;
&$_($MA)for@$w;
&$_($QA)for@$w;
&$_($TA)for@$F4;
&$_($cB)for@$w;
&$_($fB)for@$F4;
&$_($iB)for@$w;
&$_($lB)for@$F4;
&$_($nB)for@$oB;
&$_($uB)for@$S7;
&$_($CB)for@$w;
&$_($FB)for@$F4;
&$_($KB)for@$w;
&$_($OB)for@$w;
&$_($RB)for@$F4;
&$_($VB)for@$w;
&$_($YB)for@$F4;
&$_($cC)for@$dC;
&$_($iC)for@$S7;
&$_($qC)for@$rC;
&$_($wC)for@$S7;
&$_($FC)for@$GC;
&$_($LC)for@$S7;
&$_($TC)for@$UC;
&$_($sD)for@$UC;
&$_($xD)for@$w;
&$_($BD)for@$w;
&$_($FD)for@$w;
&$_($JD)for@$w;
&$_($ND)for@$w;
ni->run(@ARGV);
__DATA__
