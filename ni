#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/mio#;
$P=q#
    my $mio = ni("ni:/fabric/mio")->new;
    my $channel1 = $mio->channel;
    my $channel2 = $mio->channel;
    $channel1->write("8MB data" x 1000000);
    $channel2->write("short string");
    $mio->into_sync($socket_or_something);#;
$Q=[$f,$P];
$R=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel.#;
$S=[$i,$R];
$T=[$Q,$S];
$U=q#/fabric/mio#;
$V=bless({$e,$T,$D,$U},$F);
$W=q#ni.doc:/io#;
$X=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Y=[$i,$X];
$Z=[$Y];
$c1=q#/io#;
$d1=bless({$e,$Z,$D,$c1},$F);
$e1=q#ni.doc:/io/buffer#;
$f1=q#
    my $buf = ni("ni:/io/buffer")->new(1048576);
    $buf->write("foo")#;
$g1=[$f,$f1];
$h1=[$g1];
$i1=q#/io/buffer#;
$j1=bless({$e,$h1,$D,$i1},$F);
$k1=q#ni.doc:/io/cat#;
$l1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$m1=[$f,$l1];
$n1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$o1=[$i,$n1];
$p1=[];
$q1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[$m1,$o1,$s1];
$u1=q#/io/cat#;
$v1=bless({$e,$t1,$D,$u1},$F);
$w1=q#ni.doc:/io/exec#;
$x1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$y1=[$f,$x1];
$z1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$A1=[$i,$z1];
$B1=[];
$C1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$D1=bless({$o,$B1,$q,$C1,$s,$t},$u);
$E1=[$n,$D1];
$F1=[$y1,$A1,$E1];
$G1=q#/io/exec#;
$H1=bless({$e,$F1,$D,$G1},$F);
$I1=q#ni.doc:/io/pid#;
$J1=[];
$K1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[$M1,$Q1,$U1];
$W1=q#/io/pid#;
$X1=bless({$e,$V1,$D,$W1},$F);
$Y1=q#ni.doc:/lib#;
$Z1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$c2=[$i,$Z1];
$d2=[$c2];
$e2=q#/lib#;
$f2=bless({$e,$d2,$D,$e2},$F);
$g2=q#ni.doc:/lib/doc#;
$h2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$i2=[$f,$h2];
$j2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$k2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$l2=[];
$m2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$n2=bless({$o,$l2,$q,$m2,$s,$t},$u);
$o2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$p2=[];
$q2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$r2=bless({$o,$p2,$q,$q2,$s,$t},$u);
$s2=[$i,$j2,$k2,$n,$n2,$o2,$n,$r2];
$t2=[$i2,$s2];
$u2=q#/lib/doc#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni.doc:/semantic#;
$x2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$y2=[$i,$x2];
$z2=[$y2];
$A2=q#/semantic#;
$B2=bless({$e,$z2,$D,$A2},$F);
$C2=q#ni:/class#;
$D2=q#applied_to#;
$E2=q#class#;
$F2=q#class.c#;
$G2=q#fabric/mio.c#;
$H2=q#fabric/rmi.c#;
$I2=q#io/buffer.c#;
$J2=q#io/cat.c#;
$K2=q#io/exec.c#;
$L2=q#io/fd.c#;
$M2=q#io/file.c#;
$N2=q#io/null.c#;
$O2=q#io/object.c#;
$P2=q#io/pid.c#;
$Q2=q#io/str.c#;
$R2=q#io/transfer.c#;
$S2=q#io/transfer_async.c#;
$T2=q#io/transfer_sync.c#;
$U2=q#lib/behavior.c#;
$V2=q#lib/branch.c#;
$W2=q#lib/dataslice.c#;
$X2=q#lib/doc.c#;
$Y2=q#lib/fn.c#;
$Z2=q#lib/image.c#;
$c3=q#lib/ni.c#;
$d3=q#lib/quote_simple.c#;
$e3=q#lib/slice.c#;
$f3=q#lib/tag.c#;
$g3=q#lib/test_value.c#;
$h3=q#metaclass.c#;
$i3=q#module.c#;
$j3=q#object.c#;
$k3=q#semantic/dimension#;
$l3=q#semantic/dimension.c#;
$m3=q#semantic/task.c#;
$n3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$o3=q#slices#;
$p3=q#metaclass#;
$q3=q#module#;
$r3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$s3=q#/module#;
$t3=q#/lib/perlbranch.b#;
$u3={};
$v3=q#ctor#;
$w3=undef;
$x3=q#dtor#;
$y3=q#methods#;
$z3=q#add#;
$A3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$B3=bless({$q,$A3,$s,$t},$u);
$C3=q#apply#;
$D3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$E3=bless({$q,$D3,$s,$t},$u);
$F3={$z3,$B3,$C3,$E3};
$G3=q#/lib/branch.b#;
$H3=q#lib/slice#;
$I3=bless({$D2,$u3,$v3,$w3,$x3,$w3,$y3,$F3,$D,$G3},$H3);
$J3=q#lib/branch#;
$K3=q#lib/slice::ctors#;
$L3={};
$M3=q#my $s = shift; ni->def($s->name, $s)#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$P3=bless({$q,$O3,$s,$t},$u);
$Q3={$D,$P3};
$R3=q#/lib/named.b#;
$S3=bless({$D2,$L3,$v3,$N3,$x3,$w3,$y3,$Q3,$D,$R3},$H3);
$T3=q#lib/tag#;
$U3={};
$V3=q#namespace#;
$W3=q#'ni'#;
$X3=bless({$q,$W3,$s,$t},$u);
$Y3={$V3,$X3};
$Z3=q#/lib/named_in_ni.b#;
$c4=bless({$D2,$U3,$v3,$w3,$x3,$w3,$y3,$Y3,$D,$Z3},$H3);
$d4={};
$e4=q#package#;
$f4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$g4=bless({$q,$f4,$s,$t},$u);
$h4={$e4,$g4};
$i4=q#/lib/namespaced.b#;
$j4=bless({$D2,$d4,$v3,$w3,$x3,$w3,$y3,$h4,$D,$i4},$H3);
$k4={};
$l4=q#resolve#;
$m4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$n4=bless({$q,$m4,$s,$t},$u);
$o4={$l4,$n4};
$p4=q#/lib/resolver.b#;
$q4=bless({$D2,$k4,$v3,$w3,$x3,$w3,$y3,$o4,$D,$p4},$H3);
$r4=[$I3,$S3,$c4,$j4,$q4];
$s4=bless({$D,$t3,$o3,$r4},$T3);
$t4=q#lib/tag::ctors#;
$u4={};
$v4=q#my $s = shift; $s->apply($s->package)#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4=q#instantiate#;
$y4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$z4=bless({$q,$y4,$s,$t},$u);
$A4={$x4,$z4};
$B4=q#/lib/class_init.b#;
$C4=bless({$D2,$u4,$v3,$w4,$x3,$w3,$y3,$A4,$D,$B4},$H3);
$D4=q#fabric/mio#;
$E4=q#fabric/rmi#;
$F4=q#io/buffer#;
$G4=q#io/cat#;
$H4=q#io/exec#;
$I4=q#io/fd#;
$J4=q#io/file#;
$K4=q#io/null#;
$L4=q#io/object#;
$M4=q#io/pid#;
$N4=q#io/str#;
$O4=q#io/transfer#;
$P4=q#io/transfer_async#;
$Q4=q#io/transfer_sync#;
$R4=q#lib/behavior#;
$S4=q#lib/dataslice#;
$T4=q#lib/image#;
$U4=q#lib/ni#;
$V4=q#lib/quote_simple#;
$W4=q#lib/test_value#;
$X4=q#object#;
$Y4=q#semantic/task#;
$Z4={$E2,1,$F2,1,$D4,1,$G2,1,$E4,1,$H2,1,$F4,1,$I2,1,$G4,1,$J2,1,$H4,1,$K2,1,$I4,1,$L2,1,$J4,1,$M2,1,$K4,1,$N2,1,$L4,1,$O2,1,$M4,1,$P2,1,$N4,1,$Q2,1,$O4,1,$R2,1,$P4,1,$S2,1,$Q4,1,$T2,1,$R4,1,$U2,1,$J3,1,$V2,1,$S4,1,$W2,1,$F,1,$X2,1,$u,1,$Y2,1,$T4,1,$Z2,1,$U4,1,$c3,1,$V4,1,$d3,1,$H3,1,$e3,1,$T3,1,$f3,1,$W4,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$X4,1,$j3,1,$k3,1,$l3,1,$Y4,1,$m3,1};
$c5=q#/object#;
$d5={};
$e5=q#ni 'ni:/' . ref shift#;
$f5=bless({$q,$e5,$s,$t},$u);
$g5={$E2,$f5};
$h5=q#/lib/instance.b#;
$i5=bless({$D2,$d5,$v3,$w3,$x3,$w3,$y3,$g5,$D,$h5},$H3);
$j5=[$i5];
$k5=bless({$D2,$Z4,$D,$c5,$o3,$j5},$j3);
$l5=q#object.c::ctors#;
$m5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$R4,1,$U2,1,$J3,1,$V2,1,$S4,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$H3,1,$e3,1,$T3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$n5=q#/lib/behavior#;
$o5={};
$p5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$e,$q5};
$s5=q#/lib/documentable.b#;
$t5=bless({$D2,$o5,$v3,$w3,$x3,$w3,$y3,$r5,$D,$s5},$H3);
$u5=[$k5,$t5];
$v5=bless({$D2,$m5,$D,$n5,$o3,$u5},$U2);
$w5=q#lib/behavior.c::ctors#;
$x5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$J3,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$y5=q#/lib/definition.b#;
$z5={};
$A5=q#def#;
$B5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$C5=bless({$q,$B5,$s,$t},$u);
$D5={$A5,$C5};
$E5=q#/lib/definition_def.b#;
$F5=bless({$D2,$z5,$v3,$w3,$x3,$w3,$y3,$D5,$D,$E5},$H3);
$G5={};
$H5=q#ro#;
$I5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$J5=bless({$q,$I5,$s,$t},$u);
$K5=q#rw#;
$L5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$H5,$J5,$K5,$M5};
$O5=q#/lib/accessor.b#;
$P5=bless({$D2,$G5,$v3,$w3,$x3,$w3,$y3,$N5,$D,$O5},$H3);
$Q5={};
$R5=q#(""#;
$S5=q#shift->name#;
$T5=bless({$q,$S5,$s,$t},$u);
$U5={$R5,$T5};
$V5=q#/lib/name_as_string.b#;
$W5=bless({$D2,$Q5,$v3,$w3,$x3,$w3,$y3,$U5,$D,$V5},$H3);
$X5={};
$Y5=q#(eq#;
$Z5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$c6=bless({$q,$Z5,$s,$t},$u);
$d6={$Y5,$c6};
$e6=q#/lib/ref_eq.b#;
$f6=bless({$D2,$X5,$v3,$w3,$x3,$w3,$y3,$d6,$D,$e6},$H3);
$g6={};
$h6=q#defdata#;
$i6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$j6=bless({$q,$i6,$s,$t},$u);
$k6={$h6,$j6};
$l6=q#/lib/definition_defdata.b#;
$m6=bless({$D2,$g6,$v3,$w3,$x3,$w3,$y3,$k6,$D,$l6},$H3);
$n6=[$F5,$P5,$W5,$f6,$m6];
$o6=bless({$D2,$x5,$D,$y5,$o3,$n6},$J3);
$p6=q#lib/branch::ctors#;
$q6=[$s4,$C4,$k5,$v5,$o6];
$r6=bless({$D2,$r3,$D,$s3,$o3,$q6},$i3);
$s6=q#module.c::ctors#;
$t6={};
$u6=q#DESTROY#;
$v6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$w6=bless({$q,$v6,$s,$t},$u);
$x6=q#new#;
$y6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$z6=bless({$q,$y6,$s,$t},$u);
$A6={$u6,$w6,$x6,$z6};
$B6=q#/lib/instantiable.b#;
$C6=bless({$D2,$t6,$y3,$A6,$D,$B6},$H3);
$D6={};
$E6=q#child#;
$F6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$G6=bless({$q,$F6,$s,$t},$u);
$H6={$E6,$G6};
$I6=q#/lib/subclass.b#;
$J6=bless({$D2,$D6,$v3,$w3,$x3,$w3,$y3,$H6,$D,$I6},$H3);
$K6=[$r6,$C6,$C4,$r6,$J6];
$L6=bless({$D2,$n3,$D,$E,$o3,$K6},$F2);
$M6=q#class.c::ctors#;
$N6=q#ni:/class.c#;
$O6={$F2,1,$l3,1};
$P6=q#/class.c#;
$Q6={$F2,1,$i3,1,$l3,1};
$R6=q#/module.c#;
$S6={$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$i3,1,$j3,1,$l3,1,$m3,1};
$T6=q#/object.c#;
$U6=[$L6];
$V6=bless({$D2,$S6,$D,$T6,$o3,$U6},$p3);
$W6=q#metaclass::ctors#;
$X6={$F2,1,$U2,1,$V2,1,$W2,1,$e3,1,$f3,1,$i3,1,$l3,1};
$Y6=q#/lib/behavior.c#;
$Z6=[$V6];
$c7=bless({$D2,$X6,$D,$Y6,$o3,$Z6},$p3);
$d7=[$V6,$C6,$c7];
$e7=bless({$D2,$Q6,$D,$R6,$o3,$d7},$p3);
$f7=[$e7];
$g7=bless({$D2,$O6,$D,$P6,$o3,$f7},$p3);
$h7=q#ni:/fabric/mio#;
$i7={$D4,1};
$j7={$D4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$N4,1};
$k7=q#/io/object#;
$l7={};
$m7=q#(bool#;
$n7=[];
$o7=bless({$o,$n7,$q,1,$s,$t},$u);
$p7={$m7,$o7};
$q7=q#/io/object_ops.b#;
$r7=bless({$D2,$l7,$v3,$w3,$x3,$w3,$y3,$p7,$D,$q7},$H3);
$s7={};
$t7=q#die#;
$u7=[];
$v7=q#shift; die join " ", @_#;
$w7=bless({$o,$u7,$q,$v7,$s,$t},$u);
$x7=q#io_check#;
$y7=[];
$z7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$A7=bless({$o,$y7,$q,$z7,$s,$t},$u);
$B7=q#io_check_defined#;
$C7=[];
$D7=q#shift->io_check(sub {defined shift}, @_)#;
$E7=bless({$o,$C7,$q,$D7,$s,$t},$u);
$F7=q#io_check_true#;
$G7=[];
$H7=q#shift->io_check(sub {shift}, @_)#;
$I7=bless({$o,$G7,$q,$H7,$s,$t},$u);
$J7={$t7,$w7,$x7,$A7,$B7,$E7,$F7,$I7};
$K7=q#/io/object_checks.b#;
$L7=bless({$D2,$s7,$v3,$w3,$x3,$w3,$y3,$J7,$D,$K7},$H3);
$M7={};
$N7=q#(+#;
$O7=[];
$P7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$Q7=bless({$o,$O7,$q,$P7,$s,$t},$u);
$R7={$N7,$Q7};
$S7=q#/io/object_constructors.b#;
$T7=bless({$D2,$M7,$v3,$w3,$x3,$w3,$y3,$R7,$D,$S7},$H3);
$U7={};
$V7=q#read_all#;
$W7=[];
$X7=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$Y7=bless({$o,$W7,$q,$X7,$s,$t},$u);
$Z7={$V7,$Y7};
$c8=q#/io/object_memory.b#;
$d8=bless({$D2,$U7,$v3,$w3,$x3,$w3,$y3,$Z7,$D,$c8},$H3);
$e8={};
$f8=q#into_sync#;
$g8=[];
$h8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$i8=bless({$o,$g8,$q,$h8,$s,$t},$u);
$j8={$f8,$i8};
$k8=q#/io/object_transfer_sync.b#;
$l8=bless({$D2,$e8,$v3,$w3,$x3,$w3,$y3,$j8,$D,$k8},$H3);
$m8={};
$n8=q#into_async#;
$o8=[];
$p8=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$q8=bless({$o,$o8,$q,$p8,$s,$t},$u);
$r8={$n8,$q8};
$s8=q#/io/object_transfer_async.b#;
$t8=bless({$D2,$m8,$v3,$w3,$x3,$w3,$y3,$r8,$D,$s8},$H3);
$u8=[$k5,$r7,$L7,$T7,$d8,$l8,$t8,$t8,$l8];
$v8=bless({$D2,$j7,$D,$k7,$o3,$u8},$O2);
$w8=q#io/object.c::ctors#;
$x8={};
$y8=q#io#;
$z8=[];
$A8=q#shift->{'io'}#;
$B8=bless({$o,$z8,$q,$A8,$s,$t},$u);
$C8=q#packet_size#;
$D8=[];
$E8=q#shift->{'packet_size'}#;
$F8=bless({$o,$D8,$q,$E8,$s,$t},$u);
$G8={$y8,$B8,$C8,$F8};
$H8=q#/fabric/mio_ro.b#;
$I8=bless({$D2,$x8,$v3,$w3,$x3,$w3,$y3,$G8,$D,$H8},$H3);
$J8={};
$K8=[];
$L8=q#my ($self, $io, %args) = @_;
+{io          => $io,
  packet_size => $args{packet_size} || 32768,
  channel_id  => 0,
  channels    => {}};#;
$M8=bless({$o,$K8,$q,$L8,$s,$t},$u);
$N8={$x4,$M8};
$O8=q#/fabric/mio_init.b#;
$P8=bless({$D2,$J8,$v3,$w3,$x3,$w3,$y3,$N8,$D,$O8},$H3);
$Q8={};
$R8=q#data_packet#;
$S8=[];
$T8=q#my $self      = shift;
my $stream_id = shift;
pack 'NN/a', $stream_id, $_[0];#;
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8=q#eof_packet#;
$W8=[];
$X8=q#my ($self, $stream_id) = @_;
pack 'NN', $stream_id, 0;#;
$Y8=bless({$o,$W8,$q,$X8,$s,$t},$u);
$Z8={$R8,$U8,$V8,$Y8};
$c9=q#/fabric/mio_packet.b#;
$d9=bless({$D2,$Q8,$v3,$w3,$x3,$w3,$y3,$Z8,$D,$c9},$H3);
$e9=[$v8,$I8,$P8,$d9];
$f9=bless({$D2,$i7,$D,$U,$o3,$e9},$G2);
$g9=q#fabric/mio.c::ctors#;
$h9=q#ni:/fabric/mio.c#;
$i9={$G2,1};
$j9=q#/fabric/mio.c#;
$k9={$G2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1};
$l9=q#/io/object.c#;
$m9=[$V6];
$n9=bless({$D2,$k9,$D,$l9,$o3,$m9},$p3);
$o9=[$n9];
$p9=bless({$D2,$i9,$D,$j9,$o3,$o9},$p3);
$q9=q#ni:/fabric/mio_init.b#;
$r9=q#ni:/fabric/mio_packet.b#;
$s9=q#ni:/fabric/mio_ro.b#;
$t9=q#ni:/fabric/rmi#;
$u9={$E4,1};
$v9=q#/fabric/rmi#;
$w9={};
$x9=[];
$y9=q#my ($class, $io, $quote) = @_;#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9={$x4,$z9};
$B9=q#/fabric/rmi_init.b#;
$C9=bless({$D2,$w9,$v3,$w3,$x3,$w3,$y3,$A9,$D,$B9},$H3);
$D9=[$k5,$C9];
$E9=bless({$D2,$u9,$D,$v9,$o3,$D9},$H2);
$F9=q#fabric/rmi.c::ctors#;
$G9=q#ni:/fabric/rmi.c#;
$H9={$H2,1};
$I9=q#/fabric/rmi.c#;
$J9=[$V6];
$K9=bless({$D2,$H9,$D,$I9,$o3,$J9},$p3);
$L9=q#ni:/fabric/rmi_init.b#;
$M9=q#ni:/io/buffer#;
$N9={$F4,1};
$O9={};
$P9=[];
$Q9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$R9=bless({$o,$P9,$q,$Q9,$s,$t},$u);
$S9={$x4,$R9};
$T9=q#/io/buffer_init.b#;
$U9=bless({$D2,$O9,$v3,$w3,$x3,$w3,$y3,$S9,$D,$T9},$H3);
$V9={};
$W9=q#read#;
$X9=[];
$Y9=bless({$o,$X9,$q,$t,$s,$t},$u);
$Z9=q#write#;
$ca=[];
$da=bless({$o,$ca,$q,$t,$s,$t},$u);
$ea={$W9,$Y9,$Z9,$da};
$fa=q#/io/buffer_io.b#;
$ga=bless({$D2,$V9,$v3,$w3,$x3,$w3,$y3,$ea,$D,$fa},$H3);
$ha=[$v8,$U9,$ga];
$ia=bless({$D2,$N9,$D,$i1,$o3,$ha},$I2);
$ja=q#io/buffer.c::ctors#;
$ka=q#ni:/io/buffer.c#;
$la={$I2,1};
$ma=q#/io/buffer.c#;
$na=[$n9];
$oa=bless({$D2,$la,$D,$ma,$o3,$na},$p3);
$pa=q#ni:/io/buffer_init.b#;
$qa=q#ni:/io/buffer_io.b#;
$ra=q#ni:/io/cat#;
$sa={$G4,1};
$ta={};
$ua=[];
$va=q#shift; +{fs => [@_]}#;
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa={$x4,$wa};
$ya=q#/io/cat_init.b#;
$za=bless({$D2,$ta,$v3,$w3,$x3,$w3,$y3,$xa,$D,$ya},$H3);
$Aa={};
$Ba=[];
$Ca=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$Da=bless({$o,$Ba,$q,$Ca,$s,$t},$u);
$Ea={$W9,$Da};
$Fa=q#/io/cat_read.b#;
$Ga=bless({$D2,$Aa,$v3,$w3,$x3,$w3,$y3,$Ea,$D,$Fa},$H3);
$Ha=[$v8,$za,$Ga];
$Ia=bless({$D2,$sa,$D,$u1,$o3,$Ha},$J2);
$Ja=q#io/cat.c::ctors#;
$Ka=q#ni:/io/cat.c#;
$La={$J2,1};
$Ma=q#/io/cat.c#;
$Na=[$n9];
$Oa=bless({$D2,$La,$D,$Ma,$o3,$Na},$p3);
$Pa=q#ni:/io/cat_init.b#;
$Qa=q#ni:/io/cat_read.b#;
$Ra=q#ni:/io/exec#;
$Sa={$H4,1};
$Ta={};
$Ua=q#argv#;
$Va=[];
$Wa=q#shift->{'argv'}#;
$Xa=bless({$o,$Va,$q,$Wa,$s,$t},$u);
$Ya={$Ua,$Xa};
$Za=q#/io/exec_ro.b#;
$cb=bless({$D2,$Ta,$v3,$w3,$x3,$w3,$y3,$Ya,$D,$Za},$H3);
$db={};
$eb=[];
$fb=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb={$x4,$gb};
$ib=q#/io/exec_init.b#;
$jb=bless({$D2,$db,$v3,$w3,$x3,$w3,$y3,$hb,$D,$ib},$H3);
$kb={};
$lb=q#connect#;
$mb=[];
$nb=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#in_pipe#;
$qb=[];
$rb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#out_pipe#;
$ub=[];
$vb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#setup_stdio#;
$yb=[];
$zb=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb={$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab};
$Cb=q#/io/exec_io_setup.b#;
$Db=bless({$D2,$kb,$v3,$w3,$x3,$w3,$y3,$Bb,$D,$Cb},$H3);
$Eb={};
$Fb=q#binds_fd#;
$Gb=[];
$Hb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#fd#;
$Kb=[];
$Lb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#stderr#;
$Ob=[];
$Pb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb=q#stdin#;
$Sb=[];
$Tb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#stdout#;
$Wb=[];
$Xb=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb={$Fb,$Ib,$Jb,$Mb,$Nb,$Qb,$Rb,$Ub,$Vb,$Yb};
$cc=q#/io/exec_io_accessors.b#;
$dc=bless({$D2,$Eb,$v3,$w3,$x3,$w3,$y3,$Zb,$D,$cc},$H3);
$ec={};
$fc=q#env#;
$gc=[];
$hc=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$ic=bless({$o,$gc,$q,$hc,$s,$t},$u);
$jc={$fc,$ic};
$kc=q#/io/exec_env.b#;
$lc=bless({$D2,$ec,$v3,$w3,$x3,$w3,$y3,$jc,$D,$kc},$H3);
$mc={};
$nc=q#exec#;
$oc=[];
$pc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc=q#fork#;
$sc=[];
$tc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$uc=bless({$o,$sc,$q,$tc,$s,$t},$u);
$vc=q#move_fds#;
$wc=[];
$xc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$yc=bless({$o,$wc,$q,$xc,$s,$t},$u);
$zc={$nc,$qc,$rc,$uc,$vc,$yc};
$Ac=q#/io/exec_fork.b#;
$Bc=bless({$D2,$mc,$v3,$w3,$x3,$w3,$y3,$zc,$D,$Ac},$H3);
$Cc=[$v8,$cb,$jb,$Db,$dc,$lc,$Bc];
$Dc=bless({$D2,$Sa,$D,$G1,$o3,$Cc},$K2);
$Ec=q#io/exec.c::ctors#;
$Fc=q#ni:/io/exec.c#;
$Gc={$K2,1};
$Hc=q#/io/exec.c#;
$Ic=[$n9];
$Jc=bless({$D2,$Gc,$D,$Hc,$o3,$Ic},$p3);
$Kc=q#ni:/io/exec_env.b#;
$Lc=q#ni:/io/exec_fork.b#;
$Mc=q#ni:/io/exec_init.b#;
$Nc=q#ni:/io/exec_io_accessors.b#;
$Oc=q#ni:/io/exec_io_setup.b#;
$Pc=q#ni:/io/exec_ro.b#;
$Qc=q#ni:/io/fd#;
$Rc={$I4,1};
$Sc=q#/io/fd#;
$Tc={};
$Uc=[];
$Vc=q#shift->{'fd'}#;
$Wc=bless({$o,$Uc,$q,$Vc,$s,$t},$u);
$Xc={$Jb,$Wc};
$Yc=q#/io/fd_readers.b#;
$Zc=bless({$D2,$Tc,$v3,$w3,$x3,$w3,$y3,$Xc,$D,$Yc},$H3);
$cd={};
$dd=[];
$ed=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd={$x4,$fd};
$hd=q#/io/fd_init.b#;
$id=bless({$D2,$cd,$v3,$w3,$x3,$w3,$y3,$gd,$D,$hd},$H3);
$jd={};
$kd=q#be#;
$ld=[];
$md=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$nd=bless({$o,$ld,$q,$md,$s,$t},$u);
$od={$kd,$nd};
$pd=q#/io/fd_shell.b#;
$qd=bless({$D2,$jd,$v3,$w3,$x3,$w3,$y3,$od,$D,$pd},$H3);
$rd={};
$sd=q#cloexec#;
$td=[];
$ud=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd=q#fcntl_flag#;
$xd=[];
$yd=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$zd=bless({$o,$xd,$q,$yd,$s,$t},$u);
$Ad=q#nonblock#;
$Bd=[];
$Cd=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Dd=bless({$o,$Bd,$q,$Cd,$s,$t},$u);
$Ed={$sd,$vd,$wd,$zd,$Ad,$Dd};
$Fd=q#/io/fd_fcntl.b#;
$Gd=bless({$D2,$rd,$v3,$w3,$x3,$w3,$y3,$Ed,$D,$Fd},$H3);
$Hd={};
$Id=[];
$Jd=q#shift->close#;
$Kd=bless({$o,$Id,$q,$Jd,$s,$t},$u);
$Ld=q#close#;
$Md=[];
$Nd=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Od=bless({$o,$Md,$q,$Nd,$s,$t},$u);
$Pd={$Ld,$Od};
$Qd=q#/io/fd_gc.b#;
$Rd=bless({$D2,$Hd,$v3,$w3,$x3,$Kd,$y3,$Pd,$D,$Qd},$H3);
$Sd={};
$Td=[];
$Ud=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Vd=bless({$o,$Td,$q,$Ud,$s,$t},$u);
$Wd=[];
$Xd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Yd=bless({$o,$Wd,$q,$Xd,$s,$t},$u);
$Zd={$W9,$Vd,$Z9,$Yd};
$ce=q#/io/fd_perlio.b#;
$de=bless({$D2,$Sd,$v3,$w3,$x3,$w3,$y3,$Zd,$D,$ce},$H3);
$ee=[$v8,$Zc,$id,$qd,$Gd,$Rd,$de];
$fe=bless({$D2,$Rc,$D,$Sc,$o3,$ee},$L2);
$ge=q#io/fd.c::ctors#;
$he=q#ni:/io/fd.c#;
$ie={$L2,1};
$je=q#/io/fd.c#;
$ke=[$n9];
$le=bless({$D2,$ie,$D,$je,$o3,$ke},$p3);
$me=q#ni:/io/fd_fcntl.b#;
$ne=q#ni:/io/fd_gc.b#;
$oe=q#ni:/io/fd_init.b#;
$pe=q#ni:/io/fd_perlio.b#;
$qe=q#ni:/io/fd_readers.b#;
$re=q#ni:/io/fd_shell.b#;
$se=q#ni:/io/file#;
$te={$J4,1};
$ue=q#/io/file#;
$ve={};
$we=[];
$xe=q#shift->{'name'}#;
$ye=bless({$o,$we,$q,$xe,$s,$t},$u);
$ze={$D,$ye};
$Ae=q#/io/file_readers.b#;
$Be=bless({$D2,$ve,$v3,$w3,$x3,$w3,$y3,$ze,$D,$Ae},$H3);
$Ce={};
$De=q#mode#;
$Ee=[];
$Fe=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Ge=bless({$o,$Ee,$q,$Fe,$s,$t},$u);
$He={$De,$Ge};
$Ie=q#/io/file_accessors.b#;
$Je=bless({$D2,$Ce,$v3,$w3,$x3,$w3,$y3,$He,$D,$Ie},$H3);
$Ke={};
$Le=[];
$Me=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe={$x4,$Ne};
$Pe=q#/io/file_init.b#;
$Qe=bless({$D2,$Ke,$v3,$w3,$x3,$w3,$y3,$Oe,$D,$Pe},$H3);
$Re={};
$Se=q#r#;
$Te=[];
$Ue=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We=[];
$Xe=q#shift->r->read(@_)#;
$Ye=bless({$o,$We,$q,$Xe,$s,$t},$u);
$Ze=q#w#;
$cf=[];
$df=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$ef=bless({$o,$cf,$q,$df,$s,$t},$u);
$ff=[];
$gf=q#shift->w->write(@_)#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if={$Se,$Ve,$W9,$Ye,$Ze,$ef,$Z9,$hf};
$jf=q#/io/file_io.b#;
$kf=bless({$D2,$Re,$v3,$w3,$x3,$w3,$y3,$if,$D,$jf},$H3);
$lf=[$v8,$Be,$Je,$Qe,$kf];
$mf=bless({$D2,$te,$D,$ue,$o3,$lf},$M2);
$nf=q#io/file.c::ctors#;
$of=q#ni:/io/file.c#;
$pf={$M2,1};
$qf=q#/io/file.c#;
$rf=[$n9];
$sf=bless({$D2,$pf,$D,$qf,$o3,$rf},$p3);
$tf=q#ni:/io/file_accessors.b#;
$uf=q#ni:/io/file_init.b#;
$vf=q#ni:/io/file_io.b#;
$wf=q#ni:/io/file_readers.b#;
$xf=q#ni:/io/named_io_fns.b#;
$yf={};
$zf=q#fcntl#;
$Af=[];
$Bf=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Cf=bless({$o,$Af,$q,$Bf,$s,$t},$u);
$Df=[];
$Ef=q#CORE::fork#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=q#open2#;
$Hf=[];
$If=q#CORE::open $_[0], $_[1]#;
$Jf=bless({$o,$Hf,$q,$If,$s,$t},$u);
$Kf=q#waitpid#;
$Lf=[];
$Mf=q#CORE::waitpid $_[0], $_[1]#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of={$zf,$Cf,$rc,$Ff,$Gf,$Jf,$Kf,$Nf};
$Pf=q#/io/named_io_fns.b#;
$Qf=bless({$D2,$yf,$v3,$w3,$x3,$w3,$y3,$Of,$D,$Pf},$H3);
$Rf=q#main#;
$Sf=q#ni:/io/null#;
$Tf={$K4,1};
$Uf=q#/io/null#;
$Vf={};
$Wf=[];
$Xf=q#+{fd => undef}#;
$Yf=bless({$o,$Wf,$q,$Xf,$s,$t},$u);
$Zf={$x4,$Yf};
$cg=q#/io/null_init.b#;
$dg=bless({$D2,$Vf,$v3,$w3,$x3,$w3,$y3,$Zf,$D,$cg},$H3);
$eg={};
$fg=[];
$gg=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$hg=bless({$o,$fg,$q,$gg,$s,$t},$u);
$ig=[];
$jg=q#shift->fd->read(@_)#;
$kg=bless({$o,$ig,$q,$jg,$s,$t},$u);
$lg=[];
$mg=q#shift->fd->write(@_)#;
$ng=bless({$o,$lg,$q,$mg,$s,$t},$u);
$og={$Jb,$hg,$W9,$kg,$Z9,$ng};
$pg=q#/io/null_io.b#;
$qg=bless({$D2,$eg,$v3,$w3,$x3,$w3,$y3,$og,$D,$pg},$H3);
$rg=[$v8,$dg,$qg];
$sg=bless({$D2,$Tf,$D,$Uf,$o3,$rg},$N2);
$tg=q#io/null.c::ctors#;
$ug=q#ni:/io/null.c#;
$vg={$N2,1};
$wg=q#/io/null.c#;
$xg=[$n9];
$yg=bless({$D2,$vg,$D,$wg,$o3,$xg},$p3);
$zg=q#ni:/io/null_init.b#;
$Ag=q#ni:/io/null_io.b#;
$Bg=q#ni:/io/object#;
$Cg=q#ni:/io/object.c#;
$Dg=q#ni:/io/object_checks.b#;
$Eg=q#ni:/io/object_constructors.b#;
$Fg=q#ni:/io/object_memory.b#;
$Gg=q#ni:/io/object_ops.b#;
$Hg=q#ni:/io/object_transfer_async.b#;
$Ig=q#ni:/io/object_transfer_sync.b#;
$Jg=q#ni:/io/pid#;
$Kg={$M4,1};
$Lg={};
$Mg=q#pid#;
$Ng=[];
$Og=q#shift->{'pid'}#;
$Pg=bless({$o,$Ng,$q,$Og,$s,$t},$u);
$Qg=q#status#;
$Rg=[];
$Sg=q#shift->{'status'}#;
$Tg=bless({$o,$Rg,$q,$Sg,$s,$t},$u);
$Ug={$Mg,$Pg,$Qg,$Tg};
$Vg=q#/io/pid_readers.b#;
$Wg=bless({$D2,$Lg,$v3,$w3,$x3,$w3,$y3,$Ug,$D,$Vg},$H3);
$Xg={};
$Yg=[];
$Zg=q#shift->await#;
$ch=bless({$o,$Yg,$q,$Zg,$s,$t},$u);
$dh=[];
$eh=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$fh=bless({$o,$dh,$q,$eh,$s,$t},$u);
$gh={$x4,$fh};
$hh=q#/io/pid_init.b#;
$ih=bless({$D2,$Xg,$v3,$w3,$x3,$ch,$y3,$gh,$D,$hh},$H3);
$jh={};
$kh=q#await#;
$lh=[];
$mh=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$nh=bless({$o,$lh,$q,$mh,$s,$t},$u);
$oh=q#running#;
$ph=[];
$qh=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$rh=bless({$o,$ph,$q,$qh,$s,$t},$u);
$sh={$kh,$nh,$oh,$rh};
$th=q#/io/pid_wait.b#;
$uh=bless({$D2,$jh,$v3,$w3,$x3,$w3,$y3,$sh,$D,$th},$H3);
$vh={};
$wh=[];
$xh=q#shift->stdout->read(@_)#;
$yh=bless({$o,$wh,$q,$xh,$s,$t},$u);
$zh=[];
$Ah=q#shift->stdin->write(@_)#;
$Bh=bless({$o,$zh,$q,$Ah,$s,$t},$u);
$Ch={$W9,$yh,$Z9,$Bh};
$Dh=q#/io/pid_io.b#;
$Eh=bless({$D2,$vh,$v3,$w3,$x3,$w3,$y3,$Ch,$D,$Dh},$H3);
$Fh={};
$Gh=[];
$Hh=q#$_[0]->{external_fds}{$_[1]}#;
$Ih=bless({$o,$Gh,$q,$Hh,$s,$t},$u);
$Jh=[];
$Kh=q#shift->fd(2)#;
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh=[];
$Nh=q#shift->fd(0)#;
$Oh=bless({$o,$Mh,$q,$Nh,$s,$t},$u);
$Ph=[];
$Qh=q#shift->fd(1)#;
$Rh=bless({$o,$Ph,$q,$Qh,$s,$t},$u);
$Sh={$Jb,$Ih,$Nb,$Lh,$Rb,$Oh,$Vb,$Rh};
$Th=q#/io/pid_accessors.b#;
$Uh=bless({$D2,$Fh,$v3,$w3,$x3,$w3,$y3,$Sh,$D,$Th},$H3);
$Vh=[$v8,$Wg,$ih,$uh,$Eh,$Uh];
$Wh=bless({$D2,$Kg,$D,$W1,$o3,$Vh},$P2);
$Xh=q#io/pid.c::ctors#;
$Yh=q#ni:/io/pid.c#;
$Zh={$P2,1};
$ci=q#/io/pid.c#;
$di=[$n9];
$ei=bless({$D2,$Zh,$D,$ci,$o3,$di},$p3);
$fi=q#ni:/io/pid_accessors.b#;
$gi=q#ni:/io/pid_init.b#;
$hi=q#ni:/io/pid_io.b#;
$ii=q#ni:/io/pid_readers.b#;
$ji=q#ni:/io/pid_wait.b#;
$ki=q#ni:/io/str#;
$li={$N4,1};
$mi=q#/io/str#;
$ni={};
$oi=q#data#;
$pi=[];
$qi=q#shift->{'data'}#;
$ri=bless({$o,$pi,$q,$qi,$s,$t},$u);
$si=q#end#;
$ti=[];
$ui=q#shift->{'end'}#;
$vi=bless({$o,$ti,$q,$ui,$s,$t},$u);
$wi=q#start#;
$xi=[];
$yi=q#shift->{'start'}#;
$zi=bless({$o,$xi,$q,$yi,$s,$t},$u);
$Ai={$oi,$ri,$si,$vi,$wi,$zi};
$Bi=q#/io/str_ro.b#;
$Ci=bless({$D2,$ni,$v3,$w3,$x3,$w3,$y3,$Ai,$D,$Bi},$H3);
$Di={};
$Ei=[];
$Fi=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Gi=bless({$o,$Ei,$q,$Fi,$s,$t},$u);
$Hi={$x4,$Gi};
$Ii=q#/io/str_init.b#;
$Ji=bless({$D2,$Di,$v3,$w3,$x3,$w3,$y3,$Hi,$D,$Ii},$H3);
$Ki={};
$Li=[];
$Mi=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Ni=bless({$o,$Li,$q,$Mi,$s,$t},$u);
$Oi=q#remaining#;
$Pi=[];
$Qi=q#my $self = shift; $$self{end} - $$self{start}#;
$Ri=bless({$o,$Pi,$q,$Qi,$s,$t},$u);
$Si=[];
$Ti=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Ui=bless({$o,$Si,$q,$Ti,$s,$t},$u);
$Vi={$W9,$Ni,$Oi,$Ri,$Z9,$Ui};
$Wi=q#/io/str_io.b#;
$Xi=bless({$D2,$Ki,$v3,$w3,$x3,$w3,$y3,$Vi,$D,$Wi},$H3);
$Yi=[$v8,$Ci,$Ji,$Xi];
$Zi=bless({$D2,$li,$D,$mi,$o3,$Yi},$Q2);
$cj=q#io/str.c::ctors#;
$dj=q#ni:/io/str.c#;
$ej={$Q2,1};
$fj=q#/io/str.c#;
$gj=[$n9];
$hj=bless({$D2,$ej,$D,$fj,$o3,$gj},$p3);
$ij=q#ni:/io/str_init.b#;
$jj=q#ni:/io/str_io.b#;
$kj=q#ni:/io/str_ro.b#;
$lj=q#ni:/io/transfer#;
$mj={$O4,1,$P4,1,$Q4,1};
$nj=q#/io/transfer#;
$oj={$O4,1,$P4,1,$Q4,1,$Y4,1};
$pj=q#/semantic/task#;
$qj={};
$rj=q#outcome#;
$sj=[];
$tj=q#shift->{'outcome'}#;
$uj=bless({$o,$sj,$q,$tj,$s,$t},$u);
$vj={$rj,$uj};
$wj=q#/semantic/task_ro.b#;
$xj=bless({$D2,$qj,$v3,$w3,$x3,$w3,$y3,$vj,$D,$wj},$H3);
$yj={};
$zj=q#failure#;
$Aj=[];
$Bj=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj=q#success#;
$Ej=[];
$Fj=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Gj=bless({$o,$Ej,$q,$Fj,$s,$t},$u);
$Hj={$zj,$Cj,$Dj,$Gj};
$Ij=q#/semantic/task_outcome.b#;
$Jj=bless({$D2,$yj,$v3,$w3,$x3,$w3,$y3,$Hj,$D,$Ij},$H3);
$Kj=[$k5,$xj,$Jj];
$Lj=bless({$D2,$oj,$D,$pj,$o3,$Kj},$m3);
$Mj=q#semantic/task.c::ctors#;
$Nj={};
$Oj=[];
$Pj=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Qj=bless({$o,$Oj,$q,$Pj,$s,$t},$u);
$Rj=[];
$Sj=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Tj=bless({$o,$Rj,$q,$Sj,$s,$t},$u);
$Uj=[];
$Vj=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Wj=bless({$o,$Uj,$q,$Vj,$s,$t},$u);
$Xj={$W9,$Tj,$Z9,$Wj};
$Yj=q#/io/transfer_io_interop.b#;
$Zj=bless({$D2,$Nj,$v3,$Qj,$x3,$w3,$y3,$Xj,$D,$Yj},$H3);
$ck={};
$dk=q#pressure#;
$ek=[];
$fk=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$gk=bless({$o,$ek,$q,$fk,$s,$t},$u);
$hk=q#read_limit_throughput#;
$ik=[];
$jk=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$kk=bless({$o,$ik,$q,$jk,$s,$t},$u);
$lk=q#throughput#;
$mk=[];
$nk=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$ok=bless({$o,$mk,$q,$nk,$s,$t},$u);
$pk=q#write_limit_throughput#;
$qk=[];
$rk=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk={$dk,$gk,$hk,$kk,$lk,$ok,$pk,$sk};
$uk=q#/io/transfer_io_measurement.b#;
$vk=bless({$D2,$ck,$v3,$w3,$x3,$w3,$y3,$tk,$D,$uk},$H3);
$wk=[$Lj,$Zj,$vk];
$xk=bless({$D2,$mj,$D,$nj,$o3,$wk},$R2);
$yk=q#io/transfer.c::ctors#;
$zk=q#ni:/io/transfer.c#;
$Ak={$R2,1,$S2,1,$T2,1};
$Bk=q#/io/transfer.c#;
$Ck={$R2,1,$S2,1,$T2,1,$m3,1};
$Dk=q#/semantic/task.c#;
$Ek=[$V6];
$Fk=bless({$D2,$Ck,$D,$Dk,$o3,$Ek},$p3);
$Gk={};
$Hk=[];
$Ik=q#my $self = shift;
ni('ni:/io/object')->def("/io/object_transfer_$1.b",
  "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\\@_)->run})
if $self->name =~ /transfer_(\\w+)$/;#;
$Jk=bless({$o,$Hk,$q,$Ik,$s,$t},$u);
$Kk={};
$Lk=q#/io/transfer.c_into.b#;
$Mk=bless({$D2,$Gk,$v3,$Jk,$x3,$w3,$y3,$Kk,$D,$Lk},$H3);
$Nk=[$Fk,$Mk];
$Ok=bless({$D2,$Ak,$D,$Bk,$o3,$Nk},$p3);
$Pk=q#ni:/io/transfer.c_into.b#;
$Qk=q#ni:/io/transfer_async#;
$Rk={$P4,1};
$Sk=q#/io/transfer_async#;
$Tk={};
$Uk=[];
$Vk=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  id        => $class->new_id};#;
$Wk=bless({$o,$Uk,$q,$Vk,$s,$t},$u);
$Xk={$x4,$Wk};
$Yk=q#/io/transfer_async_init.b#;
$Zk=bless({$D2,$Tk,$v3,$w3,$x3,$w3,$y3,$Xk,$D,$Yk},$H3);
$cl={};
$dl=[];
$el=q#ni('ni:/io/transfer_async')->track(shift)#;
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl=[];
$hl=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$il=bless({$o,$gl,$q,$hl,$s,$t},$u);
$jl={};
$kl=q#/io/transfer_async_lifecycle.b#;
$ll=bless({$D2,$cl,$v3,$fl,$x3,$il,$y3,$jl,$D,$kl},$H3);
$ml={};
$nl=q#run#;
$ol=[];
$pl=q#shift#;
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl=q#run_async#;
$sl=[];
$tl=q#my $self = shift;
my $n;
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}
$self;#;
$ul=bless({$o,$sl,$q,$tl,$s,$t},$u);
$vl={$nl,$ql,$rl,$ul};
$wl=q#/io/transfer_async_run.b#;
$xl=bless({$D2,$ml,$v3,$w3,$x3,$w3,$y3,$vl,$D,$wl},$H3);
$yl=[$xk,$Zk,$ll,$xl];
$zl=bless({$D2,$Rk,$D,$Sk,$o3,$yl},$S2);
$Al=q#io/transfer_async.c::ctors#;
$Bl=q#ni:/io/transfer_async.c#;
$Cl={$S2,1};
$Dl=q#/io/transfer_async.c#;
$El=[$Ok];
$Fl=bless({$D2,$Cl,$D,$Dl,$o3,$El},$p3);
$Gl=q#ni:/io/transfer_async_init.b#;
$Hl=q#ni:/io/transfer_async_lifecycle.b#;
$Il=q#ni:/io/transfer_async_run.b#;
$Jl=q#ni:/io/transfer_io_interop.b#;
$Kl=q#ni:/io/transfer_io_measurement.b#;
$Ll=q#ni:/io/transfer_sync#;
$Ml={$Q4,1};
$Nl=q#/io/transfer_sync#;
$Ol={};
$Pl=[];
$Ql=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Rl=bless({$o,$Pl,$q,$Ql,$s,$t},$u);
$Sl={$x4,$Rl};
$Tl=q#/io/transfer_sync_init.b#;
$Ul=bless({$D2,$Ol,$v3,$w3,$x3,$w3,$y3,$Sl,$D,$Tl},$H3);
$Vl={};
$Wl=[];
$Xl=q#my $self = shift;
my $buf;
while ($self->read($buf, 32768)) {
  my $n = $self->write($buf);
  $self->failure($!) unless defined $n;
  while ($n < length $buf) {
    my $n0 = $self->write(substr $buf, $n);
    $self->failure($!) unless defined $n0;
    $n += $n0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Yl=bless({$o,$Wl,$q,$Xl,$s,$t},$u);
$Zl={$nl,$Yl};
$cm=q#/io/transfer_sync_run.b#;
$dm=bless({$D2,$Vl,$v3,$w3,$x3,$w3,$y3,$Zl,$D,$cm},$H3);
$em=[$xk,$Ul,$dm];
$fm=bless({$D2,$Ml,$D,$Nl,$o3,$em},$T2);
$gm=q#io/transfer_sync.c::ctors#;
$hm=q#ni:/io/transfer_sync.c#;
$im={$T2,1};
$jm=q#/io/transfer_sync.c#;
$km=[$Ok];
$lm=bless({$D2,$im,$D,$jm,$o3,$km},$p3);
$mm=q#ni:/io/transfer_sync_init.b#;
$nm=q#ni:/io/transfer_sync_run.b#;
$om=q#ni:/lib/accessor.b#;
$pm=q#ni:/lib/behavior#;
$qm=q#ni:/lib/behavior.c#;
$rm=q#ni:/lib/branch#;
$sm={$J3,1};
$tm=q#/lib/branch#;
$um={};
$vm=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$wm=bless({$q,$vm,$s,$t},$u);
$xm={$x4,$wm};
$ym=q#/lib/branch_init.b#;
$zm=bless({$D2,$um,$v3,$w3,$x3,$w3,$y3,$xm,$D,$ym},$H3);
$Am=[$v5,$S3,$I3,$zm,$o6];
$Bm=bless({$D2,$sm,$D,$tm,$o3,$Am},$V2);
$Cm=q#lib/branch.c::ctors#;
$Dm=q#ni:/lib/branch.b#;
$Em=q#ni:/lib/branch.c#;
$Fm={$V2,1};
$Gm=q#/lib/branch.c#;
$Hm=[$c7];
$Im=bless({$D2,$Fm,$D,$Gm,$o3,$Hm},$p3);
$Jm=q#ni:/lib/branch_init.b#;
$Km=q#ni:/lib/class_init.b#;
$Lm=q#ni:/lib/dataslice#;
$Mm={$S4,1};
$Nm=q#/lib/dataslice#;
$Om={};
$Pm=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Qm=bless({$q,$Pm,$s,$t},$u);
$Rm={$x4,$Qm};
$Sm=q#/lib/dataslice_init.b#;
$Tm=bless({$D2,$Om,$v3,$w3,$x3,$w3,$y3,$Rm,$D,$Sm},$H3);
$Um={};
$Vm=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Wm=bless({$q,$Vm,$s,$t},$u);
$Xm={$C3,$Wm};
$Ym=q#/lib/dataslice_apply.b#;
$Zm=bless({$D2,$Um,$v3,$w3,$x3,$w3,$y3,$Xm,$D,$Ym},$H3);
$cn=[$v5,$Tm,$Zm];
$dn=bless({$D2,$Mm,$D,$Nm,$o3,$cn},$W2);
$en=q#lib/dataslice.c::ctors#;
$fn=q#ni:/lib/dataslice.c#;
$gn={$W2,1};
$hn=q#/lib/dataslice.c#;
$in=[$c7];
$jn=bless({$D2,$gn,$D,$hn,$o3,$in},$p3);
$kn=q#ni:/lib/dataslice_apply.b#;
$ln=q#ni:/lib/dataslice_init.b#;
$mn=q#ni:/lib/definition.b#;
$nn=q#ni:/lib/definition_def.b#;
$on=q#ni:/lib/definition_defdata.b#;
$pn=q#ni:/lib/doc#;
$qn={$F,1};
$rn={};
$sn=q#shift; +{name => shift, doc => []}#;
$tn=bless({$q,$sn,$s,$t},$u);
$un={$x4,$tn};
$vn=q#/lib/doc_init.b#;
$wn=bless({$D2,$rn,$v3,$w3,$x3,$w3,$y3,$un,$D,$vn},$H3);
$xn={};
$yn=q#'ni.doc'#;
$zn=bless({$q,$yn,$s,$t},$u);
$An={$V3,$zn};
$Bn=q#/lib/doc_namespace.b#;
$Cn=bless({$D2,$xn,$v3,$w3,$x3,$w3,$y3,$An,$D,$Bn},$H3);
$Dn={};
$En=q#AUTOLOAD#;
$Fn=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Gn=bless({$q,$Fn,$s,$t},$u);
$Hn={$En,$Gn};
$In=q#/lib/doc_define.b#;
$Jn=bless({$D2,$Dn,$v3,$w3,$x3,$w3,$y3,$Hn,$D,$In},$H3);
$Kn={};
$Ln=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Mn=bless({$q,$Ln,$s,$t},$u);
$Nn=q#tests#;
$On=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Pn=bless({$q,$On,$s,$t},$u);
$Qn={$n,$Mn,$Nn,$Pn};
$Rn=q#/lib/doc_test.b#;
$Sn=bless({$D2,$Kn,$v3,$w3,$x3,$w3,$y3,$Qn,$D,$Rn},$H3);
$Tn=[$k5,$S3,$wn,$Cn,$Jn,$Sn];
$Un=bless({$D2,$qn,$D,$u2,$o3,$Tn},$X2);
$Vn=q#lib/doc.c::ctors#;
$Wn=q#ni:/lib/doc.c#;
$Xn={$X2,1};
$Yn=q#/lib/doc.c#;
$Zn=[$V6];
$co=bless({$D2,$Xn,$D,$Yn,$o3,$Zn},$p3);
$do=q#ni:/lib/doc_define.b#;
$eo=q#ni:/lib/doc_init.b#;
$fo=q#ni:/lib/doc_namespace.b#;
$go=q#ni:/lib/doc_test.b#;
$ho=q#ni:/lib/documentable.b#;
$io=q#ni:/lib/fn#;
$jo={$u,1};
$ko=q#/lib/fn#;
$lo={};
$mo=q#shift->compile#;
$no=bless({$q,$mo,$s,$t},$u);
$oo=q#compile#;
$po=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$qo=bless({$q,$po,$s,$t},$u);
$ro=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$so=bless({$q,$ro,$s,$t},$u);
$to={$oo,$qo,$x4,$so};
$uo=q#/lib/fn_init.b#;
$vo=bless({$D2,$lo,$v3,$no,$x3,$w3,$y3,$to,$D,$uo},$H3);
$wo={};
$xo=[];
$yo=q#shift->{'annotations'}#;
$zo=bless({$o,$xo,$q,$yo,$s,$t},$u);
$Ao=[];
$Bo=q#shift->{'code'}#;
$Co=bless({$o,$Ao,$q,$Bo,$s,$t},$u);
$Do=q#fn#;
$Eo=[];
$Fo=q#shift->{'fn'}#;
$Go=bless({$o,$Eo,$q,$Fo,$s,$t},$u);
$Ho={$o,$zo,$q,$Co,$Do,$Go};
$Io=q#/lib/fn_ro.b#;
$Jo=bless({$D2,$wo,$v3,$w3,$x3,$w3,$y3,$Ho,$D,$Io},$H3);
$Ko={};
$Lo=[];
$Mo=q#shift->{code}#;
$No=bless({$o,$Lo,$q,$Mo,$s,$t},$u);
$Oo=[];
$Po=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Qo=bless({$o,$Oo,$q,$Po,$s,$t},$u);
$Ro={$R5,$No,$Y5,$Qo};
$So=q#/lib/fn_ops.b#;
$To=bless({$D2,$Ko,$v3,$w3,$x3,$w3,$y3,$Ro,$D,$So},$H3);
$Uo={};
$Vo=q#serialize#;
$Wo=[];
$Xo=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Yo=bless({$o,$Wo,$q,$Xo,$s,$t},$u);
$Zo={$Vo,$Yo};
$cp=q#/lib/fn_serialize.b#;
$dp=bless({$D2,$Uo,$v3,$w3,$x3,$w3,$y3,$Zo,$D,$cp},$H3);
$ep=[$k5,$C6,$vo,$Jo,$To,$dp];
$fp=bless({$D2,$jo,$D,$ko,$o3,$ep},$Y2);
$gp=q#lib/fn.c::ctors#;
$hp=q#ni:/lib/fn.c#;
$ip={$Y2,1};
$jp=q#/lib/fn.c#;
$kp=[$V6];
$lp=bless({$D2,$ip,$D,$jp,$o3,$kp},$p3);
$mp=q#ni:/lib/fn_init.b#;
$np=q#ni:/lib/fn_ops.b#;
$op=q#ni:/lib/fn_ro.b#;
$pp=q#ni:/lib/fn_serialize.b#;
$qp=q#ni:/lib/gensym_generator_compact.b#;
$rp={};
$sp=q#gensym#;
$tp=[];
$up=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={$sp,$vp};
$xp=q#/lib/gensym_generator_compact.b#;
$yp=bless({$D2,$rp,$v3,$w3,$x3,$w3,$y3,$wp,$D,$xp},$H3);
$zp=q#ni:/lib/global_static_test.b#;
$Ap={};
$Bp=q#now#;
$Cp=[];
$Dp=q#ni('ni:/lib/test_value')->new(shift)#;
$Ep=q#($)#;
$Fp=bless({$o,$Cp,$q,$Dp,$s,$Ep},$u);
$Gp={$Bp,$Fp};
$Hp=q#/lib/global_static_test.b#;
$Ip=bless({$D2,$Ap,$v3,$w3,$x3,$w3,$y3,$Gp,$D,$Hp},$H3);
$Jp=q#ni:/lib/image#;
$Kp={$T4,1};
$Lp=q#/lib/image#;
$Mp={};
$Np=[];
$Op=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Pp=bless({$o,$Np,$q,$Op,$s,$t},$u);
$Qp={$x4,$Pp};
$Rp=q#/lib/image_init.b#;
$Sp=bless({$D2,$Mp,$v3,$w3,$x3,$w3,$y3,$Qp,$D,$Rp},$H3);
$Tp={};
$Up=q#address#;
$Vp=[];
$Wp=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Xp=bless({$o,$Vp,$q,$Wp,$s,$t},$u);
$Yp=q#allocate_gensym#;
$Zp=[];
$cq=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$dq=bless({$o,$Zp,$q,$cq,$s,$t},$u);
$eq=q#boot_side_effect#;
$fq=[];
$gq=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$hq=bless({$o,$fq,$q,$gq,$s,$t},$u);
$iq=q#circular_links#;
$jq=[];
$kq=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$lq=bless({$o,$jq,$q,$kq,$s,$t},$u);
$mq=q#finalizer#;
$nq=[];
$oq=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$pq=bless({$o,$nq,$q,$oq,$s,$t},$u);
$qq=q#quote#;
$rq=[];
$sq=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$tq=bless({$o,$rq,$q,$sq,$s,$t},$u);
$uq=q#reconstruction#;
$vq=[];
$wq=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$xq=bless({$o,$vq,$q,$wq,$s,$t},$u);
$yq=q#side_effect#;
$zq=[];
$Aq=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Bq=bless({$o,$zq,$q,$Aq,$s,$t},$u);
$Cq=[];
$Dq=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Eq=bless({$o,$Cq,$q,$Dq,$s,$t},$u);
$Fq={$Up,$Xp,$Yp,$dq,$eq,$hq,$iq,$lq,$mq,$pq,$qq,$tq,$uq,$xq,$yq,$Bq,$Z9,$Eq};
$Gq=q#/lib/image_quoting.b#;
$Hq=bless({$D2,$Tp,$v3,$w3,$x3,$w3,$y3,$Fq,$D,$Gq},$H3);
$Iq={};
$Jq=q#quote_code#;
$Kq=[];
$Lq=q#shift->die('cannot quote perl CODE refs', shift)#;
$Mq=bless({$o,$Kq,$q,$Lq,$s,$t},$u);
$Nq={$Jq,$Mq};
$Oq=q#/lib/quote_code_fail.b#;
$Pq=bless({$D2,$Iq,$v3,$w3,$x3,$w3,$y3,$Nq,$D,$Oq},$H3);
$Qq={};
$Rq=q#quote_array#;
$Sq=[];
$Tq=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Uq=bless({$o,$Sq,$q,$Tq,$s,$t},$u);
$Vq=q#quote_hash#;
$Wq=[];
$Xq=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Yq=bless({$o,$Wq,$q,$Xq,$s,$t},$u);
$Zq=q#quote_scalar#;
$cr=[];
$dr=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$er=bless({$o,$cr,$q,$dr,$s,$t},$u);
$fr=q#quote_scalar_ref#;
$gr=[];
$hr=q#'\\\\' . shift->quote(${$_[0]})#;
$ir=bless({$o,$gr,$q,$hr,$s,$t},$u);
$jr=q#quote_value#;
$kr=[];
$lr=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$mr=bless({$o,$kr,$q,$lr,$s,$t},$u);
$nr={$Rq,$Uq,$Vq,$Yq,$Zq,$er,$fr,$ir,$jr,$mr};
$or=q#/lib/quote_values.b#;
$pr=bless({$D2,$Qq,$v3,$w3,$x3,$w3,$y3,$nr,$D,$or},$H3);
$qr={};
$rr=q#quote_blessed#;
$sr=[];
$tr=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr=q#quote_class#;
$wr=[];
$xr=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$yr=bless({$o,$wr,$q,$xr,$s,$t},$u);
$zr=q#quote_object#;
$Ar=[];
$Br=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Cr=bless({$o,$Ar,$q,$Br,$s,$t},$u);
$Dr={$rr,$ur,$vr,$yr,$zr,$Cr};
$Er=q#/lib/quote_objects.b#;
$Fr=bless({$D2,$qr,$v3,$w3,$x3,$w3,$y3,$Dr,$D,$Er},$H3);
$Gr={};
$Hr=q#circular_arrayref#;
$Ir=[];
$Jr=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Kr=bless({$o,$Ir,$q,$Jr,$s,$t},$u);
$Lr=q#circular_hashref#;
$Mr=[];
$Nr=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Or=bless({$o,$Mr,$q,$Nr,$s,$t},$u);
$Pr=q#is_circular#;
$Qr=[];
$Rr=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Sr=bless({$o,$Qr,$q,$Rr,$s,$t},$u);
$Tr={$Hr,$Kr,$Lr,$Or,$Pr,$Sr};
$Ur=q#/lib/quote_circular_addressed.b#;
$Vr=bless({$D2,$Gr,$v3,$w3,$x3,$w3,$y3,$Tr,$D,$Ur},$H3);
$Wr=[$k5,$Sp,$Hq,$Pq,$pr,$Fr,$Vr,$yp];
$Xr=bless({$D2,$Kp,$D,$Lp,$o3,$Wr},$Z2);
$Yr=q#lib/image.c::ctors#;
$Zr=q#ni:/lib/image.c#;
$cs={$Z2,1};
$ds=q#/lib/image.c#;
$es=[$V6];
$fs=bless({$D2,$cs,$D,$ds,$o3,$es},$p3);
$gs=q#ni:/lib/image_init.b#;
$hs=q#ni:/lib/image_quoting.b#;
$is=q#ni:/lib/instance.b#;
$js=q#ni:/lib/instantiable.b#;
$ks=q#ni:/lib/json.b#;
$ls={};
$ms=q#json_decode#;
$ns=[];
$os=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$ps=bless({$o,$ns,$q,$os,$s,$Ep},$u);
$qs=q#json_encode#;
$rs=[];
$ss=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$ts=bless({$o,$rs,$q,$ss,$s,$Ep},$u);
$us=q#json_escape#;
$vs=[];
$ws=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$xs=bless({$o,$vs,$q,$ws,$s,$Ep},$u);
$ys=q#json_unescape#;
$zs=[];
$As=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Bs=bless({$o,$zs,$q,$As,$s,$Ep},$u);
$Cs=q#json_unescape_one#;
$Ds=[];
$Es=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Fs=bless({$o,$Ds,$q,$Es,$s,$Ep},$u);
$Gs={$ms,$ps,$qs,$ts,$us,$xs,$ys,$Bs,$Cs,$Fs};
$Hs=q#/lib/json.b#;
$Is=bless({$D2,$ls,$v3,$w3,$x3,$w3,$y3,$Gs,$D,$Hs},$H3);
$Js=q#ni#;
$Ks=q#ni:/lib/name_as_string.b#;
$Ls=q#ni:/lib/named.b#;
$Ms=q#ni:/lib/named_in_ni.b#;
$Ns=q#ni:/lib/namespaced.b#;
$Os=q#ni:/lib/ni#;
$Ps={$U4,1};
$Qs=q#/lib/ni#;
$Rs={};
$Ss=q#extend#;
$Ts=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Us=bless({$q,$Ts,$s,$t},$u);
$Vs=q#is_mutable#;
$Ws=q#$0 ne "-" && -w $0#;
$Xs=bless({$q,$Ws,$s,$t},$u);
$Ys=q#modify#;
$Zs=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$ct=bless({$q,$Zs,$s,$t},$u);
$dt={$Ss,$Us,$Vs,$Xs,$Ys,$ct};
$et=q#/lib/ni_self.b#;
$ft=bless({$D2,$Rs,$v3,$w3,$x3,$w3,$y3,$dt,$D,$et},$H3);
$gt={};
$ht=q#--internal/+=#;
$it=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$jt=bless({$q,$it,$s,$t},$u);
$kt=q#--internal/eval#;
$lt=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$mt=bless({$q,$lt,$s,$t},$u);
$nt=q#--internal/image#;
$ot=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$pt=bless({$q,$ot,$s,$t},$u);
$qt=q#--internal/test#;
$rt=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$st=bless({$q,$rt,$s,$t},$u);
$tt=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$ut=bless({$q,$tt,$s,$t},$u);
$vt={$ht,$jt,$kt,$mt,$nt,$pt,$qt,$st,$nl,$ut};
$wt=q#/lib/ni_main.b#;
$xt=bless({$D2,$gt,$v3,$w3,$x3,$w3,$y3,$vt,$D,$wt},$H3);
$yt={};
$zt=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$At=bless({$q,$zt,$s,$t},$u);
$Bt=q#resolver_for#;
$Ct=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Dt=bless({$q,$Ct,$s,$t},$u);
$Et={$l4,$At,$Bt,$Dt};
$Ft=q#/lib/ni_resolver.b#;
$Gt=bless({$D2,$yt,$v3,$w3,$x3,$w3,$y3,$Et,$D,$Ft},$H3);
$Ht={};
$It=q#exists#;
$Jt=q#exists $_[0]->{named}{$_[1]}#;
$Kt=bless({$q,$Jt,$s,$t},$u);
$Lt=q#quoted#;
$Mt=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Nt=bless({$q,$Mt,$s,$t},$u);
$Ot={$It,$Kt,$Lt,$Nt};
$Pt=q#/lib/ni_image.b#;
$Qt=bless({$D2,$Ht,$v3,$w3,$x3,$w3,$y3,$Ot,$D,$Pt},$H3);
$Rt=[$k5,$ft,$xt,$Gt,$Qt];
$St=bless({$D2,$Ps,$D,$Qs,$o3,$Rt},$c3);
$Tt=q#lib/ni.c::ctors#;
$Ut=q#ni:/lib/ni.c#;
$Vt={$c3,1};
$Wt=q#/lib/ni.c#;
$Xt=[$V6];
$Yt=bless({$D2,$Vt,$D,$Wt,$o3,$Xt},$p3);
$Zt=q#ni:/lib/ni_image.b#;
$cu=q#ni:/lib/ni_main.b#;
$du=q#ni:/lib/ni_resolver.b#;
$eu=q#ni:/lib/ni_self.b#;
$fu=q#ni:/lib/ni_static_util.b#;
$gu={};
$hu=q#abbrev#;
$iu=[];
$ju=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$ku=bless({$o,$iu,$q,$ju,$s,$t},$u);
$lu=q#dor#;
$mu=[];
$nu=q#defined $_[0] ? $_[0] : $_[1]#;
$ou=bless({$o,$mu,$q,$nu,$s,$t},$u);
$pu=q#indent#;
$qu=[];
$ru=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$su=bless({$o,$qu,$q,$ru,$s,$t},$u);
$tu=q#max#;
$uu=[];
$vu=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$wu=bless({$o,$uu,$q,$vu,$s,$t},$u);
$xu=q#maxstr#;
$yu=[];
$zu=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Au=bless({$o,$yu,$q,$zu,$s,$t},$u);
$Bu=q#mean#;
$Cu=[];
$Du=q#sum(@_) / (@_ || 1)#;
$Eu=bless({$o,$Cu,$q,$Du,$s,$t},$u);
$Fu=q#min#;
$Gu=[];
$Hu=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Iu=bless({$o,$Gu,$q,$Hu,$s,$t},$u);
$Ju=q#minstr#;
$Ku=[];
$Lu=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Mu=bless({$o,$Ku,$q,$Lu,$s,$t},$u);
$Nu=q#sgr#;
$Ou=[];
$Pu=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Qu=bless({$o,$Ou,$q,$Pu,$s,$t},$u);
$Ru=q#sr#;
$Su=[];
$Tu=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Uu=bless({$o,$Su,$q,$Tu,$s,$t},$u);
$Vu=q#sum#;
$Wu=[];
$Xu=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Yu=bless({$o,$Wu,$q,$Xu,$s,$t},$u);
$Zu=q#swap#;
$cv=[];
$dv=q#@_[0, 1] = @_[1, 0]#;
$ev=bless({$o,$cv,$q,$dv,$s,$t},$u);
$fv={$hu,$ku,$lu,$ou,$pu,$su,$tu,$wu,$xu,$Au,$Bu,$Eu,$Fu,$Iu,$Ju,$Mu,$Nu,$Qu,$Ru,$Uu,$Vu,$Yu,$Zu,$ev};
$gv=q#/lib/ni_static_util.b#;
$hv=bless({$D2,$gu,$v3,$w3,$x3,$w3,$y3,$fv,$D,$gv},$H3);
$iv=q#ni:/lib/perlbranch.b#;
$jv=q#ni:/lib/quote_circular_addressed.b#;
$kv=q#ni:/lib/quote_code_fail.b#;
$lv=q#ni:/lib/quote_objects.b#;
$mv=q#ni:/lib/quote_simple#;
$nv={$V4,1};
$ov=q#/lib/quote_simple#;
$pv={};
$qv=[];
$rv=q#+{}#;
$sv=bless({$o,$qv,$q,$rv,$s,$t},$u);
$tv={$x4,$sv};
$uv=q#/lib/quote_simple_init.b#;
$vv=bless({$D2,$pv,$v3,$w3,$x3,$w3,$y3,$tv,$D,$uv},$H3);
$wv={};
$xv=[];
$yv=bless({$o,$xv,$q,0,$s,$t},$u);
$zv=[];
$Av=q#shift->quote_value(shift)#;
$Bv=bless({$o,$zv,$q,$Av,$s,$t},$u);
$Cv={$Pr,$yv,$qq,$Bv};
$Dv=q#/lib/quote_simple_quote.b#;
$Ev=bless({$D2,$wv,$v3,$w3,$x3,$w3,$y3,$Cv,$D,$Dv},$H3);
$Fv=[$k5,$vv,$Ev,$Pq,$pr,$Fr];
$Gv=bless({$D2,$nv,$D,$ov,$o3,$Fv},$d3);
$Hv=q#lib/quote_simple.c::ctors#;
$Iv=q#ni:/lib/quote_simple.c#;
$Jv={$d3,1};
$Kv=q#/lib/quote_simple.c#;
$Lv=[$V6];
$Mv=bless({$D2,$Jv,$D,$Kv,$o3,$Lv},$p3);
$Nv=q#ni:/lib/quote_simple_init.b#;
$Ov=q#ni:/lib/quote_simple_quote.b#;
$Pv=q#ni:/lib/quote_values.b#;
$Qv=q#ni:/lib/ref_eq.b#;
$Rv=q#ni:/lib/resolver.b#;
$Sv=q#ni:/lib/slice#;
$Tv={$H3,1};
$Uv=q#/lib/slice#;
$Vv=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Wv=bless({$q,$Vv,$s,$t},$u);
$Xv=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Yv=bless({$q,$Xv,$s,$t},$u);
$Zv=q#lib/slice::apply#;
$cw=q#lib/slice::apply_unsafe#;
$dw={};
$ew=q#apply_unsafe#;
$fw={$C3,$Wv,$ew,$Yv};
$gw=q#/lib/slice.b#;
$hw=bless({$D2,$dw,$y3,$fw,$D,$gw},$H3);
$iw={};
$jw=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$kw=bless({$q,$jw,$s,$t},$u);
$lw={$x4,$kw};
$mw=q#/lib/slice_init.b#;
$nw=bless({$D2,$iw,$y3,$lw,$D,$mw},$H3);
$ow={};
$pw=[];
$qw=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$rw=bless({$o,$pw,$q,$qw,$s,$t},$u);
$sw={$Vo,$rw};
$tw=q#/lib/slice_serialize.b#;
$uw=bless({$D2,$ow,$v3,$w3,$x3,$w3,$y3,$sw,$D,$tw},$H3);
$vw=[$v5,$S3,$hw,$nw,$uw];
$ww=bless({$D2,$Tv,$D,$Uv,$o3,$vw},$e3);
$xw=q#lib/slice.c::ctors#;
$yw=q#ni:/lib/slice.b#;
$zw=q#ni:/lib/slice.c#;
$Aw={$e3,1};
$Bw=q#/lib/slice.c#;
$Cw=[$c7];
$Dw=bless({$D2,$Aw,$D,$Bw,$o3,$Cw},$p3);
$Ew=q#ni:/lib/slice_init.b#;
$Fw=q#ni:/lib/slice_serialize.b#;
$Gw=q#ni:/lib/static_fn.b#;
$Hw={};
$Iw=[];
$Jw=q#ni('ni:/lib/fn')->new(@_)#;
$Kw=bless({$o,$Iw,$q,$Jw,$s,$Ep},$u);
$Lw=q#fp#;
$Mw=[];
$Nw=q#($$)#;
$Ow=bless({$o,$Mw,$q,$Jw,$s,$Nw},$u);
$Pw={$Do,$Kw,$Lw,$Ow};
$Qw=q#/lib/static_fn.b#;
$Rw=bless({$D2,$Hw,$v3,$w3,$x3,$w3,$y3,$Pw,$D,$Qw},$H3);
$Sw=q#ni:/lib/subclass.b#;
$Tw=q#ni:/lib/tag#;
$Uw={$T3,1};
$Vw=q#/lib/tag#;
$Ww={};
$Xw=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Yw=bless({$q,$Xw,$s,$t},$u);
$Zw={$C3,$Yw};
$cx=q#/lib/tag.b#;
$dx=bless({$D2,$Ww,$v3,$w3,$x3,$w3,$y3,$Zw,$D,$cx},$H3);
$ex={};
$fx=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$gx=bless({$q,$fx,$s,$t},$u);
$hx={$x4,$gx};
$ix=q#/lib/tag_init.b#;
$jx=bless({$D2,$ex,$v3,$w3,$x3,$w3,$y3,$hx,$D,$ix},$H3);
$kx=[$v5,$S3,$dx,$jx];
$lx=bless({$D2,$Uw,$D,$Vw,$o3,$kx},$f3);
$mx=q#lib/tag.c::ctors#;
$nx=q#ni:/lib/tag.b#;
$ox=q#ni:/lib/tag.c#;
$px={$f3,1};
$qx=q#/lib/tag.c#;
$rx=[$c7];
$sx=bless({$D2,$px,$D,$qx,$o3,$rx},$p3);
$tx=q#ni:/lib/tag_init.b#;
$ux=q#ni:/lib/test_value#;
$vx={$W4,1};
$wx=q#/lib/test_value#;
$xx={};
$yx=[];
$zx=q#\\$_[1]#;
$Ax=bless({$o,$yx,$q,$zx,$s,$t},$u);
$Bx={$x4,$Ax};
$Cx=q#/lib/test_value_init.b#;
$Dx=bless({$D2,$xx,$v3,$w3,$x3,$w3,$y3,$Bx,$D,$Cx},$H3);
$Ex={};
$Fx=q#(==#;
$Gx=[];
$Hx=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Ix=bless({$o,$Gx,$q,$Hx,$s,$t},$u);
$Jx=q#diff#;
$Kx=[];
$Lx=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Mx=bless({$o,$Kx,$q,$Lx,$s,$t},$u);
$Nx={$Fx,$Ix,$Jx,$Mx};
$Ox=q#/lib/test_value_eq.b#;
$Px=bless({$D2,$Ex,$v3,$w3,$x3,$w3,$y3,$Nx,$D,$Ox},$H3);
$Qx={};
$Rx=[];
$Sx=q#ni::json_encode ${$_[0]}#;
$Tx=bless({$o,$Rx,$q,$Sx,$s,$t},$u);
$Ux={$R5,$Tx};
$Vx=q#/lib/test_value_str.b#;
$Wx=bless({$D2,$Qx,$v3,$w3,$x3,$w3,$y3,$Ux,$D,$Vx},$H3);
$Xx=[$k5,$Dx,$Px,$Wx];
$Yx=bless({$D2,$vx,$D,$wx,$o3,$Xx},$g3);
$Zx=q#lib/test_value.c::ctors#;
$cy=q#ni:/lib/test_value.c#;
$dy={$g3,1};
$ey=q#/lib/test_value.c#;
$fy=[$V6];
$gy=bless({$D2,$dy,$D,$ey,$o3,$fy},$p3);
$hy=q#ni:/lib/test_value_eq.b#;
$iy=q#ni:/lib/test_value_init.b#;
$jy=q#ni:/lib/test_value_str.b#;
$ky=q#ni:/metaclass#;
$ly={$p3,1};
$my=q#/metaclass#;
$ny=[$s4,$C6,$C4,$r6];
$oy=bless({$D2,$ly,$D,$my,$o3,$ny},$h3);
$py=q#metaclass.c::ctors#;
$qy=q#ni:/metaclass.c#;
$ry={$h3,1};
$sy=q#/metaclass.c#;
$ty=[$L6];
$uy=bless({$D2,$ry,$D,$sy,$o3,$ty},$p3);
$vy=q#ni:/module#;
$wy=q#ni:/module.c#;
$xy=q#ni:/object#;
$yy=q#ni:/object.c#;
$zy=q#ni:/semantic/dimension#;
$Ay={$k3,1};
$By=q#/semantic/dimension#;
$Cy=[$L6];
$Dy=bless({$D2,$Ay,$D,$By,$o3,$Cy},$l3);
$Ey=q#semantic/dimension.c::ctors#;
$Fy=q#ni:/semantic/dimension.c#;
$Gy={$l3,1};
$Hy=q#/semantic/dimension.c#;
$Iy=[$g7];
$Jy=bless({$D2,$Gy,$D,$Hy,$o3,$Iy},$p3);
$Ky=q#ni:/semantic/task#;
$Ly=q#ni:/semantic/task.c#;
$My=q#ni:/semantic/task_outcome.b#;
$Ny=q#ni:/semantic/task_ro.b#;
$Oy=q#ni:main#;
$Py={$Rf,1};
$Qy=[$Rw,$Ip,$Qf];
$Ry=bless({$D2,$Py,$D,$Rf,$o3,$Qy},$q3);
$Sy=q#module::ctors#;
$Ty=q#ni:ni#;
$Uy={$Js,1};
$Vy={$Js,1};
$Wy=q#json_escapes#;
$Xy=q##;
$Yy=q#b#;
$Zy=q#	#;
$cz=q#t#;
$dz=q#
#;
$ez=q#n#;
$fz=q##;
$gz=q#"#;
$hz=q#/#;
$iz=q#\\#;
$jz={$Xy,$Yy,$Zy,$cz,$dz,$ez,$fz,$Se,$gz,$gz,$hz,$hz,$iz,$iz};
$kz=q#json_unescapes#;
$lz={$gz,$gz,$hz,$hz,$iz,$iz,$Yy,$Xy,$ez,$dz,$Se,$fz,$cz,$Zy};
$mz={$Wy,$jz,$kz,$lz};
$nz=q#/lib/json_data.b#;
$oz=bless({$D2,$Vy,$oi,$mz,$D,$nz},$S4);
$pz=q#lib/dataslice::ctors#;
$qz=[$oz,$Is,$hv];
$rz=bless({$D2,$Uy,$D,$Js,$o3,$qz},$q3);
$sz={$d,$G,$I,$N,$O,$V,$W,$d1,$e1,$j1,$k1,$v1,$w1,$H1,$I1,$X1,$Y1,$f2,$g2,$v2,$w2,$B2,$C2,$L6,$N6,$g7,$h7,$f9,$h9,$p9,$q9,$P8,$r9,$d9,$s9,$I8,$t9,$E9,$G9,$K9,$L9,$C9,$M9,$ia,$ka,$oa,$pa,$U9,$qa,$ga,$ra,$Ia,$Ka,$Oa,$Pa,$za,$Qa,$Ga,$Ra,$Dc,$Fc,$Jc,$Kc,$lc,$Lc,$Bc,$Mc,$jb,$Nc,$dc,$Oc,$Db,$Pc,$cb,$Qc,$fe,$he,$le,$me,$Gd,$ne,$Rd,$oe,$id,$pe,$de,$qe,$Zc,$re,$qd,$se,$mf,$of,$sf,$tf,$Je,$uf,$Qe,$vf,$kf,$wf,$Be,$xf,$Qf,$Sf,$sg,$ug,$yg,$zg,$dg,$Ag,$qg,$Bg,$v8,$Cg,$n9,$Dg,$L7,$Eg,$T7,$Fg,$d8,$Gg,$r7,$Hg,$t8,$Ig,$l8,$Jg,$Wh,$Yh,$ei,$fi,$Uh,$gi,$ih,$hi,$Eh,$ii,$Wg,$ji,$uh,$ki,$Zi,$dj,$hj,$ij,$Ji,$jj,$Xi,$kj,$Ci,$lj,$xk,$zk,$Ok,$Pk,$Mk,$Qk,$zl,$Bl,$Fl,$Gl,$Zk,$Hl,$ll,$Il,$xl,$Jl,$Zj,$Kl,$vk,$Ll,$fm,$hm,$lm,$mm,$Ul,$nm,$dm,$om,$P5,$pm,$v5,$qm,$c7,$rm,$Bm,$Dm,$I3,$Em,$Im,$Jm,$zm,$Km,$C4,$Lm,$dn,$fn,$jn,$kn,$Zm,$ln,$Tm,$mn,$o6,$nn,$F5,$on,$m6,$pn,$Un,$Wn,$co,$do,$Jn,$eo,$wn,$fo,$Cn,$go,$Sn,$ho,$t5,$io,$fp,$hp,$lp,$mp,$vo,$np,$To,$op,$Jo,$pp,$dp,$qp,$yp,$zp,$Ip,$Jp,$Xr,$Zr,$fs,$gs,$Sp,$hs,$Hq,$is,$i5,$js,$C6,$ks,$Is,$Ks,$W5,$Ls,$S3,$Ms,$c4,$Ns,$j4,$Os,$St,$Ut,$Yt,$Zt,$Qt,$cu,$xt,$du,$Gt,$eu,$ft,$fu,$hv,$iv,$s4,$jv,$Vr,$kv,$Pq,$lv,$Fr,$mv,$Gv,$Iv,$Mv,$Nv,$vv,$Ov,$Ev,$Pv,$pr,$Qv,$f6,$Rv,$q4,$Sv,$ww,$yw,$hw,$zw,$Dw,$Ew,$nw,$Fw,$uw,$Gw,$Rw,$Sw,$J6,$Tw,$lx,$nx,$dx,$ox,$sx,$tx,$jx,$ux,$Yx,$cy,$gy,$hy,$Px,$iy,$Dx,$jy,$Wx,$ky,$oy,$qy,$uy,$vy,$r6,$wy,$e7,$xy,$k5,$yy,$V6,$zy,$Dy,$Fy,$Jy,$Ky,$Lj,$Ly,$Fk,$My,$Jj,$Ny,$xj,$Oy,$Ry,$Ty,$rz};
$tz=q#resolvers#;
$uz=[];
$vz=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$wz=bless({$o,$uz,$q,$vz,$s,$t},$u);
$xz=q#file#;
$yz=[];
$zz=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Az=bless({$o,$yz,$q,$zz,$s,$t},$u);
$Bz=q#null#;
$Cz=[];
$Dz=q#ni('ni:/io/null')->new#;
$Ez=bless({$o,$Cz,$q,$Dz,$s,$t},$u);
$Fz=q#sh#;
$Gz=[];
$Hz=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Iz=bless({$o,$Gz,$q,$Hz,$s,$t},$u);
$Jz=q#str#;
$Kz=[];
$Lz=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Mz=bless({$o,$Kz,$q,$Lz,$s,$t},$u);
$Nz={$Jb,$wz,$xz,$Az,$Bz,$Ez,$Fz,$Iz,$Jz,$Mz};
$Oz=bless({$c,$sz,$tz,$Nz},$U4);
$Pz=q#lib/ni::ctors#;
*$cw=\&$Yv;
*$Zv=\&$Wv;
$I3->apply_unsafe($E2);
$I3->apply_unsafe($F2);
$I3->apply_unsafe($G2);
$I3->apply_unsafe($H2);
$I3->apply_unsafe($I2);
$I3->apply_unsafe($J2);
$I3->apply_unsafe($K2);
$I3->apply_unsafe($L2);
$I3->apply_unsafe($M2);
$I3->apply_unsafe($N2);
$I3->apply_unsafe($O2);
$I3->apply_unsafe($P2);
$I3->apply_unsafe($Q2);
$I3->apply_unsafe($R2);
$I3->apply_unsafe($S2);
$I3->apply_unsafe($T2);
$I3->apply_unsafe($U2);
$I3->apply_unsafe($J3);
$I3->apply_unsafe($V2);
$I3->apply_unsafe($W2);
$I3->apply_unsafe($X2);
$I3->apply_unsafe($Y2);
$I3->apply_unsafe($Z2);
$I3->apply_unsafe($c3);
$I3->apply_unsafe($d3);
$I3->apply_unsafe($e3);
$I3->apply_unsafe($f3);
$I3->apply_unsafe($g3);
$I3->apply_unsafe($p3);
$I3->apply_unsafe($h3);
$I3->apply_unsafe($q3);
$I3->apply_unsafe($i3);
$I3->apply_unsafe($j3);
$I3->apply_unsafe($k3);
$I3->apply_unsafe($l3);
$I3->apply_unsafe($m3);
$S3->apply_unsafe($E2);
$S3->apply_unsafe($F2);
$S3->apply_unsafe($G2);
$S3->apply_unsafe($H2);
$S3->apply_unsafe($I2);
$S3->apply_unsafe($J2);
$S3->apply_unsafe($K2);
$S3->apply_unsafe($L2);
$S3->apply_unsafe($M2);
$S3->apply_unsafe($N2);
$S3->apply_unsafe($O2);
$S3->apply_unsafe($P2);
$S3->apply_unsafe($Q2);
$S3->apply_unsafe($R2);
$S3->apply_unsafe($S2);
$S3->apply_unsafe($T2);
$S3->apply_unsafe($U2);
$S3->apply_unsafe($J3);
$S3->apply_unsafe($V2);
$S3->apply_unsafe($W2);
$S3->apply_unsafe($F);
$S3->apply_unsafe($X2);
$S3->apply_unsafe($Y2);
$S3->apply_unsafe($Z2);
$S3->apply_unsafe($c3);
$S3->apply_unsafe($d3);
$S3->apply_unsafe($H3);
$S3->apply_unsafe($e3);
$S3->apply_unsafe($T3);
$S3->apply_unsafe($f3);
$S3->apply_unsafe($g3);
$S3->apply_unsafe($p3);
$S3->apply_unsafe($h3);
$S3->apply_unsafe($q3);
$S3->apply_unsafe($i3);
$S3->apply_unsafe($j3);
$S3->apply_unsafe($k3);
$S3->apply_unsafe($l3);
$S3->apply_unsafe($m3);
$c4->apply_unsafe($E2);
$c4->apply_unsafe($F2);
$c4->apply_unsafe($G2);
$c4->apply_unsafe($H2);
$c4->apply_unsafe($I2);
$c4->apply_unsafe($J2);
$c4->apply_unsafe($K2);
$c4->apply_unsafe($L2);
$c4->apply_unsafe($M2);
$c4->apply_unsafe($N2);
$c4->apply_unsafe($O2);
$c4->apply_unsafe($P2);
$c4->apply_unsafe($Q2);
$c4->apply_unsafe($R2);
$c4->apply_unsafe($S2);
$c4->apply_unsafe($T2);
$c4->apply_unsafe($U2);
$c4->apply_unsafe($J3);
$c4->apply_unsafe($V2);
$c4->apply_unsafe($W2);
$c4->apply_unsafe($X2);
$c4->apply_unsafe($Y2);
$c4->apply_unsafe($Z2);
$c4->apply_unsafe($c3);
$c4->apply_unsafe($d3);
$c4->apply_unsafe($H3);
$c4->apply_unsafe($e3);
$c4->apply_unsafe($T3);
$c4->apply_unsafe($f3);
$c4->apply_unsafe($g3);
$c4->apply_unsafe($p3);
$c4->apply_unsafe($h3);
$c4->apply_unsafe($q3);
$c4->apply_unsafe($i3);
$c4->apply_unsafe($j3);
$c4->apply_unsafe($k3);
$c4->apply_unsafe($l3);
$c4->apply_unsafe($m3);
$j4->apply_unsafe($E2);
$j4->apply_unsafe($F2);
$j4->apply_unsafe($G2);
$j4->apply_unsafe($H2);
$j4->apply_unsafe($I2);
$j4->apply_unsafe($J2);
$j4->apply_unsafe($K2);
$j4->apply_unsafe($L2);
$j4->apply_unsafe($M2);
$j4->apply_unsafe($N2);
$j4->apply_unsafe($O2);
$j4->apply_unsafe($P2);
$j4->apply_unsafe($Q2);
$j4->apply_unsafe($R2);
$j4->apply_unsafe($S2);
$j4->apply_unsafe($T2);
$j4->apply_unsafe($U2);
$j4->apply_unsafe($J3);
$j4->apply_unsafe($V2);
$j4->apply_unsafe($W2);
$j4->apply_unsafe($X2);
$j4->apply_unsafe($Y2);
$j4->apply_unsafe($Z2);
$j4->apply_unsafe($c3);
$j4->apply_unsafe($d3);
$j4->apply_unsafe($H3);
$j4->apply_unsafe($e3);
$j4->apply_unsafe($T3);
$j4->apply_unsafe($f3);
$j4->apply_unsafe($g3);
$j4->apply_unsafe($p3);
$j4->apply_unsafe($h3);
$j4->apply_unsafe($q3);
$j4->apply_unsafe($i3);
$j4->apply_unsafe($j3);
$j4->apply_unsafe($k3);
$j4->apply_unsafe($l3);
$j4->apply_unsafe($m3);
$q4->apply_unsafe($E2);
$q4->apply_unsafe($F2);
$q4->apply_unsafe($G2);
$q4->apply_unsafe($H2);
$q4->apply_unsafe($I2);
$q4->apply_unsafe($J2);
$q4->apply_unsafe($K2);
$q4->apply_unsafe($L2);
$q4->apply_unsafe($M2);
$q4->apply_unsafe($N2);
$q4->apply_unsafe($O2);
$q4->apply_unsafe($P2);
$q4->apply_unsafe($Q2);
$q4->apply_unsafe($R2);
$q4->apply_unsafe($S2);
$q4->apply_unsafe($T2);
$q4->apply_unsafe($U2);
$q4->apply_unsafe($J3);
$q4->apply_unsafe($V2);
$q4->apply_unsafe($W2);
$q4->apply_unsafe($X2);
$q4->apply_unsafe($Y2);
$q4->apply_unsafe($Z2);
$q4->apply_unsafe($c3);
$q4->apply_unsafe($d3);
$q4->apply_unsafe($e3);
$q4->apply_unsafe($T3);
$q4->apply_unsafe($f3);
$q4->apply_unsafe($g3);
$q4->apply_unsafe($p3);
$q4->apply_unsafe($h3);
$q4->apply_unsafe($q3);
$q4->apply_unsafe($i3);
$q4->apply_unsafe($j3);
$q4->apply_unsafe($k3);
$q4->apply_unsafe($l3);
$q4->apply_unsafe($m3);
$C4->apply_unsafe($E2);
$C4->apply_unsafe($F2);
$C4->apply_unsafe($G2);
$C4->apply_unsafe($H2);
$C4->apply_unsafe($I2);
$C4->apply_unsafe($J2);
$C4->apply_unsafe($K2);
$C4->apply_unsafe($L2);
$C4->apply_unsafe($M2);
$C4->apply_unsafe($N2);
$C4->apply_unsafe($O2);
$C4->apply_unsafe($P2);
$C4->apply_unsafe($Q2);
$C4->apply_unsafe($R2);
$C4->apply_unsafe($S2);
$C4->apply_unsafe($T2);
$C4->apply_unsafe($U2);
$C4->apply_unsafe($V2);
$C4->apply_unsafe($W2);
$C4->apply_unsafe($X2);
$C4->apply_unsafe($Y2);
$C4->apply_unsafe($Z2);
$C4->apply_unsafe($c3);
$C4->apply_unsafe($d3);
$C4->apply_unsafe($e3);
$C4->apply_unsafe($f3);
$C4->apply_unsafe($g3);
$C4->apply_unsafe($p3);
$C4->apply_unsafe($h3);
$C4->apply_unsafe($q3);
$C4->apply_unsafe($i3);
$C4->apply_unsafe($j3);
$C4->apply_unsafe($k3);
$C4->apply_unsafe($l3);
$C4->apply_unsafe($m3);
$i5->apply_unsafe($E2);
$i5->apply_unsafe($F2);
$i5->apply_unsafe($D4);
$i5->apply_unsafe($G2);
$i5->apply_unsafe($E4);
$i5->apply_unsafe($H2);
$i5->apply_unsafe($F4);
$i5->apply_unsafe($I2);
$i5->apply_unsafe($G4);
$i5->apply_unsafe($J2);
$i5->apply_unsafe($H4);
$i5->apply_unsafe($K2);
$i5->apply_unsafe($I4);
$i5->apply_unsafe($L2);
$i5->apply_unsafe($J4);
$i5->apply_unsafe($M2);
$i5->apply_unsafe($K4);
$i5->apply_unsafe($N2);
$i5->apply_unsafe($L4);
$i5->apply_unsafe($O2);
$i5->apply_unsafe($M4);
$i5->apply_unsafe($P2);
$i5->apply_unsafe($N4);
$i5->apply_unsafe($Q2);
$i5->apply_unsafe($O4);
$i5->apply_unsafe($R2);
$i5->apply_unsafe($P4);
$i5->apply_unsafe($S2);
$i5->apply_unsafe($Q4);
$i5->apply_unsafe($T2);
$i5->apply_unsafe($R4);
$i5->apply_unsafe($U2);
$i5->apply_unsafe($J3);
$i5->apply_unsafe($V2);
$i5->apply_unsafe($S4);
$i5->apply_unsafe($W2);
$i5->apply_unsafe($F);
$i5->apply_unsafe($X2);
$i5->apply_unsafe($u);
$i5->apply_unsafe($Y2);
$i5->apply_unsafe($T4);
$i5->apply_unsafe($Z2);
$i5->apply_unsafe($U4);
$i5->apply_unsafe($c3);
$i5->apply_unsafe($V4);
$i5->apply_unsafe($d3);
$i5->apply_unsafe($H3);
$i5->apply_unsafe($e3);
$i5->apply_unsafe($T3);
$i5->apply_unsafe($f3);
$i5->apply_unsafe($W4);
$i5->apply_unsafe($g3);
$i5->apply_unsafe($p3);
$i5->apply_unsafe($h3);
$i5->apply_unsafe($q3);
$i5->apply_unsafe($i3);
$i5->apply_unsafe($X4);
$i5->apply_unsafe($j3);
$i5->apply_unsafe($k3);
$i5->apply_unsafe($l3);
$i5->apply_unsafe($Y4);
$i5->apply_unsafe($m3);
$t5->apply_unsafe($E2);
$t5->apply_unsafe($F2);
$t5->apply_unsafe($G2);
$t5->apply_unsafe($H2);
$t5->apply_unsafe($I2);
$t5->apply_unsafe($J2);
$t5->apply_unsafe($K2);
$t5->apply_unsafe($L2);
$t5->apply_unsafe($M2);
$t5->apply_unsafe($N2);
$t5->apply_unsafe($O2);
$t5->apply_unsafe($P2);
$t5->apply_unsafe($Q2);
$t5->apply_unsafe($R2);
$t5->apply_unsafe($S2);
$t5->apply_unsafe($T2);
$t5->apply_unsafe($R4);
$t5->apply_unsafe($U2);
$t5->apply_unsafe($J3);
$t5->apply_unsafe($V2);
$t5->apply_unsafe($S4);
$t5->apply_unsafe($W2);
$t5->apply_unsafe($X2);
$t5->apply_unsafe($Y2);
$t5->apply_unsafe($Z2);
$t5->apply_unsafe($c3);
$t5->apply_unsafe($d3);
$t5->apply_unsafe($H3);
$t5->apply_unsafe($e3);
$t5->apply_unsafe($T3);
$t5->apply_unsafe($f3);
$t5->apply_unsafe($g3);
$t5->apply_unsafe($p3);
$t5->apply_unsafe($h3);
$t5->apply_unsafe($q3);
$t5->apply_unsafe($i3);
$t5->apply_unsafe($j3);
$t5->apply_unsafe($k3);
$t5->apply_unsafe($l3);
$t5->apply_unsafe($m3);
$F5->apply_unsafe($E2);
$F5->apply_unsafe($F2);
$F5->apply_unsafe($G2);
$F5->apply_unsafe($H2);
$F5->apply_unsafe($I2);
$F5->apply_unsafe($J2);
$F5->apply_unsafe($K2);
$F5->apply_unsafe($L2);
$F5->apply_unsafe($M2);
$F5->apply_unsafe($N2);
$F5->apply_unsafe($O2);
$F5->apply_unsafe($P2);
$F5->apply_unsafe($Q2);
$F5->apply_unsafe($R2);
$F5->apply_unsafe($S2);
$F5->apply_unsafe($T2);
$F5->apply_unsafe($U2);
$F5->apply_unsafe($J3);
$F5->apply_unsafe($V2);
$F5->apply_unsafe($W2);
$F5->apply_unsafe($X2);
$F5->apply_unsafe($Y2);
$F5->apply_unsafe($Z2);
$F5->apply_unsafe($c3);
$F5->apply_unsafe($d3);
$F5->apply_unsafe($e3);
$F5->apply_unsafe($f3);
$F5->apply_unsafe($g3);
$F5->apply_unsafe($p3);
$F5->apply_unsafe($h3);
$F5->apply_unsafe($q3);
$F5->apply_unsafe($i3);
$F5->apply_unsafe($j3);
$F5->apply_unsafe($k3);
$F5->apply_unsafe($l3);
$F5->apply_unsafe($m3);
$P5->apply_unsafe($E2);
$P5->apply_unsafe($F2);
$P5->apply_unsafe($G2);
$P5->apply_unsafe($H2);
$P5->apply_unsafe($I2);
$P5->apply_unsafe($J2);
$P5->apply_unsafe($K2);
$P5->apply_unsafe($L2);
$P5->apply_unsafe($M2);
$P5->apply_unsafe($N2);
$P5->apply_unsafe($O2);
$P5->apply_unsafe($P2);
$P5->apply_unsafe($Q2);
$P5->apply_unsafe($R2);
$P5->apply_unsafe($S2);
$P5->apply_unsafe($T2);
$P5->apply_unsafe($U2);
$P5->apply_unsafe($J3);
$P5->apply_unsafe($V2);
$P5->apply_unsafe($W2);
$P5->apply_unsafe($X2);
$P5->apply_unsafe($Y2);
$P5->apply_unsafe($Z2);
$P5->apply_unsafe($c3);
$P5->apply_unsafe($d3);
$P5->apply_unsafe($e3);
$P5->apply_unsafe($f3);
$P5->apply_unsafe($g3);
$P5->apply_unsafe($p3);
$P5->apply_unsafe($h3);
$P5->apply_unsafe($q3);
$P5->apply_unsafe($i3);
$P5->apply_unsafe($j3);
$P5->apply_unsafe($k3);
$P5->apply_unsafe($l3);
$P5->apply_unsafe($m3);
$W5->apply_unsafe($E2);
$W5->apply_unsafe($F2);
$W5->apply_unsafe($G2);
$W5->apply_unsafe($H2);
$W5->apply_unsafe($I2);
$W5->apply_unsafe($J2);
$W5->apply_unsafe($K2);
$W5->apply_unsafe($L2);
$W5->apply_unsafe($M2);
$W5->apply_unsafe($N2);
$W5->apply_unsafe($O2);
$W5->apply_unsafe($P2);
$W5->apply_unsafe($Q2);
$W5->apply_unsafe($R2);
$W5->apply_unsafe($S2);
$W5->apply_unsafe($T2);
$W5->apply_unsafe($U2);
$W5->apply_unsafe($J3);
$W5->apply_unsafe($V2);
$W5->apply_unsafe($W2);
$W5->apply_unsafe($X2);
$W5->apply_unsafe($Y2);
$W5->apply_unsafe($Z2);
$W5->apply_unsafe($c3);
$W5->apply_unsafe($d3);
$W5->apply_unsafe($e3);
$W5->apply_unsafe($f3);
$W5->apply_unsafe($g3);
$W5->apply_unsafe($p3);
$W5->apply_unsafe($h3);
$W5->apply_unsafe($q3);
$W5->apply_unsafe($i3);
$W5->apply_unsafe($j3);
$W5->apply_unsafe($k3);
$W5->apply_unsafe($l3);
$W5->apply_unsafe($m3);
$f6->apply_unsafe($E2);
$f6->apply_unsafe($F2);
$f6->apply_unsafe($G2);
$f6->apply_unsafe($H2);
$f6->apply_unsafe($I2);
$f6->apply_unsafe($J2);
$f6->apply_unsafe($K2);
$f6->apply_unsafe($L2);
$f6->apply_unsafe($M2);
$f6->apply_unsafe($N2);
$f6->apply_unsafe($O2);
$f6->apply_unsafe($P2);
$f6->apply_unsafe($Q2);
$f6->apply_unsafe($R2);
$f6->apply_unsafe($S2);
$f6->apply_unsafe($T2);
$f6->apply_unsafe($U2);
$f6->apply_unsafe($J3);
$f6->apply_unsafe($V2);
$f6->apply_unsafe($W2);
$f6->apply_unsafe($X2);
$f6->apply_unsafe($Y2);
$f6->apply_unsafe($Z2);
$f6->apply_unsafe($c3);
$f6->apply_unsafe($d3);
$f6->apply_unsafe($e3);
$f6->apply_unsafe($f3);
$f6->apply_unsafe($g3);
$f6->apply_unsafe($p3);
$f6->apply_unsafe($h3);
$f6->apply_unsafe($q3);
$f6->apply_unsafe($i3);
$f6->apply_unsafe($j3);
$f6->apply_unsafe($k3);
$f6->apply_unsafe($l3);
$f6->apply_unsafe($m3);
$m6->apply_unsafe($E2);
$m6->apply_unsafe($F2);
$m6->apply_unsafe($G2);
$m6->apply_unsafe($H2);
$m6->apply_unsafe($I2);
$m6->apply_unsafe($J2);
$m6->apply_unsafe($K2);
$m6->apply_unsafe($L2);
$m6->apply_unsafe($M2);
$m6->apply_unsafe($N2);
$m6->apply_unsafe($O2);
$m6->apply_unsafe($P2);
$m6->apply_unsafe($Q2);
$m6->apply_unsafe($R2);
$m6->apply_unsafe($S2);
$m6->apply_unsafe($T2);
$m6->apply_unsafe($U2);
$m6->apply_unsafe($J3);
$m6->apply_unsafe($V2);
$m6->apply_unsafe($W2);
$m6->apply_unsafe($X2);
$m6->apply_unsafe($Y2);
$m6->apply_unsafe($Z2);
$m6->apply_unsafe($c3);
$m6->apply_unsafe($d3);
$m6->apply_unsafe($e3);
$m6->apply_unsafe($f3);
$m6->apply_unsafe($g3);
$m6->apply_unsafe($p3);
$m6->apply_unsafe($h3);
$m6->apply_unsafe($q3);
$m6->apply_unsafe($i3);
$m6->apply_unsafe($j3);
$m6->apply_unsafe($k3);
$m6->apply_unsafe($l3);
$m6->apply_unsafe($m3);
$C6->apply_unsafe($E2);
$C6->apply_unsafe($F2);
$C6->apply_unsafe($G2);
$C6->apply_unsafe($H2);
$C6->apply_unsafe($I2);
$C6->apply_unsafe($J2);
$C6->apply_unsafe($K2);
$C6->apply_unsafe($L2);
$C6->apply_unsafe($M2);
$C6->apply_unsafe($N2);
$C6->apply_unsafe($O2);
$C6->apply_unsafe($P2);
$C6->apply_unsafe($Q2);
$C6->apply_unsafe($R2);
$C6->apply_unsafe($S2);
$C6->apply_unsafe($T2);
$C6->apply_unsafe($U2);
$C6->apply_unsafe($V2);
$C6->apply_unsafe($W2);
$C6->apply_unsafe($X2);
$C6->apply_unsafe($u);
$C6->apply_unsafe($Y2);
$C6->apply_unsafe($Z2);
$C6->apply_unsafe($c3);
$C6->apply_unsafe($d3);
$C6->apply_unsafe($H3);
$C6->apply_unsafe($e3);
$C6->apply_unsafe($T3);
$C6->apply_unsafe($f3);
$C6->apply_unsafe($g3);
$C6->apply_unsafe($p3);
$C6->apply_unsafe($h3);
$C6->apply_unsafe($i3);
$C6->apply_unsafe($j3);
$C6->apply_unsafe($k3);
$C6->apply_unsafe($l3);
$C6->apply_unsafe($m3);
$J6->apply_unsafe($E2);
$J6->apply_unsafe($F2);
$J6->apply_unsafe($G2);
$J6->apply_unsafe($H2);
$J6->apply_unsafe($I2);
$J6->apply_unsafe($J2);
$J6->apply_unsafe($K2);
$J6->apply_unsafe($L2);
$J6->apply_unsafe($M2);
$J6->apply_unsafe($N2);
$J6->apply_unsafe($O2);
$J6->apply_unsafe($P2);
$J6->apply_unsafe($Q2);
$J6->apply_unsafe($R2);
$J6->apply_unsafe($S2);
$J6->apply_unsafe($T2);
$J6->apply_unsafe($U2);
$J6->apply_unsafe($V2);
$J6->apply_unsafe($W2);
$J6->apply_unsafe($X2);
$J6->apply_unsafe($Y2);
$J6->apply_unsafe($Z2);
$J6->apply_unsafe($c3);
$J6->apply_unsafe($d3);
$J6->apply_unsafe($e3);
$J6->apply_unsafe($f3);
$J6->apply_unsafe($g3);
$J6->apply_unsafe($h3);
$J6->apply_unsafe($i3);
$J6->apply_unsafe($j3);
$J6->apply_unsafe($k3);
$J6->apply_unsafe($l3);
$J6->apply_unsafe($m3);
$r7->apply_unsafe($D4);
$r7->apply_unsafe($F4);
$r7->apply_unsafe($G4);
$r7->apply_unsafe($H4);
$r7->apply_unsafe($I4);
$r7->apply_unsafe($J4);
$r7->apply_unsafe($K4);
$r7->apply_unsafe($L4);
$r7->apply_unsafe($M4);
$r7->apply_unsafe($N4);
$L7->apply_unsafe($D4);
$L7->apply_unsafe($F4);
$L7->apply_unsafe($G4);
$L7->apply_unsafe($H4);
$L7->apply_unsafe($I4);
$L7->apply_unsafe($J4);
$L7->apply_unsafe($K4);
$L7->apply_unsafe($L4);
$L7->apply_unsafe($M4);
$L7->apply_unsafe($N4);
$T7->apply_unsafe($D4);
$T7->apply_unsafe($F4);
$T7->apply_unsafe($G4);
$T7->apply_unsafe($H4);
$T7->apply_unsafe($I4);
$T7->apply_unsafe($J4);
$T7->apply_unsafe($K4);
$T7->apply_unsafe($L4);
$T7->apply_unsafe($M4);
$T7->apply_unsafe($N4);
$d8->apply_unsafe($D4);
$d8->apply_unsafe($F4);
$d8->apply_unsafe($G4);
$d8->apply_unsafe($H4);
$d8->apply_unsafe($I4);
$d8->apply_unsafe($J4);
$d8->apply_unsafe($K4);
$d8->apply_unsafe($L4);
$d8->apply_unsafe($M4);
$d8->apply_unsafe($N4);
$l8->apply_unsafe($D4);
$l8->apply_unsafe($F4);
$l8->apply_unsafe($G4);
$l8->apply_unsafe($H4);
$l8->apply_unsafe($I4);
$l8->apply_unsafe($J4);
$l8->apply_unsafe($K4);
$l8->apply_unsafe($L4);
$l8->apply_unsafe($M4);
$l8->apply_unsafe($N4);
$t8->apply_unsafe($D4);
$t8->apply_unsafe($F4);
$t8->apply_unsafe($G4);
$t8->apply_unsafe($H4);
$t8->apply_unsafe($I4);
$t8->apply_unsafe($J4);
$t8->apply_unsafe($K4);
$t8->apply_unsafe($L4);
$t8->apply_unsafe($M4);
$t8->apply_unsafe($N4);
$I8->apply_unsafe($D4);
$P8->apply_unsafe($D4);
$d9->apply_unsafe($D4);
$C9->apply_unsafe($E4);
$U9->apply_unsafe($F4);
$ga->apply_unsafe($F4);
$za->apply_unsafe($G4);
$Ga->apply_unsafe($G4);
$cb->apply_unsafe($H4);
$jb->apply_unsafe($H4);
$Db->apply_unsafe($H4);
$dc->apply_unsafe($H4);
$lc->apply_unsafe($H4);
$Bc->apply_unsafe($H4);
$Zc->apply_unsafe($I4);
$id->apply_unsafe($I4);
$qd->apply_unsafe($I4);
$Gd->apply_unsafe($I4);
$Rd->apply_unsafe($I4);
$de->apply_unsafe($I4);
$Be->apply_unsafe($J4);
$Je->apply_unsafe($J4);
$Qe->apply_unsafe($J4);
$kf->apply_unsafe($J4);
$Qf->apply_unsafe($Rf);
$dg->apply_unsafe($K4);
$qg->apply_unsafe($K4);
$Wg->apply_unsafe($M4);
$ih->apply_unsafe($M4);
$uh->apply_unsafe($M4);
$Eh->apply_unsafe($M4);
$Uh->apply_unsafe($M4);
$Ci->apply_unsafe($N4);
$Ji->apply_unsafe($N4);
$Xi->apply_unsafe($N4);
$xj->apply_unsafe($O4);
$xj->apply_unsafe($P4);
$xj->apply_unsafe($Q4);
$xj->apply_unsafe($Y4);
$Jj->apply_unsafe($O4);
$Jj->apply_unsafe($P4);
$Jj->apply_unsafe($Q4);
$Jj->apply_unsafe($Y4);
$Zj->apply_unsafe($O4);
$Zj->apply_unsafe($P4);
$Zj->apply_unsafe($Q4);
$vk->apply_unsafe($O4);
$vk->apply_unsafe($P4);
$vk->apply_unsafe($Q4);
$Mk->apply_unsafe($R2);
$Mk->apply_unsafe($S2);
$Mk->apply_unsafe($T2);
$Zk->apply_unsafe($P4);
$ll->apply_unsafe($P4);
$xl->apply_unsafe($P4);
$Ul->apply_unsafe($Q4);
$dm->apply_unsafe($Q4);
$zm->apply_unsafe($J3);
$Tm->apply_unsafe($S4);
$Zm->apply_unsafe($S4);
$wn->apply_unsafe($F);
$Cn->apply_unsafe($F);
$Jn->apply_unsafe($F);
$Sn->apply_unsafe($F);
$vo->apply_unsafe($u);
$Jo->apply_unsafe($u);
$To->apply_unsafe($u);
$dp->apply_unsafe($u);
$yp->apply_unsafe($T4);
$Ip->apply_unsafe($Rf);
$Sp->apply_unsafe($T4);
$Hq->apply_unsafe($T4);
$Pq->apply_unsafe($T4);
$Pq->apply_unsafe($V4);
$pr->apply_unsafe($T4);
$pr->apply_unsafe($V4);
$Fr->apply_unsafe($T4);
$Fr->apply_unsafe($V4);
$Vr->apply_unsafe($T4);
$Is->apply_unsafe($Js);
$ft->apply_unsafe($U4);
$xt->apply_unsafe($U4);
$Gt->apply_unsafe($U4);
$Qt->apply_unsafe($U4);
$hv->apply_unsafe($Js);
$vv->apply_unsafe($V4);
$Ev->apply_unsafe($V4);
$hw->apply_unsafe($H3);
$nw->apply_unsafe($H3);
$uw->apply_unsafe($H3);
$Rw->apply_unsafe($Rf);
$dx->apply_unsafe($T3);
$jx->apply_unsafe($T3);
$Dx->apply_unsafe($W4);
$Px->apply_unsafe($W4);
$Wx->apply_unsafe($W4);
$ni::self=$Oz;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$H;
&$_($d1)for@$H;
&$_($j1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$H;
&$_($D1)for@$w;
&$_($H1)for@$H;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$H;
&$_($f2)for@$H;
&$_($n2)for@$w;
&$_($r2)for@$w;
&$_($v2)for@$H;
&$_($B2)for@$H;
&$_($B3)for@$w;
&$_($E3)for@$w;
&$_($I3)for@$K3;
&$_($N3)for@$w;
&$_($P3)for@$w;
&$_($S3)for@$K3;
&$_($X3)for@$w;
&$_($c4)for@$K3;
&$_($g4)for@$w;
&$_($j4)for@$K3;
&$_($n4)for@$w;
&$_($q4)for@$K3;
&$_($s4)for@$t4;
&$_($w4)for@$w;
&$_($z4)for@$w;
&$_($C4)for@$K3;
&$_($f5)for@$w;
&$_($i5)for@$K3;
&$_($k5)for@$l5;
&$_($q5)for@$w;
&$_($t5)for@$K3;
&$_($v5)for@$w5;
&$_($C5)for@$w;
&$_($F5)for@$K3;
&$_($J5)for@$w;
&$_($M5)for@$w;
&$_($P5)for@$K3;
&$_($T5)for@$w;
&$_($W5)for@$K3;
&$_($c6)for@$w;
&$_($f6)for@$K3;
&$_($j6)for@$w;
&$_($m6)for@$K3;
&$_($o6)for@$p6;
&$_($r6)for@$s6;
&$_($w6)for@$w;
&$_($z6)for@$w;
&$_($C6)for@$K3;
&$_($G6)for@$w;
&$_($J6)for@$K3;
&$_($L6)for@$M6;
&$_($V6)for@$W6;
&$_($c7)for@$W6;
&$_($e7)for@$W6;
&$_($g7)for@$W6;
&$_($o7)for@$w;
&$_($r7)for@$K3;
&$_($w7)for@$w;
&$_($A7)for@$w;
&$_($E7)for@$w;
&$_($I7)for@$w;
&$_($L7)for@$K3;
&$_($Q7)for@$w;
&$_($T7)for@$K3;
&$_($Y7)for@$w;
&$_($d8)for@$K3;
&$_($i8)for@$w;
&$_($l8)for@$K3;
&$_($q8)for@$w;
&$_($t8)for@$K3;
&$_($v8)for@$w8;
&$_($B8)for@$w;
&$_($F8)for@$w;
&$_($I8)for@$K3;
&$_($M8)for@$w;
&$_($P8)for@$K3;
&$_($U8)for@$w;
&$_($Y8)for@$w;
&$_($d9)for@$K3;
&$_($f9)for@$g9;
&$_($n9)for@$W6;
&$_($p9)for@$W6;
&$_($z9)for@$w;
&$_($C9)for@$K3;
&$_($E9)for@$F9;
&$_($K9)for@$W6;
&$_($R9)for@$w;
&$_($U9)for@$K3;
&$_($Y9)for@$w;
&$_($da)for@$w;
&$_($ga)for@$K3;
&$_($ia)for@$ja;
&$_($oa)for@$W6;
&$_($wa)for@$w;
&$_($za)for@$K3;
&$_($Da)for@$w;
&$_($Ga)for@$K3;
&$_($Ia)for@$Ja;
&$_($Oa)for@$W6;
&$_($Xa)for@$w;
&$_($cb)for@$K3;
&$_($gb)for@$w;
&$_($jb)for@$K3;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Db)for@$K3;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($dc)for@$K3;
&$_($ic)for@$w;
&$_($lc)for@$K3;
&$_($qc)for@$w;
&$_($uc)for@$w;
&$_($yc)for@$w;
&$_($Bc)for@$K3;
&$_($Dc)for@$Ec;
&$_($Jc)for@$W6;
&$_($Wc)for@$w;
&$_($Zc)for@$K3;
&$_($fd)for@$w;
&$_($id)for@$K3;
&$_($nd)for@$w;
&$_($qd)for@$K3;
&$_($vd)for@$w;
&$_($zd)for@$w;
&$_($Dd)for@$w;
&$_($Gd)for@$K3;
&$_($Kd)for@$w;
&$_($Od)for@$w;
&$_($Rd)for@$K3;
&$_($Vd)for@$w;
&$_($Yd)for@$w;
&$_($de)for@$K3;
&$_($fe)for@$ge;
&$_($le)for@$W6;
&$_($ye)for@$w;
&$_($Be)for@$K3;
&$_($Ge)for@$w;
&$_($Je)for@$K3;
&$_($Ne)for@$w;
&$_($Qe)for@$K3;
&$_($Ve)for@$w;
&$_($Ye)for@$w;
&$_($ef)for@$w;
&$_($hf)for@$w;
&$_($kf)for@$K3;
&$_($mf)for@$nf;
&$_($sf)for@$W6;
&$_($Cf)for@$w;
&$_($Ff)for@$w;
&$_($Jf)for@$w;
&$_($Nf)for@$w;
&$_($Qf)for@$K3;
&$_($Yf)for@$w;
&$_($dg)for@$K3;
&$_($hg)for@$w;
&$_($kg)for@$w;
&$_($ng)for@$w;
&$_($qg)for@$K3;
&$_($sg)for@$tg;
&$_($yg)for@$W6;
&$_($Pg)for@$w;
&$_($Tg)for@$w;
&$_($Wg)for@$K3;
&$_($ch)for@$w;
&$_($fh)for@$w;
&$_($ih)for@$K3;
&$_($nh)for@$w;
&$_($rh)for@$w;
&$_($uh)for@$K3;
&$_($yh)for@$w;
&$_($Bh)for@$w;
&$_($Eh)for@$K3;
&$_($Ih)for@$w;
&$_($Lh)for@$w;
&$_($Oh)for@$w;
&$_($Rh)for@$w;
&$_($Uh)for@$K3;
&$_($Wh)for@$Xh;
&$_($ei)for@$W6;
&$_($ri)for@$w;
&$_($vi)for@$w;
&$_($zi)for@$w;
&$_($Ci)for@$K3;
&$_($Gi)for@$w;
&$_($Ji)for@$K3;
&$_($Ni)for@$w;
&$_($Ri)for@$w;
&$_($Ui)for@$w;
&$_($Xi)for@$K3;
&$_($Zi)for@$cj;
&$_($hj)for@$W6;
&$_($uj)for@$w;
&$_($xj)for@$K3;
&$_($Cj)for@$w;
&$_($Gj)for@$w;
&$_($Jj)for@$K3;
&$_($Lj)for@$Mj;
&$_($Qj)for@$w;
&$_($Tj)for@$w;
&$_($Wj)for@$w;
&$_($Zj)for@$K3;
&$_($gk)for@$w;
&$_($kk)for@$w;
&$_($ok)for@$w;
&$_($sk)for@$w;
&$_($vk)for@$K3;
&$_($xk)for@$yk;
&$_($Fk)for@$W6;
&$_($Jk)for@$w;
&$_($Mk)for@$K3;
&$_($Ok)for@$W6;
&$_($Wk)for@$w;
&$_($Zk)for@$K3;
&$_($fl)for@$w;
&$_($il)for@$w;
&$_($ll)for@$K3;
&$_($ql)for@$w;
&$_($ul)for@$w;
&$_($xl)for@$K3;
&$_($zl)for@$Al;
&$_($Fl)for@$W6;
&$_($Rl)for@$w;
&$_($Ul)for@$K3;
&$_($Yl)for@$w;
&$_($dm)for@$K3;
&$_($fm)for@$gm;
&$_($lm)for@$W6;
&$_($wm)for@$w;
&$_($zm)for@$K3;
&$_($Bm)for@$Cm;
&$_($Im)for@$W6;
&$_($Qm)for@$w;
&$_($Tm)for@$K3;
&$_($Wm)for@$w;
&$_($Zm)for@$K3;
&$_($dn)for@$en;
&$_($jn)for@$W6;
&$_($tn)for@$w;
&$_($wn)for@$K3;
&$_($zn)for@$w;
&$_($Cn)for@$K3;
&$_($Gn)for@$w;
&$_($Jn)for@$K3;
&$_($Mn)for@$w;
&$_($Pn)for@$w;
&$_($Sn)for@$K3;
&$_($Un)for@$Vn;
&$_($co)for@$W6;
&$_($no)for@$w;
&$_($qo)for@$w;
&$_($so)for@$w;
&$_($vo)for@$K3;
&$_($zo)for@$w;
&$_($Co)for@$w;
&$_($Go)for@$w;
&$_($Jo)for@$K3;
&$_($No)for@$w;
&$_($Qo)for@$w;
&$_($To)for@$K3;
&$_($Yo)for@$w;
&$_($dp)for@$K3;
&$_($fp)for@$gp;
&$_($lp)for@$W6;
&$_($vp)for@$w;
&$_($yp)for@$K3;
&$_($Fp)for@$w;
&$_($Ip)for@$K3;
&$_($Pp)for@$w;
&$_($Sp)for@$K3;
&$_($Xp)for@$w;
&$_($dq)for@$w;
&$_($hq)for@$w;
&$_($lq)for@$w;
&$_($pq)for@$w;
&$_($tq)for@$w;
&$_($xq)for@$w;
&$_($Bq)for@$w;
&$_($Eq)for@$w;
&$_($Hq)for@$K3;
&$_($Mq)for@$w;
&$_($Pq)for@$K3;
&$_($Uq)for@$w;
&$_($Yq)for@$w;
&$_($er)for@$w;
&$_($ir)for@$w;
&$_($mr)for@$w;
&$_($pr)for@$K3;
&$_($ur)for@$w;
&$_($yr)for@$w;
&$_($Cr)for@$w;
&$_($Fr)for@$K3;
&$_($Kr)for@$w;
&$_($Or)for@$w;
&$_($Sr)for@$w;
&$_($Vr)for@$K3;
&$_($Xr)for@$Yr;
&$_($fs)for@$W6;
&$_($ps)for@$w;
&$_($ts)for@$w;
&$_($xs)for@$w;
&$_($Bs)for@$w;
&$_($Fs)for@$w;
&$_($Is)for@$K3;
&$_($Us)for@$w;
&$_($Xs)for@$w;
&$_($ct)for@$w;
&$_($ft)for@$K3;
&$_($jt)for@$w;
&$_($mt)for@$w;
&$_($pt)for@$w;
&$_($st)for@$w;
&$_($ut)for@$w;
&$_($xt)for@$K3;
&$_($At)for@$w;
&$_($Dt)for@$w;
&$_($Gt)for@$K3;
&$_($Kt)for@$w;
&$_($Nt)for@$w;
&$_($Qt)for@$K3;
&$_($St)for@$Tt;
&$_($Yt)for@$W6;
&$_($ku)for@$w;
&$_($ou)for@$w;
&$_($su)for@$w;
&$_($wu)for@$w;
&$_($Au)for@$w;
&$_($Eu)for@$w;
&$_($Iu)for@$w;
&$_($Mu)for@$w;
&$_($Qu)for@$w;
&$_($Uu)for@$w;
&$_($Yu)for@$w;
&$_($ev)for@$w;
&$_($hv)for@$K3;
&$_($sv)for@$w;
&$_($vv)for@$K3;
&$_($yv)for@$w;
&$_($Bv)for@$w;
&$_($Ev)for@$K3;
&$_($Gv)for@$Hv;
&$_($Mv)for@$W6;
&$_($Wv)for@$w;
&$_($Yv)for@$w;
&$_($hw)for@$K3;
&$_($kw)for@$w;
&$_($nw)for@$K3;
&$_($rw)for@$w;
&$_($uw)for@$K3;
&$_($ww)for@$xw;
&$_($Dw)for@$W6;
&$_($Kw)for@$w;
&$_($Ow)for@$w;
&$_($Rw)for@$K3;
&$_($Yw)for@$w;
&$_($dx)for@$K3;
&$_($gx)for@$w;
&$_($jx)for@$K3;
&$_($lx)for@$mx;
&$_($sx)for@$W6;
&$_($Ax)for@$w;
&$_($Dx)for@$K3;
&$_($Ix)for@$w;
&$_($Mx)for@$w;
&$_($Px)for@$K3;
&$_($Tx)for@$w;
&$_($Wx)for@$K3;
&$_($Yx)for@$Zx;
&$_($gy)for@$W6;
&$_($oy)for@$py;
&$_($uy)for@$W6;
&$_($Dy)for@$Ey;
&$_($Jy)for@$W6;
&$_($Ry)for@$Sy;
&$_($oz)for@$pz;
&$_($rz)for@$Sy;
&$_($wz)for@$w;
&$_($Az)for@$w;
&$_($Ez)for@$w;
&$_($Iz)for@$w;
&$_($Mz)for@$w;
&$_($Oz)for@$Pz;
ni->run(@ARGV);
__DATA__
