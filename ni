#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  my ($en) = ni::eval('__FILE__') =~ /eval (\d+)/;
  $$self{eval_number} = ++$en;
  Scalar::Util::weaken(${'lib/fn::evals'}{$en} = $self);
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#assertions#;
$o=[];
$p=q#error#;
$q=undef;
$r=q#outcome#;
$s=q#test#;
$t=q#annotations#;
$u=[];
$v=q#code#;
$w=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$x=q#eval_number#;
$y=q#proto#;
$z=q##;
$A=q#lib/fn#;
$B=bless({$t,$u,$v,$w,$x,500,$y,$z},$A);
$C=q#lib/fn::ctors#;
$D=q#lib/test_case#;
$E=bless({$n,$o,$p,$q,$r,$q,$s,$B},$D);
$F=q#TODO...#;
$G=[$l,$m,$E,$F];
$H=q#classes#;
$I=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$J=[$H,$I,$F];
$K=[$h,$k,$G,$J];
$L=q#name#;
$M=q#/class#;
$N=q#lib/doc#;
$O=bless({$e,$K,$L,$M},$N);
$P=q#lib/doc::ctors#;
$Q=q#ni.doc:/fabric#;
$R=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$S=[$i,$R];
$T=[$S];
$U=q#/fabric#;
$V=bless({$e,$T,$L,$U},$N);
$W=q#ni.doc:/fabric/rmi#;
$X=[];
$Y=q#/fabric/rmi#;
$Z=bless({$e,$X,$L,$Y},$N);
$c1=q#ni.doc:/io#;
$d1=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$e1=[$i,$d1];
$f1=[$e1];
$g1=q#/io#;
$h1=bless({$e,$f1,$L,$g1},$N);
$i1=q#ni.doc:/io/buffer#;
$j1=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$k1=[$f,$j1];
$l1=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$m1=[];
$n1=[];
$o1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$p1=bless({$t,$n1,$v,$o1,$x,504,$y,$z},$A);
$q1=bless({$n,$m1,$p,$q,$r,$q,$s,$p1},$D);
$r1=[$i,$l1,$q1];
$s1=[$k1,$r1];
$t1=q#/io/buffer#;
$u1=bless({$e,$s1,$L,$t1},$N);
$v1=q#ni.doc:/io/cat#;
$w1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$x1=[$f,$w1];
$y1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$z1=[];
$A1=[];
$B1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$C1=bless({$t,$A1,$v,$B1,$x,506,$y,$z},$A);
$D1=bless({$n,$z1,$p,$q,$r,$q,$s,$C1},$D);
$E1=[$i,$y1,$D1];
$F1=[$x1,$E1];
$G1=q#/io/cat#;
$H1=bless({$e,$F1,$L,$G1},$N);
$I1=q#ni.doc:/io/exec#;
$J1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$K1=[$f,$J1];
$L1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$M1=[];
$N1=[];
$O1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now [$out->read_all, $pid->await] == ["hi\\n", 0];#;
$P1=bless({$t,$N1,$v,$O1,$x,508,$y,$z},$A);
$Q1=bless({$n,$M1,$p,$q,$r,$q,$s,$P1},$D);
$R1=[$i,$L1,$Q1];
$S1=[$K1,$R1];
$T1=q#/io/exec#;
$U1=bless({$e,$S1,$L,$T1},$N);
$V1=q#ni.doc:/io/fd#;
$W1=q#
    open my $fh, ...;
    my $fd = ni('ni:/io/fd')->new($fh); \# from perl FH
    my $fd = ni('ni:/io/fd')->new(0);   \# from number
    my $fd = ni('fd:0');                \# same thing
    $fd->nonblock(1)->read($_, 100);
    $fd->be(10);                        \# move FD number
  #;
$X1=[$f,$W1];
$Y1=q#Represents a file descriptor as a child of /io/object (so the usual IO
      methods like into_async are available), and provides some convenience
      functions for things like setting up FDs for child processes. FDs are
      closed when destroyed.#;
$Z1=[];
$c2=[];
$d2=q#my ($r, $w) = POSIX::pipe;
{
  my $fd = ni('ni:/io/fd')->new($r);
}
ni('ni:/io/fd')->new($w)->be($r);   \# fails unless $r was GC-closed#;
$e2=bless({$t,$c2,$v,$d2,$x,510,$y,$z},$A);
$f2=bless({$n,$Z1,$p,$q,$r,$q,$s,$e2},$D);
$g2=[$i,$Y1,$f2];
$h2=[$X1,$g2];
$i2=q#/io/fd#;
$j2=bless({$e,$h2,$L,$i2},$N);
$k2=q#ni.doc:/io/file#;
$l2=q#
    my $f = ni('ni:/io/file')->new('/etc/passwd');
    my $f = ni('file:/etc/passwd');     \# same as above
    $f->into_sync(ni('fd:1'));          \# cat to stdout
  #;
$m2=[$f,$l2];
$n2=q#warning#;
$o2=q#Files overload the -X file test operators, but this feature wasn't
      introduced until Perl 5.12 -- prior versions won't recognize this
      overload. That means that using this overload in ni's base code will
      reduce its portability and cause tests to fail.#;
$p2=[$n2,$o2];
$q2=q#Represents a file that may or may not exist, and stores/constructs file
      descriptors for reading/writing. /io/files are one-shot objects: once
      you've consumed them for reading or written to them, you should destroy
      the object and start over (or close the file) if you want to operate on
      the file further -- put differently, /io/file objects own the FDs they
      create.#;
$r2=[];
$s2=[];
$t2=q#my $ni = ni('file:/dev/zero');
now [$ni->read($_, 8), $_] == [8, "\\0" x 8];#;
$u2=bless({$t,$s2,$v,$t2,$x,512,$y,$z},$A);
$v2=bless({$n,$r2,$p,$q,$r,$q,$s,$u2},$D);
$w2=q#File objects also provide some useful functions like atomic-updating.
      This lets you write a stream slowly into a tempfile, then rename over the
      original once the tempfile is closed. ni uses this to update itself to
      avoid race conditions.#;
$x2=[];
$y2=[];
$z2=q#ni('file:tmp1')->write_all("original contents");
{
  my $updater = ni('file:tmp1')->atomic_update;
  $updater->write_all('foo bar');
  now ni('file:tmp1')->read_all == "original contents";
}
now ni('file:tmp1')->read_all == "foo bar";
ni('file:tmp1')->rm;#;
$A2=bless({$t,$y2,$v,$z2,$x,514,$y,$z},$A);
$B2=bless({$n,$x2,$p,$q,$r,$q,$s,$A2},$D);
$C2=[$i,$q2,$v2,$w2,$B2];
$D2=[$m2,$p2,$C2];
$E2=q#/io/file#;
$F2=bless({$e,$D2,$L,$E2},$N);
$G2=q#ni.doc:/io/file_update_fd#;
$H2=q#A write fd that performs a file rename upon closing.#;
$I2=[$i,$H2];
$J2=[$I2];
$K2=q#/io/file_update_fd#;
$L2=bless({$e,$J2,$L,$K2},$N);
$M2=q#ni.doc:/io/mio#;
$N2=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$O2=[$f,$N2];
$P2=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$Q2=q#

      #;
$R2=[$i,$P2,$Q2];
$S2=[$O2,$R2];
$T2=q#/io/mio#;
$U2=bless({$e,$S2,$L,$T2},$N);
$V2=q#ni.doc:/io/mio_channel#;
$W2=q#
    #;
$X2=[$i,$W2];
$Y2=[$X2];
$Z2=q#/io/mio_channel#;
$c3=bless({$e,$Y2,$L,$Z2},$N);
$d3=q#ni.doc:/io/pid#;
$e3=q#eg#;
$f3=[];
$g3=[];
$h3=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$i3=bless({$t,$g3,$v,$h3,$x,516,$y,$z},$A);
$j3=bless({$n,$f3,$p,$q,$r,$q,$s,$i3},$D);
$k3=[$e3,$j3];
$l3=[];
$m3=[];
$n3=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$o3=bless({$t,$m3,$v,$n3,$x,518,$y,$z},$A);
$p3=bless({$n,$l3,$p,$q,$r,$q,$s,$o3},$D);
$q3=[$e3,$p3];
$r3=[];
$s3=[];
$t3=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$u3=bless({$t,$s3,$v,$t3,$x,520,$y,$z},$A);
$v3=bless({$n,$r3,$p,$q,$r,$q,$s,$u3},$D);
$w3=[$e3,$v3];
$x3=[$k3,$q3,$w3];
$y3=q#/io/pid#;
$z3=bless({$e,$x3,$L,$y3},$N);
$A3=q#ni.doc:/lib#;
$B3=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$C3=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$D3=[$i,$B3,$C3];
$E3=[$D3];
$F3=q#/lib#;
$G3=bless({$e,$E3,$L,$F3},$N);
$H3=q#ni.doc:/lib/doc#;
$I3=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$J3=[$f,$I3];
$K3=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$L3=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$M3=[];
$N3=[];
$O3=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$P3=bless({$t,$N3,$v,$O3,$x,522,$y,$z},$A);
$Q3=bless({$n,$M3,$p,$q,$r,$q,$s,$P3},$D);
$R3=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$S3=[];
$T3=[];
$U3=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = q{return 1};
my $failing_test = q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg $failing_test,
                  q[So there.]);
now scalar($doc->tests) == 2;#;
$V3=bless({$t,$T3,$v,$U3,$x,524,$y,$z},$A);
$W3=bless({$n,$S3,$p,$q,$r,$q,$s,$V3},$D);
$X3=[$i,$K3,$L3,$Q3,$R3,$W3];
$Y3=[$J3,$X3];
$Z3=q#/lib/doc#;
$c4=bless({$e,$Y3,$L,$Z3},$N);
$d4=q#ni.doc:/lib/image#;
$e4=q#
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         \# TODO#;
$f4=[$f,$e4];
$g4=q#Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.#;
$h4=[$i,$g4];
$i4=[$f4,$h4];
$j4=q#/lib/image#;
$k4=bless({$e,$i4,$L,$j4},$N);
$l4=q#ni.doc:/lib/ni#;
$m4=q#my $value = ni->resolve($name);
               my $value = ni($name);   \# alias for ni->resolve($name)
               my $self  = ni;#;
$n4=[$f,$m4];
$o4=q#The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.#;
$p4=[$i,$o4];
$q4=[$n4,$p4];
$r4=q#/lib/ni#;
$s4=bless({$e,$q4,$L,$r4},$N);
$t4=q#ni.doc:/lib/quote_simple#;
$u4=q#A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.#;
$v4=[];
$w4=[];
$x4=q#my $q = ni('ni:/lib/quote_simple')->new;
now $q->quote([1,2,3]) == "[1,2,3]";
now $q->quote({foo => 1, bar => [1, 2]}) == "{q\#bar\#,[1,2],q\#foo\#,1}";#;
$y4=bless({$t,$w4,$v,$x4,$x,526,$y,$z},$A);
$z4=bless({$n,$v4,$p,$q,$r,$q,$s,$y4},$D);
$A4=[$i,$u4,$z4];
$B4=[$A4];
$C4=q#/lib/quote_simple#;
$D4=bless({$e,$B4,$L,$C4},$N);
$E4=q#ni.doc:/lib/slice#;
$F4=q#
    ni('ni:/lib/slice')->new('/lib/foo',
      ctor => fn q{shift->say_hi},
      say_hi => fn q{print "hi from " . shift->name . "\\n"});
    $some_class->add('/lib/foo');#;
$G4=[$f,$F4];
$H4=q#A slice of methods encoding some aspect of an object's behavior. Slices
      are combined using tags and branches, and the set of slices used to
      construct a class must be disjoint except for constructors and
      destructors.#;
$I4=q#Slices are objects that provide an ->apply method, which installs their
      methods + ctors + dtors into a Perl package.#;
$J4=[];
$K4=[];
$L4=q#my $slice = ni('ni:/lib/slice')->new('foo1', foo => fn q{"bar"});
$slice->apply('test::foo1');
now bless({}, 'test::foo1')->foo == 'bar';#;
$M4=bless({$t,$K4,$v,$L4,$x,528,$y,$z},$A);
$N4=bless({$n,$J4,$p,$q,$r,$q,$s,$M4},$D);
$O4=q#Slices automatically do the equivalent of using Perl's "overload" module
      if any methods begin with an open-paren.#;
$P4=q#Classes automatically incorporate some special low-level slices that are
      used by others; one of these is /lib/instantiable.b, which implements
      ->new and ->DESTROY. These methods then call into the lists of
      constructors and destructors implemented when slices are added to a
      package.#;
$Q4=[];
$R4=[];
$S4=q#my $instances = 0;
my $class = ni('ni:/object')->child('test/foo2')
  ->def('test/foo2_init.b',
    instantiate => fn q{+{}},
    ctor => sub {++$instances},
    dtor => sub {--$instances});
now $instances == 0;
{
  my $i1 = $class->new;
  now $instances == 1;
  my $i2 = $class->new;
  now $instances == 2;
}
now $instances == 0;#;
$T4=bless({$t,$R4,$v,$S4,$x,530,$y,$z},$A);
$U4=bless({$n,$Q4,$p,$q,$r,$q,$s,$T4},$D);
$V4=[$i,$H4,$I4,$N4,$O4,$P4,$U4];
$W4=[$G4,$V4];
$X4=q#/lib/slice#;
$Y4=bless({$e,$W4,$L,$X4},$N);
$Z4=q#ni.doc:/semantic#;
$c5=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$d5=[$i,$c5];
$e5=[$d5];
$f5=q#/semantic#;
$g5=bless({$e,$e5,$L,$f5},$N);
$h5=q#ni:/class#;
$i5=q#applied_to#;
$j5=q#class#;
$k5=q#class.c#;
$l5=q#fabric/rmi.c#;
$m5=q#io/buffer.c#;
$n5=q#io/cat.c#;
$o5=q#io/exec.c#;
$p5=q#io/fd.c#;
$q5=q#io/file.c#;
$r5=q#io/file_update_fd.c#;
$s5=q#io/mio.c#;
$t5=q#io/mio_channel.c#;
$u5=q#io/null.c#;
$v5=q#io/object.c#;
$w5=q#io/pid.c#;
$x5=q#io/str.c#;
$y5=q#io/transfer.c#;
$z5=q#io/transfer_async.c#;
$A5=q#io/transfer_sync.c#;
$B5=q#lib/behavior.c#;
$C5=q#lib/branch.c#;
$D5=q#lib/dataslice.c#;
$E5=q#lib/doc.c#;
$F5=q#lib/fn.c#;
$G5=q#lib/image.c#;
$H5=q#lib/ni.c#;
$I5=q#lib/quote_simple.c#;
$J5=q#lib/slice.c#;
$K5=q#lib/tag.c#;
$L5=q#lib/test_assert_eq.c#;
$M5=q#lib/test_assertion.c#;
$N5=q#lib/test_case.c#;
$O5=q#lib/test_value.c#;
$P5=q#metaclass.c#;
$Q5=q#module.c#;
$R5=q#object.c#;
$S5=q#semantic/dimension#;
$T5=q#semantic/dimension.c#;
$U5=q#semantic/task.c#;
$V5={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$P5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$W5=q#slices#;
$X5=q#metaclass#;
$Y5=q#module#;
$Z5={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$c6=q#/module#;
$d6=q#/lib/perlbranch.b#;
$e6={};
$f6=q#ctor#;
$g6=q#dtor#;
$h6=q#methods#;
$i6=q#add#;
$j6=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$k6=bless({$v,$j6,$x,532,$y,$z},$A);
$l6=q#apply#;
$m6=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$n6=bless({$v,$m6,$x,534,$y,$z},$A);
$o6={$i6,$k6,$l6,$n6};
$p6=q#/lib/branch.b#;
$q6=q#lib/slice#;
$r6=bless({$i5,$e6,$f6,$q,$g6,$q,$h6,$o6,$L,$p6},$q6);
$s6=q#lib/branch#;
$t6=q#lib/slice::ctors#;
$u6={};
$v6=q#my $s = shift; ni->def($s->name, $s)#;
$w6=bless({$v,$v6,$x,536,$y,$z},$A);
$x6=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$y6=bless({$v,$x6,$x,538,$y,$z},$A);
$z6={$L,$y6};
$A6=q#/lib/named.b#;
$B6=bless({$i5,$u6,$f6,$w6,$g6,$q,$h6,$z6,$L,$A6},$q6);
$C6=q#lib/tag#;
$D6={};
$E6=q#namespace#;
$F6=q#'ni'#;
$G6=bless({$v,$F6,$x,540,$y,$z},$A);
$H6={$E6,$G6};
$I6=q#/lib/named_in_ni.b#;
$J6=bless({$i5,$D6,$f6,$q,$g6,$q,$h6,$H6,$L,$I6},$q6);
$K6={};
$L6=q#package#;
$M6=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$N6=bless({$v,$M6,$x,542,$y,$z},$A);
$O6={$L6,$N6};
$P6=q#/lib/namespaced.b#;
$Q6=bless({$i5,$K6,$f6,$q,$g6,$q,$h6,$O6,$L,$P6},$q6);
$R6={};
$S6=q#resolve#;
$T6=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$U6=bless({$v,$T6,$x,544,$y,$z},$A);
$V6={$S6,$U6};
$W6=q#/lib/resolver.b#;
$X6=bless({$i5,$R6,$f6,$q,$g6,$q,$h6,$V6,$L,$W6},$q6);
$Y6=[$r6,$B6,$J6,$Q6,$X6];
$Z6=bless({$L,$d6,$W5,$Y6},$C6);
$c7=q#lib/tag::ctors#;
$d7={};
$e7=q#my $s = shift; $s->apply($s->package)#;
$f7=bless({$v,$e7,$x,546,$y,$z},$A);
$g7=q#instantiate#;
$h7=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$i7=bless({$v,$h7,$x,548,$y,$z},$A);
$j7={$g7,$i7};
$k7=q#/lib/class_init.b#;
$l7=bless({$i5,$d7,$f6,$f7,$g6,$q,$h6,$j7,$L,$k7},$q6);
$m7=q#fabric/rmi#;
$n7=q#io/buffer#;
$o7=q#io/cat#;
$p7=q#io/exec#;
$q7=q#io/fd#;
$r7=q#io/file#;
$s7=q#io/file_update_fd#;
$t7=q#io/mio#;
$u7=q#io/mio_channel#;
$v7=q#io/null#;
$w7=q#io/object#;
$x7=q#io/pid#;
$y7=q#io/str#;
$z7=q#io/transfer#;
$A7=q#io/transfer_async#;
$B7=q#io/transfer_sync#;
$C7=q#lib/behavior#;
$D7=q#lib/dataslice#;
$E7=q#lib/image#;
$F7=q#lib/ni#;
$G7=q#lib/quote_simple#;
$H7=q#lib/test_assert_eq#;
$I7=q#lib/test_assertion#;
$J7=q#lib/test_value#;
$K7=q#object#;
$L7=q#semantic/task#;
$M7={$j5,1,$k5,1,$m7,1,$l5,1,$n7,1,$m5,1,$o7,1,$n5,1,$p7,1,$o5,1,$q7,1,$p5,1,$r7,1,$q5,1,$s7,1,$r5,1,$t7,1,$s5,1,$u7,1,$t5,1,$v7,1,$u5,1,$w7,1,$v5,1,$x7,1,$w5,1,$y7,1,$x5,1,$z7,1,$y5,1,$A7,1,$z5,1,$B7,1,$A5,1,$C7,1,$B5,1,$s6,1,$C5,1,$D7,1,$D5,1,$N,1,$E5,1,$A,1,$F5,1,$E7,1,$G5,1,$F7,1,$H5,1,$G7,1,$I5,1,$q6,1,$J5,1,$C6,1,$K5,1,$H7,1,$L5,1,$I7,1,$M5,1,$D,1,$N5,1,$J7,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$K7,1,$R5,1,$S5,1,$T5,1,$L7,1,$U5,1};
$N7=q#/object#;
$O7={};
$P7=q#DESTROY#;
$Q7=q#local $_;
my $self = shift;
defined($_) && $_->($self) for @{ref($self) . '::dtors'};#;
$R7=bless({$v,$Q7,$x,550,$y,$z},$A);
$S7=q#ni 'ni:/' . ref shift#;
$T7=bless({$v,$S7,$x,552,$y,$z},$A);
$U7={$P7,$R7,$j5,$T7};
$V7=q#/lib/instance.b#;
$W7=bless({$i5,$O7,$f6,$q,$g6,$q,$h6,$U7,$L,$V7},$q6);
$X7=[$W7];
$Y7=bless({$i5,$M7,$L,$N7,$W5,$X7},$R5);
$Z7=q#object.c::ctors#;
$c8={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$C7,1,$B5,1,$s6,1,$C5,1,$D7,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$q6,1,$J5,1,$C6,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$d8=q#/lib/behavior#;
$e8={};
$f8=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$g8=bless({$v,$f8,$x,554,$y,$z},$A);
$h8={$e,$g8};
$i8=q#/lib/documentable.b#;
$j8=bless({$i5,$e8,$f6,$q,$g6,$q,$h6,$h8,$L,$i8},$q6);
$k8=[$Y7,$j8];
$l8=bless({$i5,$c8,$L,$d8,$W5,$k8},$B5);
$m8=q#lib/behavior.c::ctors#;
$n8={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$s6,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$o8=q#/lib/definition.b#;
$p8={};
$q8=q#def#;
$r8=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$s8=bless({$v,$r8,$x,556,$y,$z},$A);
$t8={$q8,$s8};
$u8=q#/lib/definition_def.b#;
$v8=bless({$i5,$p8,$f6,$q,$g6,$q,$h6,$t8,$L,$u8},$q6);
$w8={};
$x8=q#ro#;
$y8=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$z8=bless({$v,$y8,$x,558,$y,$z},$A);
$A8=q#rw#;
$B8=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$C8=bless({$v,$B8,$x,560,$y,$z},$A);
$D8={$x8,$z8,$A8,$C8};
$E8=q#/lib/accessor.b#;
$F8=bless({$i5,$w8,$f6,$q,$g6,$q,$h6,$D8,$L,$E8},$q6);
$G8={};
$H8=q#(""#;
$I8=q#shift->name#;
$J8=bless({$v,$I8,$x,562,$y,$z},$A);
$K8={$H8,$J8};
$L8=q#/lib/name_as_string.b#;
$M8=bless({$i5,$G8,$f6,$q,$g6,$q,$h6,$K8,$L,$L8},$q6);
$N8={};
$O8=q#(eq#;
$P8=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$Q8=bless({$v,$P8,$x,564,$y,$z},$A);
$R8={$O8,$Q8};
$S8=q#/lib/ref_eq.b#;
$T8=bless({$i5,$N8,$f6,$q,$g6,$q,$h6,$R8,$L,$S8},$q6);
$U8={};
$V8=q#defdata#;
$W8=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$X8=bless({$v,$W8,$x,566,$y,$z},$A);
$Y8={$V8,$X8};
$Z8=q#/lib/definition_defdata.b#;
$c9=bless({$i5,$U8,$f6,$q,$g6,$q,$h6,$Y8,$L,$Z8},$q6);
$d9=[$v8,$F8,$M8,$T8,$c9];
$e9=bless({$i5,$n8,$L,$o8,$W5,$d9},$s6);
$f9=q#lib/branch::ctors#;
$g9=[$Z6,$l7,$Y7,$l8,$e9];
$h9=bless({$i5,$Z5,$L,$c6,$W5,$g9},$Q5);
$i9=q#module.c::ctors#;
$j9={};
$k9=q#new#;
$l9=q#local $_;
my $class   = shift;
my $package = ref $class ? $class->package : $class;
my $self    = bless &{"$package\\::instantiate"}($class, @_), $package;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$m9=bless({$v,$l9,$x,568,$y,$z},$A);
$n9={$k9,$m9};
$o9=q#/lib/instantiable.b#;
$p9=bless({$i5,$j9,$h6,$n9,$L,$o9},$q6);
$q9={};
$r9=q#child#;
$s9=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$t9=bless({$v,$s9,$x,570,$y,$z},$A);
$u9={$r9,$t9};
$v9=q#/lib/subclass.b#;
$w9=bless({$i5,$q9,$f6,$q,$g6,$q,$h6,$u9,$L,$v9},$q6);
$x9=[$h9,$p9,$l7,$h9,$w9];
$y9=bless({$i5,$V5,$L,$M,$W5,$x9},$k5);
$z9=q#class.c::ctors#;
$A9=q#ni:/class.c#;
$B9={$k5,1,$T5,1};
$C9=q#/class.c#;
$D9={$k5,1,$Q5,1,$T5,1};
$E9=q#/module.c#;
$F9={$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$Q5,1,$R5,1,$T5,1,$U5,1};
$G9=q#/object.c#;
$H9=[$y9];
$I9=bless({$i5,$F9,$L,$G9,$W5,$H9},$X5);
$J9=q#metaclass::ctors#;
$K9={$k5,1,$B5,1,$C5,1,$D5,1,$J5,1,$K5,1,$Q5,1,$T5,1};
$L9=q#/lib/behavior.c#;
$M9=[$I9];
$N9=bless({$i5,$K9,$L,$L9,$W5,$M9},$X5);
$O9=[$I9,$p9,$N9];
$P9=bless({$i5,$D9,$L,$E9,$W5,$O9},$X5);
$Q9=[$P9];
$R9=bless({$i5,$B9,$L,$C9,$W5,$Q9},$X5);
$S9=q#ni:/fabric/rmi#;
$T9={$m7,1};
$U9={};
$V9=[];
$W9=q#my ($class, $io, $quote) = @_;#;
$X9=bless({$t,$V9,$v,$W9,$x,572,$y,$z},$A);
$Y9={$g7,$X9};
$Z9=q#/fabric/rmi_init.b#;
$ca=bless({$i5,$U9,$f6,$q,$g6,$q,$h6,$Y9,$L,$Z9},$q6);
$da=[$Y7,$ca];
$ea=bless({$i5,$T9,$L,$Y,$W5,$da},$l5);
$fa=q#fabric/rmi.c::ctors#;
$ga=q#ni:/fabric/rmi.c#;
$ha={$l5,1};
$ia=q#/fabric/rmi.c#;
$ja=[$I9];
$ka=bless({$i5,$ha,$L,$ia,$W5,$ja},$X5);
$la=q#ni:/fabric/rmi_init.b#;
$ma=q#ni:/io/buffer#;
$na={$n7,1};
$oa={$n7,1,$o7,1,$p7,1,$q7,1,$r7,1,$s7,1,$t7,1,$u7,1,$v7,1,$w7,1,$x7,1,$y7,1};
$pa=q#/io/object#;
$qa={};
$ra=q#(bool#;
$sa=[];
$ta=bless({$t,$sa,$v,1,$x,574,$y,$z},$A);
$ua={$ra,$ta};
$va=q#/io/object_ops.b#;
$wa=bless({$i5,$qa,$f6,$q,$g6,$q,$h6,$ua,$L,$va},$q6);
$xa={};
$ya=q#die#;
$za=[];
$Aa=q#shift; die join " ", @_#;
$Ba=bless({$t,$za,$v,$Aa,$x,576,$y,$z},$A);
$Ca=q#io_check#;
$Da=[];
$Ea=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$Fa=bless({$t,$Da,$v,$Ea,$x,578,$y,$z},$A);
$Ga=q#io_check_defined#;
$Ha=[];
$Ia=q#shift->io_check(sub {defined shift}, @_)#;
$Ja=bless({$t,$Ha,$v,$Ia,$x,580,$y,$z},$A);
$Ka=q#io_check_true#;
$La=[];
$Ma=q#shift->io_check(sub {shift}, @_)#;
$Na=bless({$t,$La,$v,$Ma,$x,582,$y,$z},$A);
$Oa={$ya,$Ba,$Ca,$Fa,$Ga,$Ja,$Ka,$Na};
$Pa=q#/io/object_checks.b#;
$Qa=bless({$i5,$xa,$f6,$q,$g6,$q,$h6,$Oa,$L,$Pa},$q6);
$Ra={};
$Sa=q#(+#;
$Ta=[];
$Ua=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$Va=bless({$t,$Ta,$v,$Ua,$x,584,$y,$z},$A);
$Wa={$Sa,$Va};
$Xa=q#/io/object_constructors.b#;
$Ya=bless({$i5,$Ra,$f6,$q,$g6,$q,$h6,$Wa,$L,$Xa},$q6);
$Za={};
$cb=q#read_all#;
$db=[];
$eb=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$fb=bless({$t,$db,$v,$eb,$x,586,$y,$z},$A);
$gb=q#write_all#;
$hb=[];
$ib=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_sync($self);#;
$jb=bless({$t,$hb,$v,$ib,$x,588,$y,$z},$A);
$kb={$cb,$fb,$gb,$jb};
$lb=q#/io/object_memory.b#;
$mb=bless({$i5,$Za,$f6,$q,$g6,$q,$h6,$kb,$L,$lb},$q6);
$nb={};
$ob=q#connect_sync#;
$pb=[];
$qb=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$rb=bless({$t,$pb,$v,$qb,$x,590,$y,$z},$A);
$sb=q#into_sync#;
$tb=[];
$ub=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$vb=bless({$t,$tb,$v,$ub,$x,592,$y,$z},$A);
$wb={$ob,$rb,$sb,$vb};
$xb=q#/io/object_transfer_sync.b#;
$yb=bless({$i5,$nb,$f6,$q,$g6,$q,$h6,$wb,$L,$xb},$q6);
$zb={};
$Ab=q#connect_async#;
$Bb=[];
$Cb=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$Db=bless({$t,$Bb,$v,$Cb,$x,594,$y,$z},$A);
$Eb=q#into_async#;
$Fb=[];
$Gb=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$Hb=bless({$t,$Fb,$v,$Gb,$x,596,$y,$z},$A);
$Ib={$Ab,$Db,$Eb,$Hb};
$Jb=q#/io/object_transfer_async.b#;
$Kb=bless({$i5,$zb,$f6,$q,$g6,$q,$h6,$Ib,$L,$Jb},$q6);
$Lb=[$Y7,$wa,$Qa,$Ya,$mb,$yb,$Kb,$Kb,$yb];
$Mb=bless({$i5,$oa,$L,$pa,$W5,$Lb},$v5);
$Nb=q#io/object.c::ctors#;
$Ob={};
$Pb=[];
$Qb=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$Rb=bless({$t,$Pb,$v,$Qb,$x,598,$y,$z},$A);
$Sb={$g7,$Rb};
$Tb=q#/io/buffer_init.b#;
$Ub=bless({$i5,$Ob,$f6,$q,$g6,$q,$h6,$Sb,$L,$Tb},$q6);
$Vb={};
$Wb=q#read#;
$Xb=[];
$Yb=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$Zb=bless({$t,$Xb,$v,$Yb,$x,600,$y,$z},$A);
$cc=q#read_capacity#;
$dc=[];
$ec=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$fc=bless({$t,$dc,$v,$ec,$x,602,$y,$z},$A);
$gc=q#write#;
$hc=[];
$ic=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$jc=bless({$t,$hc,$v,$ic,$x,604,$y,$z},$A);
$kc=q#write_capacity#;
$lc=[];
$mc=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$nc=bless({$t,$lc,$v,$mc,$x,606,$y,$z},$A);
$oc={$Wb,$Zb,$cc,$fc,$gc,$jc,$kc,$nc};
$pc=q#/io/buffer_io.b#;
$qc=bless({$i5,$Vb,$f6,$q,$g6,$q,$h6,$oc,$L,$pc},$q6);
$rc=[$Mb,$Ub,$qc];
$sc=bless({$i5,$na,$L,$t1,$W5,$rc},$m5);
$tc=q#io/buffer.c::ctors#;
$uc=q#ni:/io/buffer.c#;
$vc={$m5,1};
$wc=q#/io/buffer.c#;
$xc={$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1};
$yc=q#/io/object.c#;
$zc={};
$Ac=q#def_transfer_method#;
$Bc=[];
$Cc=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$Dc=bless({$t,$Bc,$v,$Cc,$x,608,$y,$z},$A);
$Ec={$Ac,$Dc};
$Fc=q#/io/object.c_transfer_def.b#;
$Gc=bless({$i5,$zc,$f6,$q,$g6,$q,$h6,$Ec,$L,$Fc},$q6);
$Hc=[$I9,$Gc];
$Ic=bless({$i5,$xc,$L,$yc,$W5,$Hc},$X5);
$Jc=[$Ic];
$Kc=bless({$i5,$vc,$L,$wc,$W5,$Jc},$X5);
$Lc=q#ni:/io/buffer_init.b#;
$Mc=q#ni:/io/buffer_io.b#;
$Nc=q#ni:/io/cat#;
$Oc={$o7,1};
$Pc={};
$Qc=[];
$Rc=q#shift; +{fs => [@_]}#;
$Sc=bless({$t,$Qc,$v,$Rc,$x,610,$y,$z},$A);
$Tc={$g7,$Sc};
$Uc=q#/io/cat_init.b#;
$Vc=bless({$i5,$Pc,$f6,$q,$g6,$q,$h6,$Tc,$L,$Uc},$q6);
$Wc={};
$Xc=[];
$Yc=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$Zc=bless({$t,$Xc,$v,$Yc,$x,612,$y,$z},$A);
$cd={$Wb,$Zc};
$dd=q#/io/cat_read.b#;
$ed=bless({$i5,$Wc,$f6,$q,$g6,$q,$h6,$cd,$L,$dd},$q6);
$fd=[$Mb,$Vc,$ed];
$gd=bless({$i5,$Oc,$L,$G1,$W5,$fd},$n5);
$hd=q#io/cat.c::ctors#;
$id=q#ni:/io/cat.c#;
$jd={$n5,1};
$kd=q#/io/cat.c#;
$ld=[$Ic];
$md=bless({$i5,$jd,$L,$kd,$W5,$ld},$X5);
$nd=q#ni:/io/cat_init.b#;
$od=q#ni:/io/cat_read.b#;
$pd=q#ni:/io/exec#;
$qd={$p7,1};
$rd={};
$sd=q#argv#;
$td=[];
$ud=q#shift->{'argv'}#;
$vd=bless({$t,$td,$v,$ud,$x,614,$y,$z},$A);
$wd={$sd,$vd};
$xd=q#/io/exec_ro.b#;
$yd=bless({$i5,$rd,$f6,$q,$g6,$q,$h6,$wd,$L,$xd},$q6);
$zd={};
$Ad=[];
$Bd=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Cd=bless({$t,$Ad,$v,$Bd,$x,616,$y,$z},$A);
$Dd={$g7,$Cd};
$Ed=q#/io/exec_init.b#;
$Fd=bless({$i5,$zd,$f6,$q,$g6,$q,$h6,$Dd,$L,$Ed},$q6);
$Gd={};
$Hd=q#connect#;
$Id=[];
$Jd=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Kd=bless({$t,$Id,$v,$Jd,$x,618,$y,$z},$A);
$Ld=q#in_pipe#;
$Md=[];
$Nd=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Od=bless({$t,$Md,$v,$Nd,$x,620,$y,$z},$A);
$Pd=q#out_pipe#;
$Qd=[];
$Rd=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Sd=bless({$t,$Qd,$v,$Rd,$x,622,$y,$z},$A);
$Td=q#setup_stdio#;
$Ud=[];
$Vd=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Wd=bless({$t,$Ud,$v,$Vd,$x,624,$y,$z},$A);
$Xd={$Hd,$Kd,$Ld,$Od,$Pd,$Sd,$Td,$Wd};
$Yd=q#/io/exec_io_setup.b#;
$Zd=bless({$i5,$Gd,$f6,$q,$g6,$q,$h6,$Xd,$L,$Yd},$q6);
$ce={};
$de=q#binds_fd#;
$ee=[];
$fe=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$ge=bless({$t,$ee,$v,$fe,$x,626,$y,$z},$A);
$he=q#fd#;
$ie=[];
$je=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$ke=bless({$t,$ie,$v,$je,$x,628,$y,$z},$A);
$le=q#stderr#;
$me=[];
$ne=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$oe=bless({$t,$me,$v,$ne,$x,630,$y,$z},$A);
$pe=q#stdin#;
$qe=[];
$re=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$se=bless({$t,$qe,$v,$re,$x,632,$y,$z},$A);
$te=q#stdout#;
$ue=[];
$ve=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$we=bless({$t,$ue,$v,$ve,$x,634,$y,$z},$A);
$xe={$de,$ge,$he,$ke,$le,$oe,$pe,$se,$te,$we};
$ye=q#/io/exec_io_accessors.b#;
$ze=bless({$i5,$ce,$f6,$q,$g6,$q,$h6,$xe,$L,$ye},$q6);
$Ae={};
$Be=q#env#;
$Ce=[];
$De=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Ee=bless({$t,$Ce,$v,$De,$x,636,$y,$z},$A);
$Fe={$Be,$Ee};
$Ge=q#/io/exec_env.b#;
$He=bless({$i5,$Ae,$f6,$q,$g6,$q,$h6,$Fe,$L,$Ge},$q6);
$Ie={};
$Je=q#exec#;
$Ke=[];
$Le=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Me=bless({$t,$Ke,$v,$Le,$x,638,$y,$z},$A);
$Ne=q#fork#;
$Oe=[];
$Pe=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Qe=bless({$t,$Oe,$v,$Pe,$x,640,$y,$z},$A);
$Re=q#move_fds#;
$Se=[];
$Te=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Ue=bless({$t,$Se,$v,$Te,$x,642,$y,$z},$A);
$Ve={$Je,$Me,$Ne,$Qe,$Re,$Ue};
$We=q#/io/exec_fork.b#;
$Xe=bless({$i5,$Ie,$f6,$q,$g6,$q,$h6,$Ve,$L,$We},$q6);
$Ye=[$Mb,$yd,$Fd,$Zd,$ze,$He,$Xe];
$Ze=bless({$i5,$qd,$L,$T1,$W5,$Ye},$o5);
$cf=q#io/exec.c::ctors#;
$df=q#ni:/io/exec.c#;
$ef={$o5,1};
$ff=q#/io/exec.c#;
$gf=[$Ic];
$hf=bless({$i5,$ef,$L,$ff,$W5,$gf},$X5);
$if=q#ni:/io/exec_env.b#;
$jf=q#ni:/io/exec_fork.b#;
$kf=q#ni:/io/exec_init.b#;
$lf=q#ni:/io/exec_io_accessors.b#;
$mf=q#ni:/io/exec_io_setup.b#;
$nf=q#ni:/io/exec_ro.b#;
$of=q#ni:/io/fd#;
$pf={$q7,1};
$qf={};
$rf=[];
$sf=q#shift->{'fd'}#;
$tf=bless({$t,$rf,$v,$sf,$x,644,$y,$z},$A);
$uf={$he,$tf};
$vf=q#/io/fd_readers.b#;
$wf=bless({$i5,$qf,$f6,$q,$g6,$q,$h6,$uf,$L,$vf},$q6);
$xf={};
$yf=[];
$zf=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Af=bless({$t,$yf,$v,$zf,$x,646,$y,$z},$A);
$Bf={$g7,$Af};
$Cf=q#/io/fd_init.b#;
$Df=bless({$i5,$xf,$f6,$q,$g6,$q,$h6,$Bf,$L,$Cf},$q6);
$Ef={};
$Ff=q#be#;
$Gf=[];
$Hf=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$If=bless({$t,$Gf,$v,$Hf,$x,648,$y,$z},$A);
$Jf={$Ff,$If};
$Kf=q#/io/fd_shell.b#;
$Lf=bless({$i5,$Ef,$f6,$q,$g6,$q,$h6,$Jf,$L,$Kf},$q6);
$Mf={};
$Nf=q#cloexec#;
$Of=[];
$Pf=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Qf=bless({$t,$Of,$v,$Pf,$x,650,$y,$z},$A);
$Rf=q#fcntl_flag#;
$Sf=[];
$Tf=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Uf=bless({$t,$Sf,$v,$Tf,$x,652,$y,$z},$A);
$Vf=q#nonblock#;
$Wf=[];
$Xf=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Yf=bless({$t,$Wf,$v,$Xf,$x,654,$y,$z},$A);
$Zf={$Nf,$Qf,$Rf,$Uf,$Vf,$Yf};
$cg=q#/io/fd_fcntl.b#;
$dg=bless({$i5,$Mf,$f6,$q,$g6,$q,$h6,$Zf,$L,$cg},$q6);
$eg={};
$fg=[];
$gg=q#shift->close#;
$hg=bless({$t,$fg,$v,$gg,$x,656,$y,$z},$A);
$ig=q#close#;
$jg=[];
$kg=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd} if defined $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$lg=bless({$t,$jg,$v,$kg,$x,658,$y,$z},$A);
$mg={$ig,$lg};
$ng=q#/io/fd_gc.b#;
$og=bless({$i5,$eg,$f6,$q,$g6,$hg,$h6,$mg,$L,$ng},$q6);
$pg={};
$qg=[];
$rg=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$sg=bless({$t,$qg,$v,$rg,$x,660,$y,$z},$A);
$tg=[];
$ug=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$vg=bless({$t,$tg,$v,$ug,$x,662,$y,$z},$A);
$wg={$Wb,$sg,$gc,$vg};
$xg=q#/io/fd_perlio.b#;
$yg=bless({$i5,$pg,$f6,$q,$g6,$q,$h6,$wg,$L,$xg},$q6);
$zg=[$Mb,$wf,$Df,$Lf,$dg,$og,$yg];
$Ag=bless({$i5,$pf,$L,$i2,$W5,$zg},$p5);
$Bg=q#io/fd.c::ctors#;
$Cg=q#ni:/io/fd.c#;
$Dg={$p5,1};
$Eg=q#/io/fd.c#;
$Fg=[$Ic];
$Gg=bless({$i5,$Dg,$L,$Eg,$W5,$Fg},$X5);
$Hg=q#ni:/io/fd_fcntl.b#;
$Ig=q#ni:/io/fd_gc.b#;
$Jg=q#ni:/io/fd_init.b#;
$Kg=q#ni:/io/fd_perlio.b#;
$Lg=q#ni:/io/fd_readers.b#;
$Mg=q#ni:/io/fd_shell.b#;
$Ng=q#ni:/io/file#;
$Og={$r7,1};
$Pg={};
$Qg=[];
$Rg=q#shift->{'name'}#;
$Sg=bless({$t,$Qg,$v,$Rg,$x,664,$y,$z},$A);
$Tg={$L,$Sg};
$Ug=q#/io/file_readers.b#;
$Vg=bless({$i5,$Pg,$f6,$q,$g6,$q,$h6,$Tg,$L,$Ug},$q6);
$Wg={};
$Xg=q#mode#;
$Yg=[];
$Zg=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$ch=bless({$t,$Yg,$v,$Zg,$x,666,$y,$z},$A);
$dh={$Xg,$ch};
$eh=q#/io/file_accessors.b#;
$fh=bless({$i5,$Wg,$f6,$q,$g6,$q,$h6,$dh,$L,$eh},$q6);
$gh={};
$hh=[];
$ih=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$jh=bless({$t,$hh,$v,$ih,$x,668,$y,$z},$A);
$kh={$g7,$jh};
$lh=q#/io/file_init.b#;
$mh=bless({$i5,$gh,$f6,$q,$g6,$q,$h6,$kh,$L,$lh},$q6);
$nh={};
$oh=q#(-X#;
$ph=[];
$qh=q#my ($self, $test) = @_;
&{"-$test"}($$self{name});#;
$rh=bless({$t,$ph,$v,$qh,$x,670,$y,$z},$A);
$sh=q#mv#;
$th=[];
$uh=q#my ($self, $dest) = @_;
$dest = $dest->name if ref $dest;
$self->io_check_true(*POSIX::rename, $self->name, $dest);
$$self{name} = $dest;
$self;#;
$vh=bless({$t,$th,$v,$uh,$x,672,$y,$z},$A);
$wh=q#rm#;
$xh=[];
$yh=q#my $self = shift;
$self->io_check_true(*POSIX::unlink, $self->name);
$self;#;
$zh=bless({$t,$xh,$v,$yh,$x,674,$y,$z},$A);
$Ah={$oh,$rh,$sh,$vh,$wh,$zh};
$Bh=q#/io/file_fns.b#;
$Ch=bless({$i5,$nh,$f6,$q,$g6,$q,$h6,$Ah,$L,$Bh},$q6);
$Dh={};
$Eh=q#atomic_update#;
$Fh=[];
$Gh=q#my $self = shift;
my $suffix = 0;
++$suffix while -e $self->name . ".$suffix";
ni('ni:/io/file_update_fd')->new(
  $self,
  $self->class->new($self->name . ".$suffix"));#;
$Hh=bless({$t,$Fh,$v,$Gh,$x,676,$y,$z},$A);
$Ih={$Eh,$Hh};
$Jh=q#/io/file_update.b#;
$Kh=bless({$i5,$Dh,$f6,$q,$g6,$q,$h6,$Ih,$L,$Jh},$q6);
$Lh={};
$Mh=[];
$Nh=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Oh=bless({$t,$Mh,$v,$Nh,$x,678,$y,$z},$A);
$Ph=q#r#;
$Qh=[];
$Rh=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Sh=bless({$t,$Qh,$v,$Rh,$x,680,$y,$z},$A);
$Th=[];
$Uh=q#shift->r->read(@_)#;
$Vh=bless({$t,$Th,$v,$Uh,$x,682,$y,$z},$A);
$Wh=q#w#;
$Xh=[];
$Yh=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Zh=bless({$t,$Xh,$v,$Yh,$x,684,$y,$z},$A);
$ci=[];
$di=q#shift->w->write(@_)#;
$ei=bless({$t,$ci,$v,$di,$x,686,$y,$z},$A);
$fi={$ig,$Oh,$Ph,$Sh,$Wb,$Vh,$Wh,$Zh,$gc,$ei};
$gi=q#/io/file_io.b#;
$hi=bless({$i5,$Lh,$f6,$q,$g6,$q,$h6,$fi,$L,$gi},$q6);
$ii=[$Mb,$Vg,$fh,$mh,$Ch,$Kh,$hi];
$ji=bless({$i5,$Og,$L,$E2,$W5,$ii},$q5);
$ki=q#io/file.c::ctors#;
$li=q#ni:/io/file.c#;
$mi={$q5,1};
$ni=q#/io/file.c#;
$oi=[$Ic];
$pi=bless({$i5,$mi,$L,$ni,$W5,$oi},$X5);
$qi=q#ni:/io/file_accessors.b#;
$ri=q#ni:/io/file_fns.b#;
$si=q#ni:/io/file_init.b#;
$ti=q#ni:/io/file_io.b#;
$ui=q#ni:/io/file_readers.b#;
$vi=q#ni:/io/file_update.b#;
$wi=q#ni:/io/file_update_fd#;
$xi={$s7,1};
$yi={};
$zi=[];
$Ai=q#my ($class, $file, $tempfile) = @_;
my $fd = $tempfile->w;
+{writer   => $fd,
  fd       => $fd->fd,
  wfh      => undef,
  tempfile => $tempfile,
  file     => $file};#;
$Bi=bless({$t,$zi,$v,$Ai,$x,688,$y,$z},$A);
$Ci={$g7,$Bi};
$Di=q#/io/file_update_fd_init.b#;
$Ei=bless({$i5,$yi,$f6,$q,$g6,$q,$h6,$Ci,$L,$Di},$q6);
$Fi={};
$Gi=[];
$Hi=bless({$t,$Gi,$v,$gg,$x,690,$y,$z},$A);
$Ii=[];
$Ji=q#my $self = shift;
close $$self{wfh} if $$self{wfh};
$$self{writer} = undef if $$self{writer};
if ($$self{tempfile}) {
  $$self{tempfile}->mv($$self{file}->name);
  $$self{tempfile} = undef;
}
$self;#;
$Ki=bless({$t,$Ii,$v,$Ji,$x,692,$y,$z},$A);
$Li={$ig,$Ki};
$Mi=q#/io/file_update_fd_gc.b#;
$Ni=bless({$i5,$Fi,$f6,$q,$g6,$Hi,$h6,$Li,$L,$Mi},$q6);
$Oi=[$Mb,$wf,$dg,$yg,$Ei,$Ni];
$Pi=bless({$i5,$xi,$L,$K2,$W5,$Oi},$r5);
$Qi=q#io/file_update_fd.c::ctors#;
$Ri=q#ni:/io/file_update_fd.c#;
$Si={$r5,1};
$Ti=q#/io/file_update_fd.c#;
$Ui=[$Ic];
$Vi=bless({$i5,$Si,$L,$Ti,$W5,$Ui},$X5);
$Wi=q#ni:/io/file_update_fd_gc.b#;
$Xi=q#ni:/io/file_update_fd_init.b#;
$Yi=q#ni:/io/mio#;
$Zi={$t7,1};
$cj={};
$dj=q#io#;
$ej=[];
$fj=q#shift->{'io'}#;
$gj=bless({$t,$ej,$v,$fj,$x,694,$y,$z},$A);
$hj=q#packet_size#;
$ij=[];
$jj=q#shift->{'packet_size'}#;
$kj=bless({$t,$ij,$v,$jj,$x,696,$y,$z},$A);
$lj={$dj,$gj,$hj,$kj};
$mj=q#/io/mio_ro.b#;
$nj=bless({$i5,$cj,$f6,$q,$g6,$q,$h6,$lj,$L,$mj},$q6);
$oj={};
$pj=[];
$qj=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$rj=bless({$t,$pj,$v,$qj,$x,698,$y,$z},$A);
$sj={$g7,$rj};
$tj=q#/io/mio_init.b#;
$uj=bless({$i5,$oj,$f6,$q,$g6,$q,$h6,$sj,$L,$tj},$q6);
$vj={};
$wj=q#next_sender#;
$xj=[];
$yj=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$zj=bless({$t,$xj,$v,$yj,$x,700,$y,$z},$A);
$Aj={$wj,$zj};
$Bj=q#/io/mio_rr_scheduler.b#;
$Cj=bless({$i5,$vj,$f6,$q,$g6,$q,$h6,$Aj,$L,$Bj},$q6);
$Dj={};
$Ej=[];
$Fj=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$Gj=bless({$t,$Ej,$v,$Fj,$x,702,$y,$z},$A);
$Hj=[];
$Ij=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$Jj=bless({$t,$Hj,$v,$Ij,$x,704,$y,$z},$A);
$Kj=[];
$Lj=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
\# TODO#;
$Mj=bless({$t,$Kj,$v,$Lj,$x,706,$y,$z},$A);
$Nj={$ig,$Gj,$Wb,$Jj,$gc,$Mj};
$Oj=q#/io/mio_io.b#;
$Pj=bless({$i5,$Dj,$f6,$q,$g6,$q,$h6,$Nj,$L,$Oj},$q6);
$Qj={};
$Rj=q#channel#;
$Sj=[];
$Tj=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$Uj=bless({$t,$Sj,$v,$Tj,$x,708,$y,$z},$A);
$Vj=q#channels#;
$Wj=[];
$Xj=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$Yj=bless({$t,$Wj,$v,$Xj,$x,710,$y,$z},$A);
$Zj=q#unchannel#;
$ck=[];
$dk=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$ek=bless({$t,$ck,$v,$dk,$x,712,$y,$z},$A);
$fk={$Rj,$Uj,$Vj,$Yj,$Zj,$ek};
$gk=q#/io/mio_channel.b#;
$hk=bless({$i5,$Qj,$f6,$q,$g6,$q,$h6,$fk,$L,$gk},$q6);
$ik=[$Mb,$nj,$uj,$Cj,$Pj,$hk];
$jk=bless({$i5,$Zi,$L,$T2,$W5,$ik},$s5);
$kk=q#io/mio.c::ctors#;
$lk=q#ni:/io/mio.c#;
$mk={$s5,1};
$nk=q#/io/mio.c#;
$ok=[$Ic];
$pk=bless({$i5,$mk,$L,$nk,$W5,$ok},$X5);
$qk=q#ni:/io/mio_channel#;
$rk={$u7,1};
$sk={};
$tk=q#capacity#;
$uk=[];
$vk=q#shift->{'capacity'}#;
$wk=bless({$t,$uk,$v,$vk,$x,714,$y,$z},$A);
$xk=q#id#;
$yk=[];
$zk=q#shift->{'id'}#;
$Ak=bless({$t,$yk,$v,$zk,$x,716,$y,$z},$A);
$Bk=q#mio#;
$Ck=[];
$Dk=q#shift->{'mio'}#;
$Ek=bless({$t,$Ck,$v,$Dk,$x,718,$y,$z},$A);
$Fk={$tk,$wk,$xk,$Ak,$Bk,$Ek};
$Gk=q#/io/mio_channel_ro.b#;
$Hk=bless({$i5,$sk,$f6,$q,$g6,$q,$h6,$Fk,$L,$Gk},$q6);
$Ik={};
$Jk=[];
$Kk=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Lk=bless({$t,$Jk,$v,$Kk,$x,720,$y,$z},$A);
$Mk={$g7,$Lk};
$Nk=q#/io/mio_channel_init.b#;
$Ok=bless({$i5,$Ik,$f6,$q,$g6,$q,$h6,$Mk,$L,$Nk},$q6);
$Pk={};
$Qk=[];
$Rk=bless({$t,$Qk,$v,$gg,$x,722,$y,$z},$A);
$Sk={};
$Tk=q#/io/mio_channel_lifecycle.b#;
$Uk=bless({$i5,$Pk,$f6,$q,$g6,$Rk,$h6,$Sk,$L,$Tk},$q6);
$Vk={};
$Wk=[];
$Xk=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$Yk=bless({$t,$Wk,$v,$Xk,$x,724,$y,$z},$A);
$Zk=[];
$cl=q#shift->{read_buffer} ->read(@_)#;
$dl=bless({$t,$Zk,$v,$cl,$x,726,$y,$z},$A);
$el=[];
$fl=q#shift->{write_buffer}->write(@_)#;
$gl=bless({$t,$el,$v,$fl,$x,728,$y,$z},$A);
$hl={$ig,$Yk,$Wb,$dl,$gc,$gl};
$il=q#/io/mio_channel_io.b#;
$jl=bless({$i5,$Vk,$f6,$q,$g6,$q,$h6,$hl,$L,$il},$q6);
$kl=[$Mb,$Hk,$Ok,$Uk,$jl];
$ll=bless({$i5,$rk,$L,$Z2,$W5,$kl},$t5);
$ml=q#io/mio_channel.c::ctors#;
$nl=q#ni:/io/mio_channel.b#;
$ol=q#ni:/io/mio_channel.c#;
$pl={$t5,1};
$ql=q#/io/mio_channel.c#;
$rl=[$Ic];
$sl=bless({$i5,$pl,$L,$ql,$W5,$rl},$X5);
$tl=q#ni:/io/mio_channel_init.b#;
$ul=q#ni:/io/mio_channel_io.b#;
$vl=q#ni:/io/mio_channel_lifecycle.b#;
$wl=q#ni:/io/mio_channel_ro.b#;
$xl=q#ni:/io/mio_init.b#;
$yl=q#ni:/io/mio_io.b#;
$zl=q#ni:/io/mio_ro.b#;
$Al=q#ni:/io/mio_rr_scheduler.b#;
$Bl=q#ni:/io/named_io_fns.b#;
$Cl={};
$Dl=q#fcntl#;
$El=[];
$Fl=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Gl=bless({$t,$El,$v,$Fl,$x,730,$y,$z},$A);
$Hl=[];
$Il=q#CORE::fork#;
$Jl=bless({$t,$Hl,$v,$Il,$x,732,$y,$z},$A);
$Kl=q#open2#;
$Ll=[];
$Ml=q#CORE::open $_[0], $_[1]#;
$Nl=bless({$t,$Ll,$v,$Ml,$x,734,$y,$z},$A);
$Ol=q#waitpid#;
$Pl=[];
$Ql=q#CORE::waitpid $_[0], $_[1]#;
$Rl=bless({$t,$Pl,$v,$Ql,$x,736,$y,$z},$A);
$Sl={$Dl,$Gl,$Ne,$Jl,$Kl,$Nl,$Ol,$Rl};
$Tl=q#/io/named_io_fns.b#;
$Ul=bless({$i5,$Cl,$f6,$q,$g6,$q,$h6,$Sl,$L,$Tl},$q6);
$Vl=q#main#;
$Wl=q#ni:/io/null#;
$Xl={$v7,1};
$Yl=q#/io/null#;
$Zl={};
$cm=[];
$dm=q#+{fd => undef}#;
$em=bless({$t,$cm,$v,$dm,$x,738,$y,$z},$A);
$fm={$g7,$em};
$gm=q#/io/null_init.b#;
$hm=bless({$i5,$Zl,$f6,$q,$g6,$q,$h6,$fm,$L,$gm},$q6);
$im={};
$jm=[];
$km=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$lm=bless({$t,$jm,$v,$km,$x,740,$y,$z},$A);
$mm=[];
$nm=q#shift->fd->read(@_)#;
$om=bless({$t,$mm,$v,$nm,$x,742,$y,$z},$A);
$pm=[];
$qm=q#shift->fd->write(@_)#;
$rm=bless({$t,$pm,$v,$qm,$x,744,$y,$z},$A);
$sm={$he,$lm,$Wb,$om,$gc,$rm};
$tm=q#/io/null_io.b#;
$um=bless({$i5,$im,$f6,$q,$g6,$q,$h6,$sm,$L,$tm},$q6);
$vm=[$Mb,$hm,$um];
$wm=bless({$i5,$Xl,$L,$Yl,$W5,$vm},$u5);
$xm=q#io/null.c::ctors#;
$ym=q#ni:/io/null.c#;
$zm={$u5,1};
$Am=q#/io/null.c#;
$Bm=[$Ic];
$Cm=bless({$i5,$zm,$L,$Am,$W5,$Bm},$X5);
$Dm=q#ni:/io/null_init.b#;
$Em=q#ni:/io/null_io.b#;
$Fm=q#ni:/io/object#;
$Gm=q#ni:/io/object.c#;
$Hm=q#ni:/io/object.c_transfer_def.b#;
$Im=q#ni:/io/object_checks.b#;
$Jm=q#ni:/io/object_constructors.b#;
$Km=q#ni:/io/object_memory.b#;
$Lm=q#ni:/io/object_ops.b#;
$Mm=q#ni:/io/object_transfer_async.b#;
$Nm=q#ni:/io/object_transfer_sync.b#;
$Om=q#ni:/io/pid#;
$Pm={$x7,1};
$Qm={};
$Rm=q#pid#;
$Sm=[];
$Tm=q#shift->{'pid'}#;
$Um=bless({$t,$Sm,$v,$Tm,$x,746,$y,$z},$A);
$Vm=q#status#;
$Wm=[];
$Xm=q#shift->{'status'}#;
$Ym=bless({$t,$Wm,$v,$Xm,$x,748,$y,$z},$A);
$Zm={$Rm,$Um,$Vm,$Ym};
$cn=q#/io/pid_readers.b#;
$dn=bless({$i5,$Qm,$f6,$q,$g6,$q,$h6,$Zm,$L,$cn},$q6);
$en={};
$fn=[];
$gn=q#shift->await#;
$hn=bless({$t,$fn,$v,$gn,$x,750,$y,$z},$A);
$in=[];
$jn=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$kn=bless({$t,$in,$v,$jn,$x,752,$y,$z},$A);
$ln={$g7,$kn};
$mn=q#/io/pid_init.b#;
$nn=bless({$i5,$en,$f6,$q,$g6,$hn,$h6,$ln,$L,$mn},$q6);
$on={};
$pn=q#await#;
$qn=[];
$rn=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$sn=bless({$t,$qn,$v,$rn,$x,754,$y,$z},$A);
$tn=q#running#;
$un=[];
$vn=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$wn=bless({$t,$un,$v,$vn,$x,756,$y,$z},$A);
$xn={$pn,$sn,$tn,$wn};
$yn=q#/io/pid_wait.b#;
$zn=bless({$i5,$on,$f6,$q,$g6,$q,$h6,$xn,$L,$yn},$q6);
$An={};
$Bn=[];
$Cn=q#shift->stdout->read(@_)#;
$Dn=bless({$t,$Bn,$v,$Cn,$x,758,$y,$z},$A);
$En=[];
$Fn=q#shift->stdin->write(@_)#;
$Gn=bless({$t,$En,$v,$Fn,$x,760,$y,$z},$A);
$Hn={$Wb,$Dn,$gc,$Gn};
$In=q#/io/pid_io.b#;
$Jn=bless({$i5,$An,$f6,$q,$g6,$q,$h6,$Hn,$L,$In},$q6);
$Kn={};
$Ln=[];
$Mn=q#$_[0]->{external_fds}{$_[1]}#;
$Nn=bless({$t,$Ln,$v,$Mn,$x,762,$y,$z},$A);
$On=[];
$Pn=q#shift->fd(2)#;
$Qn=bless({$t,$On,$v,$Pn,$x,764,$y,$z},$A);
$Rn=[];
$Sn=q#shift->fd(0)#;
$Tn=bless({$t,$Rn,$v,$Sn,$x,766,$y,$z},$A);
$Un=[];
$Vn=q#shift->fd(1)#;
$Wn=bless({$t,$Un,$v,$Vn,$x,768,$y,$z},$A);
$Xn={$he,$Nn,$le,$Qn,$pe,$Tn,$te,$Wn};
$Yn=q#/io/pid_accessors.b#;
$Zn=bless({$i5,$Kn,$f6,$q,$g6,$q,$h6,$Xn,$L,$Yn},$q6);
$co=[$Mb,$dn,$nn,$zn,$Jn,$Zn];
$do=bless({$i5,$Pm,$L,$y3,$W5,$co},$w5);
$eo=q#io/pid.c::ctors#;
$fo=q#ni:/io/pid.c#;
$go={$w5,1};
$ho=q#/io/pid.c#;
$io=[$Ic];
$jo=bless({$i5,$go,$L,$ho,$W5,$io},$X5);
$ko=q#ni:/io/pid_accessors.b#;
$lo=q#ni:/io/pid_init.b#;
$mo=q#ni:/io/pid_io.b#;
$no=q#ni:/io/pid_readers.b#;
$oo=q#ni:/io/pid_wait.b#;
$po=q#ni:/io/str#;
$qo={$y7,1};
$ro=q#/io/str#;
$so={};
$to=q#data#;
$uo=[];
$vo=q#shift->{'data'}#;
$wo=bless({$t,$uo,$v,$vo,$x,770,$y,$z},$A);
$xo=q#end#;
$yo=[];
$zo=q#shift->{'end'}#;
$Ao=bless({$t,$yo,$v,$zo,$x,772,$y,$z},$A);
$Bo=q#start#;
$Co=[];
$Do=q#shift->{'start'}#;
$Eo=bless({$t,$Co,$v,$Do,$x,774,$y,$z},$A);
$Fo={$to,$wo,$xo,$Ao,$Bo,$Eo};
$Go=q#/io/str_ro.b#;
$Ho=bless({$i5,$so,$f6,$q,$g6,$q,$h6,$Fo,$L,$Go},$q6);
$Io={};
$Jo=[];
$Ko=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Lo=bless({$t,$Jo,$v,$Ko,$x,776,$y,$z},$A);
$Mo={$g7,$Lo};
$No=q#/io/str_init.b#;
$Oo=bless({$i5,$Io,$f6,$q,$g6,$q,$h6,$Mo,$L,$No},$q6);
$Po={};
$Qo=[];
$Ro=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$So=bless({$t,$Qo,$v,$Ro,$x,778,$y,$z},$A);
$To=q#remaining#;
$Uo=[];
$Vo=q#my $self = shift; $$self{end} - $$self{start}#;
$Wo=bless({$t,$Uo,$v,$Vo,$x,780,$y,$z},$A);
$Xo=[];
$Yo=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Zo=bless({$t,$Xo,$v,$Yo,$x,782,$y,$z},$A);
$cp={$Wb,$So,$To,$Wo,$gc,$Zo};
$dp=q#/io/str_io.b#;
$ep=bless({$i5,$Po,$f6,$q,$g6,$q,$h6,$cp,$L,$dp},$q6);
$fp=[$Mb,$Ho,$Oo,$ep];
$gp=bless({$i5,$qo,$L,$ro,$W5,$fp},$x5);
$hp=q#io/str.c::ctors#;
$ip=q#ni:/io/str.c#;
$jp={$x5,1};
$kp=q#/io/str.c#;
$lp=[$Ic];
$mp=bless({$i5,$jp,$L,$kp,$W5,$lp},$X5);
$np=q#ni:/io/str_init.b#;
$op=q#ni:/io/str_io.b#;
$pp=q#ni:/io/str_ro.b#;
$qp=q#ni:/io/transfer#;
$rp={$z7,1,$A7,1,$B7,1};
$sp=q#/io/transfer#;
$tp={$z7,1,$A7,1,$B7,1,$L7,1};
$up=q#/semantic/task#;
$vp={};
$wp=[];
$xp=q#shift->{'outcome'}#;
$yp=bless({$t,$wp,$v,$xp,$x,784,$y,$z},$A);
$zp={$r,$yp};
$Ap=q#/semantic/task_ro.b#;
$Bp=bless({$i5,$vp,$f6,$q,$g6,$q,$h6,$zp,$L,$Ap},$q6);
$Cp={};
$Dp=q#failure#;
$Ep=[];
$Fp=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Gp=bless({$t,$Ep,$v,$Fp,$x,786,$y,$z},$A);
$Hp=q#success#;
$Ip=[];
$Jp=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Kp=bless({$t,$Ip,$v,$Jp,$x,788,$y,$z},$A);
$Lp={$Dp,$Gp,$Hp,$Kp};
$Mp=q#/semantic/task_outcome.b#;
$Np=bless({$i5,$Cp,$f6,$q,$g6,$q,$h6,$Lp,$L,$Mp},$q6);
$Op=[$Y7,$Bp,$Np];
$Pp=bless({$i5,$tp,$L,$up,$W5,$Op},$U5);
$Qp=q#semantic/task.c::ctors#;
$Rp={};
$Sp=[];
$Tp=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Up=bless({$t,$Sp,$v,$Tp,$x,790,$y,$z},$A);
$Vp=[];
$Wp=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Xp=bless({$t,$Vp,$v,$Wp,$x,792,$y,$z},$A);
$Yp=[];
$Zp=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$cq=bless({$t,$Yp,$v,$Zp,$x,794,$y,$z},$A);
$dq={$Wb,$Xp,$gc,$cq};
$eq=q#/io/transfer_io_interop.b#;
$fq=bless({$i5,$Rp,$f6,$Up,$g6,$q,$h6,$dq,$L,$eq},$q6);
$gq={};
$hq=q#pressure#;
$iq=[];
$jq=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$kq=bless({$t,$iq,$v,$jq,$x,796,$y,$z},$A);
$lq=q#read_limit_throughput#;
$mq=[];
$nq=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$oq=bless({$t,$mq,$v,$nq,$x,798,$y,$z},$A);
$pq=q#throughput#;
$qq=[];
$rq=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$sq=bless({$t,$qq,$v,$rq,$x,800,$y,$z},$A);
$tq=q#write_limit_throughput#;
$uq=[];
$vq=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$wq=bless({$t,$uq,$v,$vq,$x,802,$y,$z},$A);
$xq={$hq,$kq,$lq,$oq,$pq,$sq,$tq,$wq};
$yq=q#/io/transfer_io_measurement.b#;
$zq=bless({$i5,$gq,$f6,$q,$g6,$q,$h6,$xq,$L,$yq},$q6);
$Aq=[$Pp,$fq,$zq];
$Bq=bless({$i5,$rp,$L,$sp,$W5,$Aq},$y5);
$Cq=q#io/transfer.c::ctors#;
$Dq=q#ni:/io/transfer.c#;
$Eq={$y5,1,$z5,1,$A5,1};
$Fq=q#/io/transfer.c#;
$Gq={$y5,1,$z5,1,$A5,1,$U5,1};
$Hq=q#/semantic/task.c#;
$Iq=[$I9];
$Jq=bless({$i5,$Gq,$L,$Hq,$W5,$Iq},$X5);
$Kq={};
$Lq=[];
$Mq=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$Nq=bless({$t,$Lq,$v,$Mq,$x,806,$y,$z},$A);
$Oq={};
$Pq=q#/io/transfer.c_into.b#;
$Qq=bless({$i5,$Kq,$f6,$Nq,$g6,$q,$h6,$Oq,$L,$Pq},$q6);
$Rq=[$Jq,$Qq];
$Sq=bless({$i5,$Eq,$L,$Fq,$W5,$Rq},$X5);
$Tq=q#ni:/io/transfer.c_into.b#;
$Uq=q#ni:/io/transfer_async#;
$Vq={$A7,1};
$Wq=q#/io/transfer_async#;
$Xq={};
$Yq=q#dest_io#;
$Zq=[];
$cr=q#shift->{'dest_io'}#;
$dr=bless({$t,$Zq,$v,$cr,$x,808,$y,$z},$A);
$er=[];
$fr=bless({$t,$er,$v,$zk,$x,810,$y,$z},$A);
$gr=q#source_io#;
$hr=[];
$ir=q#shift->{'source_io'}#;
$jr=bless({$t,$hr,$v,$ir,$x,812,$y,$z},$A);
$kr={$Yq,$dr,$xk,$fr,$gr,$jr};
$lr=q#/io/transfer_async_ro.b#;
$mr=bless({$i5,$Xq,$f6,$q,$g6,$q,$h6,$kr,$L,$lr},$q6);
$nr={};
$or=[];
$pr=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$qr=bless({$t,$or,$v,$pr,$x,814,$y,$z},$A);
$rr={$g7,$qr};
$sr=q#/io/transfer_async_init.b#;
$tr=bless({$i5,$nr,$f6,$q,$g6,$q,$h6,$rr,$L,$sr},$q6);
$ur={};
$vr=[];
$wr=q#ni('ni:/io/transfer_async')->track(shift)#;
$xr=bless({$t,$vr,$v,$wr,$x,816,$y,$z},$A);
$yr=[];
$zr=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$Ar=bless({$t,$yr,$v,$zr,$x,818,$y,$z},$A);
$Br={};
$Cr=q#/io/transfer_async_lifecycle.b#;
$Dr=bless({$i5,$ur,$f6,$xr,$g6,$Ar,$h6,$Br,$L,$Cr},$q6);
$Er={};
$Fr=q#run#;
$Gr=[];
$Hr=q#shift#;
$Ir=bless({$t,$Gr,$v,$Hr,$x,820,$y,$z},$A);
$Jr=q#run_async#;
$Kr=[];
$Lr=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Mr=bless({$t,$Kr,$v,$Lr,$x,822,$y,$z},$A);
$Nr={$Fr,$Ir,$Jr,$Mr};
$Or=q#/io/transfer_async_run.b#;
$Pr=bless({$i5,$Er,$f6,$q,$g6,$q,$h6,$Nr,$L,$Or},$q6);
$Qr=[$Bq,$mr,$tr,$Dr,$Pr];
$Rr=q#tracked_transfers#;
$Sr={};
$Tr=q#transfer_id#;
$Ur=bless({$i5,$Vq,$L,$Wq,$W5,$Qr,$Rr,$Sr,$Tr,0},$z5);
$Vr=q#io/transfer_async.c::ctors#;
$Wr=q#ni:/io/transfer_async.c#;
$Xr={$z5,1};
$Yr=q#/io/transfer_async.c#;
$Zr={};
$cs=[];
$ds=q#my $self = shift;
$$self{tracked_transfers} = {};
$$self{transfer_id}       = 0;#;
$es=bless({$t,$cs,$v,$ds,$x,832,$y,$z},$A);
$fs=q#new_id#;
$gs=[];
$hs=q#++shift->{transfer_id}#;
$is=bless({$t,$gs,$v,$hs,$x,834,$y,$z},$A);
$js=q#track#;
$ks=[];
$ls=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$ms=bless({$t,$ks,$v,$ls,$x,836,$y,$z},$A);
$ns=q#untrack#;
$os=[];
$ps=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$qs=bless({$t,$os,$v,$ps,$x,838,$y,$z},$A);
$rs={$fs,$is,$js,$ms,$ns,$qs};
$ss=q#/io/transfer_async.c_tracker.b#;
$ts=bless({$i5,$Zr,$f6,$es,$g6,$q,$h6,$rs,$L,$ss},$q6);
$us=[$Sq,$ts];
$vs=bless({$i5,$Xr,$L,$Yr,$W5,$us},$X5);
$ws=q#ni:/io/transfer_async.c_tracker.b#;
$xs=q#ni:/io/transfer_async_init.b#;
$ys=q#ni:/io/transfer_async_lifecycle.b#;
$zs=q#ni:/io/transfer_async_ro.b#;
$As=q#ni:/io/transfer_async_run.b#;
$Bs=q#ni:/io/transfer_io_interop.b#;
$Cs=q#ni:/io/transfer_io_measurement.b#;
$Ds=q#ni:/io/transfer_sync#;
$Es={$B7,1};
$Fs=q#/io/transfer_sync#;
$Gs={};
$Hs=[];
$Is=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Js=bless({$t,$Hs,$v,$Is,$x,840,$y,$z},$A);
$Ks={$g7,$Js};
$Ls=q#/io/transfer_sync_init.b#;
$Ms=bless({$i5,$Gs,$f6,$q,$g6,$q,$h6,$Ks,$L,$Ls},$q6);
$Ns={};
$Os=[];
$Ps=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Qs=bless({$t,$Os,$v,$Ps,$x,842,$y,$z},$A);
$Rs={$Fr,$Qs};
$Ss=q#/io/transfer_sync_run.b#;
$Ts=bless({$i5,$Ns,$f6,$q,$g6,$q,$h6,$Rs,$L,$Ss},$q6);
$Us=[$Bq,$Ms,$Ts];
$Vs=bless({$i5,$Es,$L,$Fs,$W5,$Us},$A5);
$Ws=q#io/transfer_sync.c::ctors#;
$Xs=q#ni:/io/transfer_sync.c#;
$Ys={$A5,1};
$Zs=q#/io/transfer_sync.c#;
$ct=[$Sq];
$dt=bless({$i5,$Ys,$L,$Zs,$W5,$ct},$X5);
$et=q#ni:/io/transfer_sync_init.b#;
$ft=q#ni:/io/transfer_sync_run.b#;
$gt=q#ni:/lib/accessor.b#;
$ht=q#ni:/lib/behavior#;
$it=q#ni:/lib/behavior.c#;
$jt=q#ni:/lib/branch#;
$kt={$s6,1};
$lt=q#/lib/branch#;
$mt={};
$nt=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$ot=bless({$v,$nt,$x,848,$y,$z},$A);
$pt={$g7,$ot};
$qt=q#/lib/branch_init.b#;
$rt=bless({$i5,$mt,$f6,$q,$g6,$q,$h6,$pt,$L,$qt},$q6);
$st=[$l8,$B6,$r6,$rt,$e9];
$tt=bless({$i5,$kt,$L,$lt,$W5,$st},$C5);
$ut=q#lib/branch.c::ctors#;
$vt=q#ni:/lib/branch.b#;
$wt=q#ni:/lib/branch.c#;
$xt={$C5,1};
$yt=q#/lib/branch.c#;
$zt=[$N9];
$At=bless({$i5,$xt,$L,$yt,$W5,$zt},$X5);
$Bt=q#ni:/lib/branch_init.b#;
$Ct=q#ni:/lib/class_init.b#;
$Dt=q#ni:/lib/dataslice#;
$Et={$D7,1};
$Ft=q#/lib/dataslice#;
$Gt={};
$Ht=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$It=bless({$v,$Ht,$x,850,$y,$z},$A);
$Jt={$g7,$It};
$Kt=q#/lib/dataslice_init.b#;
$Lt=bless({$i5,$Gt,$f6,$q,$g6,$q,$h6,$Jt,$L,$Kt},$q6);
$Mt={};
$Nt=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Ot=bless({$v,$Nt,$x,852,$y,$z},$A);
$Pt={$l6,$Ot};
$Qt=q#/lib/dataslice_apply.b#;
$Rt=bless({$i5,$Mt,$f6,$q,$g6,$q,$h6,$Pt,$L,$Qt},$q6);
$St=[$l8,$Lt,$Rt];
$Tt=bless({$i5,$Et,$L,$Ft,$W5,$St},$D5);
$Ut=q#lib/dataslice.c::ctors#;
$Vt=q#ni:/lib/dataslice.c#;
$Wt={$D5,1};
$Xt=q#/lib/dataslice.c#;
$Yt=[$N9];
$Zt=bless({$i5,$Wt,$L,$Xt,$W5,$Yt},$X5);
$cu=q#ni:/lib/dataslice_apply.b#;
$du=q#ni:/lib/dataslice_init.b#;
$eu=q#ni:/lib/definition.b#;
$fu=q#ni:/lib/definition_def.b#;
$gu=q#ni:/lib/definition_defdata.b#;
$hu=q#ni:/lib/doc#;
$iu={$N,1};
$ju={};
$ku=q#shift; +{name => shift, doc => []}#;
$lu=bless({$v,$ku,$x,854,$y,$z},$A);
$mu={$g7,$lu};
$nu=q#/lib/doc_init.b#;
$ou=bless({$i5,$ju,$f6,$q,$g6,$q,$h6,$mu,$L,$nu},$q6);
$pu={};
$qu=q#'ni.doc'#;
$ru=bless({$v,$qu,$x,856,$y,$z},$A);
$su={$E6,$ru};
$tu=q#/lib/doc_namespace.b#;
$uu=bless({$i5,$pu,$f6,$q,$g6,$q,$h6,$su,$L,$tu},$q6);
$vu={};
$wu=q#AUTOLOAD#;
$xu=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$yu=bless({$v,$xu,$x,858,$y,$z},$A);
$zu={$wu,$yu};
$Au=q#/lib/doc_define.b#;
$Bu=bless({$i5,$vu,$f6,$q,$g6,$q,$h6,$zu,$L,$Au},$q6);
$Cu={};
$Du=q#shift->referent#;
$Eu=bless({$v,$Du,$x,860,$y,$z},$A);
$Fu=q#referent#;
$Gu=q#ni 'ni:' . shift->{name}#;
$Hu=bless({$v,$Gu,$x,862,$y,$z},$A);
$Iu={$xo,$Eu,$Fu,$Hu};
$Ju=q#/lib/doc_end.b#;
$Ku=bless({$i5,$Cu,$f6,$q,$g6,$q,$h6,$Iu,$L,$Ju},$q6);
$Lu={};
$Mu=q#my $self = shift;
push @{$$self{doc}}, [eg => eg($_)] for @_;
$self;#;
$Nu=bless({$v,$Mu,$x,864,$y,$z},$A);
$Ou=q#linearized#;
$Pu=q#map @$_, @{shift->{doc}}#;
$Qu=bless({$v,$Pu,$x,866,$y,$z},$A);
$Ru=q#tests#;
$Su=q#my $self = shift;
grep ref($_) eq 'lib/test_case', $self->linearized;#;
$Tu=bless({$v,$Su,$x,868,$y,$z},$A);
$Uu={$e3,$Nu,$Ou,$Qu,$Ru,$Tu};
$Vu=q#/lib/doc_test.b#;
$Wu=bless({$i5,$Lu,$f6,$q,$g6,$q,$h6,$Uu,$L,$Vu},$q6);
$Xu=[$Y7,$B6,$ou,$uu,$Bu,$Ku,$Wu];
$Yu=bless({$i5,$iu,$L,$Z3,$W5,$Xu},$E5);
$Zu=q#lib/doc.c::ctors#;
$cv=q#ni:/lib/doc.c#;
$dv={$E5,1};
$ev=q#/lib/doc.c#;
$fv=[$I9];
$gv=bless({$i5,$dv,$L,$ev,$W5,$fv},$X5);
$hv=q#ni:/lib/doc_define.b#;
$iv=q#ni:/lib/doc_end.b#;
$jv=q#ni:/lib/doc_init.b#;
$kv=q#ni:/lib/doc_namespace.b#;
$lv=q#ni:/lib/doc_test.b#;
$mv=q#ni:/lib/documentable.b#;
$nv=q#ni:/lib/fn#;
$ov={$A,1};
$pv=q#/lib/fn#;
$qv={};
$rv=q#shift->compile#;
$sv=bless({$v,$rv,$x,870,$y,$z},$A);
$tv=q#my $self = shift;
delete ${'lib/fn::evals'}{$$self{eval_number}}
  if defined $$self{eval_number};#;
$uv=bless({$v,$tv,$x,872,$y,$z},$A);
$vv=q#compile#;
$wv=q#local $@;
my $self = shift;
$$self{proto} ||= '';
my $code = "sub $$self{proto} {$$self{code}\\n}";
my ($en) = ni::eval('__FILE__') =~ /eval (\\d+)/;
$$self{eval_number} = ++$en;
Scalar::Util::weaken(${'lib/fn::evals'}{$en} = $self);
$$self{fn} = ni::eval $code;
die "ni:/lib/fn failed to compile $code: $@" if $@;
$$self{fn};#;
$xv=bless({$v,$wv,$x,874,$y,$z},$A);
$yv=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  eval_number => undef,
  annotations => [@_]};#;
$zv=bless({$v,$yv,$x,876,$y,$z},$A);
$Av={$vv,$xv,$g7,$zv};
$Bv=q#/lib/fn_init.b#;
$Cv=bless({$i5,$qv,$f6,$sv,$g6,$uv,$h6,$Av,$L,$Bv},$q6);
$Dv={};
$Ev=[];
$Fv=q#shift->{'annotations'}#;
$Gv=bless({$t,$Ev,$v,$Fv,$x,878,$y,$z},$A);
$Hv=[];
$Iv=q#shift->{'code'}#;
$Jv=bless({$t,$Hv,$v,$Iv,$x,880,$y,$z},$A);
$Kv=[];
$Lv=q#shift->{'eval_number'}#;
$Mv=bless({$t,$Kv,$v,$Lv,$x,882,$y,$z},$A);
$Nv=q#fn#;
$Ov=[];
$Pv=q#shift->{'fn'}#;
$Qv=bless({$t,$Ov,$v,$Pv,$x,884,$y,$z},$A);
$Rv={$t,$Gv,$v,$Jv,$x,$Mv,$Nv,$Qv};
$Sv=q#/lib/fn_ro.b#;
$Tv=bless({$i5,$Dv,$f6,$q,$g6,$q,$h6,$Rv,$L,$Sv},$q6);
$Uv={};
$Vv=[];
$Wv=q#my $self = shift; "fn {$$self{code}}"#;
$Xv=bless({$t,$Vv,$v,$Wv,$x,886,$y,$z},$A);
$Yv=[];
$Zv=bless({$t,$Yv,$v,$P8,$x,888,$y,$z},$A);
$cw={$H8,$Xv,$O8,$Zv};
$dw=q#/lib/fn_ops.b#;
$ew=bless({$i5,$Uv,$f6,$q,$g6,$q,$h6,$cw,$L,$dw},$q6);
$fw={};
$gw=q#serialize#;
$hw=[];
$iw=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$jw=bless({$t,$hw,$v,$iw,$x,890,$y,$z},$A);
$kw={$gw,$jw};
$lw=q#/lib/fn_serialize.b#;
$mw=bless({$i5,$fw,$f6,$q,$g6,$q,$h6,$kw,$L,$lw},$q6);
$nw=[$Y7,$p9,$Cv,$Tv,$ew,$mw];
$ow=bless({$i5,$ov,$L,$pv,$W5,$nw},$F5);
$pw=q#lib/fn.c::ctors#;
$qw=q#ni:/lib/fn.c#;
$rw={$F5,1};
$sw=q#/lib/fn.c#;
$tw={};
$uw=[];
$vw=q#my $self = shift;
$SIG{__WARN__} = sub {warn $self->resolve_evals(shift), @_};
$SIG{__DIE__}  = sub {die  $self->resolve_evals(shift), @_};#;
$ww=bless({$t,$uw,$v,$vw,$x,894,$y,$z},$A);
$xw=q#resolve_evals#;
$yw=[];
$zw=q#my ($self, $trace) = @_;
1 while $trace =~ s\#\\(eval (\\d+)\\)\#
  ${'lib/fn::evals'}{$1}{code} || "(anonymous eval $1)"\#eg;
$trace;#;
$Aw=bless({$t,$yw,$v,$zw,$x,896,$y,$z},$A);
$Bw={$xw,$Aw};
$Cw=q#/lib/fn.c_resolve_eval.b#;
$Dw=bless({$i5,$tw,$f6,$ww,$g6,$q,$h6,$Bw,$L,$Cw},$q6);
$Ew=[$I9,$Dw];
$Fw=bless({$i5,$rw,$L,$sw,$W5,$Ew},$X5);
$Gw=q#ni:/lib/fn.c_resolve_eval.b#;
$Hw=q#ni:/lib/fn_init.b#;
$Iw=q#ni:/lib/fn_ops.b#;
$Jw=q#ni:/lib/fn_ro.b#;
$Kw=q#ni:/lib/fn_serialize.b#;
$Lw=q#ni:/lib/gensym_generator_compact.b#;
$Mw={};
$Nw=q#gensym#;
$Ow=[];
$Pw=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Qw=bless({$t,$Ow,$v,$Pw,$x,898,$y,$z},$A);
$Rw={$Nw,$Qw};
$Sw=q#/lib/gensym_generator_compact.b#;
$Tw=bless({$i5,$Mw,$f6,$q,$g6,$q,$h6,$Rw,$L,$Sw},$q6);
$Uw=q#ni:/lib/global_static_test.b#;
$Vw={};
$Ww=[];
$Xw=q#ni('ni:/lib/test_case')->new(shift)#;
$Yw=q#($)#;
$Zw=bless({$t,$Ww,$v,$Xw,$x,900,$y,$Yw},$A);
$cx=q#now#;
$dx=[];
$ex=q#ni('ni:/lib/test_value')->new(shift)#;
$fx=bless({$t,$dx,$v,$ex,$x,902,$y,$Yw},$A);
$gx={$e3,$Zw,$cx,$fx};
$hx=q#/lib/global_static_test.b#;
$ix=bless({$i5,$Vw,$f6,$q,$g6,$q,$h6,$gx,$L,$hx},$q6);
$jx=q#ni:/lib/image#;
$kx={$E7,1};
$lx={};
$mx=[];
$nx=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$ox=bless({$t,$mx,$v,$nx,$x,904,$y,$z},$A);
$px={$g7,$ox};
$qx=q#/lib/image_init.b#;
$rx=bless({$i5,$lx,$f6,$q,$g6,$q,$h6,$px,$L,$qx},$q6);
$sx={};
$tx=q#address#;
$ux=[];
$vx=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$wx=bless({$t,$ux,$v,$vx,$x,906,$y,$z},$A);
$xx=q#allocate_gensym#;
$yx=[];
$zx=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Ax=bless({$t,$yx,$v,$zx,$x,908,$y,$z},$A);
$Bx=q#boot_side_effect#;
$Cx=[];
$Dx=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ex=bless({$t,$Cx,$v,$Dx,$x,910,$y,$z},$A);
$Fx=q#circular_links#;
$Gx=[];
$Hx=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Ix=bless({$t,$Gx,$v,$Hx,$x,912,$y,$z},$A);
$Jx=q#finalizer#;
$Kx=[];
$Lx=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Mx=bless({$t,$Kx,$v,$Lx,$x,914,$y,$z},$A);
$Nx=q#quote#;
$Ox=[];
$Px=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Qx=bless({$t,$Ox,$v,$Px,$x,916,$y,$z},$A);
$Rx=q#reconstruction#;
$Sx=[];
$Tx=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ux=bless({$t,$Sx,$v,$Tx,$x,918,$y,$z},$A);
$Vx=q#side_effect#;
$Wx=[];
$Xx=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Yx=bless({$t,$Wx,$v,$Xx,$x,920,$y,$z},$A);
$Zx=[];
$cy=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$dy=bless({$t,$Zx,$v,$cy,$x,922,$y,$z},$A);
$ey={$tx,$wx,$xx,$Ax,$Bx,$Ex,$Fx,$Ix,$Jx,$Mx,$Nx,$Qx,$Rx,$Ux,$Vx,$Yx,$gc,$dy};
$fy=q#/lib/image_quoting.b#;
$gy=bless({$i5,$sx,$f6,$q,$g6,$q,$h6,$ey,$L,$fy},$q6);
$hy={};
$iy=q#quote_code#;
$jy=[];
$ky=q#shift->die('cannot quote perl CODE refs', shift)#;
$ly=bless({$t,$jy,$v,$ky,$x,924,$y,$z},$A);
$my={$iy,$ly};
$ny=q#/lib/quote_code_fail.b#;
$oy=bless({$i5,$hy,$f6,$q,$g6,$q,$h6,$my,$L,$ny},$q6);
$py={};
$qy=q#quote_array#;
$ry=[];
$sy=q#local $_;
my ($self, $v) = @_;
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$ty=bless({$t,$ry,$v,$sy,$x,926,$y,$z},$A);
$uy=q#quote_hash#;
$vy=[];
$wy=q#local $_;
my ($self, $v) = @_;
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$xy=bless({$t,$vy,$v,$wy,$x,928,$y,$z},$A);
$yy=q#quote_scalar#;
$zy=[];
$Ay=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$By=bless({$t,$zy,$v,$Ay,$x,930,$y,$z},$A);
$Cy=q#quote_scalar_ref#;
$Dy=[];
$Ey=q#'\\\\' . shift->quote(${$_[0]})#;
$Fy=bless({$t,$Dy,$v,$Ey,$x,932,$y,$z},$A);
$Gy=q#quote_value#;
$Hy=[];
$Iy=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Jy=bless({$t,$Hy,$v,$Iy,$x,934,$y,$z},$A);
$Ky={$qy,$ty,$uy,$xy,$yy,$By,$Cy,$Fy,$Gy,$Jy};
$Ly=q#/lib/quote_values.b#;
$My=bless({$i5,$py,$f6,$q,$g6,$q,$h6,$Ky,$L,$Ly},$q6);
$Ny={};
$Oy=q#quote_blessed#;
$Py=[];
$Qy=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Ry=bless({$t,$Py,$v,$Qy,$x,936,$y,$z},$A);
$Sy=q#quote_class#;
$Ty=[];
$Uy=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Vy=bless({$t,$Ty,$v,$Uy,$x,938,$y,$z},$A);
$Wy=q#quote_object#;
$Xy=[];
$Yy=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . '::ctors') . ';')
  if @{ref($_[0]) . '::ctors'};
$q;#;
$Zy=bless({$t,$Xy,$v,$Yy,$x,940,$y,$z},$A);
$cz={$Oy,$Ry,$Sy,$Vy,$Wy,$Zy};
$dz=q#/lib/quote_objects.b#;
$ez=bless({$i5,$Ny,$f6,$q,$g6,$q,$h6,$cz,$L,$dz},$q6);
$fz={};
$gz=q#circular_arrayref#;
$hz=[];
$iz=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$jz=bless({$t,$hz,$v,$iz,$x,942,$y,$z},$A);
$kz=q#circular_hashref#;
$lz=[];
$mz=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$nz=bless({$t,$lz,$v,$mz,$x,944,$y,$z},$A);
$oz=q#is_circular#;
$pz=[];
$qz=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$rz=bless({$t,$pz,$v,$qz,$x,946,$y,$z},$A);
$sz={$gz,$jz,$kz,$nz,$oz,$rz};
$tz=q#/lib/quote_circular_addressed.b#;
$uz=bless({$i5,$fz,$f6,$q,$g6,$q,$h6,$sz,$L,$tz},$q6);
$vz=[$Y7,$rx,$gy,$oy,$My,$ez,$uz,$Tw];
$wz=bless({$i5,$kx,$L,$j4,$W5,$vz},$G5);
$xz=q#lib/image.c::ctors#;
$yz=q#ni:/lib/image.c#;
$zz={$G5,1};
$Az=q#/lib/image.c#;
$Bz=[$I9];
$Cz=bless({$i5,$zz,$L,$Az,$W5,$Bz},$X5);
$Dz=q#ni:/lib/image_init.b#;
$Ez=q#ni:/lib/image_quoting.b#;
$Fz=q#ni:/lib/instance.b#;
$Gz=q#ni:/lib/instantiable.b#;
$Hz=q#ni:/lib/json.b#;
$Iz={};
$Jz=q#json_decode#;
$Kz=[];
$Lz=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Mz=bless({$t,$Kz,$v,$Lz,$x,948,$y,$Yw},$A);
$Nz=q#json_encode#;
$Oz=[];
$Pz=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Qz=bless({$t,$Oz,$v,$Pz,$x,950,$y,$Yw},$A);
$Rz=q#json_escape#;
$Sz=[];
$Tz=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Uz=bless({$t,$Sz,$v,$Tz,$x,952,$y,$Yw},$A);
$Vz=q#json_unescape#;
$Wz=[];
$Xz=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Yz=bless({$t,$Wz,$v,$Xz,$x,954,$y,$Yw},$A);
$Zz=q#json_unescape_one#;
$cA=[];
$dA=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$eA=bless({$t,$cA,$v,$dA,$x,956,$y,$Yw},$A);
$fA={$Jz,$Mz,$Nz,$Qz,$Rz,$Uz,$Vz,$Yz,$Zz,$eA};
$gA=q#/lib/json.b#;
$hA=bless({$i5,$Iz,$f6,$q,$g6,$q,$h6,$fA,$L,$gA},$q6);
$iA=q#ni#;
$jA=q#ni:/lib/name_as_string.b#;
$kA=q#ni:/lib/named.b#;
$lA=q#ni:/lib/named_in_ni.b#;
$mA=q#ni:/lib/namespaced.b#;
$nA=q#ni:/lib/ni#;
$oA={$F7,1};
$pA={};
$qA=q#extend#;
$rA=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$sA=bless({$v,$rA,$x,958,$y,$z},$A);
$tA=q#is_mutable#;
$uA=q#$0 ne '-' && -w $0#;
$vA=bless({$v,$uA,$x,960,$y,$z},$A);
$wA=q#modify#;
$xA=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$yA=bless({$v,$xA,$x,962,$y,$z},$A);
$zA={$qA,$sA,$tA,$vA,$wA,$yA};
$AA=q#/lib/ni_self.b#;
$BA=bless({$i5,$pA,$f6,$q,$g6,$q,$h6,$zA,$L,$AA},$q6);
$CA={};
$DA=q#--internal/+=#;
$EA=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$FA=bless({$v,$EA,$x,964,$y,$z},$A);
$GA=q#--internal/eval#;
$HA=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$IA=bless({$v,$HA,$x,966,$y,$z},$A);
$JA=q#--internal/image#;
$KA=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$LA=bless({$v,$KA,$x,968,$y,$z},$A);
$MA=q#--internal/test#;
$NA=q#my $self   = shift;
my $failed = 0;
my @tests  = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
for (@tests) {
  $_->run;
  print "$_\\n";
}
for my $f (grep $_->failed, @tests) {
  ++$failed;
  print "\\nTEST FAIL\\n", $f->test, "\\n";
  print "\\nERROR ", ni('ni:/lib/fn')->resolve_evals($f->error)
    if $f->error;
  print "\\nASSERTIONS\\n";
  print "  $_\\n" for @{$f->assertions};
}

print "\\nSUMMARY\\n";
printf "% 4d test(s) passed\\n", @tests - $failed;
printf "% 4d test(s) failed\\n", $failed;
!!$failed;#;
$OA=bless({$v,$NA,$x,970,$y,$z},$A);
$PA=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$QA=bless({$v,$PA,$x,972,$y,$z},$A);
$RA={$DA,$FA,$GA,$IA,$JA,$LA,$MA,$OA,$Fr,$QA};
$SA=q#/lib/ni_main.b#;
$TA=bless({$i5,$CA,$f6,$q,$g6,$q,$h6,$RA,$L,$SA},$q6);
$UA={};
$VA=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$WA=bless({$v,$VA,$x,974,$y,$z},$A);
$XA=q#resolver_for#;
$YA=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$ZA=bless({$v,$YA,$x,976,$y,$z},$A);
$cB={$S6,$WA,$XA,$ZA};
$dB=q#/lib/ni_resolver.b#;
$eB=bless({$i5,$UA,$f6,$q,$g6,$q,$h6,$cB,$L,$dB},$q6);
$fB={};
$gB=q#exists#;
$hB=q#exists $_[0]->{named}{$_[1]}#;
$iB=bless({$v,$hB,$x,978,$y,$z},$A);
$jB=q#quoted#;
$kB=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$lB=bless({$v,$kB,$x,980,$y,$z},$A);
$mB={$gB,$iB,$jB,$lB};
$nB=q#/lib/ni_image.b#;
$oB=bless({$i5,$fB,$f6,$q,$g6,$q,$h6,$mB,$L,$nB},$q6);
$pB=[$Y7,$BA,$TA,$eB,$oB];
$qB=bless({$i5,$oA,$L,$r4,$W5,$pB},$H5);
$rB=q#lib/ni.c::ctors#;
$sB=q#ni:/lib/ni.c#;
$tB={$H5,1};
$uB=q#/lib/ni.c#;
$vB=[$I9];
$wB=bless({$i5,$tB,$L,$uB,$W5,$vB},$X5);
$xB=q#ni:/lib/ni_image.b#;
$yB=q#ni:/lib/ni_main.b#;
$zB=q#ni:/lib/ni_resolver.b#;
$AB=q#ni:/lib/ni_self.b#;
$BB=q#ni:/lib/ni_static_util.b#;
$CB={};
$DB=q#abbrev#;
$EB=[];
$FB=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$GB=bless({$t,$EB,$v,$FB,$x,982,$y,$z},$A);
$HB=q#dor#;
$IB=[];
$JB=q#defined $_[0] ? $_[0] : $_[1]#;
$KB=bless({$t,$IB,$v,$JB,$x,984,$y,$z},$A);
$LB=q#indent#;
$MB=[];
$NB=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$OB=bless({$t,$MB,$v,$NB,$x,986,$y,$z},$A);
$PB=q#max#;
$QB=[];
$RB=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$SB=bless({$t,$QB,$v,$RB,$x,988,$y,$z},$A);
$TB=q#maxstr#;
$UB=[];
$VB=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$WB=bless({$t,$UB,$v,$VB,$x,990,$y,$z},$A);
$XB=q#mean#;
$YB=[];
$ZB=q#sum(@_) / (@_ || 1)#;
$cC=bless({$t,$YB,$v,$ZB,$x,992,$y,$z},$A);
$dC=q#min#;
$eC=[];
$fC=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$gC=bless({$t,$eC,$v,$fC,$x,994,$y,$z},$A);
$hC=q#minstr#;
$iC=[];
$jC=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$kC=bless({$t,$iC,$v,$jC,$x,996,$y,$z},$A);
$lC=q#sgr#;
$mC=[];
$nC=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$oC=bless({$t,$mC,$v,$nC,$x,998,$y,$z},$A);
$pC=q#sr#;
$qC=[];
$rC=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$sC=bless({$t,$qC,$v,$rC,$x,1000,$y,$z},$A);
$tC=q#sum#;
$uC=[];
$vC=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$wC=bless({$t,$uC,$v,$vC,$x,1002,$y,$z},$A);
$xC=q#swap#;
$yC=[];
$zC=q#@_[0, 1] = @_[1, 0]#;
$AC=bless({$t,$yC,$v,$zC,$x,1004,$y,$z},$A);
$BC={$DB,$GB,$HB,$KB,$LB,$OB,$PB,$SB,$TB,$WB,$XB,$cC,$dC,$gC,$hC,$kC,$lC,$oC,$pC,$sC,$tC,$wC,$xC,$AC};
$CC=q#/lib/ni_static_util.b#;
$DC=bless({$i5,$CB,$f6,$q,$g6,$q,$h6,$BC,$L,$CC},$q6);
$EC=q#ni:/lib/perlbranch.b#;
$FC=q#ni:/lib/quote_circular_addressed.b#;
$GC=q#ni:/lib/quote_code_fail.b#;
$HC=q#ni:/lib/quote_objects.b#;
$IC=q#ni:/lib/quote_simple#;
$JC={$G7,1};
$KC={};
$LC=[];
$MC=q#+{}#;
$NC=bless({$t,$LC,$v,$MC,$x,1006,$y,$z},$A);
$OC={$g7,$NC};
$PC=q#/lib/quote_simple_init.b#;
$QC=bless({$i5,$KC,$f6,$q,$g6,$q,$h6,$OC,$L,$PC},$q6);
$RC={};
$SC=[];
$TC=bless({$t,$SC,$v,0,$x,1008,$y,$z},$A);
$UC=[];
$VC=q#shift->quote_value(shift)#;
$WC=bless({$t,$UC,$v,$VC,$x,1010,$y,$z},$A);
$XC={$oz,$TC,$Nx,$WC};
$YC=q#/lib/quote_simple_quote.b#;
$ZC=bless({$i5,$RC,$f6,$q,$g6,$q,$h6,$XC,$L,$YC},$q6);
$cD=[$Y7,$QC,$ZC,$oy,$My,$ez];
$dD=bless({$i5,$JC,$L,$C4,$W5,$cD},$I5);
$eD=q#lib/quote_simple.c::ctors#;
$fD=q#ni:/lib/quote_simple.c#;
$gD={$I5,1};
$hD=q#/lib/quote_simple.c#;
$iD=[$I9];
$jD=bless({$i5,$gD,$L,$hD,$W5,$iD},$X5);
$kD=q#ni:/lib/quote_simple_init.b#;
$lD=q#ni:/lib/quote_simple_quote.b#;
$mD=q#ni:/lib/quote_values.b#;
$nD=q#ni:/lib/ref_eq.b#;
$oD=q#ni:/lib/resolver.b#;
$pD=q#ni:/lib/slice#;
$qD={$q6,1};
$rD=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$sD=bless({$v,$rD,$x,1012,$y,$z},$A);
$tD=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$uD=bless({$v,$tD,$x,1014,$y,$z},$A);
$vD=q#lib/slice::apply#;
$wD=q#lib/slice::apply_unsafe#;
$xD={};
$yD=q#apply_unsafe#;
$zD={$l6,$sD,$yD,$uD};
$AD=q#/lib/slice.b#;
$BD=bless({$i5,$xD,$h6,$zD,$L,$AD},$q6);
$CD={};
$DD=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$ED=bless({$v,$DD,$x,1016,$y,$z},$A);
$FD={$g7,$ED};
$GD=q#/lib/slice_init.b#;
$HD=bless({$i5,$CD,$h6,$FD,$L,$GD},$q6);
$ID={};
$JD=[];
$KD=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$LD=bless({$t,$JD,$v,$KD,$x,1018,$y,$z},$A);
$MD={$gw,$LD};
$ND=q#/lib/slice_serialize.b#;
$OD=bless({$i5,$ID,$f6,$q,$g6,$q,$h6,$MD,$L,$ND},$q6);
$PD=[$l8,$B6,$BD,$HD,$OD];
$QD=bless({$i5,$qD,$L,$X4,$W5,$PD},$J5);
$RD=q#lib/slice.c::ctors#;
$SD=q#ni:/lib/slice.b#;
$TD=q#ni:/lib/slice.c#;
$UD={$J5,1};
$VD=q#/lib/slice.c#;
$WD=[$N9];
$XD=bless({$i5,$UD,$L,$VD,$W5,$WD},$X5);
$YD=q#ni:/lib/slice_init.b#;
$ZD=q#ni:/lib/slice_serialize.b#;
$cE=q#ni:/lib/static_fn.b#;
$dE={};
$eE=[];
$fE=q#ni('ni:/lib/fn')->new(@_)#;
$gE=bless({$t,$eE,$v,$fE,$x,1020,$y,$Yw},$A);
$hE=q#fp#;
$iE=[];
$jE=q#($$)#;
$kE=bless({$t,$iE,$v,$fE,$x,1022,$y,$jE},$A);
$lE={$Nv,$gE,$hE,$kE};
$mE=q#/lib/static_fn.b#;
$nE=bless({$i5,$dE,$f6,$q,$g6,$q,$h6,$lE,$L,$mE},$q6);
$oE=q#ni:/lib/subclass.b#;
$pE=q#ni:/lib/tag#;
$qE={$C6,1};
$rE=q#/lib/tag#;
$sE={};
$tE=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$uE=bless({$v,$tE,$x,1024,$y,$z},$A);
$vE={$l6,$uE};
$wE=q#/lib/tag.b#;
$xE=bless({$i5,$sE,$f6,$q,$g6,$q,$h6,$vE,$L,$wE},$q6);
$yE={};
$zE=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$AE=bless({$v,$zE,$x,1026,$y,$z},$A);
$BE={$g7,$AE};
$CE=q#/lib/tag_init.b#;
$DE=bless({$i5,$yE,$f6,$q,$g6,$q,$h6,$BE,$L,$CE},$q6);
$EE=[$l8,$B6,$xE,$DE];
$FE=bless({$i5,$qE,$L,$rE,$W5,$EE},$K5);
$GE=q#lib/tag.c::ctors#;
$HE=q#ni:/lib/tag.b#;
$IE=q#ni:/lib/tag.c#;
$JE={$K5,1};
$KE=q#/lib/tag.c#;
$LE=[$N9];
$ME=bless({$i5,$JE,$L,$KE,$W5,$LE},$X5);
$NE=q#ni:/lib/tag_init.b#;
$OE=q#ni:/lib/test_assert_eq#;
$PE={$H7,1};
$QE=q#/lib/test_assert_eq#;
$RE={$H7,1,$I7,1};
$SE=q#/lib/test_assertion#;
$TE={};
$UE=q#commit#;
$VE=[];
$WE=q#my $self = shift;
my $test = ni('ni:/lib/test_case')->running_test;
push @{$test->assertions}, $self->result;
$self;#;
$XE=bless({$t,$VE,$v,$WE,$x,1028,$y,$z},$A);
$YE={$UE,$XE};
$ZE=q#/lib/test_assertion_commit.b#;
$cF=bless({$i5,$TE,$f6,$q,$g6,$q,$h6,$YE,$L,$ZE},$q6);
$dF=[$Y7,$cF];
$eF=bless({$i5,$RE,$L,$SE,$W5,$dF},$M5);
$fF=q#lib/test_assertion.c::ctors#;
$gF={};
$hF=[];
$iF=q#my ($class, $diff) = @_;
+{diff => $diff};#;
$jF=bless({$t,$hF,$v,$iF,$x,1030,$y,$z},$A);
$kF={$g7,$jF};
$lF=q#/lib/test_assert_eq_init.b#;
$mF=bless({$i5,$gF,$f6,$q,$g6,$q,$h6,$kF,$L,$lF},$q6);
$nF={};
$oF=[];
$pF=q#my $self = shift;
$self->failed ? "FAIL " . ni::json_encode $$self{diff}
              : "PASS";#;
$qF=bless({$t,$oF,$v,$pF,$x,1032,$y,$z},$A);
$rF=q#failed#;
$sF=[];
$tF=q#defined shift->{diff}#;
$uF=bless({$t,$sF,$v,$tF,$x,1034,$y,$z},$A);
$vF=q#result#;
$wF=[];
$xF=bless({$t,$wF,$v,$Hr,$x,1036,$y,$z},$A);
$yF={$H8,$qF,$rF,$uF,$vF,$xF};
$zF=q#/lib/test_assert_eq_result.b#;
$AF=bless({$i5,$nF,$f6,$q,$g6,$q,$h6,$yF,$L,$zF},$q6);
$BF=[$eF,$mF,$AF];
$CF=bless({$i5,$PE,$L,$QE,$W5,$BF},$L5);
$DF=q#lib/test_assert_eq.c::ctors#;
$EF=q#ni:/lib/test_assert_eq.c#;
$FF={$L5,1};
$GF=q#/lib/test_assert_eq.c#;
$HF={$L5,1,$M5,1};
$IF=q#/lib/test_assertion.c#;
$JF=[$I9];
$KF=bless({$i5,$HF,$L,$IF,$W5,$JF},$X5);
$LF=[$KF];
$MF=bless({$i5,$FF,$L,$GF,$W5,$LF},$X5);
$NF=q#ni:/lib/test_assert_eq_init.b#;
$OF=q#ni:/lib/test_assert_eq_result.b#;
$PF=q#ni:/lib/test_assertion#;
$QF=q#ni:/lib/test_assertion.c#;
$RF=q#ni:/lib/test_assertion_commit.b#;
$SF=q#ni:/lib/test_case#;
$TF={$D,1};
$UF=q#/lib/test_case#;
$VF=q#running_test#;
$WF={};
$XF=[];
$YF=q#shift->{'assertions'}#;
$ZF=bless({$t,$XF,$v,$YF,$x,1038,$y,$z},$A);
$cG=[];
$dG=q#shift->{'test'}#;
$eG=bless({$t,$cG,$v,$dG,$x,1040,$y,$z},$A);
$fG={$n,$ZF,$s,$eG};
$gG=q#/lib/test_case_ro.b#;
$hG=bless({$i5,$WF,$f6,$q,$g6,$q,$h6,$fG,$L,$gG},$q6);
$iG={};
$jG=[];
$kG=q#@_ == 2 ? $_[0]->{'error'} = $_[1] : shift->{'error'}#;
$lG=bless({$t,$jG,$v,$kG,$x,1042,$y,$z},$A);
$mG={$p,$lG};
$nG=q#/lib/test_case_rw.b#;
$oG=bless({$i5,$iG,$f6,$q,$g6,$q,$h6,$mG,$L,$nG},$q6);
$pG={};
$qG=[];
$rG=q#my $class = shift;
my $test  = fn shift;
+{test       => $test,
  assertions => [],
  error      => undef,
  outcome    => undef};#;
$sG=bless({$t,$qG,$v,$rG,$x,1044,$y,$z},$A);
$tG={$g7,$sG};
$uG=q#/lib/test_case_init.b#;
$vG=bless({$i5,$pG,$f6,$q,$g6,$q,$h6,$tG,$L,$uG},$q6);
$wG={};
$xG=[];
$yG=q#my $self = shift;
join '', $self->failed  ? 'FAIL ' : 'PASS ',
         $self->error   ? 'E'     : ':',
         map $_->failed ? 'X'     : '.', @{$$self{assertions}};#;
$zG=bless({$t,$xG,$v,$yG,$x,1046,$y,$z},$A);
$AG=[];
$BG=q#!shift->{outcome}->[0]#;
$CG=bless({$t,$AG,$v,$BG,$x,1048,$y,$z},$A);
$DG={$H8,$zG,$rF,$CG};
$EG=q#/lib/test_case_metrics.b#;
$FG=bless({$i5,$wG,$f6,$q,$g6,$q,$h6,$DG,$L,$EG},$q6);
$GG={};
$HG=q#done#;
$IG=[];
$JG=q#my $self = shift;
my @failed = grep $_->failed, @{$$self{assertions}};
my $any_failed = @failed || defined $$self{error};
$$self{outcome} = [!$any_failed, $$self{error}, @failed];#;
$KG=bless({$t,$IG,$v,$JG,$x,1050,$y,$z},$A);
$LG=[];
$MG=q#local $_;
my $self = shift;
$self->class->with_test($self, \\&{$$self{test}});
$self;#;
$NG=bless({$t,$LG,$v,$MG,$x,1052,$y,$z},$A);
$OG={$HG,$KG,$Fr,$NG};
$PG=q#/lib/test_case_run.b#;
$QG=bless({$i5,$GG,$f6,$q,$g6,$q,$h6,$OG,$L,$PG},$q6);
$RG=[$Y7,$hG,$oG,$vG,$FG,$QG];
$SG=bless({$i5,$TF,$L,$UF,$VF,$q,$W5,$RG},$N5);
$TG=q#lib/test_case.c::ctors#;
$UG=q#ni:/lib/test_case.c#;
$VG={$N5,1};
$WG=q#/lib/test_case.c#;
$XG={};
$YG=[];
$ZG=q#shift->{'running_test'}#;
$cH=bless({$t,$YG,$v,$ZG,$x,1056,$y,$z},$A);
$dH={$VF,$cH};
$eH=q#/lib/test_case.c_test_ro.b#;
$fH=bless({$i5,$XG,$f6,$q,$g6,$q,$h6,$dH,$L,$eH},$q6);
$gH={};
$hH=[];
$iH=q#shift->{running_test} = undef#;
$jH=bless({$t,$hH,$v,$iH,$x,1058,$y,$z},$A);
$kH=q#with_test#;
$lH=[];
$mH=q#my ($self, $test, $f) = @_;
local $$self{running_test} = $test;
eval {&$f};
$test->error($@) if $@;
$test->done;#;
$nH=bless({$t,$lH,$v,$mH,$x,1060,$y,$z},$A);
$oH={$kH,$nH};
$pH=q#/lib/test_case.c_test.b#;
$qH=bless({$i5,$gH,$f6,$jH,$g6,$q,$h6,$oH,$L,$pH},$q6);
$rH=[$I9,$fH,$qH];
$sH=bless({$i5,$VG,$L,$WG,$W5,$rH},$X5);
$tH=q#ni:/lib/test_case.c_test.b#;
$uH=q#ni:/lib/test_case.c_test_ro.b#;
$vH=q#ni:/lib/test_case_init.b#;
$wH=q#ni:/lib/test_case_metrics.b#;
$xH=q#ni:/lib/test_case_ro.b#;
$yH=q#ni:/lib/test_case_run.b#;
$zH=q#ni:/lib/test_case_rw.b#;
$AH=q#ni:/lib/test_value#;
$BH={$J7,1};
$CH=q#/lib/test_value#;
$DH={};
$EH=[];
$FH=q#\\$_[1]#;
$GH=bless({$t,$EH,$v,$FH,$x,1062,$y,$z},$A);
$HH={$g7,$GH};
$IH=q#/lib/test_value_init.b#;
$JH=bless({$i5,$DH,$f6,$q,$g6,$q,$h6,$HH,$L,$IH},$q6);
$KH={};
$LH=q#(==#;
$MH=[];
$NH=q#my ($self, $rhs) = @_;
ni('ni:/lib/test_assert_eq')
  ->new($self->diff($rhs))
  ->commit;#;
$OH=bless({$t,$MH,$v,$NH,$x,1064,$y,$z},$A);
$PH=q#diff#;
$QH=[];
$RH=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  no warnings 'uninitialized';
  return {scalar_difference => [$lhs, $rhs]} if $lhs ne $rhs;
}
return undef;#;
$SH=bless({$t,$QH,$v,$RH,$x,1066,$y,$z},$A);
$TH={$LH,$OH,$PH,$SH};
$UH=q#/lib/test_value_eq.b#;
$VH=bless({$i5,$KH,$f6,$q,$g6,$q,$h6,$TH,$L,$UH},$q6);
$WH={};
$XH=[];
$YH=q#ni::json_encode ${$_[0]}#;
$ZH=bless({$t,$XH,$v,$YH,$x,1068,$y,$z},$A);
$cI={$H8,$ZH};
$dI=q#/lib/test_value_str.b#;
$eI=bless({$i5,$WH,$f6,$q,$g6,$q,$h6,$cI,$L,$dI},$q6);
$fI=[$Y7,$JH,$VH,$eI];
$gI=bless({$i5,$BH,$L,$CH,$W5,$fI},$O5);
$hI=q#lib/test_value.c::ctors#;
$iI=q#ni:/lib/test_value.c#;
$jI={$O5,1};
$kI=q#/lib/test_value.c#;
$lI=[$I9];
$mI=bless({$i5,$jI,$L,$kI,$W5,$lI},$X5);
$nI=q#ni:/lib/test_value_eq.b#;
$oI=q#ni:/lib/test_value_init.b#;
$pI=q#ni:/lib/test_value_str.b#;
$qI=q#ni:/metaclass#;
$rI={$X5,1};
$sI=q#/metaclass#;
$tI=[$Z6,$p9,$l7,$h9];
$uI=bless({$i5,$rI,$L,$sI,$W5,$tI},$P5);
$vI=q#metaclass.c::ctors#;
$wI=q#ni:/metaclass.c#;
$xI={$P5,1};
$yI=q#/metaclass.c#;
$zI=[$y9];
$AI=bless({$i5,$xI,$L,$yI,$W5,$zI},$X5);
$BI=q#ni:/module#;
$CI=q#ni:/module.c#;
$DI=q#ni:/object#;
$EI=q#ni:/object.c#;
$FI=q#ni:/semantic/dimension#;
$GI={$S5,1};
$HI=q#/semantic/dimension#;
$II=[$y9];
$JI=bless({$i5,$GI,$L,$HI,$W5,$II},$T5);
$KI=q#semantic/dimension.c::ctors#;
$LI=q#ni:/semantic/dimension.c#;
$MI={$T5,1};
$NI=q#/semantic/dimension.c#;
$OI=[$R9];
$PI=bless({$i5,$MI,$L,$NI,$W5,$OI},$X5);
$QI=q#ni:/semantic/task#;
$RI=q#ni:/semantic/task.c#;
$SI=q#ni:/semantic/task_outcome.b#;
$TI=q#ni:/semantic/task_ro.b#;
$UI=q#ni:main#;
$VI={$Vl,1};
$WI=[$nE,$ix,$Ul];
$XI=bless({$i5,$VI,$L,$Vl,$W5,$WI},$Y5);
$YI=q#module::ctors#;
$ZI=q#ni:ni#;
$cJ={$iA,1};
$dJ={$iA,1};
$eJ=q#json_escapes#;
$fJ=q##;
$gJ=q#b#;
$hJ=q#	#;
$iJ=q#t#;
$jJ=q#
#;
$kJ=q#n#;
$lJ=q##;
$mJ=q#"#;
$nJ=q#/#;
$oJ=q#\\#;
$pJ={$fJ,$gJ,$hJ,$iJ,$jJ,$kJ,$lJ,$Ph,$mJ,$mJ,$nJ,$nJ,$oJ,$oJ};
$qJ=q#json_unescapes#;
$rJ={$mJ,$mJ,$nJ,$nJ,$oJ,$oJ,$gJ,$fJ,$kJ,$jJ,$Ph,$lJ,$iJ,$hJ};
$sJ={$eJ,$pJ,$qJ,$rJ};
$tJ=q#/lib/json_data.b#;
$uJ=bless({$i5,$dJ,$to,$sJ,$L,$tJ},$D7);
$vJ=[$uJ,$hA,$DC];
$wJ=bless({$i5,$cJ,$L,$iA,$W5,$vJ},$Y5);
$xJ={$d,$O,$Q,$V,$W,$Z,$c1,$h1,$i1,$u1,$v1,$H1,$I1,$U1,$V1,$j2,$k2,$F2,$G2,$L2,$M2,$U2,$V2,$c3,$d3,$z3,$A3,$G3,$H3,$c4,$d4,$k4,$l4,$s4,$t4,$D4,$E4,$Y4,$Z4,$g5,$h5,$y9,$A9,$R9,$S9,$ea,$ga,$ka,$la,$ca,$ma,$sc,$uc,$Kc,$Lc,$Ub,$Mc,$qc,$Nc,$gd,$id,$md,$nd,$Vc,$od,$ed,$pd,$Ze,$df,$hf,$if,$He,$jf,$Xe,$kf,$Fd,$lf,$ze,$mf,$Zd,$nf,$yd,$of,$Ag,$Cg,$Gg,$Hg,$dg,$Ig,$og,$Jg,$Df,$Kg,$yg,$Lg,$wf,$Mg,$Lf,$Ng,$ji,$li,$pi,$qi,$fh,$ri,$Ch,$si,$mh,$ti,$hi,$ui,$Vg,$vi,$Kh,$wi,$Pi,$Ri,$Vi,$Wi,$Ni,$Xi,$Ei,$Yi,$jk,$lk,$pk,$qk,$ll,$nl,$hk,$ol,$sl,$tl,$Ok,$ul,$jl,$vl,$Uk,$wl,$Hk,$xl,$uj,$yl,$Pj,$zl,$nj,$Al,$Cj,$Bl,$Ul,$Wl,$wm,$ym,$Cm,$Dm,$hm,$Em,$um,$Fm,$Mb,$Gm,$Ic,$Hm,$Gc,$Im,$Qa,$Jm,$Ya,$Km,$mb,$Lm,$wa,$Mm,$Kb,$Nm,$yb,$Om,$do,$fo,$jo,$ko,$Zn,$lo,$nn,$mo,$Jn,$no,$dn,$oo,$zn,$po,$gp,$ip,$mp,$np,$Oo,$op,$ep,$pp,$Ho,$qp,$Bq,$Dq,$Sq,$Tq,$Qq,$Uq,$Ur,$Wr,$vs,$ws,$ts,$xs,$tr,$ys,$Dr,$zs,$mr,$As,$Pr,$Bs,$fq,$Cs,$zq,$Ds,$Vs,$Xs,$dt,$et,$Ms,$ft,$Ts,$gt,$F8,$ht,$l8,$it,$N9,$jt,$tt,$vt,$r6,$wt,$At,$Bt,$rt,$Ct,$l7,$Dt,$Tt,$Vt,$Zt,$cu,$Rt,$du,$Lt,$eu,$e9,$fu,$v8,$gu,$c9,$hu,$Yu,$cv,$gv,$hv,$Bu,$iv,$Ku,$jv,$ou,$kv,$uu,$lv,$Wu,$mv,$j8,$nv,$ow,$qw,$Fw,$Gw,$Dw,$Hw,$Cv,$Iw,$ew,$Jw,$Tv,$Kw,$mw,$Lw,$Tw,$Uw,$ix,$jx,$wz,$yz,$Cz,$Dz,$rx,$Ez,$gy,$Fz,$W7,$Gz,$p9,$Hz,$hA,$jA,$M8,$kA,$B6,$lA,$J6,$mA,$Q6,$nA,$qB,$sB,$wB,$xB,$oB,$yB,$TA,$zB,$eB,$AB,$BA,$BB,$DC,$EC,$Z6,$FC,$uz,$GC,$oy,$HC,$ez,$IC,$dD,$fD,$jD,$kD,$QC,$lD,$ZC,$mD,$My,$nD,$T8,$oD,$X6,$pD,$QD,$SD,$BD,$TD,$XD,$YD,$HD,$ZD,$OD,$cE,$nE,$oE,$w9,$pE,$FE,$HE,$xE,$IE,$ME,$NE,$DE,$OE,$CF,$EF,$MF,$NF,$mF,$OF,$AF,$PF,$eF,$QF,$KF,$RF,$cF,$SF,$SG,$UG,$sH,$tH,$qH,$uH,$fH,$vH,$vG,$wH,$FG,$xH,$hG,$yH,$QG,$zH,$oG,$AH,$gI,$iI,$mI,$nI,$VH,$oI,$JH,$pI,$eI,$qI,$uI,$wI,$AI,$BI,$h9,$CI,$P9,$DI,$Y7,$EI,$I9,$FI,$JI,$LI,$PI,$QI,$Pp,$RI,$Jq,$SI,$Np,$TI,$Bp,$UI,$XI,$ZI,$wJ};
$yJ=q#resolvers#;
$zJ=[];
$AJ=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$BJ=bless({$t,$zJ,$v,$AJ,$x,1070,$y,$z},$A);
$CJ=q#file#;
$DJ=[];
$EJ=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$FJ=bless({$t,$DJ,$v,$EJ,$x,1072,$y,$z},$A);
$GJ=q#null#;
$HJ=[];
$IJ=q#ni('ni:/io/null')->new#;
$JJ=bless({$t,$HJ,$v,$IJ,$x,1074,$y,$z},$A);
$KJ=q#sh#;
$LJ=[];
$MJ=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$NJ=bless({$t,$LJ,$v,$MJ,$x,1076,$y,$z},$A);
$OJ=q#str#;
$PJ=[];
$QJ=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$RJ=bless({$t,$PJ,$v,$QJ,$x,1078,$y,$z},$A);
$SJ={$he,$BJ,$CJ,$FJ,$GJ,$JJ,$KJ,$NJ,$OJ,$RJ};
$TJ=bless({$c,$xJ,$yJ,$SJ},$F7);
*$wD=\&$uD;
*$vD=\&$sD;
$r6->apply_unsafe($j5);
$r6->apply_unsafe($k5);
$r6->apply_unsafe($l5);
$r6->apply_unsafe($m5);
$r6->apply_unsafe($n5);
$r6->apply_unsafe($o5);
$r6->apply_unsafe($p5);
$r6->apply_unsafe($q5);
$r6->apply_unsafe($r5);
$r6->apply_unsafe($s5);
$r6->apply_unsafe($t5);
$r6->apply_unsafe($u5);
$r6->apply_unsafe($v5);
$r6->apply_unsafe($w5);
$r6->apply_unsafe($x5);
$r6->apply_unsafe($y5);
$r6->apply_unsafe($z5);
$r6->apply_unsafe($A5);
$r6->apply_unsafe($B5);
$r6->apply_unsafe($s6);
$r6->apply_unsafe($C5);
$r6->apply_unsafe($D5);
$r6->apply_unsafe($E5);
$r6->apply_unsafe($F5);
$r6->apply_unsafe($G5);
$r6->apply_unsafe($H5);
$r6->apply_unsafe($I5);
$r6->apply_unsafe($J5);
$r6->apply_unsafe($K5);
$r6->apply_unsafe($L5);
$r6->apply_unsafe($M5);
$r6->apply_unsafe($N5);
$r6->apply_unsafe($O5);
$r6->apply_unsafe($X5);
$r6->apply_unsafe($P5);
$r6->apply_unsafe($Y5);
$r6->apply_unsafe($Q5);
$r6->apply_unsafe($R5);
$r6->apply_unsafe($S5);
$r6->apply_unsafe($T5);
$r6->apply_unsafe($U5);
$B6->apply_unsafe($j5);
$B6->apply_unsafe($k5);
$B6->apply_unsafe($l5);
$B6->apply_unsafe($m5);
$B6->apply_unsafe($n5);
$B6->apply_unsafe($o5);
$B6->apply_unsafe($p5);
$B6->apply_unsafe($q5);
$B6->apply_unsafe($r5);
$B6->apply_unsafe($s5);
$B6->apply_unsafe($t5);
$B6->apply_unsafe($u5);
$B6->apply_unsafe($v5);
$B6->apply_unsafe($w5);
$B6->apply_unsafe($x5);
$B6->apply_unsafe($y5);
$B6->apply_unsafe($z5);
$B6->apply_unsafe($A5);
$B6->apply_unsafe($B5);
$B6->apply_unsafe($s6);
$B6->apply_unsafe($C5);
$B6->apply_unsafe($D5);
$B6->apply_unsafe($N);
$B6->apply_unsafe($E5);
$B6->apply_unsafe($F5);
$B6->apply_unsafe($G5);
$B6->apply_unsafe($H5);
$B6->apply_unsafe($I5);
$B6->apply_unsafe($q6);
$B6->apply_unsafe($J5);
$B6->apply_unsafe($C6);
$B6->apply_unsafe($K5);
$B6->apply_unsafe($L5);
$B6->apply_unsafe($M5);
$B6->apply_unsafe($N5);
$B6->apply_unsafe($O5);
$B6->apply_unsafe($X5);
$B6->apply_unsafe($P5);
$B6->apply_unsafe($Y5);
$B6->apply_unsafe($Q5);
$B6->apply_unsafe($R5);
$B6->apply_unsafe($S5);
$B6->apply_unsafe($T5);
$B6->apply_unsafe($U5);
$J6->apply_unsafe($j5);
$J6->apply_unsafe($k5);
$J6->apply_unsafe($l5);
$J6->apply_unsafe($m5);
$J6->apply_unsafe($n5);
$J6->apply_unsafe($o5);
$J6->apply_unsafe($p5);
$J6->apply_unsafe($q5);
$J6->apply_unsafe($r5);
$J6->apply_unsafe($s5);
$J6->apply_unsafe($t5);
$J6->apply_unsafe($u5);
$J6->apply_unsafe($v5);
$J6->apply_unsafe($w5);
$J6->apply_unsafe($x5);
$J6->apply_unsafe($y5);
$J6->apply_unsafe($z5);
$J6->apply_unsafe($A5);
$J6->apply_unsafe($B5);
$J6->apply_unsafe($s6);
$J6->apply_unsafe($C5);
$J6->apply_unsafe($D5);
$J6->apply_unsafe($E5);
$J6->apply_unsafe($F5);
$J6->apply_unsafe($G5);
$J6->apply_unsafe($H5);
$J6->apply_unsafe($I5);
$J6->apply_unsafe($q6);
$J6->apply_unsafe($J5);
$J6->apply_unsafe($C6);
$J6->apply_unsafe($K5);
$J6->apply_unsafe($L5);
$J6->apply_unsafe($M5);
$J6->apply_unsafe($N5);
$J6->apply_unsafe($O5);
$J6->apply_unsafe($X5);
$J6->apply_unsafe($P5);
$J6->apply_unsafe($Y5);
$J6->apply_unsafe($Q5);
$J6->apply_unsafe($R5);
$J6->apply_unsafe($S5);
$J6->apply_unsafe($T5);
$J6->apply_unsafe($U5);
$Q6->apply_unsafe($j5);
$Q6->apply_unsafe($k5);
$Q6->apply_unsafe($l5);
$Q6->apply_unsafe($m5);
$Q6->apply_unsafe($n5);
$Q6->apply_unsafe($o5);
$Q6->apply_unsafe($p5);
$Q6->apply_unsafe($q5);
$Q6->apply_unsafe($r5);
$Q6->apply_unsafe($s5);
$Q6->apply_unsafe($t5);
$Q6->apply_unsafe($u5);
$Q6->apply_unsafe($v5);
$Q6->apply_unsafe($w5);
$Q6->apply_unsafe($x5);
$Q6->apply_unsafe($y5);
$Q6->apply_unsafe($z5);
$Q6->apply_unsafe($A5);
$Q6->apply_unsafe($B5);
$Q6->apply_unsafe($s6);
$Q6->apply_unsafe($C5);
$Q6->apply_unsafe($D5);
$Q6->apply_unsafe($E5);
$Q6->apply_unsafe($F5);
$Q6->apply_unsafe($G5);
$Q6->apply_unsafe($H5);
$Q6->apply_unsafe($I5);
$Q6->apply_unsafe($q6);
$Q6->apply_unsafe($J5);
$Q6->apply_unsafe($C6);
$Q6->apply_unsafe($K5);
$Q6->apply_unsafe($L5);
$Q6->apply_unsafe($M5);
$Q6->apply_unsafe($N5);
$Q6->apply_unsafe($O5);
$Q6->apply_unsafe($X5);
$Q6->apply_unsafe($P5);
$Q6->apply_unsafe($Y5);
$Q6->apply_unsafe($Q5);
$Q6->apply_unsafe($R5);
$Q6->apply_unsafe($S5);
$Q6->apply_unsafe($T5);
$Q6->apply_unsafe($U5);
$X6->apply_unsafe($j5);
$X6->apply_unsafe($k5);
$X6->apply_unsafe($l5);
$X6->apply_unsafe($m5);
$X6->apply_unsafe($n5);
$X6->apply_unsafe($o5);
$X6->apply_unsafe($p5);
$X6->apply_unsafe($q5);
$X6->apply_unsafe($r5);
$X6->apply_unsafe($s5);
$X6->apply_unsafe($t5);
$X6->apply_unsafe($u5);
$X6->apply_unsafe($v5);
$X6->apply_unsafe($w5);
$X6->apply_unsafe($x5);
$X6->apply_unsafe($y5);
$X6->apply_unsafe($z5);
$X6->apply_unsafe($A5);
$X6->apply_unsafe($B5);
$X6->apply_unsafe($s6);
$X6->apply_unsafe($C5);
$X6->apply_unsafe($D5);
$X6->apply_unsafe($E5);
$X6->apply_unsafe($F5);
$X6->apply_unsafe($G5);
$X6->apply_unsafe($H5);
$X6->apply_unsafe($I5);
$X6->apply_unsafe($J5);
$X6->apply_unsafe($C6);
$X6->apply_unsafe($K5);
$X6->apply_unsafe($L5);
$X6->apply_unsafe($M5);
$X6->apply_unsafe($N5);
$X6->apply_unsafe($O5);
$X6->apply_unsafe($X5);
$X6->apply_unsafe($P5);
$X6->apply_unsafe($Y5);
$X6->apply_unsafe($Q5);
$X6->apply_unsafe($R5);
$X6->apply_unsafe($S5);
$X6->apply_unsafe($T5);
$X6->apply_unsafe($U5);
$l7->apply_unsafe($j5);
$l7->apply_unsafe($k5);
$l7->apply_unsafe($l5);
$l7->apply_unsafe($m5);
$l7->apply_unsafe($n5);
$l7->apply_unsafe($o5);
$l7->apply_unsafe($p5);
$l7->apply_unsafe($q5);
$l7->apply_unsafe($r5);
$l7->apply_unsafe($s5);
$l7->apply_unsafe($t5);
$l7->apply_unsafe($u5);
$l7->apply_unsafe($v5);
$l7->apply_unsafe($w5);
$l7->apply_unsafe($x5);
$l7->apply_unsafe($y5);
$l7->apply_unsafe($z5);
$l7->apply_unsafe($A5);
$l7->apply_unsafe($B5);
$l7->apply_unsafe($C5);
$l7->apply_unsafe($D5);
$l7->apply_unsafe($E5);
$l7->apply_unsafe($F5);
$l7->apply_unsafe($G5);
$l7->apply_unsafe($H5);
$l7->apply_unsafe($I5);
$l7->apply_unsafe($J5);
$l7->apply_unsafe($K5);
$l7->apply_unsafe($L5);
$l7->apply_unsafe($M5);
$l7->apply_unsafe($N5);
$l7->apply_unsafe($O5);
$l7->apply_unsafe($X5);
$l7->apply_unsafe($P5);
$l7->apply_unsafe($Y5);
$l7->apply_unsafe($Q5);
$l7->apply_unsafe($R5);
$l7->apply_unsafe($S5);
$l7->apply_unsafe($T5);
$l7->apply_unsafe($U5);
$W7->apply_unsafe($j5);
$W7->apply_unsafe($k5);
$W7->apply_unsafe($m7);
$W7->apply_unsafe($l5);
$W7->apply_unsafe($n7);
$W7->apply_unsafe($m5);
$W7->apply_unsafe($o7);
$W7->apply_unsafe($n5);
$W7->apply_unsafe($p7);
$W7->apply_unsafe($o5);
$W7->apply_unsafe($q7);
$W7->apply_unsafe($p5);
$W7->apply_unsafe($r7);
$W7->apply_unsafe($q5);
$W7->apply_unsafe($s7);
$W7->apply_unsafe($r5);
$W7->apply_unsafe($t7);
$W7->apply_unsafe($s5);
$W7->apply_unsafe($u7);
$W7->apply_unsafe($t5);
$W7->apply_unsafe($v7);
$W7->apply_unsafe($u5);
$W7->apply_unsafe($w7);
$W7->apply_unsafe($v5);
$W7->apply_unsafe($x7);
$W7->apply_unsafe($w5);
$W7->apply_unsafe($y7);
$W7->apply_unsafe($x5);
$W7->apply_unsafe($z7);
$W7->apply_unsafe($y5);
$W7->apply_unsafe($A7);
$W7->apply_unsafe($z5);
$W7->apply_unsafe($B7);
$W7->apply_unsafe($A5);
$W7->apply_unsafe($C7);
$W7->apply_unsafe($B5);
$W7->apply_unsafe($s6);
$W7->apply_unsafe($C5);
$W7->apply_unsafe($D7);
$W7->apply_unsafe($D5);
$W7->apply_unsafe($N);
$W7->apply_unsafe($E5);
$W7->apply_unsafe($A);
$W7->apply_unsafe($F5);
$W7->apply_unsafe($E7);
$W7->apply_unsafe($G5);
$W7->apply_unsafe($F7);
$W7->apply_unsafe($H5);
$W7->apply_unsafe($G7);
$W7->apply_unsafe($I5);
$W7->apply_unsafe($q6);
$W7->apply_unsafe($J5);
$W7->apply_unsafe($C6);
$W7->apply_unsafe($K5);
$W7->apply_unsafe($H7);
$W7->apply_unsafe($L5);
$W7->apply_unsafe($I7);
$W7->apply_unsafe($M5);
$W7->apply_unsafe($D);
$W7->apply_unsafe($N5);
$W7->apply_unsafe($J7);
$W7->apply_unsafe($O5);
$W7->apply_unsafe($X5);
$W7->apply_unsafe($P5);
$W7->apply_unsafe($Y5);
$W7->apply_unsafe($Q5);
$W7->apply_unsafe($K7);
$W7->apply_unsafe($R5);
$W7->apply_unsafe($S5);
$W7->apply_unsafe($T5);
$W7->apply_unsafe($L7);
$W7->apply_unsafe($U5);
$j8->apply_unsafe($j5);
$j8->apply_unsafe($k5);
$j8->apply_unsafe($l5);
$j8->apply_unsafe($m5);
$j8->apply_unsafe($n5);
$j8->apply_unsafe($o5);
$j8->apply_unsafe($p5);
$j8->apply_unsafe($q5);
$j8->apply_unsafe($r5);
$j8->apply_unsafe($s5);
$j8->apply_unsafe($t5);
$j8->apply_unsafe($u5);
$j8->apply_unsafe($v5);
$j8->apply_unsafe($w5);
$j8->apply_unsafe($x5);
$j8->apply_unsafe($y5);
$j8->apply_unsafe($z5);
$j8->apply_unsafe($A5);
$j8->apply_unsafe($C7);
$j8->apply_unsafe($B5);
$j8->apply_unsafe($s6);
$j8->apply_unsafe($C5);
$j8->apply_unsafe($D7);
$j8->apply_unsafe($D5);
$j8->apply_unsafe($E5);
$j8->apply_unsafe($F5);
$j8->apply_unsafe($G5);
$j8->apply_unsafe($H5);
$j8->apply_unsafe($I5);
$j8->apply_unsafe($q6);
$j8->apply_unsafe($J5);
$j8->apply_unsafe($C6);
$j8->apply_unsafe($K5);
$j8->apply_unsafe($L5);
$j8->apply_unsafe($M5);
$j8->apply_unsafe($N5);
$j8->apply_unsafe($O5);
$j8->apply_unsafe($X5);
$j8->apply_unsafe($P5);
$j8->apply_unsafe($Y5);
$j8->apply_unsafe($Q5);
$j8->apply_unsafe($R5);
$j8->apply_unsafe($S5);
$j8->apply_unsafe($T5);
$j8->apply_unsafe($U5);
$v8->apply_unsafe($j5);
$v8->apply_unsafe($k5);
$v8->apply_unsafe($l5);
$v8->apply_unsafe($m5);
$v8->apply_unsafe($n5);
$v8->apply_unsafe($o5);
$v8->apply_unsafe($p5);
$v8->apply_unsafe($q5);
$v8->apply_unsafe($r5);
$v8->apply_unsafe($s5);
$v8->apply_unsafe($t5);
$v8->apply_unsafe($u5);
$v8->apply_unsafe($v5);
$v8->apply_unsafe($w5);
$v8->apply_unsafe($x5);
$v8->apply_unsafe($y5);
$v8->apply_unsafe($z5);
$v8->apply_unsafe($A5);
$v8->apply_unsafe($B5);
$v8->apply_unsafe($s6);
$v8->apply_unsafe($C5);
$v8->apply_unsafe($D5);
$v8->apply_unsafe($E5);
$v8->apply_unsafe($F5);
$v8->apply_unsafe($G5);
$v8->apply_unsafe($H5);
$v8->apply_unsafe($I5);
$v8->apply_unsafe($J5);
$v8->apply_unsafe($K5);
$v8->apply_unsafe($L5);
$v8->apply_unsafe($M5);
$v8->apply_unsafe($N5);
$v8->apply_unsafe($O5);
$v8->apply_unsafe($X5);
$v8->apply_unsafe($P5);
$v8->apply_unsafe($Y5);
$v8->apply_unsafe($Q5);
$v8->apply_unsafe($R5);
$v8->apply_unsafe($S5);
$v8->apply_unsafe($T5);
$v8->apply_unsafe($U5);
$F8->apply_unsafe($j5);
$F8->apply_unsafe($k5);
$F8->apply_unsafe($l5);
$F8->apply_unsafe($m5);
$F8->apply_unsafe($n5);
$F8->apply_unsafe($o5);
$F8->apply_unsafe($p5);
$F8->apply_unsafe($q5);
$F8->apply_unsafe($r5);
$F8->apply_unsafe($s5);
$F8->apply_unsafe($t5);
$F8->apply_unsafe($u5);
$F8->apply_unsafe($v5);
$F8->apply_unsafe($w5);
$F8->apply_unsafe($x5);
$F8->apply_unsafe($y5);
$F8->apply_unsafe($z5);
$F8->apply_unsafe($A5);
$F8->apply_unsafe($B5);
$F8->apply_unsafe($s6);
$F8->apply_unsafe($C5);
$F8->apply_unsafe($D5);
$F8->apply_unsafe($E5);
$F8->apply_unsafe($F5);
$F8->apply_unsafe($G5);
$F8->apply_unsafe($H5);
$F8->apply_unsafe($I5);
$F8->apply_unsafe($J5);
$F8->apply_unsafe($K5);
$F8->apply_unsafe($L5);
$F8->apply_unsafe($M5);
$F8->apply_unsafe($N5);
$F8->apply_unsafe($O5);
$F8->apply_unsafe($X5);
$F8->apply_unsafe($P5);
$F8->apply_unsafe($Y5);
$F8->apply_unsafe($Q5);
$F8->apply_unsafe($R5);
$F8->apply_unsafe($S5);
$F8->apply_unsafe($T5);
$F8->apply_unsafe($U5);
$M8->apply_unsafe($j5);
$M8->apply_unsafe($k5);
$M8->apply_unsafe($l5);
$M8->apply_unsafe($m5);
$M8->apply_unsafe($n5);
$M8->apply_unsafe($o5);
$M8->apply_unsafe($p5);
$M8->apply_unsafe($q5);
$M8->apply_unsafe($r5);
$M8->apply_unsafe($s5);
$M8->apply_unsafe($t5);
$M8->apply_unsafe($u5);
$M8->apply_unsafe($v5);
$M8->apply_unsafe($w5);
$M8->apply_unsafe($x5);
$M8->apply_unsafe($y5);
$M8->apply_unsafe($z5);
$M8->apply_unsafe($A5);
$M8->apply_unsafe($B5);
$M8->apply_unsafe($s6);
$M8->apply_unsafe($C5);
$M8->apply_unsafe($D5);
$M8->apply_unsafe($E5);
$M8->apply_unsafe($F5);
$M8->apply_unsafe($G5);
$M8->apply_unsafe($H5);
$M8->apply_unsafe($I5);
$M8->apply_unsafe($J5);
$M8->apply_unsafe($K5);
$M8->apply_unsafe($L5);
$M8->apply_unsafe($M5);
$M8->apply_unsafe($N5);
$M8->apply_unsafe($O5);
$M8->apply_unsafe($X5);
$M8->apply_unsafe($P5);
$M8->apply_unsafe($Y5);
$M8->apply_unsafe($Q5);
$M8->apply_unsafe($R5);
$M8->apply_unsafe($S5);
$M8->apply_unsafe($T5);
$M8->apply_unsafe($U5);
$T8->apply_unsafe($j5);
$T8->apply_unsafe($k5);
$T8->apply_unsafe($l5);
$T8->apply_unsafe($m5);
$T8->apply_unsafe($n5);
$T8->apply_unsafe($o5);
$T8->apply_unsafe($p5);
$T8->apply_unsafe($q5);
$T8->apply_unsafe($r5);
$T8->apply_unsafe($s5);
$T8->apply_unsafe($t5);
$T8->apply_unsafe($u5);
$T8->apply_unsafe($v5);
$T8->apply_unsafe($w5);
$T8->apply_unsafe($x5);
$T8->apply_unsafe($y5);
$T8->apply_unsafe($z5);
$T8->apply_unsafe($A5);
$T8->apply_unsafe($B5);
$T8->apply_unsafe($s6);
$T8->apply_unsafe($C5);
$T8->apply_unsafe($D5);
$T8->apply_unsafe($E5);
$T8->apply_unsafe($F5);
$T8->apply_unsafe($G5);
$T8->apply_unsafe($H5);
$T8->apply_unsafe($I5);
$T8->apply_unsafe($J5);
$T8->apply_unsafe($K5);
$T8->apply_unsafe($L5);
$T8->apply_unsafe($M5);
$T8->apply_unsafe($N5);
$T8->apply_unsafe($O5);
$T8->apply_unsafe($X5);
$T8->apply_unsafe($P5);
$T8->apply_unsafe($Y5);
$T8->apply_unsafe($Q5);
$T8->apply_unsafe($R5);
$T8->apply_unsafe($S5);
$T8->apply_unsafe($T5);
$T8->apply_unsafe($U5);
$c9->apply_unsafe($j5);
$c9->apply_unsafe($k5);
$c9->apply_unsafe($l5);
$c9->apply_unsafe($m5);
$c9->apply_unsafe($n5);
$c9->apply_unsafe($o5);
$c9->apply_unsafe($p5);
$c9->apply_unsafe($q5);
$c9->apply_unsafe($r5);
$c9->apply_unsafe($s5);
$c9->apply_unsafe($t5);
$c9->apply_unsafe($u5);
$c9->apply_unsafe($v5);
$c9->apply_unsafe($w5);
$c9->apply_unsafe($x5);
$c9->apply_unsafe($y5);
$c9->apply_unsafe($z5);
$c9->apply_unsafe($A5);
$c9->apply_unsafe($B5);
$c9->apply_unsafe($s6);
$c9->apply_unsafe($C5);
$c9->apply_unsafe($D5);
$c9->apply_unsafe($E5);
$c9->apply_unsafe($F5);
$c9->apply_unsafe($G5);
$c9->apply_unsafe($H5);
$c9->apply_unsafe($I5);
$c9->apply_unsafe($J5);
$c9->apply_unsafe($K5);
$c9->apply_unsafe($L5);
$c9->apply_unsafe($M5);
$c9->apply_unsafe($N5);
$c9->apply_unsafe($O5);
$c9->apply_unsafe($X5);
$c9->apply_unsafe($P5);
$c9->apply_unsafe($Y5);
$c9->apply_unsafe($Q5);
$c9->apply_unsafe($R5);
$c9->apply_unsafe($S5);
$c9->apply_unsafe($T5);
$c9->apply_unsafe($U5);
$p9->apply_unsafe($j5);
$p9->apply_unsafe($k5);
$p9->apply_unsafe($l5);
$p9->apply_unsafe($m5);
$p9->apply_unsafe($n5);
$p9->apply_unsafe($o5);
$p9->apply_unsafe($p5);
$p9->apply_unsafe($q5);
$p9->apply_unsafe($r5);
$p9->apply_unsafe($s5);
$p9->apply_unsafe($t5);
$p9->apply_unsafe($u5);
$p9->apply_unsafe($v5);
$p9->apply_unsafe($w5);
$p9->apply_unsafe($x5);
$p9->apply_unsafe($y5);
$p9->apply_unsafe($z5);
$p9->apply_unsafe($A5);
$p9->apply_unsafe($B5);
$p9->apply_unsafe($C5);
$p9->apply_unsafe($D5);
$p9->apply_unsafe($E5);
$p9->apply_unsafe($A);
$p9->apply_unsafe($F5);
$p9->apply_unsafe($G5);
$p9->apply_unsafe($H5);
$p9->apply_unsafe($I5);
$p9->apply_unsafe($q6);
$p9->apply_unsafe($J5);
$p9->apply_unsafe($C6);
$p9->apply_unsafe($K5);
$p9->apply_unsafe($L5);
$p9->apply_unsafe($M5);
$p9->apply_unsafe($N5);
$p9->apply_unsafe($O5);
$p9->apply_unsafe($X5);
$p9->apply_unsafe($P5);
$p9->apply_unsafe($Q5);
$p9->apply_unsafe($R5);
$p9->apply_unsafe($S5);
$p9->apply_unsafe($T5);
$p9->apply_unsafe($U5);
$w9->apply_unsafe($j5);
$w9->apply_unsafe($k5);
$w9->apply_unsafe($l5);
$w9->apply_unsafe($m5);
$w9->apply_unsafe($n5);
$w9->apply_unsafe($o5);
$w9->apply_unsafe($p5);
$w9->apply_unsafe($q5);
$w9->apply_unsafe($r5);
$w9->apply_unsafe($s5);
$w9->apply_unsafe($t5);
$w9->apply_unsafe($u5);
$w9->apply_unsafe($v5);
$w9->apply_unsafe($w5);
$w9->apply_unsafe($x5);
$w9->apply_unsafe($y5);
$w9->apply_unsafe($z5);
$w9->apply_unsafe($A5);
$w9->apply_unsafe($B5);
$w9->apply_unsafe($C5);
$w9->apply_unsafe($D5);
$w9->apply_unsafe($E5);
$w9->apply_unsafe($F5);
$w9->apply_unsafe($G5);
$w9->apply_unsafe($H5);
$w9->apply_unsafe($I5);
$w9->apply_unsafe($J5);
$w9->apply_unsafe($K5);
$w9->apply_unsafe($L5);
$w9->apply_unsafe($M5);
$w9->apply_unsafe($N5);
$w9->apply_unsafe($O5);
$w9->apply_unsafe($P5);
$w9->apply_unsafe($Q5);
$w9->apply_unsafe($R5);
$w9->apply_unsafe($S5);
$w9->apply_unsafe($T5);
$w9->apply_unsafe($U5);
$ca->apply_unsafe($m7);
$wa->apply_unsafe($n7);
$wa->apply_unsafe($o7);
$wa->apply_unsafe($p7);
$wa->apply_unsafe($q7);
$wa->apply_unsafe($r7);
$wa->apply_unsafe($s7);
$wa->apply_unsafe($t7);
$wa->apply_unsafe($u7);
$wa->apply_unsafe($v7);
$wa->apply_unsafe($w7);
$wa->apply_unsafe($x7);
$wa->apply_unsafe($y7);
$Qa->apply_unsafe($n7);
$Qa->apply_unsafe($o7);
$Qa->apply_unsafe($p7);
$Qa->apply_unsafe($q7);
$Qa->apply_unsafe($r7);
$Qa->apply_unsafe($s7);
$Qa->apply_unsafe($t7);
$Qa->apply_unsafe($u7);
$Qa->apply_unsafe($v7);
$Qa->apply_unsafe($w7);
$Qa->apply_unsafe($x7);
$Qa->apply_unsafe($y7);
$Ya->apply_unsafe($n7);
$Ya->apply_unsafe($o7);
$Ya->apply_unsafe($p7);
$Ya->apply_unsafe($q7);
$Ya->apply_unsafe($r7);
$Ya->apply_unsafe($s7);
$Ya->apply_unsafe($t7);
$Ya->apply_unsafe($u7);
$Ya->apply_unsafe($v7);
$Ya->apply_unsafe($w7);
$Ya->apply_unsafe($x7);
$Ya->apply_unsafe($y7);
$mb->apply_unsafe($n7);
$mb->apply_unsafe($o7);
$mb->apply_unsafe($p7);
$mb->apply_unsafe($q7);
$mb->apply_unsafe($r7);
$mb->apply_unsafe($s7);
$mb->apply_unsafe($t7);
$mb->apply_unsafe($u7);
$mb->apply_unsafe($v7);
$mb->apply_unsafe($w7);
$mb->apply_unsafe($x7);
$mb->apply_unsafe($y7);
$yb->apply_unsafe($n7);
$yb->apply_unsafe($o7);
$yb->apply_unsafe($p7);
$yb->apply_unsafe($q7);
$yb->apply_unsafe($r7);
$yb->apply_unsafe($s7);
$yb->apply_unsafe($t7);
$yb->apply_unsafe($u7);
$yb->apply_unsafe($v7);
$yb->apply_unsafe($w7);
$yb->apply_unsafe($x7);
$yb->apply_unsafe($y7);
$Kb->apply_unsafe($n7);
$Kb->apply_unsafe($o7);
$Kb->apply_unsafe($p7);
$Kb->apply_unsafe($q7);
$Kb->apply_unsafe($r7);
$Kb->apply_unsafe($s7);
$Kb->apply_unsafe($t7);
$Kb->apply_unsafe($u7);
$Kb->apply_unsafe($v7);
$Kb->apply_unsafe($w7);
$Kb->apply_unsafe($x7);
$Kb->apply_unsafe($y7);
$Ub->apply_unsafe($n7);
$qc->apply_unsafe($n7);
$Gc->apply_unsafe($m5);
$Gc->apply_unsafe($n5);
$Gc->apply_unsafe($o5);
$Gc->apply_unsafe($p5);
$Gc->apply_unsafe($q5);
$Gc->apply_unsafe($r5);
$Gc->apply_unsafe($s5);
$Gc->apply_unsafe($t5);
$Gc->apply_unsafe($u5);
$Gc->apply_unsafe($v5);
$Gc->apply_unsafe($w5);
$Gc->apply_unsafe($x5);
$Vc->apply_unsafe($o7);
$ed->apply_unsafe($o7);
$yd->apply_unsafe($p7);
$Fd->apply_unsafe($p7);
$Zd->apply_unsafe($p7);
$ze->apply_unsafe($p7);
$He->apply_unsafe($p7);
$Xe->apply_unsafe($p7);
$wf->apply_unsafe($q7);
$wf->apply_unsafe($s7);
$Df->apply_unsafe($q7);
$Lf->apply_unsafe($q7);
$dg->apply_unsafe($q7);
$dg->apply_unsafe($s7);
$og->apply_unsafe($q7);
$yg->apply_unsafe($q7);
$yg->apply_unsafe($s7);
$Vg->apply_unsafe($r7);
$fh->apply_unsafe($r7);
$mh->apply_unsafe($r7);
$Ch->apply_unsafe($r7);
$Kh->apply_unsafe($r7);
$hi->apply_unsafe($r7);
$Ei->apply_unsafe($s7);
$Ni->apply_unsafe($s7);
$nj->apply_unsafe($t7);
$uj->apply_unsafe($t7);
$Cj->apply_unsafe($t7);
$Pj->apply_unsafe($t7);
$hk->apply_unsafe($t7);
$Hk->apply_unsafe($u7);
$Ok->apply_unsafe($u7);
$Uk->apply_unsafe($u7);
$jl->apply_unsafe($u7);
$Ul->apply_unsafe($Vl);
$hm->apply_unsafe($v7);
$um->apply_unsafe($v7);
$dn->apply_unsafe($x7);
$nn->apply_unsafe($x7);
$zn->apply_unsafe($x7);
$Jn->apply_unsafe($x7);
$Zn->apply_unsafe($x7);
$Ho->apply_unsafe($y7);
$Oo->apply_unsafe($y7);
$ep->apply_unsafe($y7);
$Bp->apply_unsafe($z7);
$Bp->apply_unsafe($A7);
$Bp->apply_unsafe($B7);
$Bp->apply_unsafe($L7);
$Np->apply_unsafe($z7);
$Np->apply_unsafe($A7);
$Np->apply_unsafe($B7);
$Np->apply_unsafe($L7);
$fq->apply_unsafe($z7);
$fq->apply_unsafe($A7);
$fq->apply_unsafe($B7);
$zq->apply_unsafe($z7);
$zq->apply_unsafe($A7);
$zq->apply_unsafe($B7);
$Qq->apply_unsafe($y5);
$Qq->apply_unsafe($z5);
$Qq->apply_unsafe($A5);
$mr->apply_unsafe($A7);
$tr->apply_unsafe($A7);
$Dr->apply_unsafe($A7);
$Pr->apply_unsafe($A7);
$ts->apply_unsafe($z5);
$Ms->apply_unsafe($B7);
$Ts->apply_unsafe($B7);
$rt->apply_unsafe($s6);
$Lt->apply_unsafe($D7);
$Rt->apply_unsafe($D7);
$ou->apply_unsafe($N);
$uu->apply_unsafe($N);
$Bu->apply_unsafe($N);
$Ku->apply_unsafe($N);
$Wu->apply_unsafe($N);
$Cv->apply_unsafe($A);
$Tv->apply_unsafe($A);
$ew->apply_unsafe($A);
$mw->apply_unsafe($A);
$Dw->apply_unsafe($F5);
$Tw->apply_unsafe($E7);
$ix->apply_unsafe($Vl);
$rx->apply_unsafe($E7);
$gy->apply_unsafe($E7);
$oy->apply_unsafe($E7);
$oy->apply_unsafe($G7);
$My->apply_unsafe($E7);
$My->apply_unsafe($G7);
$ez->apply_unsafe($E7);
$ez->apply_unsafe($G7);
$uz->apply_unsafe($E7);
$hA->apply_unsafe($iA);
$BA->apply_unsafe($F7);
$TA->apply_unsafe($F7);
$eB->apply_unsafe($F7);
$oB->apply_unsafe($F7);
$DC->apply_unsafe($iA);
$QC->apply_unsafe($G7);
$ZC->apply_unsafe($G7);
$BD->apply_unsafe($q6);
$HD->apply_unsafe($q6);
$OD->apply_unsafe($q6);
$nE->apply_unsafe($Vl);
$xE->apply_unsafe($C6);
$DE->apply_unsafe($C6);
$cF->apply_unsafe($H7);
$cF->apply_unsafe($I7);
$mF->apply_unsafe($H7);
$AF->apply_unsafe($H7);
$hG->apply_unsafe($D);
$oG->apply_unsafe($D);
$vG->apply_unsafe($D);
$FG->apply_unsafe($D);
$QG->apply_unsafe($D);
$fH->apply_unsafe($N5);
$qH->apply_unsafe($N5);
$JH->apply_unsafe($J7);
$VH->apply_unsafe($J7);
$eI->apply_unsafe($J7);
$ni::self=$TJ;
&$_($B)for@$C;
&$_($O)for@$P;
&$_($V)for@$P;
&$_($Z)for@$P;
&$_($h1)for@$P;
&$_($p1)for@$C;
&$_($u1)for@$P;
&$_($C1)for@$C;
&$_($H1)for@$P;
&$_($P1)for@$C;
&$_($U1)for@$P;
&$_($e2)for@$C;
&$_($j2)for@$P;
&$_($u2)for@$C;
&$_($A2)for@$C;
&$_($F2)for@$P;
&$_($L2)for@$P;
&$_($U2)for@$P;
&$_($c3)for@$P;
&$_($i3)for@$C;
&$_($o3)for@$C;
&$_($u3)for@$C;
&$_($z3)for@$P;
&$_($G3)for@$P;
&$_($P3)for@$C;
&$_($V3)for@$C;
&$_($c4)for@$P;
&$_($k4)for@$P;
&$_($s4)for@$P;
&$_($y4)for@$C;
&$_($D4)for@$P;
&$_($M4)for@$C;
&$_($T4)for@$C;
&$_($Y4)for@$P;
&$_($g5)for@$P;
&$_($k6)for@$C;
&$_($n6)for@$C;
&$_($r6)for@$t6;
&$_($w6)for@$C;
&$_($y6)for@$C;
&$_($B6)for@$t6;
&$_($G6)for@$C;
&$_($J6)for@$t6;
&$_($N6)for@$C;
&$_($Q6)for@$t6;
&$_($U6)for@$C;
&$_($X6)for@$t6;
&$_($Z6)for@$c7;
&$_($f7)for@$C;
&$_($i7)for@$C;
&$_($l7)for@$t6;
&$_($R7)for@$C;
&$_($T7)for@$C;
&$_($W7)for@$t6;
&$_($Y7)for@$Z7;
&$_($g8)for@$C;
&$_($j8)for@$t6;
&$_($l8)for@$m8;
&$_($s8)for@$C;
&$_($v8)for@$t6;
&$_($z8)for@$C;
&$_($C8)for@$C;
&$_($F8)for@$t6;
&$_($J8)for@$C;
&$_($M8)for@$t6;
&$_($Q8)for@$C;
&$_($T8)for@$t6;
&$_($X8)for@$C;
&$_($c9)for@$t6;
&$_($e9)for@$f9;
&$_($h9)for@$i9;
&$_($m9)for@$C;
&$_($p9)for@$t6;
&$_($t9)for@$C;
&$_($w9)for@$t6;
&$_($y9)for@$z9;
&$_($I9)for@$J9;
&$_($N9)for@$J9;
&$_($P9)for@$J9;
&$_($R9)for@$J9;
&$_($X9)for@$C;
&$_($ca)for@$t6;
&$_($ea)for@$fa;
&$_($ka)for@$J9;
&$_($ta)for@$C;
&$_($wa)for@$t6;
&$_($Ba)for@$C;
&$_($Fa)for@$C;
&$_($Ja)for@$C;
&$_($Na)for@$C;
&$_($Qa)for@$t6;
&$_($Va)for@$C;
&$_($Ya)for@$t6;
&$_($fb)for@$C;
&$_($jb)for@$C;
&$_($mb)for@$t6;
&$_($rb)for@$C;
&$_($vb)for@$C;
&$_($yb)for@$t6;
&$_($Db)for@$C;
&$_($Hb)for@$C;
&$_($Kb)for@$t6;
&$_($Mb)for@$Nb;
&$_($Rb)for@$C;
&$_($Ub)for@$t6;
&$_($Zb)for@$C;
&$_($fc)for@$C;
&$_($jc)for@$C;
&$_($nc)for@$C;
&$_($qc)for@$t6;
&$_($sc)for@$tc;
&$_($Dc)for@$C;
&$_($Gc)for@$t6;
&$_($Ic)for@$J9;
&$_($Kc)for@$J9;
&$_($Sc)for@$C;
&$_($Vc)for@$t6;
&$_($Zc)for@$C;
&$_($ed)for@$t6;
&$_($gd)for@$hd;
&$_($md)for@$J9;
&$_($vd)for@$C;
&$_($yd)for@$t6;
&$_($Cd)for@$C;
&$_($Fd)for@$t6;
&$_($Kd)for@$C;
&$_($Od)for@$C;
&$_($Sd)for@$C;
&$_($Wd)for@$C;
&$_($Zd)for@$t6;
&$_($ge)for@$C;
&$_($ke)for@$C;
&$_($oe)for@$C;
&$_($se)for@$C;
&$_($we)for@$C;
&$_($ze)for@$t6;
&$_($Ee)for@$C;
&$_($He)for@$t6;
&$_($Me)for@$C;
&$_($Qe)for@$C;
&$_($Ue)for@$C;
&$_($Xe)for@$t6;
&$_($Ze)for@$cf;
&$_($hf)for@$J9;
&$_($tf)for@$C;
&$_($wf)for@$t6;
&$_($Af)for@$C;
&$_($Df)for@$t6;
&$_($If)for@$C;
&$_($Lf)for@$t6;
&$_($Qf)for@$C;
&$_($Uf)for@$C;
&$_($Yf)for@$C;
&$_($dg)for@$t6;
&$_($hg)for@$C;
&$_($lg)for@$C;
&$_($og)for@$t6;
&$_($sg)for@$C;
&$_($vg)for@$C;
&$_($yg)for@$t6;
&$_($Ag)for@$Bg;
&$_($Gg)for@$J9;
&$_($Sg)for@$C;
&$_($Vg)for@$t6;
&$_($ch)for@$C;
&$_($fh)for@$t6;
&$_($jh)for@$C;
&$_($mh)for@$t6;
&$_($rh)for@$C;
&$_($vh)for@$C;
&$_($zh)for@$C;
&$_($Ch)for@$t6;
&$_($Hh)for@$C;
&$_($Kh)for@$t6;
&$_($Oh)for@$C;
&$_($Sh)for@$C;
&$_($Vh)for@$C;
&$_($Zh)for@$C;
&$_($ei)for@$C;
&$_($hi)for@$t6;
&$_($ji)for@$ki;
&$_($pi)for@$J9;
&$_($Bi)for@$C;
&$_($Ei)for@$t6;
&$_($Hi)for@$C;
&$_($Ki)for@$C;
&$_($Ni)for@$t6;
&$_($Pi)for@$Qi;
&$_($Vi)for@$J9;
&$_($gj)for@$C;
&$_($kj)for@$C;
&$_($nj)for@$t6;
&$_($rj)for@$C;
&$_($uj)for@$t6;
&$_($zj)for@$C;
&$_($Cj)for@$t6;
&$_($Gj)for@$C;
&$_($Jj)for@$C;
&$_($Mj)for@$C;
&$_($Pj)for@$t6;
&$_($Uj)for@$C;
&$_($Yj)for@$C;
&$_($ek)for@$C;
&$_($hk)for@$t6;
&$_($jk)for@$kk;
&$_($pk)for@$J9;
&$_($wk)for@$C;
&$_($Ak)for@$C;
&$_($Ek)for@$C;
&$_($Hk)for@$t6;
&$_($Lk)for@$C;
&$_($Ok)for@$t6;
&$_($Rk)for@$C;
&$_($Uk)for@$t6;
&$_($Yk)for@$C;
&$_($dl)for@$C;
&$_($gl)for@$C;
&$_($jl)for@$t6;
&$_($ll)for@$ml;
&$_($sl)for@$J9;
&$_($Gl)for@$C;
&$_($Jl)for@$C;
&$_($Nl)for@$C;
&$_($Rl)for@$C;
&$_($Ul)for@$t6;
&$_($em)for@$C;
&$_($hm)for@$t6;
&$_($lm)for@$C;
&$_($om)for@$C;
&$_($rm)for@$C;
&$_($um)for@$t6;
&$_($wm)for@$xm;
&$_($Cm)for@$J9;
&$_($Um)for@$C;
&$_($Ym)for@$C;
&$_($dn)for@$t6;
&$_($hn)for@$C;
&$_($kn)for@$C;
&$_($nn)for@$t6;
&$_($sn)for@$C;
&$_($wn)for@$C;
&$_($zn)for@$t6;
&$_($Dn)for@$C;
&$_($Gn)for@$C;
&$_($Jn)for@$t6;
&$_($Nn)for@$C;
&$_($Qn)for@$C;
&$_($Tn)for@$C;
&$_($Wn)for@$C;
&$_($Zn)for@$t6;
&$_($do)for@$eo;
&$_($jo)for@$J9;
&$_($wo)for@$C;
&$_($Ao)for@$C;
&$_($Eo)for@$C;
&$_($Ho)for@$t6;
&$_($Lo)for@$C;
&$_($Oo)for@$t6;
&$_($So)for@$C;
&$_($Wo)for@$C;
&$_($Zo)for@$C;
&$_($ep)for@$t6;
&$_($gp)for@$hp;
&$_($mp)for@$J9;
&$_($yp)for@$C;
&$_($Bp)for@$t6;
&$_($Gp)for@$C;
&$_($Kp)for@$C;
&$_($Np)for@$t6;
&$_($Pp)for@$Qp;
&$_($Up)for@$C;
&$_($Xp)for@$C;
&$_($cq)for@$C;
&$_($fq)for@$t6;
&$_($kq)for@$C;
&$_($oq)for@$C;
&$_($sq)for@$C;
&$_($wq)for@$C;
&$_($zq)for@$t6;
&$_($Bq)for@$Cq;
&$_($Jq)for@$J9;
&$_($Nq)for@$C;
&$_($Qq)for@$t6;
&$_($Sq)for@$J9;
&$_($dr)for@$C;
&$_($fr)for@$C;
&$_($jr)for@$C;
&$_($mr)for@$t6;
&$_($qr)for@$C;
&$_($tr)for@$t6;
&$_($xr)for@$C;
&$_($Ar)for@$C;
&$_($Dr)for@$t6;
&$_($Ir)for@$C;
&$_($Mr)for@$C;
&$_($Pr)for@$t6;
&$_($Ur)for@$Vr;
&$_($es)for@$C;
&$_($is)for@$C;
&$_($ms)for@$C;
&$_($qs)for@$C;
&$_($ts)for@$t6;
&$_($vs)for@$J9;
&$_($Js)for@$C;
&$_($Ms)for@$t6;
&$_($Qs)for@$C;
&$_($Ts)for@$t6;
&$_($Vs)for@$Ws;
&$_($dt)for@$J9;
&$_($ot)for@$C;
&$_($rt)for@$t6;
&$_($tt)for@$ut;
&$_($At)for@$J9;
&$_($It)for@$C;
&$_($Lt)for@$t6;
&$_($Ot)for@$C;
&$_($Rt)for@$t6;
&$_($Tt)for@$Ut;
&$_($Zt)for@$J9;
&$_($lu)for@$C;
&$_($ou)for@$t6;
&$_($ru)for@$C;
&$_($uu)for@$t6;
&$_($yu)for@$C;
&$_($Bu)for@$t6;
&$_($Eu)for@$C;
&$_($Hu)for@$C;
&$_($Ku)for@$t6;
&$_($Nu)for@$C;
&$_($Qu)for@$C;
&$_($Tu)for@$C;
&$_($Wu)for@$t6;
&$_($Yu)for@$Zu;
&$_($gv)for@$J9;
&$_($sv)for@$C;
&$_($uv)for@$C;
&$_($xv)for@$C;
&$_($zv)for@$C;
&$_($Cv)for@$t6;
&$_($Gv)for@$C;
&$_($Jv)for@$C;
&$_($Mv)for@$C;
&$_($Qv)for@$C;
&$_($Tv)for@$t6;
&$_($Xv)for@$C;
&$_($Zv)for@$C;
&$_($ew)for@$t6;
&$_($jw)for@$C;
&$_($mw)for@$t6;
&$_($ow)for@$pw;
&$_($ww)for@$C;
&$_($Aw)for@$C;
&$_($Dw)for@$t6;
&$_($Fw)for@$J9;
&$_($Qw)for@$C;
&$_($Tw)for@$t6;
&$_($Zw)for@$C;
&$_($fx)for@$C;
&$_($ix)for@$t6;
&$_($ox)for@$C;
&$_($rx)for@$t6;
&$_($wx)for@$C;
&$_($Ax)for@$C;
&$_($Ex)for@$C;
&$_($Ix)for@$C;
&$_($Mx)for@$C;
&$_($Qx)for@$C;
&$_($Ux)for@$C;
&$_($Yx)for@$C;
&$_($dy)for@$C;
&$_($gy)for@$t6;
&$_($ly)for@$C;
&$_($oy)for@$t6;
&$_($ty)for@$C;
&$_($xy)for@$C;
&$_($By)for@$C;
&$_($Fy)for@$C;
&$_($Jy)for@$C;
&$_($My)for@$t6;
&$_($Ry)for@$C;
&$_($Vy)for@$C;
&$_($Zy)for@$C;
&$_($ez)for@$t6;
&$_($jz)for@$C;
&$_($nz)for@$C;
&$_($rz)for@$C;
&$_($uz)for@$t6;
&$_($wz)for@$xz;
&$_($Cz)for@$J9;
&$_($Mz)for@$C;
&$_($Qz)for@$C;
&$_($Uz)for@$C;
&$_($Yz)for@$C;
&$_($eA)for@$C;
&$_($hA)for@$t6;
&$_($sA)for@$C;
&$_($vA)for@$C;
&$_($yA)for@$C;
&$_($BA)for@$t6;
&$_($FA)for@$C;
&$_($IA)for@$C;
&$_($LA)for@$C;
&$_($OA)for@$C;
&$_($QA)for@$C;
&$_($TA)for@$t6;
&$_($WA)for@$C;
&$_($ZA)for@$C;
&$_($eB)for@$t6;
&$_($iB)for@$C;
&$_($lB)for@$C;
&$_($oB)for@$t6;
&$_($qB)for@$rB;
&$_($wB)for@$J9;
&$_($GB)for@$C;
&$_($KB)for@$C;
&$_($OB)for@$C;
&$_($SB)for@$C;
&$_($WB)for@$C;
&$_($cC)for@$C;
&$_($gC)for@$C;
&$_($kC)for@$C;
&$_($oC)for@$C;
&$_($sC)for@$C;
&$_($wC)for@$C;
&$_($AC)for@$C;
&$_($DC)for@$t6;
&$_($NC)for@$C;
&$_($QC)for@$t6;
&$_($TC)for@$C;
&$_($WC)for@$C;
&$_($ZC)for@$t6;
&$_($dD)for@$eD;
&$_($jD)for@$J9;
&$_($sD)for@$C;
&$_($uD)for@$C;
&$_($BD)for@$t6;
&$_($ED)for@$C;
&$_($HD)for@$t6;
&$_($LD)for@$C;
&$_($OD)for@$t6;
&$_($QD)for@$RD;
&$_($XD)for@$J9;
&$_($gE)for@$C;
&$_($kE)for@$C;
&$_($nE)for@$t6;
&$_($uE)for@$C;
&$_($xE)for@$t6;
&$_($AE)for@$C;
&$_($DE)for@$t6;
&$_($FE)for@$GE;
&$_($ME)for@$J9;
&$_($XE)for@$C;
&$_($cF)for@$t6;
&$_($eF)for@$fF;
&$_($jF)for@$C;
&$_($mF)for@$t6;
&$_($qF)for@$C;
&$_($uF)for@$C;
&$_($xF)for@$C;
&$_($AF)for@$t6;
&$_($CF)for@$DF;
&$_($KF)for@$J9;
&$_($MF)for@$J9;
&$_($ZF)for@$C;
&$_($eG)for@$C;
&$_($hG)for@$t6;
&$_($lG)for@$C;
&$_($oG)for@$t6;
&$_($sG)for@$C;
&$_($vG)for@$t6;
&$_($zG)for@$C;
&$_($CG)for@$C;
&$_($FG)for@$t6;
&$_($KG)for@$C;
&$_($NG)for@$C;
&$_($QG)for@$t6;
&$_($SG)for@$TG;
&$_($cH)for@$C;
&$_($fH)for@$t6;
&$_($jH)for@$C;
&$_($nH)for@$C;
&$_($qH)for@$t6;
&$_($sH)for@$J9;
&$_($GH)for@$C;
&$_($JH)for@$t6;
&$_($OH)for@$C;
&$_($SH)for@$C;
&$_($VH)for@$t6;
&$_($ZH)for@$C;
&$_($eI)for@$t6;
&$_($gI)for@$hI;
&$_($mI)for@$J9;
&$_($uI)for@$vI;
&$_($AI)for@$J9;
&$_($JI)for@$KI;
&$_($PI)for@$J9;
&$_($XI)for@$YI;
&$_($wJ)for@$YI;
&$_($BJ)for@$C;
&$_($FJ)for@$C;
&$_($JJ)for@$C;
&$_($NJ)for@$C;
&$_($RJ)for@$C;
ni->run(@ARGV);
__DATA__
