#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/rmi#;
$P=[];
$Q=q#/fabric/rmi#;
$R=bless({$e,$P,$D,$Q},$F);
$S=q#ni.doc:/io#;
$T=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$U=[$i,$T];
$V=[$U];
$W=q#/io#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/io/buffer#;
$Z=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$c1=[$f,$Z];
$d1=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$e1=[$i,$d1];
$f1=[];
$g1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q#/io/buffer#;
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q#ni.doc:/io/cat#;
$n1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$o1=[$f,$n1];
$p1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$q1=[$i,$p1];
$r1=[];
$s1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$o1,$q1,$u1];
$w1=q#/io/cat#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/io/exec#;
$z1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$A1=[$f,$z1];
$B1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$C1=[$i,$B1];
$D1=[];
$E1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now [$out->read_all, $pid->await] == ["hi\\n", 0];#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$A1,$C1,$G1];
$I1=q#/io/exec#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/io/fd#;
$L1=q#
    open my $fh, ...;
    my $fd = ni('ni:/io/fd')->new($fh); \# from perl FH
    my $fd = ni('ni:/io/fd')->new(0);   \# from number
    my $fd = ni('fd:0');                \# same thing
    $fd->nonblock(1)->read($_, 100);
    $fd->be(10);                        \# move FD number
  #;
$M1=[$f,$L1];
$N1=q#Represents a file descriptor as a child of /io/object (so the usual IO
      methods like into_async are available), and provides some convenience
      functions for things like setting up FDs for child processes. FDs are
      closed when destroyed.#;
$O1=[$i,$N1];
$P1=[];
$Q1=q#my ($r, $w) = POSIX::pipe;
{
  my $fd = ni('ni:/io/fd')->new($r);
}
ni('ni:/io/fd')->new($w)->be($r);   \# fails unless $r was GC-closed#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=[$n,$R1];
$T1=[$M1,$O1,$S1];
$U1=q#/io/fd#;
$V1=bless({$e,$T1,$D,$U1},$F);
$W1=q#ni.doc:/io/file#;
$X1=q#
    my $f = ni('ni:/io/file')->new('/etc/passwd');
    my $f = ni('file:/etc/passwd');     \# same as above
    $f->into_sync(ni('fd:1'));          \# cat to stdout
  #;
$Y1=[$f,$X1];
$Z1=q#warning#;
$c2=q#Files overload the -X file test operators, but this feature wasn't
      introduced until Perl 5.12 -- prior versions won't recognize this
      overload. That means that using this overload in ni's base code will
      reduce its portability and cause tests to fail.#;
$d2=[$Z1,$c2];
$e2=q#Represents a file that may or may not exist, and stores/constructs file
      descriptors for reading/writing. /io/files are one-shot objects: once
      you've consumed them for reading or written to them, you should destroy
      the object and start over (or close the file) if you want to operate on
      the file further -- put differently, /io/file objects own the FDs they
      create.#;
$f2=[];
$g2=q#my $ni = ni('file:ni');
now [$ni->read($_, 19), $_] == [19, "\#!/usr/bin/env perl"];#;
$h2=bless({$o,$f2,$q,$g2,$s,$t},$u);
$i2=q#File objects also provide some useful functions like atomic-updating.
      This lets you write a stream slowly into a tempfile, then rename over the
      original once the tempfile is closed. ni uses this to update itself to
      avoid race conditions.#;
$j2=[];
$k2=q#ni('file:tmp1')->write_all("original contents");
{
  my $updater = ni('file:tmp1')->atomic_update;
  $updater->write_all('foo bar');
  now ni('file:tmp1')->read_all == "original contents";
}
now ni('file:tmp1')->read_all == "foo bar";#;
$l2=bless({$o,$j2,$q,$k2,$s,$t},$u);
$m2=[$i,$e2,$n,$h2,$i2,$n,$l2];
$n2=[$Y1,$d2,$m2];
$o2=q#/io/file#;
$p2=bless({$e,$n2,$D,$o2},$F);
$q2=q#ni.doc:/io/mio#;
$r2=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$s2=[$f,$r2];
$t2=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$u2=q#

      #;
$v2=[$i,$t2,$u2];
$w2=[$s2,$v2];
$x2=q#/io/mio#;
$y2=bless({$e,$w2,$D,$x2},$F);
$z2=q#ni.doc:/io/mio_channel#;
$A2=q#
    #;
$B2=[$i,$A2];
$C2=[$B2];
$D2=q#/io/mio_channel#;
$E2=bless({$e,$C2,$D,$D2},$F);
$F2=q#ni.doc:/io/pid#;
$G2=[];
$H2=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$I2=bless({$o,$G2,$q,$H2,$s,$t},$u);
$J2=[$n,$I2];
$K2=[];
$L2=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$M2=bless({$o,$K2,$q,$L2,$s,$t},$u);
$N2=[$n,$M2];
$O2=[];
$P2=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$Q2=bless({$o,$O2,$q,$P2,$s,$t},$u);
$R2=[$n,$Q2];
$S2=[$J2,$N2,$R2];
$T2=q#/io/pid#;
$U2=bless({$e,$S2,$D,$T2},$F);
$V2=q#ni.doc:/lib#;
$W2=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$X2=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$Y2=[$i,$W2,$X2];
$Z2=[$Y2];
$c3=q#/lib#;
$d3=bless({$e,$Z2,$D,$c3},$F);
$e3=q#ni.doc:/lib/doc#;
$f3=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$g3=[$f,$f3];
$h3=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$i3=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$j3=[];
$k3=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$l3=bless({$o,$j3,$q,$k3,$s,$t},$u);
$m3=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$n3=[];
$o3=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$p3=bless({$o,$n3,$q,$o3,$s,$t},$u);
$q3=[$i,$h3,$i3,$n,$l3,$m3,$n,$p3];
$r3=[$g3,$q3];
$s3=q#/lib/doc#;
$t3=bless({$e,$r3,$D,$s3},$F);
$u3=q#ni.doc:/lib/image#;
$v3=q#
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         \# TODO#;
$w3=[$f,$v3];
$x3=q#Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.#;
$y3=[$i,$x3];
$z3=[$w3,$y3];
$A3=q#/lib/image#;
$B3=bless({$e,$z3,$D,$A3},$F);
$C3=q#ni.doc:/lib/ni#;
$D3=q#my $value = ni->resolve($name);
               my $value = ni($name);   \# alias for ni->resolve($name)
               my $self  = ni;#;
$E3=[$f,$D3];
$F3=q#The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.#;
$G3=[$i,$F3];
$H3=[$E3,$G3];
$I3=q#/lib/ni#;
$J3=bless({$e,$H3,$D,$I3},$F);
$K3=q#ni.doc:/lib/quote_simple#;
$L3=q#A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.#;
$M3=[$i,$L3];
$N3=[];
$O3=q#my $q = ni('ni:/lib/quote_simple')->new;
now $q->quote([1,2,3]) == "[1,2,3]";
now $q->quote({foo => 1, bar => [1, 2]}) == "{q\#bar\#,[1,2],q\#foo\#,1}";#;
$P3=bless({$o,$N3,$q,$O3,$s,$t},$u);
$Q3=[$n,$P3];
$R3=[$M3,$Q3];
$S3=q#/lib/quote_simple#;
$T3=bless({$e,$R3,$D,$S3},$F);
$U3=q#ni.doc:/semantic#;
$V3=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$W3=[$i,$V3];
$X3=[$W3];
$Y3=q#/semantic#;
$Z3=bless({$e,$X3,$D,$Y3},$F);
$c4=q#ni:/class#;
$d4=q#applied_to#;
$e4=q#class#;
$f4=q#class.c#;
$g4=q#fabric/rmi.c#;
$h4=q#io/buffer.c#;
$i4=q#io/cat.c#;
$j4=q#io/exec.c#;
$k4=q#io/fd.c#;
$l4=q#io/file.c#;
$m4=q#io/mio.c#;
$n4=q#io/mio_channel.c#;
$o4=q#io/null.c#;
$p4=q#io/object.c#;
$q4=q#io/pid.c#;
$r4=q#io/str.c#;
$s4=q#io/transfer.c#;
$t4=q#io/transfer_async.c#;
$u4=q#io/transfer_sync.c#;
$v4=q#lib/behavior.c#;
$w4=q#lib/branch.c#;
$x4=q#lib/dataslice.c#;
$y4=q#lib/doc.c#;
$z4=q#lib/fn.c#;
$A4=q#lib/image.c#;
$B4=q#lib/ni.c#;
$C4=q#lib/quote_simple.c#;
$D4=q#lib/slice.c#;
$E4=q#lib/tag.c#;
$F4=q#lib/test_value.c#;
$G4=q#metaclass.c#;
$H4=q#module.c#;
$I4=q#object.c#;
$J4=q#semantic/dimension#;
$K4=q#semantic/dimension.c#;
$L4=q#semantic/task.c#;
$M4={$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1};
$N4=q#slices#;
$O4=q#metaclass#;
$P4=q#module#;
$Q4={$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$O4,1,$G4,1,$P4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1};
$R4=q#/module#;
$S4=q#/lib/perlbranch.b#;
$T4={};
$U4=q#ctor#;
$V4=undef;
$W4=q#dtor#;
$X4=q#methods#;
$Y4=q#add#;
$Z4=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$c5=bless({$q,$Z4,$s,$t},$u);
$d5=q#apply#;
$e5=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$f5=bless({$q,$e5,$s,$t},$u);
$g5={$Y4,$c5,$d5,$f5};
$h5=q#/lib/branch.b#;
$i5=q#lib/slice#;
$j5=bless({$d4,$T4,$U4,$V4,$W4,$V4,$X4,$g5,$D,$h5},$i5);
$k5=q#lib/branch#;
$l5=q#lib/slice::ctors#;
$m5={};
$n5=q#my $s = shift; ni->def($s->name, $s)#;
$o5=bless({$q,$n5,$s,$t},$u);
$p5=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$D,$q5};
$s5=q#/lib/named.b#;
$t5=bless({$d4,$m5,$U4,$o5,$W4,$V4,$X4,$r5,$D,$s5},$i5);
$u5=q#lib/tag#;
$v5={};
$w5=q#namespace#;
$x5=q#'ni'#;
$y5=bless({$q,$x5,$s,$t},$u);
$z5={$w5,$y5};
$A5=q#/lib/named_in_ni.b#;
$B5=bless({$d4,$v5,$U4,$V4,$W4,$V4,$X4,$z5,$D,$A5},$i5);
$C5={};
$D5=q#package#;
$E5=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$F5=bless({$q,$E5,$s,$t},$u);
$G5={$D5,$F5};
$H5=q#/lib/namespaced.b#;
$I5=bless({$d4,$C5,$U4,$V4,$W4,$V4,$X4,$G5,$D,$H5},$i5);
$J5={};
$K5=q#resolve#;
$L5=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/resolver.b#;
$P5=bless({$d4,$J5,$U4,$V4,$W4,$V4,$X4,$N5,$D,$O5},$i5);
$Q5=[$j5,$t5,$B5,$I5,$P5];
$R5=bless({$D,$S4,$N4,$Q5},$u5);
$S5=q#lib/tag::ctors#;
$T5={};
$U5=q#my $s = shift; $s->apply($s->package)#;
$V5=bless({$q,$U5,$s,$t},$u);
$W5=q#instantiate#;
$X5=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$Y5=bless({$q,$X5,$s,$t},$u);
$Z5={$W5,$Y5};
$c6=q#/lib/class_init.b#;
$d6=bless({$d4,$T5,$U4,$V5,$W4,$V4,$X4,$Z5,$D,$c6},$i5);
$e6=q#fabric/rmi#;
$f6=q#io/buffer#;
$g6=q#io/cat#;
$h6=q#io/exec#;
$i6=q#io/fd#;
$j6=q#io/file#;
$k6=q#io/mio#;
$l6=q#io/mio_channel#;
$m6=q#io/null#;
$n6=q#io/object#;
$o6=q#io/pid#;
$p6=q#io/str#;
$q6=q#io/transfer#;
$r6=q#io/transfer_async#;
$s6=q#io/transfer_sync#;
$t6=q#lib/behavior#;
$u6=q#lib/dataslice#;
$v6=q#lib/image#;
$w6=q#lib/ni#;
$x6=q#lib/quote_simple#;
$y6=q#lib/test_value#;
$z6=q#object#;
$A6=q#semantic/task#;
$B6={$e4,1,$f4,1,$e6,1,$g4,1,$f6,1,$h4,1,$g6,1,$i4,1,$h6,1,$j4,1,$i6,1,$k4,1,$j6,1,$l4,1,$k6,1,$m4,1,$l6,1,$n4,1,$m6,1,$o4,1,$n6,1,$p4,1,$o6,1,$q4,1,$p6,1,$r4,1,$q6,1,$s4,1,$r6,1,$t4,1,$s6,1,$u4,1,$t6,1,$v4,1,$k5,1,$w4,1,$u6,1,$x4,1,$F,1,$y4,1,$u,1,$z4,1,$v6,1,$A4,1,$w6,1,$B4,1,$x6,1,$C4,1,$i5,1,$D4,1,$u5,1,$E4,1,$y6,1,$F4,1,$O4,1,$G4,1,$P4,1,$H4,1,$z6,1,$I4,1,$J4,1,$K4,1,$A6,1,$L4,1};
$C6=q#/object#;
$D6={};
$E6=q#ni 'ni:/' . ref shift#;
$F6=bless({$q,$E6,$s,$t},$u);
$G6={$e4,$F6};
$H6=q#/lib/instance.b#;
$I6=bless({$d4,$D6,$U4,$V4,$W4,$V4,$X4,$G6,$D,$H6},$i5);
$J6=[$I6];
$K6=bless({$d4,$B6,$D,$C6,$N4,$J6},$I4);
$L6=q#object.c::ctors#;
$M6={$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$t6,1,$v4,1,$k5,1,$w4,1,$u6,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$i5,1,$D4,1,$u5,1,$E4,1,$F4,1,$O4,1,$G4,1,$P4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1};
$N6=q#/lib/behavior#;
$O6={};
$P6=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$Q6=bless({$q,$P6,$s,$t},$u);
$R6={$e,$Q6};
$S6=q#/lib/documentable.b#;
$T6=bless({$d4,$O6,$U4,$V4,$W4,$V4,$X4,$R6,$D,$S6},$i5);
$U6=[$K6,$T6];
$V6=bless({$d4,$M6,$D,$N6,$N4,$U6},$v4);
$W6=q#lib/behavior.c::ctors#;
$X6={$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$k5,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$O4,1,$G4,1,$P4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1};
$Y6=q#/lib/definition.b#;
$Z6={};
$c7=q#def#;
$d7=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$e7=bless({$q,$d7,$s,$t},$u);
$f7={$c7,$e7};
$g7=q#/lib/definition_def.b#;
$h7=bless({$d4,$Z6,$U4,$V4,$W4,$V4,$X4,$f7,$D,$g7},$i5);
$i7={};
$j7=q#ro#;
$k7=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$l7=bless({$q,$k7,$s,$t},$u);
$m7=q#rw#;
$n7=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$o7=bless({$q,$n7,$s,$t},$u);
$p7={$j7,$l7,$m7,$o7};
$q7=q#/lib/accessor.b#;
$r7=bless({$d4,$i7,$U4,$V4,$W4,$V4,$X4,$p7,$D,$q7},$i5);
$s7={};
$t7=q#(""#;
$u7=q#shift->name#;
$v7=bless({$q,$u7,$s,$t},$u);
$w7={$t7,$v7};
$x7=q#/lib/name_as_string.b#;
$y7=bless({$d4,$s7,$U4,$V4,$W4,$V4,$X4,$w7,$D,$x7},$i5);
$z7={};
$A7=q#(eq#;
$B7=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$C7=bless({$q,$B7,$s,$t},$u);
$D7={$A7,$C7};
$E7=q#/lib/ref_eq.b#;
$F7=bless({$d4,$z7,$U4,$V4,$W4,$V4,$X4,$D7,$D,$E7},$i5);
$G7={};
$H7=q#defdata#;
$I7=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$J7=bless({$q,$I7,$s,$t},$u);
$K7={$H7,$J7};
$L7=q#/lib/definition_defdata.b#;
$M7=bless({$d4,$G7,$U4,$V4,$W4,$V4,$X4,$K7,$D,$L7},$i5);
$N7=[$h7,$r7,$y7,$F7,$M7];
$O7=bless({$d4,$X6,$D,$Y6,$N4,$N7},$k5);
$P7=q#lib/branch::ctors#;
$Q7=[$R5,$d6,$K6,$V6,$O7];
$R7=bless({$d4,$Q4,$D,$R4,$N4,$Q7},$H4);
$S7=q#module.c::ctors#;
$T7={};
$U7=q#DESTROY#;
$V7=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$W7=bless({$q,$V7,$s,$t},$u);
$X7=q#new#;
$Y7=q#local $_;
my $class   = shift;
my $package = ref $class ? $class->package : $class;
my $self = bless &{"$package\\::instantiate"}($class, @_), $package;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$Z7=bless({$q,$Y7,$s,$t},$u);
$c8={$U7,$W7,$X7,$Z7};
$d8=q#/lib/instantiable.b#;
$e8=bless({$d4,$T7,$X4,$c8,$D,$d8},$i5);
$f8={};
$g8=q#child#;
$h8=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$i8=bless({$q,$h8,$s,$t},$u);
$j8={$g8,$i8};
$k8=q#/lib/subclass.b#;
$l8=bless({$d4,$f8,$U4,$V4,$W4,$V4,$X4,$j8,$D,$k8},$i5);
$m8=[$R7,$e8,$d6,$R7,$l8];
$n8=bless({$d4,$M4,$D,$E,$N4,$m8},$f4);
$o8=q#class.c::ctors#;
$p8=q#ni:/class.c#;
$q8={$f4,1,$K4,1};
$r8=q#/class.c#;
$s8={$f4,1,$H4,1,$K4,1};
$t8=q#/module.c#;
$u8={$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$H4,1,$I4,1,$K4,1,$L4,1};
$v8=q#/object.c#;
$w8=[$n8];
$x8=bless({$d4,$u8,$D,$v8,$N4,$w8},$O4);
$y8=q#metaclass::ctors#;
$z8={$f4,1,$v4,1,$w4,1,$x4,1,$D4,1,$E4,1,$H4,1,$K4,1};
$A8=q#/lib/behavior.c#;
$B8=[$x8];
$C8=bless({$d4,$z8,$D,$A8,$N4,$B8},$O4);
$D8=[$x8,$e8,$C8];
$E8=bless({$d4,$s8,$D,$t8,$N4,$D8},$O4);
$F8=[$E8];
$G8=bless({$d4,$q8,$D,$r8,$N4,$F8},$O4);
$H8=q#ni:/fabric/rmi#;
$I8={$e6,1};
$J8={};
$K8=[];
$L8=q#my ($class, $io, $quote) = @_;#;
$M8=bless({$o,$K8,$q,$L8,$s,$t},$u);
$N8={$W5,$M8};
$O8=q#/fabric/rmi_init.b#;
$P8=bless({$d4,$J8,$U4,$V4,$W4,$V4,$X4,$N8,$D,$O8},$i5);
$Q8=[$K6,$P8];
$R8=bless({$d4,$I8,$D,$Q,$N4,$Q8},$g4);
$S8=q#fabric/rmi.c::ctors#;
$T8=q#ni:/fabric/rmi.c#;
$U8={$g4,1};
$V8=q#/fabric/rmi.c#;
$W8=[$x8];
$X8=bless({$d4,$U8,$D,$V8,$N4,$W8},$O4);
$Y8=q#ni:/fabric/rmi_init.b#;
$Z8=q#ni:/io/buffer#;
$c9={$f6,1};
$d9={$f6,1,$g6,1,$h6,1,$i6,1,$j6,1,$k6,1,$l6,1,$m6,1,$n6,1,$o6,1,$p6,1};
$e9=q#/io/object#;
$f9={};
$g9=q#(bool#;
$h9=[];
$i9=bless({$o,$h9,$q,1,$s,$t},$u);
$j9={$g9,$i9};
$k9=q#/io/object_ops.b#;
$l9=bless({$d4,$f9,$U4,$V4,$W4,$V4,$X4,$j9,$D,$k9},$i5);
$m9={};
$n9=q#die#;
$o9=[];
$p9=q#shift; die join " ", @_#;
$q9=bless({$o,$o9,$q,$p9,$s,$t},$u);
$r9=q#io_check#;
$s9=[];
$t9=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$u9=bless({$o,$s9,$q,$t9,$s,$t},$u);
$v9=q#io_check_defined#;
$w9=[];
$x9=q#shift->io_check(sub {defined shift}, @_)#;
$y9=bless({$o,$w9,$q,$x9,$s,$t},$u);
$z9=q#io_check_true#;
$A9=[];
$B9=q#shift->io_check(sub {shift}, @_)#;
$C9=bless({$o,$A9,$q,$B9,$s,$t},$u);
$D9={$n9,$q9,$r9,$u9,$v9,$y9,$z9,$C9};
$E9=q#/io/object_checks.b#;
$F9=bless({$d4,$m9,$U4,$V4,$W4,$V4,$X4,$D9,$D,$E9},$i5);
$G9={};
$H9=q#(+#;
$I9=[];
$J9=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$K9=bless({$o,$I9,$q,$J9,$s,$t},$u);
$L9={$H9,$K9};
$M9=q#/io/object_constructors.b#;
$N9=bless({$d4,$G9,$U4,$V4,$W4,$V4,$X4,$L9,$D,$M9},$i5);
$O9={};
$P9=q#read_all#;
$Q9=[];
$R9=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$S9=bless({$o,$Q9,$q,$R9,$s,$t},$u);
$T9=q#write_all#;
$U9=[];
$V9=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_async($self);#;
$W9=bless({$o,$U9,$q,$V9,$s,$t},$u);
$X9={$P9,$S9,$T9,$W9};
$Y9=q#/io/object_memory.b#;
$Z9=bless({$d4,$O9,$U4,$V4,$W4,$V4,$X4,$X9,$D,$Y9},$i5);
$ca={};
$da=q#connect_sync#;
$ea=[];
$fa=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$ga=bless({$o,$ea,$q,$fa,$s,$t},$u);
$ha=q#into_sync#;
$ia=[];
$ja=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$ka=bless({$o,$ia,$q,$ja,$s,$t},$u);
$la={$da,$ga,$ha,$ka};
$ma=q#/io/object_transfer_sync.b#;
$na=bless({$d4,$ca,$U4,$V4,$W4,$V4,$X4,$la,$D,$ma},$i5);
$oa={};
$pa=q#connect_async#;
$qa=[];
$ra=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta=q#into_async#;
$ua=[];
$va=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa={$pa,$sa,$ta,$wa};
$ya=q#/io/object_transfer_async.b#;
$za=bless({$d4,$oa,$U4,$V4,$W4,$V4,$X4,$xa,$D,$ya},$i5);
$Aa=[$K6,$l9,$F9,$N9,$Z9,$na,$za,$za,$na];
$Ba=bless({$d4,$d9,$D,$e9,$N4,$Aa},$p4);
$Ca=q#io/object.c::ctors#;
$Da={};
$Ea=[];
$Fa=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$Ga=bless({$o,$Ea,$q,$Fa,$s,$t},$u);
$Ha={$W5,$Ga};
$Ia=q#/io/buffer_init.b#;
$Ja=bless({$d4,$Da,$U4,$V4,$W4,$V4,$X4,$Ha,$D,$Ia},$i5);
$Ka={};
$La=q#read#;
$Ma=[];
$Na=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$Oa=bless({$o,$Ma,$q,$Na,$s,$t},$u);
$Pa=q#read_capacity#;
$Qa=[];
$Ra=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta=q#write#;
$Ua=[];
$Va=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#write_capacity#;
$Ya=[];
$Za=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db={$La,$Oa,$Pa,$Sa,$Ta,$Wa,$Xa,$cb};
$eb=q#/io/buffer_io.b#;
$fb=bless({$d4,$Ka,$U4,$V4,$W4,$V4,$X4,$db,$D,$eb},$i5);
$gb=[$Ba,$Ja,$fb];
$hb=bless({$d4,$c9,$D,$k1,$N4,$gb},$h4);
$ib=q#io/buffer.c::ctors#;
$jb=q#ni:/io/buffer.c#;
$kb={$h4,1};
$lb=q#/io/buffer.c#;
$mb={$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1};
$nb=q#/io/object.c#;
$ob={};
$pb=q#def_transfer_method#;
$qb=[];
$rb=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb={$pb,$sb};
$ub=q#/io/object.c_transfer_def.b#;
$vb=bless({$d4,$ob,$U4,$V4,$W4,$V4,$X4,$tb,$D,$ub},$i5);
$wb=[$x8,$vb];
$xb=bless({$d4,$mb,$D,$nb,$N4,$wb},$O4);
$yb=[$xb];
$zb=bless({$d4,$kb,$D,$lb,$N4,$yb},$O4);
$Ab=q#ni:/io/buffer_init.b#;
$Bb=q#ni:/io/buffer_io.b#;
$Cb=q#ni:/io/cat#;
$Db={$g6,1};
$Eb={};
$Fb=[];
$Gb=q#shift; +{fs => [@_]}#;
$Hb=bless({$o,$Fb,$q,$Gb,$s,$t},$u);
$Ib={$W5,$Hb};
$Jb=q#/io/cat_init.b#;
$Kb=bless({$d4,$Eb,$U4,$V4,$W4,$V4,$X4,$Ib,$D,$Jb},$i5);
$Lb={};
$Mb=[];
$Nb=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb={$La,$Ob};
$Qb=q#/io/cat_read.b#;
$Rb=bless({$d4,$Lb,$U4,$V4,$W4,$V4,$X4,$Pb,$D,$Qb},$i5);
$Sb=[$Ba,$Kb,$Rb];
$Tb=bless({$d4,$Db,$D,$w1,$N4,$Sb},$i4);
$Ub=q#io/cat.c::ctors#;
$Vb=q#ni:/io/cat.c#;
$Wb={$i4,1};
$Xb=q#/io/cat.c#;
$Yb=[$xb];
$Zb=bless({$d4,$Wb,$D,$Xb,$N4,$Yb},$O4);
$cc=q#ni:/io/cat_init.b#;
$dc=q#ni:/io/cat_read.b#;
$ec=q#ni:/io/exec#;
$fc={$h6,1};
$gc={};
$hc=q#argv#;
$ic=[];
$jc=q#shift->{'argv'}#;
$kc=bless({$o,$ic,$q,$jc,$s,$t},$u);
$lc={$hc,$kc};
$mc=q#/io/exec_ro.b#;
$nc=bless({$d4,$gc,$U4,$V4,$W4,$V4,$X4,$lc,$D,$mc},$i5);
$oc={};
$pc=[];
$qc=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$rc=bless({$o,$pc,$q,$qc,$s,$t},$u);
$sc={$W5,$rc};
$tc=q#/io/exec_init.b#;
$uc=bless({$d4,$oc,$U4,$V4,$W4,$V4,$X4,$sc,$D,$tc},$i5);
$vc={};
$wc=q#connect#;
$xc=[];
$yc=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$zc=bless({$o,$xc,$q,$yc,$s,$t},$u);
$Ac=q#in_pipe#;
$Bc=[];
$Cc=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Dc=bless({$o,$Bc,$q,$Cc,$s,$t},$u);
$Ec=q#out_pipe#;
$Fc=[];
$Gc=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Hc=bless({$o,$Fc,$q,$Gc,$s,$t},$u);
$Ic=q#setup_stdio#;
$Jc=[];
$Kc=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Lc=bless({$o,$Jc,$q,$Kc,$s,$t},$u);
$Mc={$wc,$zc,$Ac,$Dc,$Ec,$Hc,$Ic,$Lc};
$Nc=q#/io/exec_io_setup.b#;
$Oc=bless({$d4,$vc,$U4,$V4,$W4,$V4,$X4,$Mc,$D,$Nc},$i5);
$Pc={};
$Qc=q#binds_fd#;
$Rc=[];
$Sc=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$Tc=bless({$o,$Rc,$q,$Sc,$s,$t},$u);
$Uc=q#fd#;
$Vc=[];
$Wc=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Xc=bless({$o,$Vc,$q,$Wc,$s,$t},$u);
$Yc=q#stderr#;
$Zc=[];
$cd=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$dd=bless({$o,$Zc,$q,$cd,$s,$t},$u);
$ed=q#stdin#;
$fd=[];
$gd=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$hd=bless({$o,$fd,$q,$gd,$s,$t},$u);
$id=q#stdout#;
$jd=[];
$kd=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$ld=bless({$o,$jd,$q,$kd,$s,$t},$u);
$md={$Qc,$Tc,$Uc,$Xc,$Yc,$dd,$ed,$hd,$id,$ld};
$nd=q#/io/exec_io_accessors.b#;
$od=bless({$d4,$Pc,$U4,$V4,$W4,$V4,$X4,$md,$D,$nd},$i5);
$pd={};
$qd=q#env#;
$rd=[];
$sd=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$td=bless({$o,$rd,$q,$sd,$s,$t},$u);
$ud={$qd,$td};
$vd=q#/io/exec_env.b#;
$wd=bless({$d4,$pd,$U4,$V4,$W4,$V4,$X4,$ud,$D,$vd},$i5);
$xd={};
$yd=q#exec#;
$zd=[];
$Ad=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Bd=bless({$o,$zd,$q,$Ad,$s,$t},$u);
$Cd=q#fork#;
$Dd=[];
$Ed=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Fd=bless({$o,$Dd,$q,$Ed,$s,$t},$u);
$Gd=q#move_fds#;
$Hd=[];
$Id=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Jd=bless({$o,$Hd,$q,$Id,$s,$t},$u);
$Kd={$yd,$Bd,$Cd,$Fd,$Gd,$Jd};
$Ld=q#/io/exec_fork.b#;
$Md=bless({$d4,$xd,$U4,$V4,$W4,$V4,$X4,$Kd,$D,$Ld},$i5);
$Nd=[$Ba,$nc,$uc,$Oc,$od,$wd,$Md];
$Od=bless({$d4,$fc,$D,$I1,$N4,$Nd},$j4);
$Pd=q#io/exec.c::ctors#;
$Qd=q#ni:/io/exec.c#;
$Rd={$j4,1};
$Sd=q#/io/exec.c#;
$Td=[$xb];
$Ud=bless({$d4,$Rd,$D,$Sd,$N4,$Td},$O4);
$Vd=q#ni:/io/exec_env.b#;
$Wd=q#ni:/io/exec_fork.b#;
$Xd=q#ni:/io/exec_init.b#;
$Yd=q#ni:/io/exec_io_accessors.b#;
$Zd=q#ni:/io/exec_io_setup.b#;
$ce=q#ni:/io/exec_ro.b#;
$de=q#ni:/io/fd#;
$ee={$i6,1};
$fe={};
$ge=[];
$he=q#shift->{'fd'}#;
$ie=bless({$o,$ge,$q,$he,$s,$t},$u);
$je={$Uc,$ie};
$ke=q#/io/fd_readers.b#;
$le=bless({$d4,$fe,$U4,$V4,$W4,$V4,$X4,$je,$D,$ke},$i5);
$me={};
$ne=[];
$oe=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$pe=bless({$o,$ne,$q,$oe,$s,$t},$u);
$qe={$W5,$pe};
$re=q#/io/fd_init.b#;
$se=bless({$d4,$me,$U4,$V4,$W4,$V4,$X4,$qe,$D,$re},$i5);
$te={};
$ue=q#be#;
$ve=[];
$we=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$xe=bless({$o,$ve,$q,$we,$s,$t},$u);
$ye={$ue,$xe};
$ze=q#/io/fd_shell.b#;
$Ae=bless({$d4,$te,$U4,$V4,$W4,$V4,$X4,$ye,$D,$ze},$i5);
$Be={};
$Ce=q#cloexec#;
$De=[];
$Ee=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge=q#fcntl_flag#;
$He=[];
$Ie=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Je=bless({$o,$He,$q,$Ie,$s,$t},$u);
$Ke=q#nonblock#;
$Le=[];
$Me=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe={$Ce,$Fe,$Ge,$Je,$Ke,$Ne};
$Pe=q#/io/fd_fcntl.b#;
$Qe=bless({$d4,$Be,$U4,$V4,$W4,$V4,$X4,$Oe,$D,$Pe},$i5);
$Re={};
$Se=[];
$Te=q#shift->close#;
$Ue=bless({$o,$Se,$q,$Te,$s,$t},$u);
$Ve=q#close#;
$We=[];
$Xe=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Ye=bless({$o,$We,$q,$Xe,$s,$t},$u);
$Ze={$Ve,$Ye};
$cf=q#/io/fd_gc.b#;
$df=bless({$d4,$Re,$U4,$V4,$W4,$Ue,$X4,$Ze,$D,$cf},$i5);
$ef={};
$ff=[];
$gf=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if=[];
$jf=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$kf=bless({$o,$if,$q,$jf,$s,$t},$u);
$lf={$La,$hf,$Ta,$kf};
$mf=q#/io/fd_perlio.b#;
$nf=bless({$d4,$ef,$U4,$V4,$W4,$V4,$X4,$lf,$D,$mf},$i5);
$of=[$Ba,$le,$se,$Ae,$Qe,$df,$nf];
$pf=bless({$d4,$ee,$D,$U1,$N4,$of},$k4);
$qf=q#io/fd.c::ctors#;
$rf=q#ni:/io/fd.c#;
$sf={$k4,1};
$tf=q#/io/fd.c#;
$uf=[$xb];
$vf=bless({$d4,$sf,$D,$tf,$N4,$uf},$O4);
$wf=q#ni:/io/fd_fcntl.b#;
$xf=q#ni:/io/fd_gc.b#;
$yf=q#ni:/io/fd_init.b#;
$zf=q#ni:/io/fd_perlio.b#;
$Af=q#ni:/io/fd_readers.b#;
$Bf=q#ni:/io/fd_shell.b#;
$Cf=q#ni:/io/file#;
$Df={$j6,1};
$Ef={};
$Ff=[];
$Gf=q#shift->{'name'}#;
$Hf=bless({$o,$Ff,$q,$Gf,$s,$t},$u);
$If={$D,$Hf};
$Jf=q#/io/file_readers.b#;
$Kf=bless({$d4,$Ef,$U4,$V4,$W4,$V4,$X4,$If,$D,$Jf},$i5);
$Lf={};
$Mf=q#mode#;
$Nf=[];
$Of=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Pf=bless({$o,$Nf,$q,$Of,$s,$t},$u);
$Qf={$Mf,$Pf};
$Rf=q#/io/file_accessors.b#;
$Sf=bless({$d4,$Lf,$U4,$V4,$W4,$V4,$X4,$Qf,$D,$Rf},$i5);
$Tf={};
$Uf=[];
$Vf=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Wf=bless({$o,$Uf,$q,$Vf,$s,$t},$u);
$Xf={$W5,$Wf};
$Yf=q#/io/file_init.b#;
$Zf=bless({$d4,$Tf,$U4,$V4,$W4,$V4,$X4,$Xf,$D,$Yf},$i5);
$cg={};
$dg=q#(-X#;
$eg=[];
$fg=q#my ($self, $test) = @_;
&{"-$test"}($$self{name});#;
$gg=bless({$o,$eg,$q,$fg,$s,$t},$u);
$hg={$dg,$gg};
$ig=q#/io/file_fns.b#;
$jg=bless({$d4,$cg,$U4,$V4,$W4,$V4,$X4,$hg,$D,$ig},$i5);
$kg={};
$lg=[];
$mg=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$ng=bless({$o,$lg,$q,$mg,$s,$t},$u);
$og=q#r#;
$pg=[];
$qg=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$rg=bless({$o,$pg,$q,$qg,$s,$t},$u);
$sg=[];
$tg=q#shift->r->read(@_)#;
$ug=bless({$o,$sg,$q,$tg,$s,$t},$u);
$vg=q#w#;
$wg=[];
$xg=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$yg=bless({$o,$wg,$q,$xg,$s,$t},$u);
$zg=[];
$Ag=q#shift->w->write(@_)#;
$Bg=bless({$o,$zg,$q,$Ag,$s,$t},$u);
$Cg={$Ve,$ng,$og,$rg,$La,$ug,$vg,$yg,$Ta,$Bg};
$Dg=q#/io/file_io.b#;
$Eg=bless({$d4,$kg,$U4,$V4,$W4,$V4,$X4,$Cg,$D,$Dg},$i5);
$Fg=[$Ba,$Kf,$Sf,$Zf,$jg,$Eg];
$Gg=bless({$d4,$Df,$D,$o2,$N4,$Fg},$l4);
$Hg=q#io/file.c::ctors#;
$Ig=q#ni:/io/file.c#;
$Jg={$l4,1};
$Kg=q#/io/file.c#;
$Lg=[$xb];
$Mg=bless({$d4,$Jg,$D,$Kg,$N4,$Lg},$O4);
$Ng=q#ni:/io/file_accessors.b#;
$Og=q#ni:/io/file_fns.b#;
$Pg=q#ni:/io/file_init.b#;
$Qg=q#ni:/io/file_io.b#;
$Rg=q#ni:/io/file_readers.b#;
$Sg=q#ni:/io/mio#;
$Tg={$k6,1};
$Ug={};
$Vg=q#io#;
$Wg=[];
$Xg=q#shift->{'io'}#;
$Yg=bless({$o,$Wg,$q,$Xg,$s,$t},$u);
$Zg=q#packet_size#;
$ch=[];
$dh=q#shift->{'packet_size'}#;
$eh=bless({$o,$ch,$q,$dh,$s,$t},$u);
$fh={$Vg,$Yg,$Zg,$eh};
$gh=q#/io/mio_ro.b#;
$hh=bless({$d4,$Ug,$U4,$V4,$W4,$V4,$X4,$fh,$D,$gh},$i5);
$ih={};
$jh=[];
$kh=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$lh=bless({$o,$jh,$q,$kh,$s,$t},$u);
$mh={$W5,$lh};
$nh=q#/io/mio_init.b#;
$oh=bless({$d4,$ih,$U4,$V4,$W4,$V4,$X4,$mh,$D,$nh},$i5);
$ph={};
$qh=q#next_sender#;
$rh=[];
$sh=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$th=bless({$o,$rh,$q,$sh,$s,$t},$u);
$uh={$qh,$th};
$vh=q#/io/mio_rr_scheduler.b#;
$wh=bless({$d4,$ph,$U4,$V4,$W4,$V4,$X4,$uh,$D,$vh},$i5);
$xh={};
$yh=[];
$zh=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$Ah=bless({$o,$yh,$q,$zh,$s,$t},$u);
$Bh=[];
$Ch=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$Dh=bless({$o,$Bh,$q,$Ch,$s,$t},$u);
$Eh=[];
$Fh=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
\# TODO#;
$Gh=bless({$o,$Eh,$q,$Fh,$s,$t},$u);
$Hh={$Ve,$Ah,$La,$Dh,$Ta,$Gh};
$Ih=q#/io/mio_io.b#;
$Jh=bless({$d4,$xh,$U4,$V4,$W4,$V4,$X4,$Hh,$D,$Ih},$i5);
$Kh={};
$Lh=q#channel#;
$Mh=[];
$Nh=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$Oh=bless({$o,$Mh,$q,$Nh,$s,$t},$u);
$Ph=q#channels#;
$Qh=[];
$Rh=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$Sh=bless({$o,$Qh,$q,$Rh,$s,$t},$u);
$Th=q#unchannel#;
$Uh=[];
$Vh=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$Wh=bless({$o,$Uh,$q,$Vh,$s,$t},$u);
$Xh={$Lh,$Oh,$Ph,$Sh,$Th,$Wh};
$Yh=q#/io/mio_channel.b#;
$Zh=bless({$d4,$Kh,$U4,$V4,$W4,$V4,$X4,$Xh,$D,$Yh},$i5);
$ci=[$Ba,$hh,$oh,$wh,$Jh,$Zh];
$di=bless({$d4,$Tg,$D,$x2,$N4,$ci},$m4);
$ei=q#io/mio.c::ctors#;
$fi=q#ni:/io/mio.c#;
$gi={$m4,1};
$hi=q#/io/mio.c#;
$ii=[$xb];
$ji=bless({$d4,$gi,$D,$hi,$N4,$ii},$O4);
$ki=q#ni:/io/mio_channel#;
$li={$l6,1};
$mi={};
$ni=q#capacity#;
$oi=[];
$pi=q#shift->{'capacity'}#;
$qi=bless({$o,$oi,$q,$pi,$s,$t},$u);
$ri=q#id#;
$si=[];
$ti=q#shift->{'id'}#;
$ui=bless({$o,$si,$q,$ti,$s,$t},$u);
$vi=q#mio#;
$wi=[];
$xi=q#shift->{'mio'}#;
$yi=bless({$o,$wi,$q,$xi,$s,$t},$u);
$zi={$ni,$qi,$ri,$ui,$vi,$yi};
$Ai=q#/io/mio_channel_ro.b#;
$Bi=bless({$d4,$mi,$U4,$V4,$W4,$V4,$X4,$zi,$D,$Ai},$i5);
$Ci={};
$Di=[];
$Ei=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Fi=bless({$o,$Di,$q,$Ei,$s,$t},$u);
$Gi={$W5,$Fi};
$Hi=q#/io/mio_channel_init.b#;
$Ii=bless({$d4,$Ci,$U4,$V4,$W4,$V4,$X4,$Gi,$D,$Hi},$i5);
$Ji={};
$Ki=[];
$Li=bless({$o,$Ki,$q,$Te,$s,$t},$u);
$Mi={};
$Ni=q#/io/mio_channel_lifecycle.b#;
$Oi=bless({$d4,$Ji,$U4,$V4,$W4,$Li,$X4,$Mi,$D,$Ni},$i5);
$Pi={};
$Qi=[];
$Ri=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$Si=bless({$o,$Qi,$q,$Ri,$s,$t},$u);
$Ti=[];
$Ui=q#shift->{read_buffer} ->read(@_)#;
$Vi=bless({$o,$Ti,$q,$Ui,$s,$t},$u);
$Wi=[];
$Xi=q#shift->{write_buffer}->write(@_)#;
$Yi=bless({$o,$Wi,$q,$Xi,$s,$t},$u);
$Zi={$Ve,$Si,$La,$Vi,$Ta,$Yi};
$cj=q#/io/mio_channel_io.b#;
$dj=bless({$d4,$Pi,$U4,$V4,$W4,$V4,$X4,$Zi,$D,$cj},$i5);
$ej=[$Ba,$Bi,$Ii,$Oi,$dj];
$fj=bless({$d4,$li,$D,$D2,$N4,$ej},$n4);
$gj=q#io/mio_channel.c::ctors#;
$hj=q#ni:/io/mio_channel.b#;
$ij=q#ni:/io/mio_channel.c#;
$jj={$n4,1};
$kj=q#/io/mio_channel.c#;
$lj=[$xb];
$mj=bless({$d4,$jj,$D,$kj,$N4,$lj},$O4);
$nj=q#ni:/io/mio_channel_init.b#;
$oj=q#ni:/io/mio_channel_io.b#;
$pj=q#ni:/io/mio_channel_lifecycle.b#;
$qj=q#ni:/io/mio_channel_ro.b#;
$rj=q#ni:/io/mio_init.b#;
$sj=q#ni:/io/mio_io.b#;
$tj=q#ni:/io/mio_ro.b#;
$uj=q#ni:/io/mio_rr_scheduler.b#;
$vj=q#ni:/io/named_io_fns.b#;
$wj={};
$xj=q#fcntl#;
$yj=[];
$zj=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Aj=bless({$o,$yj,$q,$zj,$s,$t},$u);
$Bj=[];
$Cj=q#CORE::fork#;
$Dj=bless({$o,$Bj,$q,$Cj,$s,$t},$u);
$Ej=q#open2#;
$Fj=[];
$Gj=q#CORE::open $_[0], $_[1]#;
$Hj=bless({$o,$Fj,$q,$Gj,$s,$t},$u);
$Ij=q#waitpid#;
$Jj=[];
$Kj=q#CORE::waitpid $_[0], $_[1]#;
$Lj=bless({$o,$Jj,$q,$Kj,$s,$t},$u);
$Mj={$xj,$Aj,$Cd,$Dj,$Ej,$Hj,$Ij,$Lj};
$Nj=q#/io/named_io_fns.b#;
$Oj=bless({$d4,$wj,$U4,$V4,$W4,$V4,$X4,$Mj,$D,$Nj},$i5);
$Pj=q#main#;
$Qj=q#ni:/io/null#;
$Rj={$m6,1};
$Sj=q#/io/null#;
$Tj={};
$Uj=[];
$Vj=q#+{fd => undef}#;
$Wj=bless({$o,$Uj,$q,$Vj,$s,$t},$u);
$Xj={$W5,$Wj};
$Yj=q#/io/null_init.b#;
$Zj=bless({$d4,$Tj,$U4,$V4,$W4,$V4,$X4,$Xj,$D,$Yj},$i5);
$ck={};
$dk=[];
$ek=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$fk=bless({$o,$dk,$q,$ek,$s,$t},$u);
$gk=[];
$hk=q#shift->fd->read(@_)#;
$ik=bless({$o,$gk,$q,$hk,$s,$t},$u);
$jk=[];
$kk=q#shift->fd->write(@_)#;
$lk=bless({$o,$jk,$q,$kk,$s,$t},$u);
$mk={$Uc,$fk,$La,$ik,$Ta,$lk};
$nk=q#/io/null_io.b#;
$ok=bless({$d4,$ck,$U4,$V4,$W4,$V4,$X4,$mk,$D,$nk},$i5);
$pk=[$Ba,$Zj,$ok];
$qk=bless({$d4,$Rj,$D,$Sj,$N4,$pk},$o4);
$rk=q#io/null.c::ctors#;
$sk=q#ni:/io/null.c#;
$tk={$o4,1};
$uk=q#/io/null.c#;
$vk=[$xb];
$wk=bless({$d4,$tk,$D,$uk,$N4,$vk},$O4);
$xk=q#ni:/io/null_init.b#;
$yk=q#ni:/io/null_io.b#;
$zk=q#ni:/io/object#;
$Ak=q#ni:/io/object.c#;
$Bk=q#ni:/io/object.c_transfer_def.b#;
$Ck=q#ni:/io/object_checks.b#;
$Dk=q#ni:/io/object_constructors.b#;
$Ek=q#ni:/io/object_memory.b#;
$Fk=q#ni:/io/object_ops.b#;
$Gk=q#ni:/io/object_transfer_async.b#;
$Hk=q#ni:/io/object_transfer_sync.b#;
$Ik=q#ni:/io/pid#;
$Jk={$o6,1};
$Kk={};
$Lk=q#pid#;
$Mk=[];
$Nk=q#shift->{'pid'}#;
$Ok=bless({$o,$Mk,$q,$Nk,$s,$t},$u);
$Pk=q#status#;
$Qk=[];
$Rk=q#shift->{'status'}#;
$Sk=bless({$o,$Qk,$q,$Rk,$s,$t},$u);
$Tk={$Lk,$Ok,$Pk,$Sk};
$Uk=q#/io/pid_readers.b#;
$Vk=bless({$d4,$Kk,$U4,$V4,$W4,$V4,$X4,$Tk,$D,$Uk},$i5);
$Wk={};
$Xk=[];
$Yk=q#shift->await#;
$Zk=bless({$o,$Xk,$q,$Yk,$s,$t},$u);
$cl=[];
$dl=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$el=bless({$o,$cl,$q,$dl,$s,$t},$u);
$fl={$W5,$el};
$gl=q#/io/pid_init.b#;
$hl=bless({$d4,$Wk,$U4,$V4,$W4,$Zk,$X4,$fl,$D,$gl},$i5);
$il={};
$jl=q#await#;
$kl=[];
$ll=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$ml=bless({$o,$kl,$q,$ll,$s,$t},$u);
$nl=q#running#;
$ol=[];
$pl=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl={$jl,$ml,$nl,$ql};
$sl=q#/io/pid_wait.b#;
$tl=bless({$d4,$il,$U4,$V4,$W4,$V4,$X4,$rl,$D,$sl},$i5);
$ul={};
$vl=[];
$wl=q#shift->stdout->read(@_)#;
$xl=bless({$o,$vl,$q,$wl,$s,$t},$u);
$yl=[];
$zl=q#shift->stdin->write(@_)#;
$Al=bless({$o,$yl,$q,$zl,$s,$t},$u);
$Bl={$La,$xl,$Ta,$Al};
$Cl=q#/io/pid_io.b#;
$Dl=bless({$d4,$ul,$U4,$V4,$W4,$V4,$X4,$Bl,$D,$Cl},$i5);
$El={};
$Fl=[];
$Gl=q#$_[0]->{external_fds}{$_[1]}#;
$Hl=bless({$o,$Fl,$q,$Gl,$s,$t},$u);
$Il=[];
$Jl=q#shift->fd(2)#;
$Kl=bless({$o,$Il,$q,$Jl,$s,$t},$u);
$Ll=[];
$Ml=q#shift->fd(0)#;
$Nl=bless({$o,$Ll,$q,$Ml,$s,$t},$u);
$Ol=[];
$Pl=q#shift->fd(1)#;
$Ql=bless({$o,$Ol,$q,$Pl,$s,$t},$u);
$Rl={$Uc,$Hl,$Yc,$Kl,$ed,$Nl,$id,$Ql};
$Sl=q#/io/pid_accessors.b#;
$Tl=bless({$d4,$El,$U4,$V4,$W4,$V4,$X4,$Rl,$D,$Sl},$i5);
$Ul=[$Ba,$Vk,$hl,$tl,$Dl,$Tl];
$Vl=bless({$d4,$Jk,$D,$T2,$N4,$Ul},$q4);
$Wl=q#io/pid.c::ctors#;
$Xl=q#ni:/io/pid.c#;
$Yl={$q4,1};
$Zl=q#/io/pid.c#;
$cm=[$xb];
$dm=bless({$d4,$Yl,$D,$Zl,$N4,$cm},$O4);
$em=q#ni:/io/pid_accessors.b#;
$fm=q#ni:/io/pid_init.b#;
$gm=q#ni:/io/pid_io.b#;
$hm=q#ni:/io/pid_readers.b#;
$im=q#ni:/io/pid_wait.b#;
$jm=q#ni:/io/str#;
$km={$p6,1};
$lm=q#/io/str#;
$mm={};
$nm=q#data#;
$om=[];
$pm=q#shift->{'data'}#;
$qm=bless({$o,$om,$q,$pm,$s,$t},$u);
$rm=q#end#;
$sm=[];
$tm=q#shift->{'end'}#;
$um=bless({$o,$sm,$q,$tm,$s,$t},$u);
$vm=q#start#;
$wm=[];
$xm=q#shift->{'start'}#;
$ym=bless({$o,$wm,$q,$xm,$s,$t},$u);
$zm={$nm,$qm,$rm,$um,$vm,$ym};
$Am=q#/io/str_ro.b#;
$Bm=bless({$d4,$mm,$U4,$V4,$W4,$V4,$X4,$zm,$D,$Am},$i5);
$Cm={};
$Dm=[];
$Em=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Fm=bless({$o,$Dm,$q,$Em,$s,$t},$u);
$Gm={$W5,$Fm};
$Hm=q#/io/str_init.b#;
$Im=bless({$d4,$Cm,$U4,$V4,$W4,$V4,$X4,$Gm,$D,$Hm},$i5);
$Jm={};
$Km=[];
$Lm=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Mm=bless({$o,$Km,$q,$Lm,$s,$t},$u);
$Nm=q#remaining#;
$Om=[];
$Pm=q#my $self = shift; $$self{end} - $$self{start}#;
$Qm=bless({$o,$Om,$q,$Pm,$s,$t},$u);
$Rm=[];
$Sm=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Tm=bless({$o,$Rm,$q,$Sm,$s,$t},$u);
$Um={$La,$Mm,$Nm,$Qm,$Ta,$Tm};
$Vm=q#/io/str_io.b#;
$Wm=bless({$d4,$Jm,$U4,$V4,$W4,$V4,$X4,$Um,$D,$Vm},$i5);
$Xm=[$Ba,$Bm,$Im,$Wm];
$Ym=bless({$d4,$km,$D,$lm,$N4,$Xm},$r4);
$Zm=q#io/str.c::ctors#;
$cn=q#ni:/io/str.c#;
$dn={$r4,1};
$en=q#/io/str.c#;
$fn=[$xb];
$gn=bless({$d4,$dn,$D,$en,$N4,$fn},$O4);
$hn=q#ni:/io/str_init.b#;
$in=q#ni:/io/str_io.b#;
$jn=q#ni:/io/str_ro.b#;
$kn=q#ni:/io/transfer#;
$ln={$q6,1,$r6,1,$s6,1};
$mn=q#/io/transfer#;
$nn={$q6,1,$r6,1,$s6,1,$A6,1};
$on=q#/semantic/task#;
$pn={};
$qn=q#outcome#;
$rn=[];
$sn=q#shift->{'outcome'}#;
$tn=bless({$o,$rn,$q,$sn,$s,$t},$u);
$un={$qn,$tn};
$vn=q#/semantic/task_ro.b#;
$wn=bless({$d4,$pn,$U4,$V4,$W4,$V4,$X4,$un,$D,$vn},$i5);
$xn={};
$yn=q#failure#;
$zn=[];
$An=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Bn=bless({$o,$zn,$q,$An,$s,$t},$u);
$Cn=q#success#;
$Dn=[];
$En=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Fn=bless({$o,$Dn,$q,$En,$s,$t},$u);
$Gn={$yn,$Bn,$Cn,$Fn};
$Hn=q#/semantic/task_outcome.b#;
$In=bless({$d4,$xn,$U4,$V4,$W4,$V4,$X4,$Gn,$D,$Hn},$i5);
$Jn=[$K6,$wn,$In];
$Kn=bless({$d4,$nn,$D,$on,$N4,$Jn},$L4);
$Ln=q#semantic/task.c::ctors#;
$Mn={};
$Nn=[];
$On=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Pn=bless({$o,$Nn,$q,$On,$s,$t},$u);
$Qn=[];
$Rn=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Sn=bless({$o,$Qn,$q,$Rn,$s,$t},$u);
$Tn=[];
$Un=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn={$La,$Sn,$Ta,$Vn};
$Xn=q#/io/transfer_io_interop.b#;
$Yn=bless({$d4,$Mn,$U4,$Pn,$W4,$V4,$X4,$Wn,$D,$Xn},$i5);
$Zn={};
$co=q#pressure#;
$do=[];
$eo=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$fo=bless({$o,$do,$q,$eo,$s,$t},$u);
$go=q#read_limit_throughput#;
$ho=[];
$io=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$jo=bless({$o,$ho,$q,$io,$s,$t},$u);
$ko=q#throughput#;
$lo=[];
$mo=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$no=bless({$o,$lo,$q,$mo,$s,$t},$u);
$oo=q#write_limit_throughput#;
$po=[];
$qo=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so={$co,$fo,$go,$jo,$ko,$no,$oo,$ro};
$to=q#/io/transfer_io_measurement.b#;
$uo=bless({$d4,$Zn,$U4,$V4,$W4,$V4,$X4,$so,$D,$to},$i5);
$vo=[$Kn,$Yn,$uo];
$wo=bless({$d4,$ln,$D,$mn,$N4,$vo},$s4);
$xo=q#io/transfer.c::ctors#;
$yo=q#ni:/io/transfer.c#;
$zo={$s4,1,$t4,1,$u4,1};
$Ao=q#/io/transfer.c#;
$Bo={$s4,1,$t4,1,$u4,1,$L4,1};
$Co=q#/semantic/task.c#;
$Do=[$x8];
$Eo=bless({$d4,$Bo,$D,$Co,$N4,$Do},$O4);
$Fo={};
$Go=[];
$Ho=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo={};
$Ko=q#/io/transfer.c_into.b#;
$Lo=bless({$d4,$Fo,$U4,$Io,$W4,$V4,$X4,$Jo,$D,$Ko},$i5);
$Mo=[$Eo,$Lo];
$No=bless({$d4,$zo,$D,$Ao,$N4,$Mo},$O4);
$Oo=q#ni:/io/transfer.c_into.b#;
$Po=q#ni:/io/transfer_async#;
$Qo={$r6,1};
$Ro=q#/io/transfer_async#;
$So={};
$To=q#dest_io#;
$Uo=[];
$Vo=q#shift->{'dest_io'}#;
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo=[];
$Yo=bless({$o,$Xo,$q,$ti,$s,$t},$u);
$Zo=q#source_io#;
$cp=[];
$dp=q#shift->{'source_io'}#;
$ep=bless({$o,$cp,$q,$dp,$s,$t},$u);
$fp={$To,$Wo,$ri,$Yo,$Zo,$ep};
$gp=q#/io/transfer_async_ro.b#;
$hp=bless({$d4,$So,$U4,$V4,$W4,$V4,$X4,$fp,$D,$gp},$i5);
$ip={};
$jp=[];
$kp=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$lp=bless({$o,$jp,$q,$kp,$s,$t},$u);
$mp={$W5,$lp};
$np=q#/io/transfer_async_init.b#;
$op=bless({$d4,$ip,$U4,$V4,$W4,$V4,$X4,$mp,$D,$np},$i5);
$pp={};
$qp=[];
$rp=q#ni('ni:/io/transfer_async')->track(shift)#;
$sp=bless({$o,$qp,$q,$rp,$s,$t},$u);
$tp=[];
$up=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={};
$xp=q#/io/transfer_async_lifecycle.b#;
$yp=bless({$d4,$pp,$U4,$sp,$W4,$vp,$X4,$wp,$D,$xp},$i5);
$zp={};
$Ap=q#run#;
$Bp=[];
$Cp=q#shift#;
$Dp=bless({$o,$Bp,$q,$Cp,$s,$t},$u);
$Ep=q#run_async#;
$Fp=[];
$Gp=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Hp=bless({$o,$Fp,$q,$Gp,$s,$t},$u);
$Ip={$Ap,$Dp,$Ep,$Hp};
$Jp=q#/io/transfer_async_run.b#;
$Kp=bless({$d4,$zp,$U4,$V4,$W4,$V4,$X4,$Ip,$D,$Jp},$i5);
$Lp=[$wo,$hp,$op,$yp,$Kp];
$Mp=q#tracked_transfers#;
$Np={};
$Op=q#transfer_id#;
$Pp=bless({$d4,$Qo,$D,$Ro,$N4,$Lp,$Mp,$Np,$Op,0},$t4);
$Qp=q#io/transfer_async.c::ctors#;
$Rp=q#ni:/io/transfer_async.c#;
$Sp={$t4,1};
$Tp=q#/io/transfer_async.c#;
$Up={};
$Vp=[];
$Wp=q#my $self = shift;
$$self{tracked_transfers} = {};
$$self{transfer_id}       = 0;#;
$Xp=bless({$o,$Vp,$q,$Wp,$s,$t},$u);
$Yp=q#new_id#;
$Zp=[];
$cq=q#++shift->{transfer_id}#;
$dq=bless({$o,$Zp,$q,$cq,$s,$t},$u);
$eq=q#track#;
$fq=[];
$gq=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$hq=bless({$o,$fq,$q,$gq,$s,$t},$u);
$iq=q#untrack#;
$jq=[];
$kq=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$lq=bless({$o,$jq,$q,$kq,$s,$t},$u);
$mq={$Yp,$dq,$eq,$hq,$iq,$lq};
$nq=q#/io/transfer_async.c_tracker.b#;
$oq=bless({$d4,$Up,$U4,$Xp,$W4,$V4,$X4,$mq,$D,$nq},$i5);
$pq=[$No,$oq];
$qq=bless({$d4,$Sp,$D,$Tp,$N4,$pq},$O4);
$rq=q#ni:/io/transfer_async.c_tracker.b#;
$sq=q#ni:/io/transfer_async_init.b#;
$tq=q#ni:/io/transfer_async_lifecycle.b#;
$uq=q#ni:/io/transfer_async_ro.b#;
$vq=q#ni:/io/transfer_async_run.b#;
$wq=q#ni:/io/transfer_io_interop.b#;
$xq=q#ni:/io/transfer_io_measurement.b#;
$yq=q#ni:/io/transfer_sync#;
$zq={$s6,1};
$Aq=q#/io/transfer_sync#;
$Bq={};
$Cq=[];
$Dq=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Eq=bless({$o,$Cq,$q,$Dq,$s,$t},$u);
$Fq={$W5,$Eq};
$Gq=q#/io/transfer_sync_init.b#;
$Hq=bless({$d4,$Bq,$U4,$V4,$W4,$V4,$X4,$Fq,$D,$Gq},$i5);
$Iq={};
$Jq=[];
$Kq=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Lq=bless({$o,$Jq,$q,$Kq,$s,$t},$u);
$Mq={$Ap,$Lq};
$Nq=q#/io/transfer_sync_run.b#;
$Oq=bless({$d4,$Iq,$U4,$V4,$W4,$V4,$X4,$Mq,$D,$Nq},$i5);
$Pq=[$wo,$Hq,$Oq];
$Qq=bless({$d4,$zq,$D,$Aq,$N4,$Pq},$u4);
$Rq=q#io/transfer_sync.c::ctors#;
$Sq=q#ni:/io/transfer_sync.c#;
$Tq={$u4,1};
$Uq=q#/io/transfer_sync.c#;
$Vq=[$No];
$Wq=bless({$d4,$Tq,$D,$Uq,$N4,$Vq},$O4);
$Xq=q#ni:/io/transfer_sync_init.b#;
$Yq=q#ni:/io/transfer_sync_run.b#;
$Zq=q#ni:/lib/accessor.b#;
$cr=q#ni:/lib/behavior#;
$dr=q#ni:/lib/behavior.c#;
$er=q#ni:/lib/branch#;
$fr={$k5,1};
$gr=q#/lib/branch#;
$hr={};
$ir=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$jr=bless({$q,$ir,$s,$t},$u);
$kr={$W5,$jr};
$lr=q#/lib/branch_init.b#;
$mr=bless({$d4,$hr,$U4,$V4,$W4,$V4,$X4,$kr,$D,$lr},$i5);
$nr=[$V6,$t5,$j5,$mr,$O7];
$or=bless({$d4,$fr,$D,$gr,$N4,$nr},$w4);
$pr=q#lib/branch.c::ctors#;
$qr=q#ni:/lib/branch.b#;
$rr=q#ni:/lib/branch.c#;
$sr={$w4,1};
$tr=q#/lib/branch.c#;
$ur=[$C8];
$vr=bless({$d4,$sr,$D,$tr,$N4,$ur},$O4);
$wr=q#ni:/lib/branch_init.b#;
$xr=q#ni:/lib/class_init.b#;
$yr=q#ni:/lib/dataslice#;
$zr={$u6,1};
$Ar=q#/lib/dataslice#;
$Br={};
$Cr=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Dr=bless({$q,$Cr,$s,$t},$u);
$Er={$W5,$Dr};
$Fr=q#/lib/dataslice_init.b#;
$Gr=bless({$d4,$Br,$U4,$V4,$W4,$V4,$X4,$Er,$D,$Fr},$i5);
$Hr={};
$Ir=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Jr=bless({$q,$Ir,$s,$t},$u);
$Kr={$d5,$Jr};
$Lr=q#/lib/dataslice_apply.b#;
$Mr=bless({$d4,$Hr,$U4,$V4,$W4,$V4,$X4,$Kr,$D,$Lr},$i5);
$Nr=[$V6,$Gr,$Mr];
$Or=bless({$d4,$zr,$D,$Ar,$N4,$Nr},$x4);
$Pr=q#lib/dataslice.c::ctors#;
$Qr=q#ni:/lib/dataslice.c#;
$Rr={$x4,1};
$Sr=q#/lib/dataslice.c#;
$Tr=[$C8];
$Ur=bless({$d4,$Rr,$D,$Sr,$N4,$Tr},$O4);
$Vr=q#ni:/lib/dataslice_apply.b#;
$Wr=q#ni:/lib/dataslice_init.b#;
$Xr=q#ni:/lib/definition.b#;
$Yr=q#ni:/lib/definition_def.b#;
$Zr=q#ni:/lib/definition_defdata.b#;
$cs=q#ni:/lib/doc#;
$ds={$F,1};
$es={};
$fs=q#shift; +{name => shift, doc => []}#;
$gs=bless({$q,$fs,$s,$t},$u);
$hs={$W5,$gs};
$is=q#/lib/doc_init.b#;
$js=bless({$d4,$es,$U4,$V4,$W4,$V4,$X4,$hs,$D,$is},$i5);
$ks={};
$ls=q#'ni.doc'#;
$ms=bless({$q,$ls,$s,$t},$u);
$ns={$w5,$ms};
$os=q#/lib/doc_namespace.b#;
$ps=bless({$d4,$ks,$U4,$V4,$W4,$V4,$X4,$ns,$D,$os},$i5);
$qs={};
$rs=q#AUTOLOAD#;
$ss=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$ts=bless({$q,$ss,$s,$t},$u);
$us={$rs,$ts};
$vs=q#/lib/doc_define.b#;
$ws=bless({$d4,$qs,$U4,$V4,$W4,$V4,$X4,$us,$D,$vs},$i5);
$xs={};
$ys=q#shift->referent#;
$zs=bless({$q,$ys,$s,$t},$u);
$As=q#referent#;
$Bs=q#ni 'ni:' . shift->{name}#;
$Cs=bless({$q,$Bs,$s,$t},$u);
$Ds={$rm,$zs,$As,$Cs};
$Es=q#/lib/doc_end.b#;
$Fs=bless({$d4,$xs,$U4,$V4,$W4,$V4,$X4,$Ds,$D,$Es},$i5);
$Gs={};
$Hs=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Is=bless({$q,$Hs,$s,$t},$u);
$Js=q#linearized#;
$Ks=q#map @$_, @{shift->{doc}}#;
$Ls=bless({$q,$Ks,$s,$t},$u);
$Ms=q#tests#;
$Ns=q#my $self = shift;
my @flattened = $self->linearized;
return () unless @flattened;
my @eg_indexes = grep $flattened[$_] eq 'eg', 0..$\#flattened;
for (@eg_indexes) {
  ++$_ until $_ > @flattened or ref $flattened[$_] eq 'lib/fn';
}
@flattened[@eg_indexes];#;
$Os=bless({$q,$Ns,$s,$t},$u);
$Ps={$n,$Is,$Js,$Ls,$Ms,$Os};
$Qs=q#/lib/doc_test.b#;
$Rs=bless({$d4,$Gs,$U4,$V4,$W4,$V4,$X4,$Ps,$D,$Qs},$i5);
$Ss=[$K6,$t5,$js,$ps,$ws,$Fs,$Rs];
$Ts=bless({$d4,$ds,$D,$s3,$N4,$Ss},$y4);
$Us=q#lib/doc.c::ctors#;
$Vs=q#ni:/lib/doc.c#;
$Ws={$y4,1};
$Xs=q#/lib/doc.c#;
$Ys=[$x8];
$Zs=bless({$d4,$Ws,$D,$Xs,$N4,$Ys},$O4);
$ct=q#ni:/lib/doc_define.b#;
$dt=q#ni:/lib/doc_end.b#;
$et=q#ni:/lib/doc_init.b#;
$ft=q#ni:/lib/doc_namespace.b#;
$gt=q#ni:/lib/doc_test.b#;
$ht=q#ni:/lib/documentable.b#;
$it=q#ni:/lib/fn#;
$jt={$u,1};
$kt=q#/lib/fn#;
$lt={};
$mt=q#shift->compile#;
$nt=bless({$q,$mt,$s,$t},$u);
$ot=q#compile#;
$pt=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$qt=bless({$q,$pt,$s,$t},$u);
$rt=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$st=bless({$q,$rt,$s,$t},$u);
$tt={$ot,$qt,$W5,$st};
$ut=q#/lib/fn_init.b#;
$vt=bless({$d4,$lt,$U4,$nt,$W4,$V4,$X4,$tt,$D,$ut},$i5);
$wt={};
$xt=[];
$yt=q#shift->{'annotations'}#;
$zt=bless({$o,$xt,$q,$yt,$s,$t},$u);
$At=[];
$Bt=q#shift->{'code'}#;
$Ct=bless({$o,$At,$q,$Bt,$s,$t},$u);
$Dt=q#fn#;
$Et=[];
$Ft=q#shift->{'fn'}#;
$Gt=bless({$o,$Et,$q,$Ft,$s,$t},$u);
$Ht={$o,$zt,$q,$Ct,$Dt,$Gt};
$It=q#/lib/fn_ro.b#;
$Jt=bless({$d4,$wt,$U4,$V4,$W4,$V4,$X4,$Ht,$D,$It},$i5);
$Kt={};
$Lt=[];
$Mt=q#shift->{code}#;
$Nt=bless({$o,$Lt,$q,$Mt,$s,$t},$u);
$Ot=[];
$Pt=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Qt=bless({$o,$Ot,$q,$Pt,$s,$t},$u);
$Rt={$t7,$Nt,$A7,$Qt};
$St=q#/lib/fn_ops.b#;
$Tt=bless({$d4,$Kt,$U4,$V4,$W4,$V4,$X4,$Rt,$D,$St},$i5);
$Ut={};
$Vt=q#serialize#;
$Wt=[];
$Xt=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Yt=bless({$o,$Wt,$q,$Xt,$s,$t},$u);
$Zt={$Vt,$Yt};
$cu=q#/lib/fn_serialize.b#;
$du=bless({$d4,$Ut,$U4,$V4,$W4,$V4,$X4,$Zt,$D,$cu},$i5);
$eu=[$K6,$e8,$vt,$Jt,$Tt,$du];
$fu=bless({$d4,$jt,$D,$kt,$N4,$eu},$z4);
$gu=q#lib/fn.c::ctors#;
$hu=q#ni:/lib/fn.c#;
$iu={$z4,1};
$ju=q#/lib/fn.c#;
$ku=[$x8];
$lu=bless({$d4,$iu,$D,$ju,$N4,$ku},$O4);
$mu=q#ni:/lib/fn_init.b#;
$nu=q#ni:/lib/fn_ops.b#;
$ou=q#ni:/lib/fn_ro.b#;
$pu=q#ni:/lib/fn_serialize.b#;
$qu=q#ni:/lib/gensym_generator_compact.b#;
$ru={};
$su=q#gensym#;
$tu=[];
$uu=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$vu=bless({$o,$tu,$q,$uu,$s,$t},$u);
$wu={$su,$vu};
$xu=q#/lib/gensym_generator_compact.b#;
$yu=bless({$d4,$ru,$U4,$V4,$W4,$V4,$X4,$wu,$D,$xu},$i5);
$zu=q#ni:/lib/global_static_test.b#;
$Au={};
$Bu=q#now#;
$Cu=[];
$Du=q#ni('ni:/lib/test_value')->new(shift)#;
$Eu=q#($)#;
$Fu=bless({$o,$Cu,$q,$Du,$s,$Eu},$u);
$Gu={$Bu,$Fu};
$Hu=q#/lib/global_static_test.b#;
$Iu=bless({$d4,$Au,$U4,$V4,$W4,$V4,$X4,$Gu,$D,$Hu},$i5);
$Ju=q#ni:/lib/image#;
$Ku={$v6,1};
$Lu={};
$Mu=[];
$Nu=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Ou=bless({$o,$Mu,$q,$Nu,$s,$t},$u);
$Pu={$W5,$Ou};
$Qu=q#/lib/image_init.b#;
$Ru=bless({$d4,$Lu,$U4,$V4,$W4,$V4,$X4,$Pu,$D,$Qu},$i5);
$Su={};
$Tu=q#address#;
$Uu=[];
$Vu=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Wu=bless({$o,$Uu,$q,$Vu,$s,$t},$u);
$Xu=q#allocate_gensym#;
$Yu=[];
$Zu=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$cv=bless({$o,$Yu,$q,$Zu,$s,$t},$u);
$dv=q#boot_side_effect#;
$ev=[];
$fv=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$gv=bless({$o,$ev,$q,$fv,$s,$t},$u);
$hv=q#circular_links#;
$iv=[];
$jv=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$kv=bless({$o,$iv,$q,$jv,$s,$t},$u);
$lv=q#finalizer#;
$mv=[];
$nv=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$ov=bless({$o,$mv,$q,$nv,$s,$t},$u);
$pv=q#quote#;
$qv=[];
$rv=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$sv=bless({$o,$qv,$q,$rv,$s,$t},$u);
$tv=q#reconstruction#;
$uv=[];
$vv=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$wv=bless({$o,$uv,$q,$vv,$s,$t},$u);
$xv=q#side_effect#;
$yv=[];
$zv=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Av=bless({$o,$yv,$q,$zv,$s,$t},$u);
$Bv=[];
$Cv=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Dv=bless({$o,$Bv,$q,$Cv,$s,$t},$u);
$Ev={$Tu,$Wu,$Xu,$cv,$dv,$gv,$hv,$kv,$lv,$ov,$pv,$sv,$tv,$wv,$xv,$Av,$Ta,$Dv};
$Fv=q#/lib/image_quoting.b#;
$Gv=bless({$d4,$Su,$U4,$V4,$W4,$V4,$X4,$Ev,$D,$Fv},$i5);
$Hv={};
$Iv=q#quote_code#;
$Jv=[];
$Kv=q#shift->die('cannot quote perl CODE refs', shift)#;
$Lv=bless({$o,$Jv,$q,$Kv,$s,$t},$u);
$Mv={$Iv,$Lv};
$Nv=q#/lib/quote_code_fail.b#;
$Ov=bless({$d4,$Hv,$U4,$V4,$W4,$V4,$X4,$Mv,$D,$Nv},$i5);
$Pv={};
$Qv=q#quote_array#;
$Rv=[];
$Sv=q#local $_;
my ($self, $v) = @_;
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Tv=bless({$o,$Rv,$q,$Sv,$s,$t},$u);
$Uv=q#quote_hash#;
$Vv=[];
$Wv=q#local $_;
my ($self, $v) = @_;
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Xv=bless({$o,$Vv,$q,$Wv,$s,$t},$u);
$Yv=q#quote_scalar#;
$Zv=[];
$cw=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$dw=bless({$o,$Zv,$q,$cw,$s,$t},$u);
$ew=q#quote_scalar_ref#;
$fw=[];
$gw=q#'\\\\' . shift->quote(${$_[0]})#;
$hw=bless({$o,$fw,$q,$gw,$s,$t},$u);
$iw=q#quote_value#;
$jw=[];
$kw=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$lw=bless({$o,$jw,$q,$kw,$s,$t},$u);
$mw={$Qv,$Tv,$Uv,$Xv,$Yv,$dw,$ew,$hw,$iw,$lw};
$nw=q#/lib/quote_values.b#;
$ow=bless({$d4,$Pv,$U4,$V4,$W4,$V4,$X4,$mw,$D,$nw},$i5);
$pw={};
$qw=q#quote_blessed#;
$rw=[];
$sw=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$tw=bless({$o,$rw,$q,$sw,$s,$t},$u);
$uw=q#quote_class#;
$vw=[];
$ww=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$xw=bless({$o,$vw,$q,$ww,$s,$t},$u);
$yw=q#quote_object#;
$zw=[];
$Aw=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . '::ctors') . ';')
  if @{ref($_[0]) . '::ctors'};
$q;#;
$Bw=bless({$o,$zw,$q,$Aw,$s,$t},$u);
$Cw={$qw,$tw,$uw,$xw,$yw,$Bw};
$Dw=q#/lib/quote_objects.b#;
$Ew=bless({$d4,$pw,$U4,$V4,$W4,$V4,$X4,$Cw,$D,$Dw},$i5);
$Fw={};
$Gw=q#circular_arrayref#;
$Hw=[];
$Iw=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Jw=bless({$o,$Hw,$q,$Iw,$s,$t},$u);
$Kw=q#circular_hashref#;
$Lw=[];
$Mw=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Nw=bless({$o,$Lw,$q,$Mw,$s,$t},$u);
$Ow=q#is_circular#;
$Pw=[];
$Qw=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Rw=bless({$o,$Pw,$q,$Qw,$s,$t},$u);
$Sw={$Gw,$Jw,$Kw,$Nw,$Ow,$Rw};
$Tw=q#/lib/quote_circular_addressed.b#;
$Uw=bless({$d4,$Fw,$U4,$V4,$W4,$V4,$X4,$Sw,$D,$Tw},$i5);
$Vw=[$K6,$Ru,$Gv,$Ov,$ow,$Ew,$Uw,$yu];
$Ww=bless({$d4,$Ku,$D,$A3,$N4,$Vw},$A4);
$Xw=q#lib/image.c::ctors#;
$Yw=q#ni:/lib/image.c#;
$Zw={$A4,1};
$cx=q#/lib/image.c#;
$dx=[$x8];
$ex=bless({$d4,$Zw,$D,$cx,$N4,$dx},$O4);
$fx=q#ni:/lib/image_init.b#;
$gx=q#ni:/lib/image_quoting.b#;
$hx=q#ni:/lib/instance.b#;
$ix=q#ni:/lib/instantiable.b#;
$jx=q#ni:/lib/json.b#;
$kx={};
$lx=q#json_decode#;
$mx=[];
$nx=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$ox=bless({$o,$mx,$q,$nx,$s,$Eu},$u);
$px=q#json_encode#;
$qx=[];
$rx=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$sx=bless({$o,$qx,$q,$rx,$s,$Eu},$u);
$tx=q#json_escape#;
$ux=[];
$vx=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$wx=bless({$o,$ux,$q,$vx,$s,$Eu},$u);
$xx=q#json_unescape#;
$yx=[];
$zx=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Ax=bless({$o,$yx,$q,$zx,$s,$Eu},$u);
$Bx=q#json_unescape_one#;
$Cx=[];
$Dx=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Ex=bless({$o,$Cx,$q,$Dx,$s,$Eu},$u);
$Fx={$lx,$ox,$px,$sx,$tx,$wx,$xx,$Ax,$Bx,$Ex};
$Gx=q#/lib/json.b#;
$Hx=bless({$d4,$kx,$U4,$V4,$W4,$V4,$X4,$Fx,$D,$Gx},$i5);
$Ix=q#ni#;
$Jx=q#ni:/lib/name_as_string.b#;
$Kx=q#ni:/lib/named.b#;
$Lx=q#ni:/lib/named_in_ni.b#;
$Mx=q#ni:/lib/namespaced.b#;
$Nx=q#ni:/lib/ni#;
$Ox={$w6,1};
$Px={};
$Qx=q#extend#;
$Rx=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Sx=bless({$q,$Rx,$s,$t},$u);
$Tx=q#is_mutable#;
$Ux=q#$0 ne '-' && -w $0#;
$Vx=bless({$q,$Ux,$s,$t},$u);
$Wx=q#modify#;
$Xx=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Yx=bless({$q,$Xx,$s,$t},$u);
$Zx={$Qx,$Sx,$Tx,$Vx,$Wx,$Yx};
$cy=q#/lib/ni_self.b#;
$dy=bless({$d4,$Px,$U4,$V4,$W4,$V4,$X4,$Zx,$D,$cy},$i5);
$ey={};
$fy=q#--internal/+=#;
$gy=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$hy=bless({$q,$gy,$s,$t},$u);
$iy=q#--internal/eval#;
$jy=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$ky=bless({$q,$jy,$s,$t},$u);
$ly=q#--internal/image#;
$my=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$ny=bless({$q,$my,$s,$t},$u);
$oy=q#--internal/test#;
$py=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$qy=bless({$q,$py,$s,$t},$u);
$ry=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$sy=bless({$q,$ry,$s,$t},$u);
$ty={$fy,$hy,$iy,$ky,$ly,$ny,$oy,$qy,$Ap,$sy};
$uy=q#/lib/ni_main.b#;
$vy=bless({$d4,$ey,$U4,$V4,$W4,$V4,$X4,$ty,$D,$uy},$i5);
$wy={};
$xy=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$yy=bless({$q,$xy,$s,$t},$u);
$zy=q#resolver_for#;
$Ay=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$By=bless({$q,$Ay,$s,$t},$u);
$Cy={$K5,$yy,$zy,$By};
$Dy=q#/lib/ni_resolver.b#;
$Ey=bless({$d4,$wy,$U4,$V4,$W4,$V4,$X4,$Cy,$D,$Dy},$i5);
$Fy={};
$Gy=q#exists#;
$Hy=q#exists $_[0]->{named}{$_[1]}#;
$Iy=bless({$q,$Hy,$s,$t},$u);
$Jy=q#quoted#;
$Ky=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Ly=bless({$q,$Ky,$s,$t},$u);
$My={$Gy,$Iy,$Jy,$Ly};
$Ny=q#/lib/ni_image.b#;
$Oy=bless({$d4,$Fy,$U4,$V4,$W4,$V4,$X4,$My,$D,$Ny},$i5);
$Py=[$K6,$dy,$vy,$Ey,$Oy];
$Qy=bless({$d4,$Ox,$D,$I3,$N4,$Py},$B4);
$Ry=q#lib/ni.c::ctors#;
$Sy=q#ni:/lib/ni.c#;
$Ty={$B4,1};
$Uy=q#/lib/ni.c#;
$Vy=[$x8];
$Wy=bless({$d4,$Ty,$D,$Uy,$N4,$Vy},$O4);
$Xy=q#ni:/lib/ni_image.b#;
$Yy=q#ni:/lib/ni_main.b#;
$Zy=q#ni:/lib/ni_resolver.b#;
$cz=q#ni:/lib/ni_self.b#;
$dz=q#ni:/lib/ni_static_util.b#;
$ez={};
$fz=q#abbrev#;
$gz=[];
$hz=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$iz=bless({$o,$gz,$q,$hz,$s,$t},$u);
$jz=q#dor#;
$kz=[];
$lz=q#defined $_[0] ? $_[0] : $_[1]#;
$mz=bless({$o,$kz,$q,$lz,$s,$t},$u);
$nz=q#indent#;
$oz=[];
$pz=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$qz=bless({$o,$oz,$q,$pz,$s,$t},$u);
$rz=q#max#;
$sz=[];
$tz=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$uz=bless({$o,$sz,$q,$tz,$s,$t},$u);
$vz=q#maxstr#;
$wz=[];
$xz=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$yz=bless({$o,$wz,$q,$xz,$s,$t},$u);
$zz=q#mean#;
$Az=[];
$Bz=q#sum(@_) / (@_ || 1)#;
$Cz=bless({$o,$Az,$q,$Bz,$s,$t},$u);
$Dz=q#min#;
$Ez=[];
$Fz=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Gz=bless({$o,$Ez,$q,$Fz,$s,$t},$u);
$Hz=q#minstr#;
$Iz=[];
$Jz=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Kz=bless({$o,$Iz,$q,$Jz,$s,$t},$u);
$Lz=q#sgr#;
$Mz=[];
$Nz=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Oz=bless({$o,$Mz,$q,$Nz,$s,$t},$u);
$Pz=q#sr#;
$Qz=[];
$Rz=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Sz=bless({$o,$Qz,$q,$Rz,$s,$t},$u);
$Tz=q#sum#;
$Uz=[];
$Vz=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Wz=bless({$o,$Uz,$q,$Vz,$s,$t},$u);
$Xz=q#swap#;
$Yz=[];
$Zz=q#@_[0, 1] = @_[1, 0]#;
$cA=bless({$o,$Yz,$q,$Zz,$s,$t},$u);
$dA={$fz,$iz,$jz,$mz,$nz,$qz,$rz,$uz,$vz,$yz,$zz,$Cz,$Dz,$Gz,$Hz,$Kz,$Lz,$Oz,$Pz,$Sz,$Tz,$Wz,$Xz,$cA};
$eA=q#/lib/ni_static_util.b#;
$fA=bless({$d4,$ez,$U4,$V4,$W4,$V4,$X4,$dA,$D,$eA},$i5);
$gA=q#ni:/lib/perlbranch.b#;
$hA=q#ni:/lib/quote_circular_addressed.b#;
$iA=q#ni:/lib/quote_code_fail.b#;
$jA=q#ni:/lib/quote_objects.b#;
$kA=q#ni:/lib/quote_simple#;
$lA={$x6,1};
$mA={};
$nA=[];
$oA=q#+{}#;
$pA=bless({$o,$nA,$q,$oA,$s,$t},$u);
$qA={$W5,$pA};
$rA=q#/lib/quote_simple_init.b#;
$sA=bless({$d4,$mA,$U4,$V4,$W4,$V4,$X4,$qA,$D,$rA},$i5);
$tA={};
$uA=[];
$vA=bless({$o,$uA,$q,0,$s,$t},$u);
$wA=[];
$xA=q#shift->quote_value(shift)#;
$yA=bless({$o,$wA,$q,$xA,$s,$t},$u);
$zA={$Ow,$vA,$pv,$yA};
$AA=q#/lib/quote_simple_quote.b#;
$BA=bless({$d4,$tA,$U4,$V4,$W4,$V4,$X4,$zA,$D,$AA},$i5);
$CA=[$K6,$sA,$BA,$Ov,$ow,$Ew];
$DA=bless({$d4,$lA,$D,$S3,$N4,$CA},$C4);
$EA=q#lib/quote_simple.c::ctors#;
$FA=q#ni:/lib/quote_simple.c#;
$GA={$C4,1};
$HA=q#/lib/quote_simple.c#;
$IA=[$x8];
$JA=bless({$d4,$GA,$D,$HA,$N4,$IA},$O4);
$KA=q#ni:/lib/quote_simple_init.b#;
$LA=q#ni:/lib/quote_simple_quote.b#;
$MA=q#ni:/lib/quote_values.b#;
$NA=q#ni:/lib/ref_eq.b#;
$OA=q#ni:/lib/resolver.b#;
$PA=q#ni:/lib/slice#;
$QA={$i5,1};
$RA=q#/lib/slice#;
$SA=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$TA=bless({$q,$SA,$s,$t},$u);
$UA=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$VA=bless({$q,$UA,$s,$t},$u);
$WA=q#lib/slice::apply#;
$XA=q#lib/slice::apply_unsafe#;
$YA={};
$ZA=q#apply_unsafe#;
$cB={$d5,$TA,$ZA,$VA};
$dB=q#/lib/slice.b#;
$eB=bless({$d4,$YA,$X4,$cB,$D,$dB},$i5);
$fB={};
$gB=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$hB=bless({$q,$gB,$s,$t},$u);
$iB={$W5,$hB};
$jB=q#/lib/slice_init.b#;
$kB=bless({$d4,$fB,$X4,$iB,$D,$jB},$i5);
$lB={};
$mB=[];
$nB=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$oB=bless({$o,$mB,$q,$nB,$s,$t},$u);
$pB={$Vt,$oB};
$qB=q#/lib/slice_serialize.b#;
$rB=bless({$d4,$lB,$U4,$V4,$W4,$V4,$X4,$pB,$D,$qB},$i5);
$sB=[$V6,$t5,$eB,$kB,$rB];
$tB=bless({$d4,$QA,$D,$RA,$N4,$sB},$D4);
$uB=q#lib/slice.c::ctors#;
$vB=q#ni:/lib/slice.b#;
$wB=q#ni:/lib/slice.c#;
$xB={$D4,1};
$yB=q#/lib/slice.c#;
$zB=[$C8];
$AB=bless({$d4,$xB,$D,$yB,$N4,$zB},$O4);
$BB=q#ni:/lib/slice_init.b#;
$CB=q#ni:/lib/slice_serialize.b#;
$DB=q#ni:/lib/static_fn.b#;
$EB={};
$FB=[];
$GB=q#ni('ni:/lib/fn')->new(@_)#;
$HB=bless({$o,$FB,$q,$GB,$s,$Eu},$u);
$IB=q#fp#;
$JB=[];
$KB=q#($$)#;
$LB=bless({$o,$JB,$q,$GB,$s,$KB},$u);
$MB={$Dt,$HB,$IB,$LB};
$NB=q#/lib/static_fn.b#;
$OB=bless({$d4,$EB,$U4,$V4,$W4,$V4,$X4,$MB,$D,$NB},$i5);
$PB=q#ni:/lib/subclass.b#;
$QB=q#ni:/lib/tag#;
$RB={$u5,1};
$SB=q#/lib/tag#;
$TB={};
$UB=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$VB=bless({$q,$UB,$s,$t},$u);
$WB={$d5,$VB};
$XB=q#/lib/tag.b#;
$YB=bless({$d4,$TB,$U4,$V4,$W4,$V4,$X4,$WB,$D,$XB},$i5);
$ZB={};
$cC=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$dC=bless({$q,$cC,$s,$t},$u);
$eC={$W5,$dC};
$fC=q#/lib/tag_init.b#;
$gC=bless({$d4,$ZB,$U4,$V4,$W4,$V4,$X4,$eC,$D,$fC},$i5);
$hC=[$V6,$t5,$YB,$gC];
$iC=bless({$d4,$RB,$D,$SB,$N4,$hC},$E4);
$jC=q#lib/tag.c::ctors#;
$kC=q#ni:/lib/tag.b#;
$lC=q#ni:/lib/tag.c#;
$mC={$E4,1};
$nC=q#/lib/tag.c#;
$oC=[$C8];
$pC=bless({$d4,$mC,$D,$nC,$N4,$oC},$O4);
$qC=q#ni:/lib/tag_init.b#;
$rC=q#ni:/lib/test_value#;
$sC={$y6,1};
$tC=q#/lib/test_value#;
$uC={};
$vC=[];
$wC=q#\\$_[1]#;
$xC=bless({$o,$vC,$q,$wC,$s,$t},$u);
$yC={$W5,$xC};
$zC=q#/lib/test_value_init.b#;
$AC=bless({$d4,$uC,$U4,$V4,$W4,$V4,$X4,$yC,$D,$zC},$i5);
$BC={};
$CC=q#(==#;
$DC=[];
$EC=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$FC=bless({$o,$DC,$q,$EC,$s,$t},$u);
$GC=q#diff#;
$HC=[];
$IC=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]}
    unless !defined($lhs) && !defined($rhs) || $lhs eq $rhs;
}
return undef;#;
$JC=bless({$o,$HC,$q,$IC,$s,$t},$u);
$KC={$CC,$FC,$GC,$JC};
$LC=q#/lib/test_value_eq.b#;
$MC=bless({$d4,$BC,$U4,$V4,$W4,$V4,$X4,$KC,$D,$LC},$i5);
$NC={};
$OC=[];
$PC=q#ni::json_encode ${$_[0]}#;
$QC=bless({$o,$OC,$q,$PC,$s,$t},$u);
$RC={$t7,$QC};
$SC=q#/lib/test_value_str.b#;
$TC=bless({$d4,$NC,$U4,$V4,$W4,$V4,$X4,$RC,$D,$SC},$i5);
$UC=[$K6,$AC,$MC,$TC];
$VC=bless({$d4,$sC,$D,$tC,$N4,$UC},$F4);
$WC=q#lib/test_value.c::ctors#;
$XC=q#ni:/lib/test_value.c#;
$YC={$F4,1};
$ZC=q#/lib/test_value.c#;
$cD=[$x8];
$dD=bless({$d4,$YC,$D,$ZC,$N4,$cD},$O4);
$eD=q#ni:/lib/test_value_eq.b#;
$fD=q#ni:/lib/test_value_init.b#;
$gD=q#ni:/lib/test_value_str.b#;
$hD=q#ni:/metaclass#;
$iD={$O4,1};
$jD=q#/metaclass#;
$kD=[$R5,$e8,$d6,$R7];
$lD=bless({$d4,$iD,$D,$jD,$N4,$kD},$G4);
$mD=q#metaclass.c::ctors#;
$nD=q#ni:/metaclass.c#;
$oD={$G4,1};
$pD=q#/metaclass.c#;
$qD=[$n8];
$rD=bless({$d4,$oD,$D,$pD,$N4,$qD},$O4);
$sD=q#ni:/module#;
$tD=q#ni:/module.c#;
$uD=q#ni:/object#;
$vD=q#ni:/object.c#;
$wD=q#ni:/semantic/dimension#;
$xD={$J4,1};
$yD=q#/semantic/dimension#;
$zD=[$n8];
$AD=bless({$d4,$xD,$D,$yD,$N4,$zD},$K4);
$BD=q#semantic/dimension.c::ctors#;
$CD=q#ni:/semantic/dimension.c#;
$DD={$K4,1};
$ED=q#/semantic/dimension.c#;
$FD=[$G8];
$GD=bless({$d4,$DD,$D,$ED,$N4,$FD},$O4);
$HD=q#ni:/semantic/task#;
$ID=q#ni:/semantic/task.c#;
$JD=q#ni:/semantic/task_outcome.b#;
$KD=q#ni:/semantic/task_ro.b#;
$LD=q#ni:main#;
$MD={$Pj,1};
$ND=[$OB,$Iu,$Oj];
$OD=bless({$d4,$MD,$D,$Pj,$N4,$ND},$P4);
$PD=q#module::ctors#;
$QD=q#ni:ni#;
$RD={$Ix,1};
$SD={$Ix,1};
$TD=q#json_escapes#;
$UD=q##;
$VD=q#b#;
$WD=q#	#;
$XD=q#t#;
$YD=q#
#;
$ZD=q#n#;
$cE=q##;
$dE=q#"#;
$eE=q#/#;
$fE=q#\\#;
$gE={$UD,$VD,$WD,$XD,$YD,$ZD,$cE,$og,$dE,$dE,$eE,$eE,$fE,$fE};
$hE=q#json_unescapes#;
$iE={$dE,$dE,$eE,$eE,$fE,$fE,$VD,$UD,$ZD,$YD,$og,$cE,$XD,$WD};
$jE={$TD,$gE,$hE,$iE};
$kE=q#/lib/json_data.b#;
$lE=bless({$d4,$SD,$nm,$jE,$D,$kE},$u6);
$mE=[$lE,$Hx,$fA];
$nE=bless({$d4,$RD,$D,$Ix,$N4,$mE},$P4);
$oE={$d,$G,$I,$N,$O,$R,$S,$X,$Y,$l1,$m1,$x1,$y1,$J1,$K1,$V1,$W1,$p2,$q2,$y2,$z2,$E2,$F2,$U2,$V2,$d3,$e3,$t3,$u3,$B3,$C3,$J3,$K3,$T3,$U3,$Z3,$c4,$n8,$p8,$G8,$H8,$R8,$T8,$X8,$Y8,$P8,$Z8,$hb,$jb,$zb,$Ab,$Ja,$Bb,$fb,$Cb,$Tb,$Vb,$Zb,$cc,$Kb,$dc,$Rb,$ec,$Od,$Qd,$Ud,$Vd,$wd,$Wd,$Md,$Xd,$uc,$Yd,$od,$Zd,$Oc,$ce,$nc,$de,$pf,$rf,$vf,$wf,$Qe,$xf,$df,$yf,$se,$zf,$nf,$Af,$le,$Bf,$Ae,$Cf,$Gg,$Ig,$Mg,$Ng,$Sf,$Og,$jg,$Pg,$Zf,$Qg,$Eg,$Rg,$Kf,$Sg,$di,$fi,$ji,$ki,$fj,$hj,$Zh,$ij,$mj,$nj,$Ii,$oj,$dj,$pj,$Oi,$qj,$Bi,$rj,$oh,$sj,$Jh,$tj,$hh,$uj,$wh,$vj,$Oj,$Qj,$qk,$sk,$wk,$xk,$Zj,$yk,$ok,$zk,$Ba,$Ak,$xb,$Bk,$vb,$Ck,$F9,$Dk,$N9,$Ek,$Z9,$Fk,$l9,$Gk,$za,$Hk,$na,$Ik,$Vl,$Xl,$dm,$em,$Tl,$fm,$hl,$gm,$Dl,$hm,$Vk,$im,$tl,$jm,$Ym,$cn,$gn,$hn,$Im,$in,$Wm,$jn,$Bm,$kn,$wo,$yo,$No,$Oo,$Lo,$Po,$Pp,$Rp,$qq,$rq,$oq,$sq,$op,$tq,$yp,$uq,$hp,$vq,$Kp,$wq,$Yn,$xq,$uo,$yq,$Qq,$Sq,$Wq,$Xq,$Hq,$Yq,$Oq,$Zq,$r7,$cr,$V6,$dr,$C8,$er,$or,$qr,$j5,$rr,$vr,$wr,$mr,$xr,$d6,$yr,$Or,$Qr,$Ur,$Vr,$Mr,$Wr,$Gr,$Xr,$O7,$Yr,$h7,$Zr,$M7,$cs,$Ts,$Vs,$Zs,$ct,$ws,$dt,$Fs,$et,$js,$ft,$ps,$gt,$Rs,$ht,$T6,$it,$fu,$hu,$lu,$mu,$vt,$nu,$Tt,$ou,$Jt,$pu,$du,$qu,$yu,$zu,$Iu,$Ju,$Ww,$Yw,$ex,$fx,$Ru,$gx,$Gv,$hx,$I6,$ix,$e8,$jx,$Hx,$Jx,$y7,$Kx,$t5,$Lx,$B5,$Mx,$I5,$Nx,$Qy,$Sy,$Wy,$Xy,$Oy,$Yy,$vy,$Zy,$Ey,$cz,$dy,$dz,$fA,$gA,$R5,$hA,$Uw,$iA,$Ov,$jA,$Ew,$kA,$DA,$FA,$JA,$KA,$sA,$LA,$BA,$MA,$ow,$NA,$F7,$OA,$P5,$PA,$tB,$vB,$eB,$wB,$AB,$BB,$kB,$CB,$rB,$DB,$OB,$PB,$l8,$QB,$iC,$kC,$YB,$lC,$pC,$qC,$gC,$rC,$VC,$XC,$dD,$eD,$MC,$fD,$AC,$gD,$TC,$hD,$lD,$nD,$rD,$sD,$R7,$tD,$E8,$uD,$K6,$vD,$x8,$wD,$AD,$CD,$GD,$HD,$Kn,$ID,$Eo,$JD,$In,$KD,$wn,$LD,$OD,$QD,$nE};
$pE=q#resolvers#;
$qE=[];
$rE=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$sE=bless({$o,$qE,$q,$rE,$s,$t},$u);
$tE=q#file#;
$uE=[];
$vE=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$wE=bless({$o,$uE,$q,$vE,$s,$t},$u);
$xE=q#null#;
$yE=[];
$zE=q#ni('ni:/io/null')->new#;
$AE=bless({$o,$yE,$q,$zE,$s,$t},$u);
$BE=q#sh#;
$CE=[];
$DE=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$EE=bless({$o,$CE,$q,$DE,$s,$t},$u);
$FE=q#str#;
$GE=[];
$HE=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$IE=bless({$o,$GE,$q,$HE,$s,$t},$u);
$JE={$Uc,$sE,$tE,$wE,$xE,$AE,$BE,$EE,$FE,$IE};
$KE=bless({$c,$oE,$pE,$JE},$w6);
*$XA=\&$VA;
*$WA=\&$TA;
$j5->apply_unsafe($e4);
$j5->apply_unsafe($f4);
$j5->apply_unsafe($g4);
$j5->apply_unsafe($h4);
$j5->apply_unsafe($i4);
$j5->apply_unsafe($j4);
$j5->apply_unsafe($k4);
$j5->apply_unsafe($l4);
$j5->apply_unsafe($m4);
$j5->apply_unsafe($n4);
$j5->apply_unsafe($o4);
$j5->apply_unsafe($p4);
$j5->apply_unsafe($q4);
$j5->apply_unsafe($r4);
$j5->apply_unsafe($s4);
$j5->apply_unsafe($t4);
$j5->apply_unsafe($u4);
$j5->apply_unsafe($v4);
$j5->apply_unsafe($k5);
$j5->apply_unsafe($w4);
$j5->apply_unsafe($x4);
$j5->apply_unsafe($y4);
$j5->apply_unsafe($z4);
$j5->apply_unsafe($A4);
$j5->apply_unsafe($B4);
$j5->apply_unsafe($C4);
$j5->apply_unsafe($D4);
$j5->apply_unsafe($E4);
$j5->apply_unsafe($F4);
$j5->apply_unsafe($O4);
$j5->apply_unsafe($G4);
$j5->apply_unsafe($P4);
$j5->apply_unsafe($H4);
$j5->apply_unsafe($I4);
$j5->apply_unsafe($J4);
$j5->apply_unsafe($K4);
$j5->apply_unsafe($L4);
$t5->apply_unsafe($e4);
$t5->apply_unsafe($f4);
$t5->apply_unsafe($g4);
$t5->apply_unsafe($h4);
$t5->apply_unsafe($i4);
$t5->apply_unsafe($j4);
$t5->apply_unsafe($k4);
$t5->apply_unsafe($l4);
$t5->apply_unsafe($m4);
$t5->apply_unsafe($n4);
$t5->apply_unsafe($o4);
$t5->apply_unsafe($p4);
$t5->apply_unsafe($q4);
$t5->apply_unsafe($r4);
$t5->apply_unsafe($s4);
$t5->apply_unsafe($t4);
$t5->apply_unsafe($u4);
$t5->apply_unsafe($v4);
$t5->apply_unsafe($k5);
$t5->apply_unsafe($w4);
$t5->apply_unsafe($x4);
$t5->apply_unsafe($F);
$t5->apply_unsafe($y4);
$t5->apply_unsafe($z4);
$t5->apply_unsafe($A4);
$t5->apply_unsafe($B4);
$t5->apply_unsafe($C4);
$t5->apply_unsafe($i5);
$t5->apply_unsafe($D4);
$t5->apply_unsafe($u5);
$t5->apply_unsafe($E4);
$t5->apply_unsafe($F4);
$t5->apply_unsafe($O4);
$t5->apply_unsafe($G4);
$t5->apply_unsafe($P4);
$t5->apply_unsafe($H4);
$t5->apply_unsafe($I4);
$t5->apply_unsafe($J4);
$t5->apply_unsafe($K4);
$t5->apply_unsafe($L4);
$B5->apply_unsafe($e4);
$B5->apply_unsafe($f4);
$B5->apply_unsafe($g4);
$B5->apply_unsafe($h4);
$B5->apply_unsafe($i4);
$B5->apply_unsafe($j4);
$B5->apply_unsafe($k4);
$B5->apply_unsafe($l4);
$B5->apply_unsafe($m4);
$B5->apply_unsafe($n4);
$B5->apply_unsafe($o4);
$B5->apply_unsafe($p4);
$B5->apply_unsafe($q4);
$B5->apply_unsafe($r4);
$B5->apply_unsafe($s4);
$B5->apply_unsafe($t4);
$B5->apply_unsafe($u4);
$B5->apply_unsafe($v4);
$B5->apply_unsafe($k5);
$B5->apply_unsafe($w4);
$B5->apply_unsafe($x4);
$B5->apply_unsafe($y4);
$B5->apply_unsafe($z4);
$B5->apply_unsafe($A4);
$B5->apply_unsafe($B4);
$B5->apply_unsafe($C4);
$B5->apply_unsafe($i5);
$B5->apply_unsafe($D4);
$B5->apply_unsafe($u5);
$B5->apply_unsafe($E4);
$B5->apply_unsafe($F4);
$B5->apply_unsafe($O4);
$B5->apply_unsafe($G4);
$B5->apply_unsafe($P4);
$B5->apply_unsafe($H4);
$B5->apply_unsafe($I4);
$B5->apply_unsafe($J4);
$B5->apply_unsafe($K4);
$B5->apply_unsafe($L4);
$I5->apply_unsafe($e4);
$I5->apply_unsafe($f4);
$I5->apply_unsafe($g4);
$I5->apply_unsafe($h4);
$I5->apply_unsafe($i4);
$I5->apply_unsafe($j4);
$I5->apply_unsafe($k4);
$I5->apply_unsafe($l4);
$I5->apply_unsafe($m4);
$I5->apply_unsafe($n4);
$I5->apply_unsafe($o4);
$I5->apply_unsafe($p4);
$I5->apply_unsafe($q4);
$I5->apply_unsafe($r4);
$I5->apply_unsafe($s4);
$I5->apply_unsafe($t4);
$I5->apply_unsafe($u4);
$I5->apply_unsafe($v4);
$I5->apply_unsafe($k5);
$I5->apply_unsafe($w4);
$I5->apply_unsafe($x4);
$I5->apply_unsafe($y4);
$I5->apply_unsafe($z4);
$I5->apply_unsafe($A4);
$I5->apply_unsafe($B4);
$I5->apply_unsafe($C4);
$I5->apply_unsafe($i5);
$I5->apply_unsafe($D4);
$I5->apply_unsafe($u5);
$I5->apply_unsafe($E4);
$I5->apply_unsafe($F4);
$I5->apply_unsafe($O4);
$I5->apply_unsafe($G4);
$I5->apply_unsafe($P4);
$I5->apply_unsafe($H4);
$I5->apply_unsafe($I4);
$I5->apply_unsafe($J4);
$I5->apply_unsafe($K4);
$I5->apply_unsafe($L4);
$P5->apply_unsafe($e4);
$P5->apply_unsafe($f4);
$P5->apply_unsafe($g4);
$P5->apply_unsafe($h4);
$P5->apply_unsafe($i4);
$P5->apply_unsafe($j4);
$P5->apply_unsafe($k4);
$P5->apply_unsafe($l4);
$P5->apply_unsafe($m4);
$P5->apply_unsafe($n4);
$P5->apply_unsafe($o4);
$P5->apply_unsafe($p4);
$P5->apply_unsafe($q4);
$P5->apply_unsafe($r4);
$P5->apply_unsafe($s4);
$P5->apply_unsafe($t4);
$P5->apply_unsafe($u4);
$P5->apply_unsafe($v4);
$P5->apply_unsafe($k5);
$P5->apply_unsafe($w4);
$P5->apply_unsafe($x4);
$P5->apply_unsafe($y4);
$P5->apply_unsafe($z4);
$P5->apply_unsafe($A4);
$P5->apply_unsafe($B4);
$P5->apply_unsafe($C4);
$P5->apply_unsafe($D4);
$P5->apply_unsafe($u5);
$P5->apply_unsafe($E4);
$P5->apply_unsafe($F4);
$P5->apply_unsafe($O4);
$P5->apply_unsafe($G4);
$P5->apply_unsafe($P4);
$P5->apply_unsafe($H4);
$P5->apply_unsafe($I4);
$P5->apply_unsafe($J4);
$P5->apply_unsafe($K4);
$P5->apply_unsafe($L4);
$d6->apply_unsafe($e4);
$d6->apply_unsafe($f4);
$d6->apply_unsafe($g4);
$d6->apply_unsafe($h4);
$d6->apply_unsafe($i4);
$d6->apply_unsafe($j4);
$d6->apply_unsafe($k4);
$d6->apply_unsafe($l4);
$d6->apply_unsafe($m4);
$d6->apply_unsafe($n4);
$d6->apply_unsafe($o4);
$d6->apply_unsafe($p4);
$d6->apply_unsafe($q4);
$d6->apply_unsafe($r4);
$d6->apply_unsafe($s4);
$d6->apply_unsafe($t4);
$d6->apply_unsafe($u4);
$d6->apply_unsafe($v4);
$d6->apply_unsafe($w4);
$d6->apply_unsafe($x4);
$d6->apply_unsafe($y4);
$d6->apply_unsafe($z4);
$d6->apply_unsafe($A4);
$d6->apply_unsafe($B4);
$d6->apply_unsafe($C4);
$d6->apply_unsafe($D4);
$d6->apply_unsafe($E4);
$d6->apply_unsafe($F4);
$d6->apply_unsafe($O4);
$d6->apply_unsafe($G4);
$d6->apply_unsafe($P4);
$d6->apply_unsafe($H4);
$d6->apply_unsafe($I4);
$d6->apply_unsafe($J4);
$d6->apply_unsafe($K4);
$d6->apply_unsafe($L4);
$I6->apply_unsafe($e4);
$I6->apply_unsafe($f4);
$I6->apply_unsafe($e6);
$I6->apply_unsafe($g4);
$I6->apply_unsafe($f6);
$I6->apply_unsafe($h4);
$I6->apply_unsafe($g6);
$I6->apply_unsafe($i4);
$I6->apply_unsafe($h6);
$I6->apply_unsafe($j4);
$I6->apply_unsafe($i6);
$I6->apply_unsafe($k4);
$I6->apply_unsafe($j6);
$I6->apply_unsafe($l4);
$I6->apply_unsafe($k6);
$I6->apply_unsafe($m4);
$I6->apply_unsafe($l6);
$I6->apply_unsafe($n4);
$I6->apply_unsafe($m6);
$I6->apply_unsafe($o4);
$I6->apply_unsafe($n6);
$I6->apply_unsafe($p4);
$I6->apply_unsafe($o6);
$I6->apply_unsafe($q4);
$I6->apply_unsafe($p6);
$I6->apply_unsafe($r4);
$I6->apply_unsafe($q6);
$I6->apply_unsafe($s4);
$I6->apply_unsafe($r6);
$I6->apply_unsafe($t4);
$I6->apply_unsafe($s6);
$I6->apply_unsafe($u4);
$I6->apply_unsafe($t6);
$I6->apply_unsafe($v4);
$I6->apply_unsafe($k5);
$I6->apply_unsafe($w4);
$I6->apply_unsafe($u6);
$I6->apply_unsafe($x4);
$I6->apply_unsafe($F);
$I6->apply_unsafe($y4);
$I6->apply_unsafe($u);
$I6->apply_unsafe($z4);
$I6->apply_unsafe($v6);
$I6->apply_unsafe($A4);
$I6->apply_unsafe($w6);
$I6->apply_unsafe($B4);
$I6->apply_unsafe($x6);
$I6->apply_unsafe($C4);
$I6->apply_unsafe($i5);
$I6->apply_unsafe($D4);
$I6->apply_unsafe($u5);
$I6->apply_unsafe($E4);
$I6->apply_unsafe($y6);
$I6->apply_unsafe($F4);
$I6->apply_unsafe($O4);
$I6->apply_unsafe($G4);
$I6->apply_unsafe($P4);
$I6->apply_unsafe($H4);
$I6->apply_unsafe($z6);
$I6->apply_unsafe($I4);
$I6->apply_unsafe($J4);
$I6->apply_unsafe($K4);
$I6->apply_unsafe($A6);
$I6->apply_unsafe($L4);
$T6->apply_unsafe($e4);
$T6->apply_unsafe($f4);
$T6->apply_unsafe($g4);
$T6->apply_unsafe($h4);
$T6->apply_unsafe($i4);
$T6->apply_unsafe($j4);
$T6->apply_unsafe($k4);
$T6->apply_unsafe($l4);
$T6->apply_unsafe($m4);
$T6->apply_unsafe($n4);
$T6->apply_unsafe($o4);
$T6->apply_unsafe($p4);
$T6->apply_unsafe($q4);
$T6->apply_unsafe($r4);
$T6->apply_unsafe($s4);
$T6->apply_unsafe($t4);
$T6->apply_unsafe($u4);
$T6->apply_unsafe($t6);
$T6->apply_unsafe($v4);
$T6->apply_unsafe($k5);
$T6->apply_unsafe($w4);
$T6->apply_unsafe($u6);
$T6->apply_unsafe($x4);
$T6->apply_unsafe($y4);
$T6->apply_unsafe($z4);
$T6->apply_unsafe($A4);
$T6->apply_unsafe($B4);
$T6->apply_unsafe($C4);
$T6->apply_unsafe($i5);
$T6->apply_unsafe($D4);
$T6->apply_unsafe($u5);
$T6->apply_unsafe($E4);
$T6->apply_unsafe($F4);
$T6->apply_unsafe($O4);
$T6->apply_unsafe($G4);
$T6->apply_unsafe($P4);
$T6->apply_unsafe($H4);
$T6->apply_unsafe($I4);
$T6->apply_unsafe($J4);
$T6->apply_unsafe($K4);
$T6->apply_unsafe($L4);
$h7->apply_unsafe($e4);
$h7->apply_unsafe($f4);
$h7->apply_unsafe($g4);
$h7->apply_unsafe($h4);
$h7->apply_unsafe($i4);
$h7->apply_unsafe($j4);
$h7->apply_unsafe($k4);
$h7->apply_unsafe($l4);
$h7->apply_unsafe($m4);
$h7->apply_unsafe($n4);
$h7->apply_unsafe($o4);
$h7->apply_unsafe($p4);
$h7->apply_unsafe($q4);
$h7->apply_unsafe($r4);
$h7->apply_unsafe($s4);
$h7->apply_unsafe($t4);
$h7->apply_unsafe($u4);
$h7->apply_unsafe($v4);
$h7->apply_unsafe($k5);
$h7->apply_unsafe($w4);
$h7->apply_unsafe($x4);
$h7->apply_unsafe($y4);
$h7->apply_unsafe($z4);
$h7->apply_unsafe($A4);
$h7->apply_unsafe($B4);
$h7->apply_unsafe($C4);
$h7->apply_unsafe($D4);
$h7->apply_unsafe($E4);
$h7->apply_unsafe($F4);
$h7->apply_unsafe($O4);
$h7->apply_unsafe($G4);
$h7->apply_unsafe($P4);
$h7->apply_unsafe($H4);
$h7->apply_unsafe($I4);
$h7->apply_unsafe($J4);
$h7->apply_unsafe($K4);
$h7->apply_unsafe($L4);
$r7->apply_unsafe($e4);
$r7->apply_unsafe($f4);
$r7->apply_unsafe($g4);
$r7->apply_unsafe($h4);
$r7->apply_unsafe($i4);
$r7->apply_unsafe($j4);
$r7->apply_unsafe($k4);
$r7->apply_unsafe($l4);
$r7->apply_unsafe($m4);
$r7->apply_unsafe($n4);
$r7->apply_unsafe($o4);
$r7->apply_unsafe($p4);
$r7->apply_unsafe($q4);
$r7->apply_unsafe($r4);
$r7->apply_unsafe($s4);
$r7->apply_unsafe($t4);
$r7->apply_unsafe($u4);
$r7->apply_unsafe($v4);
$r7->apply_unsafe($k5);
$r7->apply_unsafe($w4);
$r7->apply_unsafe($x4);
$r7->apply_unsafe($y4);
$r7->apply_unsafe($z4);
$r7->apply_unsafe($A4);
$r7->apply_unsafe($B4);
$r7->apply_unsafe($C4);
$r7->apply_unsafe($D4);
$r7->apply_unsafe($E4);
$r7->apply_unsafe($F4);
$r7->apply_unsafe($O4);
$r7->apply_unsafe($G4);
$r7->apply_unsafe($P4);
$r7->apply_unsafe($H4);
$r7->apply_unsafe($I4);
$r7->apply_unsafe($J4);
$r7->apply_unsafe($K4);
$r7->apply_unsafe($L4);
$y7->apply_unsafe($e4);
$y7->apply_unsafe($f4);
$y7->apply_unsafe($g4);
$y7->apply_unsafe($h4);
$y7->apply_unsafe($i4);
$y7->apply_unsafe($j4);
$y7->apply_unsafe($k4);
$y7->apply_unsafe($l4);
$y7->apply_unsafe($m4);
$y7->apply_unsafe($n4);
$y7->apply_unsafe($o4);
$y7->apply_unsafe($p4);
$y7->apply_unsafe($q4);
$y7->apply_unsafe($r4);
$y7->apply_unsafe($s4);
$y7->apply_unsafe($t4);
$y7->apply_unsafe($u4);
$y7->apply_unsafe($v4);
$y7->apply_unsafe($k5);
$y7->apply_unsafe($w4);
$y7->apply_unsafe($x4);
$y7->apply_unsafe($y4);
$y7->apply_unsafe($z4);
$y7->apply_unsafe($A4);
$y7->apply_unsafe($B4);
$y7->apply_unsafe($C4);
$y7->apply_unsafe($D4);
$y7->apply_unsafe($E4);
$y7->apply_unsafe($F4);
$y7->apply_unsafe($O4);
$y7->apply_unsafe($G4);
$y7->apply_unsafe($P4);
$y7->apply_unsafe($H4);
$y7->apply_unsafe($I4);
$y7->apply_unsafe($J4);
$y7->apply_unsafe($K4);
$y7->apply_unsafe($L4);
$F7->apply_unsafe($e4);
$F7->apply_unsafe($f4);
$F7->apply_unsafe($g4);
$F7->apply_unsafe($h4);
$F7->apply_unsafe($i4);
$F7->apply_unsafe($j4);
$F7->apply_unsafe($k4);
$F7->apply_unsafe($l4);
$F7->apply_unsafe($m4);
$F7->apply_unsafe($n4);
$F7->apply_unsafe($o4);
$F7->apply_unsafe($p4);
$F7->apply_unsafe($q4);
$F7->apply_unsafe($r4);
$F7->apply_unsafe($s4);
$F7->apply_unsafe($t4);
$F7->apply_unsafe($u4);
$F7->apply_unsafe($v4);
$F7->apply_unsafe($k5);
$F7->apply_unsafe($w4);
$F7->apply_unsafe($x4);
$F7->apply_unsafe($y4);
$F7->apply_unsafe($z4);
$F7->apply_unsafe($A4);
$F7->apply_unsafe($B4);
$F7->apply_unsafe($C4);
$F7->apply_unsafe($D4);
$F7->apply_unsafe($E4);
$F7->apply_unsafe($F4);
$F7->apply_unsafe($O4);
$F7->apply_unsafe($G4);
$F7->apply_unsafe($P4);
$F7->apply_unsafe($H4);
$F7->apply_unsafe($I4);
$F7->apply_unsafe($J4);
$F7->apply_unsafe($K4);
$F7->apply_unsafe($L4);
$M7->apply_unsafe($e4);
$M7->apply_unsafe($f4);
$M7->apply_unsafe($g4);
$M7->apply_unsafe($h4);
$M7->apply_unsafe($i4);
$M7->apply_unsafe($j4);
$M7->apply_unsafe($k4);
$M7->apply_unsafe($l4);
$M7->apply_unsafe($m4);
$M7->apply_unsafe($n4);
$M7->apply_unsafe($o4);
$M7->apply_unsafe($p4);
$M7->apply_unsafe($q4);
$M7->apply_unsafe($r4);
$M7->apply_unsafe($s4);
$M7->apply_unsafe($t4);
$M7->apply_unsafe($u4);
$M7->apply_unsafe($v4);
$M7->apply_unsafe($k5);
$M7->apply_unsafe($w4);
$M7->apply_unsafe($x4);
$M7->apply_unsafe($y4);
$M7->apply_unsafe($z4);
$M7->apply_unsafe($A4);
$M7->apply_unsafe($B4);
$M7->apply_unsafe($C4);
$M7->apply_unsafe($D4);
$M7->apply_unsafe($E4);
$M7->apply_unsafe($F4);
$M7->apply_unsafe($O4);
$M7->apply_unsafe($G4);
$M7->apply_unsafe($P4);
$M7->apply_unsafe($H4);
$M7->apply_unsafe($I4);
$M7->apply_unsafe($J4);
$M7->apply_unsafe($K4);
$M7->apply_unsafe($L4);
$e8->apply_unsafe($e4);
$e8->apply_unsafe($f4);
$e8->apply_unsafe($g4);
$e8->apply_unsafe($h4);
$e8->apply_unsafe($i4);
$e8->apply_unsafe($j4);
$e8->apply_unsafe($k4);
$e8->apply_unsafe($l4);
$e8->apply_unsafe($m4);
$e8->apply_unsafe($n4);
$e8->apply_unsafe($o4);
$e8->apply_unsafe($p4);
$e8->apply_unsafe($q4);
$e8->apply_unsafe($r4);
$e8->apply_unsafe($s4);
$e8->apply_unsafe($t4);
$e8->apply_unsafe($u4);
$e8->apply_unsafe($v4);
$e8->apply_unsafe($w4);
$e8->apply_unsafe($x4);
$e8->apply_unsafe($y4);
$e8->apply_unsafe($u);
$e8->apply_unsafe($z4);
$e8->apply_unsafe($A4);
$e8->apply_unsafe($B4);
$e8->apply_unsafe($C4);
$e8->apply_unsafe($i5);
$e8->apply_unsafe($D4);
$e8->apply_unsafe($u5);
$e8->apply_unsafe($E4);
$e8->apply_unsafe($F4);
$e8->apply_unsafe($O4);
$e8->apply_unsafe($G4);
$e8->apply_unsafe($H4);
$e8->apply_unsafe($I4);
$e8->apply_unsafe($J4);
$e8->apply_unsafe($K4);
$e8->apply_unsafe($L4);
$l8->apply_unsafe($e4);
$l8->apply_unsafe($f4);
$l8->apply_unsafe($g4);
$l8->apply_unsafe($h4);
$l8->apply_unsafe($i4);
$l8->apply_unsafe($j4);
$l8->apply_unsafe($k4);
$l8->apply_unsafe($l4);
$l8->apply_unsafe($m4);
$l8->apply_unsafe($n4);
$l8->apply_unsafe($o4);
$l8->apply_unsafe($p4);
$l8->apply_unsafe($q4);
$l8->apply_unsafe($r4);
$l8->apply_unsafe($s4);
$l8->apply_unsafe($t4);
$l8->apply_unsafe($u4);
$l8->apply_unsafe($v4);
$l8->apply_unsafe($w4);
$l8->apply_unsafe($x4);
$l8->apply_unsafe($y4);
$l8->apply_unsafe($z4);
$l8->apply_unsafe($A4);
$l8->apply_unsafe($B4);
$l8->apply_unsafe($C4);
$l8->apply_unsafe($D4);
$l8->apply_unsafe($E4);
$l8->apply_unsafe($F4);
$l8->apply_unsafe($G4);
$l8->apply_unsafe($H4);
$l8->apply_unsafe($I4);
$l8->apply_unsafe($J4);
$l8->apply_unsafe($K4);
$l8->apply_unsafe($L4);
$P8->apply_unsafe($e6);
$l9->apply_unsafe($f6);
$l9->apply_unsafe($g6);
$l9->apply_unsafe($h6);
$l9->apply_unsafe($i6);
$l9->apply_unsafe($j6);
$l9->apply_unsafe($k6);
$l9->apply_unsafe($l6);
$l9->apply_unsafe($m6);
$l9->apply_unsafe($n6);
$l9->apply_unsafe($o6);
$l9->apply_unsafe($p6);
$F9->apply_unsafe($f6);
$F9->apply_unsafe($g6);
$F9->apply_unsafe($h6);
$F9->apply_unsafe($i6);
$F9->apply_unsafe($j6);
$F9->apply_unsafe($k6);
$F9->apply_unsafe($l6);
$F9->apply_unsafe($m6);
$F9->apply_unsafe($n6);
$F9->apply_unsafe($o6);
$F9->apply_unsafe($p6);
$N9->apply_unsafe($f6);
$N9->apply_unsafe($g6);
$N9->apply_unsafe($h6);
$N9->apply_unsafe($i6);
$N9->apply_unsafe($j6);
$N9->apply_unsafe($k6);
$N9->apply_unsafe($l6);
$N9->apply_unsafe($m6);
$N9->apply_unsafe($n6);
$N9->apply_unsafe($o6);
$N9->apply_unsafe($p6);
$Z9->apply_unsafe($f6);
$Z9->apply_unsafe($g6);
$Z9->apply_unsafe($h6);
$Z9->apply_unsafe($i6);
$Z9->apply_unsafe($j6);
$Z9->apply_unsafe($k6);
$Z9->apply_unsafe($l6);
$Z9->apply_unsafe($m6);
$Z9->apply_unsafe($n6);
$Z9->apply_unsafe($o6);
$Z9->apply_unsafe($p6);
$na->apply_unsafe($f6);
$na->apply_unsafe($g6);
$na->apply_unsafe($h6);
$na->apply_unsafe($i6);
$na->apply_unsafe($j6);
$na->apply_unsafe($k6);
$na->apply_unsafe($l6);
$na->apply_unsafe($m6);
$na->apply_unsafe($n6);
$na->apply_unsafe($o6);
$na->apply_unsafe($p6);
$za->apply_unsafe($f6);
$za->apply_unsafe($g6);
$za->apply_unsafe($h6);
$za->apply_unsafe($i6);
$za->apply_unsafe($j6);
$za->apply_unsafe($k6);
$za->apply_unsafe($l6);
$za->apply_unsafe($m6);
$za->apply_unsafe($n6);
$za->apply_unsafe($o6);
$za->apply_unsafe($p6);
$Ja->apply_unsafe($f6);
$fb->apply_unsafe($f6);
$vb->apply_unsafe($h4);
$vb->apply_unsafe($i4);
$vb->apply_unsafe($j4);
$vb->apply_unsafe($k4);
$vb->apply_unsafe($l4);
$vb->apply_unsafe($m4);
$vb->apply_unsafe($n4);
$vb->apply_unsafe($o4);
$vb->apply_unsafe($p4);
$vb->apply_unsafe($q4);
$vb->apply_unsafe($r4);
$Kb->apply_unsafe($g6);
$Rb->apply_unsafe($g6);
$nc->apply_unsafe($h6);
$uc->apply_unsafe($h6);
$Oc->apply_unsafe($h6);
$od->apply_unsafe($h6);
$wd->apply_unsafe($h6);
$Md->apply_unsafe($h6);
$le->apply_unsafe($i6);
$se->apply_unsafe($i6);
$Ae->apply_unsafe($i6);
$Qe->apply_unsafe($i6);
$df->apply_unsafe($i6);
$nf->apply_unsafe($i6);
$Kf->apply_unsafe($j6);
$Sf->apply_unsafe($j6);
$Zf->apply_unsafe($j6);
$jg->apply_unsafe($j6);
$Eg->apply_unsafe($j6);
$hh->apply_unsafe($k6);
$oh->apply_unsafe($k6);
$wh->apply_unsafe($k6);
$Jh->apply_unsafe($k6);
$Zh->apply_unsafe($k6);
$Bi->apply_unsafe($l6);
$Ii->apply_unsafe($l6);
$Oi->apply_unsafe($l6);
$dj->apply_unsafe($l6);
$Oj->apply_unsafe($Pj);
$Zj->apply_unsafe($m6);
$ok->apply_unsafe($m6);
$Vk->apply_unsafe($o6);
$hl->apply_unsafe($o6);
$tl->apply_unsafe($o6);
$Dl->apply_unsafe($o6);
$Tl->apply_unsafe($o6);
$Bm->apply_unsafe($p6);
$Im->apply_unsafe($p6);
$Wm->apply_unsafe($p6);
$wn->apply_unsafe($q6);
$wn->apply_unsafe($r6);
$wn->apply_unsafe($s6);
$wn->apply_unsafe($A6);
$In->apply_unsafe($q6);
$In->apply_unsafe($r6);
$In->apply_unsafe($s6);
$In->apply_unsafe($A6);
$Yn->apply_unsafe($q6);
$Yn->apply_unsafe($r6);
$Yn->apply_unsafe($s6);
$uo->apply_unsafe($q6);
$uo->apply_unsafe($r6);
$uo->apply_unsafe($s6);
$Lo->apply_unsafe($s4);
$Lo->apply_unsafe($t4);
$Lo->apply_unsafe($u4);
$hp->apply_unsafe($r6);
$op->apply_unsafe($r6);
$yp->apply_unsafe($r6);
$Kp->apply_unsafe($r6);
$oq->apply_unsafe($t4);
$Hq->apply_unsafe($s6);
$Oq->apply_unsafe($s6);
$mr->apply_unsafe($k5);
$Gr->apply_unsafe($u6);
$Mr->apply_unsafe($u6);
$js->apply_unsafe($F);
$ps->apply_unsafe($F);
$ws->apply_unsafe($F);
$Fs->apply_unsafe($F);
$Rs->apply_unsafe($F);
$vt->apply_unsafe($u);
$Jt->apply_unsafe($u);
$Tt->apply_unsafe($u);
$du->apply_unsafe($u);
$yu->apply_unsafe($v6);
$Iu->apply_unsafe($Pj);
$Ru->apply_unsafe($v6);
$Gv->apply_unsafe($v6);
$Ov->apply_unsafe($v6);
$Ov->apply_unsafe($x6);
$ow->apply_unsafe($v6);
$ow->apply_unsafe($x6);
$Ew->apply_unsafe($v6);
$Ew->apply_unsafe($x6);
$Uw->apply_unsafe($v6);
$Hx->apply_unsafe($Ix);
$dy->apply_unsafe($w6);
$vy->apply_unsafe($w6);
$Ey->apply_unsafe($w6);
$Oy->apply_unsafe($w6);
$fA->apply_unsafe($Ix);
$sA->apply_unsafe($x6);
$BA->apply_unsafe($x6);
$eB->apply_unsafe($i5);
$kB->apply_unsafe($i5);
$rB->apply_unsafe($i5);
$OB->apply_unsafe($Pj);
$YB->apply_unsafe($u5);
$gC->apply_unsafe($u5);
$AC->apply_unsafe($y6);
$MC->apply_unsafe($y6);
$TC->apply_unsafe($y6);
$ni::self=$KE;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($R)for@$H;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$H;
&$_($h2)for@$w;
&$_($l2)for@$w;
&$_($p2)for@$H;
&$_($y2)for@$H;
&$_($E2)for@$H;
&$_($I2)for@$w;
&$_($M2)for@$w;
&$_($Q2)for@$w;
&$_($U2)for@$H;
&$_($d3)for@$H;
&$_($l3)for@$w;
&$_($p3)for@$w;
&$_($t3)for@$H;
&$_($B3)for@$H;
&$_($J3)for@$H;
&$_($P3)for@$w;
&$_($T3)for@$H;
&$_($Z3)for@$H;
&$_($c5)for@$w;
&$_($f5)for@$w;
&$_($j5)for@$l5;
&$_($o5)for@$w;
&$_($q5)for@$w;
&$_($t5)for@$l5;
&$_($y5)for@$w;
&$_($B5)for@$l5;
&$_($F5)for@$w;
&$_($I5)for@$l5;
&$_($M5)for@$w;
&$_($P5)for@$l5;
&$_($R5)for@$S5;
&$_($V5)for@$w;
&$_($Y5)for@$w;
&$_($d6)for@$l5;
&$_($F6)for@$w;
&$_($I6)for@$l5;
&$_($K6)for@$L6;
&$_($Q6)for@$w;
&$_($T6)for@$l5;
&$_($V6)for@$W6;
&$_($e7)for@$w;
&$_($h7)for@$l5;
&$_($l7)for@$w;
&$_($o7)for@$w;
&$_($r7)for@$l5;
&$_($v7)for@$w;
&$_($y7)for@$l5;
&$_($C7)for@$w;
&$_($F7)for@$l5;
&$_($J7)for@$w;
&$_($M7)for@$l5;
&$_($O7)for@$P7;
&$_($R7)for@$S7;
&$_($W7)for@$w;
&$_($Z7)for@$w;
&$_($e8)for@$l5;
&$_($i8)for@$w;
&$_($l8)for@$l5;
&$_($n8)for@$o8;
&$_($x8)for@$y8;
&$_($C8)for@$y8;
&$_($E8)for@$y8;
&$_($G8)for@$y8;
&$_($M8)for@$w;
&$_($P8)for@$l5;
&$_($R8)for@$S8;
&$_($X8)for@$y8;
&$_($i9)for@$w;
&$_($l9)for@$l5;
&$_($q9)for@$w;
&$_($u9)for@$w;
&$_($y9)for@$w;
&$_($C9)for@$w;
&$_($F9)for@$l5;
&$_($K9)for@$w;
&$_($N9)for@$l5;
&$_($S9)for@$w;
&$_($W9)for@$w;
&$_($Z9)for@$l5;
&$_($ga)for@$w;
&$_($ka)for@$w;
&$_($na)for@$l5;
&$_($sa)for@$w;
&$_($wa)for@$w;
&$_($za)for@$l5;
&$_($Ba)for@$Ca;
&$_($Ga)for@$w;
&$_($Ja)for@$l5;
&$_($Oa)for@$w;
&$_($Sa)for@$w;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($fb)for@$l5;
&$_($hb)for@$ib;
&$_($sb)for@$w;
&$_($vb)for@$l5;
&$_($xb)for@$y8;
&$_($zb)for@$y8;
&$_($Hb)for@$w;
&$_($Kb)for@$l5;
&$_($Ob)for@$w;
&$_($Rb)for@$l5;
&$_($Tb)for@$Ub;
&$_($Zb)for@$y8;
&$_($kc)for@$w;
&$_($nc)for@$l5;
&$_($rc)for@$w;
&$_($uc)for@$l5;
&$_($zc)for@$w;
&$_($Dc)for@$w;
&$_($Hc)for@$w;
&$_($Lc)for@$w;
&$_($Oc)for@$l5;
&$_($Tc)for@$w;
&$_($Xc)for@$w;
&$_($dd)for@$w;
&$_($hd)for@$w;
&$_($ld)for@$w;
&$_($od)for@$l5;
&$_($td)for@$w;
&$_($wd)for@$l5;
&$_($Bd)for@$w;
&$_($Fd)for@$w;
&$_($Jd)for@$w;
&$_($Md)for@$l5;
&$_($Od)for@$Pd;
&$_($Ud)for@$y8;
&$_($ie)for@$w;
&$_($le)for@$l5;
&$_($pe)for@$w;
&$_($se)for@$l5;
&$_($xe)for@$w;
&$_($Ae)for@$l5;
&$_($Fe)for@$w;
&$_($Je)for@$w;
&$_($Ne)for@$w;
&$_($Qe)for@$l5;
&$_($Ue)for@$w;
&$_($Ye)for@$w;
&$_($df)for@$l5;
&$_($hf)for@$w;
&$_($kf)for@$w;
&$_($nf)for@$l5;
&$_($pf)for@$qf;
&$_($vf)for@$y8;
&$_($Hf)for@$w;
&$_($Kf)for@$l5;
&$_($Pf)for@$w;
&$_($Sf)for@$l5;
&$_($Wf)for@$w;
&$_($Zf)for@$l5;
&$_($gg)for@$w;
&$_($jg)for@$l5;
&$_($ng)for@$w;
&$_($rg)for@$w;
&$_($ug)for@$w;
&$_($yg)for@$w;
&$_($Bg)for@$w;
&$_($Eg)for@$l5;
&$_($Gg)for@$Hg;
&$_($Mg)for@$y8;
&$_($Yg)for@$w;
&$_($eh)for@$w;
&$_($hh)for@$l5;
&$_($lh)for@$w;
&$_($oh)for@$l5;
&$_($th)for@$w;
&$_($wh)for@$l5;
&$_($Ah)for@$w;
&$_($Dh)for@$w;
&$_($Gh)for@$w;
&$_($Jh)for@$l5;
&$_($Oh)for@$w;
&$_($Sh)for@$w;
&$_($Wh)for@$w;
&$_($Zh)for@$l5;
&$_($di)for@$ei;
&$_($ji)for@$y8;
&$_($qi)for@$w;
&$_($ui)for@$w;
&$_($yi)for@$w;
&$_($Bi)for@$l5;
&$_($Fi)for@$w;
&$_($Ii)for@$l5;
&$_($Li)for@$w;
&$_($Oi)for@$l5;
&$_($Si)for@$w;
&$_($Vi)for@$w;
&$_($Yi)for@$w;
&$_($dj)for@$l5;
&$_($fj)for@$gj;
&$_($mj)for@$y8;
&$_($Aj)for@$w;
&$_($Dj)for@$w;
&$_($Hj)for@$w;
&$_($Lj)for@$w;
&$_($Oj)for@$l5;
&$_($Wj)for@$w;
&$_($Zj)for@$l5;
&$_($fk)for@$w;
&$_($ik)for@$w;
&$_($lk)for@$w;
&$_($ok)for@$l5;
&$_($qk)for@$rk;
&$_($wk)for@$y8;
&$_($Ok)for@$w;
&$_($Sk)for@$w;
&$_($Vk)for@$l5;
&$_($Zk)for@$w;
&$_($el)for@$w;
&$_($hl)for@$l5;
&$_($ml)for@$w;
&$_($ql)for@$w;
&$_($tl)for@$l5;
&$_($xl)for@$w;
&$_($Al)for@$w;
&$_($Dl)for@$l5;
&$_($Hl)for@$w;
&$_($Kl)for@$w;
&$_($Nl)for@$w;
&$_($Ql)for@$w;
&$_($Tl)for@$l5;
&$_($Vl)for@$Wl;
&$_($dm)for@$y8;
&$_($qm)for@$w;
&$_($um)for@$w;
&$_($ym)for@$w;
&$_($Bm)for@$l5;
&$_($Fm)for@$w;
&$_($Im)for@$l5;
&$_($Mm)for@$w;
&$_($Qm)for@$w;
&$_($Tm)for@$w;
&$_($Wm)for@$l5;
&$_($Ym)for@$Zm;
&$_($gn)for@$y8;
&$_($tn)for@$w;
&$_($wn)for@$l5;
&$_($Bn)for@$w;
&$_($Fn)for@$w;
&$_($In)for@$l5;
&$_($Kn)for@$Ln;
&$_($Pn)for@$w;
&$_($Sn)for@$w;
&$_($Vn)for@$w;
&$_($Yn)for@$l5;
&$_($fo)for@$w;
&$_($jo)for@$w;
&$_($no)for@$w;
&$_($ro)for@$w;
&$_($uo)for@$l5;
&$_($wo)for@$xo;
&$_($Eo)for@$y8;
&$_($Io)for@$w;
&$_($Lo)for@$l5;
&$_($No)for@$y8;
&$_($Wo)for@$w;
&$_($Yo)for@$w;
&$_($ep)for@$w;
&$_($hp)for@$l5;
&$_($lp)for@$w;
&$_($op)for@$l5;
&$_($sp)for@$w;
&$_($vp)for@$w;
&$_($yp)for@$l5;
&$_($Dp)for@$w;
&$_($Hp)for@$w;
&$_($Kp)for@$l5;
&$_($Pp)for@$Qp;
&$_($Xp)for@$w;
&$_($dq)for@$w;
&$_($hq)for@$w;
&$_($lq)for@$w;
&$_($oq)for@$l5;
&$_($qq)for@$y8;
&$_($Eq)for@$w;
&$_($Hq)for@$l5;
&$_($Lq)for@$w;
&$_($Oq)for@$l5;
&$_($Qq)for@$Rq;
&$_($Wq)for@$y8;
&$_($jr)for@$w;
&$_($mr)for@$l5;
&$_($or)for@$pr;
&$_($vr)for@$y8;
&$_($Dr)for@$w;
&$_($Gr)for@$l5;
&$_($Jr)for@$w;
&$_($Mr)for@$l5;
&$_($Or)for@$Pr;
&$_($Ur)for@$y8;
&$_($gs)for@$w;
&$_($js)for@$l5;
&$_($ms)for@$w;
&$_($ps)for@$l5;
&$_($ts)for@$w;
&$_($ws)for@$l5;
&$_($zs)for@$w;
&$_($Cs)for@$w;
&$_($Fs)for@$l5;
&$_($Is)for@$w;
&$_($Ls)for@$w;
&$_($Os)for@$w;
&$_($Rs)for@$l5;
&$_($Ts)for@$Us;
&$_($Zs)for@$y8;
&$_($nt)for@$w;
&$_($qt)for@$w;
&$_($st)for@$w;
&$_($vt)for@$l5;
&$_($zt)for@$w;
&$_($Ct)for@$w;
&$_($Gt)for@$w;
&$_($Jt)for@$l5;
&$_($Nt)for@$w;
&$_($Qt)for@$w;
&$_($Tt)for@$l5;
&$_($Yt)for@$w;
&$_($du)for@$l5;
&$_($fu)for@$gu;
&$_($lu)for@$y8;
&$_($vu)for@$w;
&$_($yu)for@$l5;
&$_($Fu)for@$w;
&$_($Iu)for@$l5;
&$_($Ou)for@$w;
&$_($Ru)for@$l5;
&$_($Wu)for@$w;
&$_($cv)for@$w;
&$_($gv)for@$w;
&$_($kv)for@$w;
&$_($ov)for@$w;
&$_($sv)for@$w;
&$_($wv)for@$w;
&$_($Av)for@$w;
&$_($Dv)for@$w;
&$_($Gv)for@$l5;
&$_($Lv)for@$w;
&$_($Ov)for@$l5;
&$_($Tv)for@$w;
&$_($Xv)for@$w;
&$_($dw)for@$w;
&$_($hw)for@$w;
&$_($lw)for@$w;
&$_($ow)for@$l5;
&$_($tw)for@$w;
&$_($xw)for@$w;
&$_($Bw)for@$w;
&$_($Ew)for@$l5;
&$_($Jw)for@$w;
&$_($Nw)for@$w;
&$_($Rw)for@$w;
&$_($Uw)for@$l5;
&$_($Ww)for@$Xw;
&$_($ex)for@$y8;
&$_($ox)for@$w;
&$_($sx)for@$w;
&$_($wx)for@$w;
&$_($Ax)for@$w;
&$_($Ex)for@$w;
&$_($Hx)for@$l5;
&$_($Sx)for@$w;
&$_($Vx)for@$w;
&$_($Yx)for@$w;
&$_($dy)for@$l5;
&$_($hy)for@$w;
&$_($ky)for@$w;
&$_($ny)for@$w;
&$_($qy)for@$w;
&$_($sy)for@$w;
&$_($vy)for@$l5;
&$_($yy)for@$w;
&$_($By)for@$w;
&$_($Ey)for@$l5;
&$_($Iy)for@$w;
&$_($Ly)for@$w;
&$_($Oy)for@$l5;
&$_($Qy)for@$Ry;
&$_($Wy)for@$y8;
&$_($iz)for@$w;
&$_($mz)for@$w;
&$_($qz)for@$w;
&$_($uz)for@$w;
&$_($yz)for@$w;
&$_($Cz)for@$w;
&$_($Gz)for@$w;
&$_($Kz)for@$w;
&$_($Oz)for@$w;
&$_($Sz)for@$w;
&$_($Wz)for@$w;
&$_($cA)for@$w;
&$_($fA)for@$l5;
&$_($pA)for@$w;
&$_($sA)for@$l5;
&$_($vA)for@$w;
&$_($yA)for@$w;
&$_($BA)for@$l5;
&$_($DA)for@$EA;
&$_($JA)for@$y8;
&$_($TA)for@$w;
&$_($VA)for@$w;
&$_($eB)for@$l5;
&$_($hB)for@$w;
&$_($kB)for@$l5;
&$_($oB)for@$w;
&$_($rB)for@$l5;
&$_($tB)for@$uB;
&$_($AB)for@$y8;
&$_($HB)for@$w;
&$_($LB)for@$w;
&$_($OB)for@$l5;
&$_($VB)for@$w;
&$_($YB)for@$l5;
&$_($dC)for@$w;
&$_($gC)for@$l5;
&$_($iC)for@$jC;
&$_($pC)for@$y8;
&$_($xC)for@$w;
&$_($AC)for@$l5;
&$_($FC)for@$w;
&$_($JC)for@$w;
&$_($MC)for@$l5;
&$_($QC)for@$w;
&$_($TC)for@$l5;
&$_($VC)for@$WC;
&$_($dD)for@$y8;
&$_($lD)for@$mD;
&$_($rD)for@$y8;
&$_($AD)for@$BD;
&$_($GD)for@$y8;
&$_($OD)for@$PD;
&$_($nE)for@$PD;
&$_($sE)for@$w;
&$_($wE)for@$w;
&$_($AE)for@$w;
&$_($EE)for@$w;
&$_($IE)for@$w;
ni->run(@ARGV);
__DATA__
