#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/mio#;
$P=q#
    my $mio = ni("ni:/fabric/mio")->new;
    my $channel1 = $mio->channel;
    my $channel2 = $mio->channel;
    $channel1->write("8MB data" x 1000000);
    $channel2->write("short string");
    $mio->into_sync($socket_or_something);#;
$Q=[$f,$P];
$R=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel.#;
$S=[$i,$R];
$T=[$Q,$S];
$U=q#/fabric/mio#;
$V=bless({$e,$T,$D,$U},$F);
$W=q#ni.doc:/io#;
$X=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Y=[$i,$X];
$Z=[$Y];
$c1=q#/io#;
$d1=bless({$e,$Z,$D,$c1},$F);
$e1=q#ni.doc:/io/buffer#;
$f1=q#
    my $buf = ni("ni:/io/buffer")->new(1048576);
    $buf->write("foo")#;
$g1=[$f,$f1];
$h1=[$g1];
$i1=q#/io/buffer#;
$j1=bless({$e,$h1,$D,$i1},$F);
$k1=q#ni.doc:/io/cat#;
$l1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$m1=[$f,$l1];
$n1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$o1=[$i,$n1];
$p1=[];
$q1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[$m1,$o1,$s1];
$u1=q#/io/cat#;
$v1=bless({$e,$t1,$D,$u1},$F);
$w1=q#ni.doc:/io/exec#;
$x1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$y1=[$f,$x1];
$z1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$A1=[$i,$z1];
$B1=[];
$C1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$D1=bless({$o,$B1,$q,$C1,$s,$t},$u);
$E1=[$n,$D1];
$F1=[$y1,$A1,$E1];
$G1=q#/io/exec#;
$H1=bless({$e,$F1,$D,$G1},$F);
$I1=q#ni.doc:/io/pid#;
$J1=[];
$K1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[$M1,$Q1,$U1];
$W1=q#/io/pid#;
$X1=bless({$e,$V1,$D,$W1},$F);
$Y1=q#ni.doc:/lib#;
$Z1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$c2=[$i,$Z1];
$d2=[$c2];
$e2=q#/lib#;
$f2=bless({$e,$d2,$D,$e2},$F);
$g2=q#ni.doc:/lib/doc#;
$h2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$i2=[$f,$h2];
$j2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$k2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$l2=[];
$m2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$n2=bless({$o,$l2,$q,$m2,$s,$t},$u);
$o2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$p2=[];
$q2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$r2=bless({$o,$p2,$q,$q2,$s,$t},$u);
$s2=[$i,$j2,$k2,$n,$n2,$o2,$n,$r2];
$t2=[$i2,$s2];
$u2=q#/lib/doc#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni.doc:/semantic#;
$x2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$y2=[$i,$x2];
$z2=[$y2];
$A2=q#/semantic#;
$B2=bless({$e,$z2,$D,$A2},$F);
$C2=q#ni:/class#;
$D2=q#applied_to#;
$E2=q#class#;
$F2=q#class.c#;
$G2=q#fabric/mio.c#;
$H2=q#fabric/rmi.c#;
$I2=q#io/buffer.c#;
$J2=q#io/cat.c#;
$K2=q#io/exec.c#;
$L2=q#io/fd.c#;
$M2=q#io/file.c#;
$N2=q#io/null.c#;
$O2=q#io/object.c#;
$P2=q#io/pid.c#;
$Q2=q#io/str.c#;
$R2=q#io/transfer.c#;
$S2=q#io/transfer_async.c#;
$T2=q#io/transfer_sync.c#;
$U2=q#lib/behavior.c#;
$V2=q#lib/branch.c#;
$W2=q#lib/dataslice.c#;
$X2=q#lib/doc.c#;
$Y2=q#lib/fn.c#;
$Z2=q#lib/image.c#;
$c3=q#lib/ni.c#;
$d3=q#lib/quote_simple.c#;
$e3=q#lib/slice.c#;
$f3=q#lib/tag.c#;
$g3=q#lib/test_value.c#;
$h3=q#metaclass.c#;
$i3=q#module.c#;
$j3=q#object.c#;
$k3=q#semantic/dimension#;
$l3=q#semantic/dimension.c#;
$m3=q#semantic/task.c#;
$n3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$o3=q#slices#;
$p3=q#metaclass#;
$q3=q#module#;
$r3={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$s3=q#/module#;
$t3=q#/lib/perlbranch.b#;
$u3={};
$v3=q#ctor#;
$w3=undef;
$x3=q#dtor#;
$y3=q#methods#;
$z3=q#add#;
$A3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$B3=bless({$q,$A3,$s,$t},$u);
$C3=q#apply#;
$D3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$E3=bless({$q,$D3,$s,$t},$u);
$F3={$z3,$B3,$C3,$E3};
$G3=q#/lib/branch.b#;
$H3=q#lib/slice#;
$I3=bless({$D2,$u3,$v3,$w3,$x3,$w3,$y3,$F3,$D,$G3},$H3);
$J3=q#lib/branch#;
$K3=q#lib/slice::ctors#;
$L3={};
$M3=q#my $s = shift; ni->def($s->name, $s)#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$P3=bless({$q,$O3,$s,$t},$u);
$Q3={$D,$P3};
$R3=q#/lib/named.b#;
$S3=bless({$D2,$L3,$v3,$N3,$x3,$w3,$y3,$Q3,$D,$R3},$H3);
$T3=q#lib/tag#;
$U3={};
$V3=q#namespace#;
$W3=q#'ni'#;
$X3=bless({$q,$W3,$s,$t},$u);
$Y3={$V3,$X3};
$Z3=q#/lib/named_in_ni.b#;
$c4=bless({$D2,$U3,$v3,$w3,$x3,$w3,$y3,$Y3,$D,$Z3},$H3);
$d4={};
$e4=q#package#;
$f4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$g4=bless({$q,$f4,$s,$t},$u);
$h4={$e4,$g4};
$i4=q#/lib/namespaced.b#;
$j4=bless({$D2,$d4,$v3,$w3,$x3,$w3,$y3,$h4,$D,$i4},$H3);
$k4={};
$l4=q#resolve#;
$m4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$n4=bless({$q,$m4,$s,$t},$u);
$o4={$l4,$n4};
$p4=q#/lib/resolver.b#;
$q4=bless({$D2,$k4,$v3,$w3,$x3,$w3,$y3,$o4,$D,$p4},$H3);
$r4=[$I3,$S3,$c4,$j4,$q4];
$s4=bless({$D,$t3,$o3,$r4},$T3);
$t4=q#lib/tag::ctors#;
$u4={};
$v4=q#my $s = shift; $s->apply($s->package)#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4=q#instantiate#;
$y4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$z4=bless({$q,$y4,$s,$t},$u);
$A4={$x4,$z4};
$B4=q#/lib/class_init.b#;
$C4=bless({$D2,$u4,$v3,$w4,$x3,$w3,$y3,$A4,$D,$B4},$H3);
$D4=q#fabric/mio#;
$E4=q#fabric/rmi#;
$F4=q#io/buffer#;
$G4=q#io/cat#;
$H4=q#io/exec#;
$I4=q#io/fd#;
$J4=q#io/file#;
$K4=q#io/null#;
$L4=q#io/object#;
$M4=q#io/pid#;
$N4=q#io/str#;
$O4=q#io/transfer#;
$P4=q#io/transfer_async#;
$Q4=q#io/transfer_sync#;
$R4=q#lib/behavior#;
$S4=q#lib/dataslice#;
$T4=q#lib/image#;
$U4=q#lib/ni#;
$V4=q#lib/quote_simple#;
$W4=q#lib/test_value#;
$X4=q#object#;
$Y4=q#semantic/task#;
$Z4={$E2,1,$F2,1,$D4,1,$G2,1,$E4,1,$H2,1,$F4,1,$I2,1,$G4,1,$J2,1,$H4,1,$K2,1,$I4,1,$L2,1,$J4,1,$M2,1,$K4,1,$N2,1,$L4,1,$O2,1,$M4,1,$P2,1,$N4,1,$Q2,1,$O4,1,$R2,1,$P4,1,$S2,1,$Q4,1,$T2,1,$R4,1,$U2,1,$J3,1,$V2,1,$S4,1,$W2,1,$F,1,$X2,1,$u,1,$Y2,1,$T4,1,$Z2,1,$U4,1,$c3,1,$V4,1,$d3,1,$H3,1,$e3,1,$T3,1,$f3,1,$W4,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$X4,1,$j3,1,$k3,1,$l3,1,$Y4,1,$m3,1};
$c5=q#/object#;
$d5={};
$e5=q#ni 'ni:/' . ref shift#;
$f5=bless({$q,$e5,$s,$t},$u);
$g5={$E2,$f5};
$h5=q#/lib/instance.b#;
$i5=bless({$D2,$d5,$v3,$w3,$x3,$w3,$y3,$g5,$D,$h5},$H3);
$j5=[$i5];
$k5=bless({$D2,$Z4,$D,$c5,$o3,$j5},$j3);
$l5=q#object.c::ctors#;
$m5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$R4,1,$U2,1,$J3,1,$V2,1,$S4,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$H3,1,$e3,1,$T3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$n5=q#/lib/behavior#;
$o5={};
$p5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$e,$q5};
$s5=q#/lib/documentable.b#;
$t5=bless({$D2,$o5,$v3,$w3,$x3,$w3,$y3,$r5,$D,$s5},$H3);
$u5=[$k5,$t5];
$v5=bless({$D2,$m5,$D,$n5,$o3,$u5},$U2);
$w5=q#lib/behavior.c::ctors#;
$x5={$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$J3,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$p3,1,$h3,1,$q3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1};
$y5=q#/lib/definition.b#;
$z5={};
$A5=q#def#;
$B5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$C5=bless({$q,$B5,$s,$t},$u);
$D5={$A5,$C5};
$E5=q#/lib/definition_def.b#;
$F5=bless({$D2,$z5,$v3,$w3,$x3,$w3,$y3,$D5,$D,$E5},$H3);
$G5={};
$H5=q#ro#;
$I5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$J5=bless({$q,$I5,$s,$t},$u);
$K5=q#rw#;
$L5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$H5,$J5,$K5,$M5};
$O5=q#/lib/accessor.b#;
$P5=bless({$D2,$G5,$v3,$w3,$x3,$w3,$y3,$N5,$D,$O5},$H3);
$Q5={};
$R5=q#(""#;
$S5=q#shift->name#;
$T5=bless({$q,$S5,$s,$t},$u);
$U5={$R5,$T5};
$V5=q#/lib/name_as_string.b#;
$W5=bless({$D2,$Q5,$v3,$w3,$x3,$w3,$y3,$U5,$D,$V5},$H3);
$X5={};
$Y5=q#(eq#;
$Z5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$c6=bless({$q,$Z5,$s,$t},$u);
$d6={$Y5,$c6};
$e6=q#/lib/ref_eq.b#;
$f6=bless({$D2,$X5,$v3,$w3,$x3,$w3,$y3,$d6,$D,$e6},$H3);
$g6={};
$h6=q#defdata#;
$i6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$j6=bless({$q,$i6,$s,$t},$u);
$k6={$h6,$j6};
$l6=q#/lib/definition_defdata.b#;
$m6=bless({$D2,$g6,$v3,$w3,$x3,$w3,$y3,$k6,$D,$l6},$H3);
$n6=[$F5,$P5,$W5,$f6,$m6];
$o6=bless({$D2,$x5,$D,$y5,$o3,$n6},$J3);
$p6=q#lib/branch::ctors#;
$q6=[$s4,$C4,$k5,$v5,$o6];
$r6=bless({$D2,$r3,$D,$s3,$o3,$q6},$i3);
$s6=q#module.c::ctors#;
$t6={};
$u6=q#DESTROY#;
$v6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$w6=bless({$q,$v6,$s,$t},$u);
$x6=q#new#;
$y6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$z6=bless({$q,$y6,$s,$t},$u);
$A6={$u6,$w6,$x6,$z6};
$B6=q#/lib/instantiable.b#;
$C6=bless({$D2,$t6,$y3,$A6,$D,$B6},$H3);
$D6={};
$E6=q#child#;
$F6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$G6=bless({$q,$F6,$s,$t},$u);
$H6={$E6,$G6};
$I6=q#/lib/subclass.b#;
$J6=bless({$D2,$D6,$v3,$w3,$x3,$w3,$y3,$H6,$D,$I6},$H3);
$K6=[$r6,$C6,$C4,$r6,$J6];
$L6=bless({$D2,$n3,$D,$E,$o3,$K6},$F2);
$M6=q#class.c::ctors#;
$N6=q#ni:/class.c#;
$O6={$F2,1,$l3,1};
$P6=q#/class.c#;
$Q6={$F2,1,$i3,1,$l3,1};
$R6=q#/module.c#;
$S6={$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$i3,1,$j3,1,$l3,1,$m3,1};
$T6=q#/object.c#;
$U6=[$L6];
$V6=bless({$D2,$S6,$D,$T6,$o3,$U6},$p3);
$W6=q#metaclass::ctors#;
$X6={$F2,1,$U2,1,$V2,1,$W2,1,$e3,1,$f3,1,$i3,1,$l3,1};
$Y6=q#/lib/behavior.c#;
$Z6=[$V6];
$c7=bless({$D2,$X6,$D,$Y6,$o3,$Z6},$p3);
$d7=[$V6,$C6,$c7];
$e7=bless({$D2,$Q6,$D,$R6,$o3,$d7},$p3);
$f7=[$e7];
$g7=bless({$D2,$O6,$D,$P6,$o3,$f7},$p3);
$h7=q#ni:/fabric/mio#;
$i7={$D4,1};
$j7={$D4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$N4,1};
$k7=q#/io/object#;
$l7={};
$m7=q#(bool#;
$n7=[];
$o7=bless({$o,$n7,$q,1,$s,$t},$u);
$p7={$m7,$o7};
$q7=q#/io/object_ops.b#;
$r7=bless({$D2,$l7,$v3,$w3,$x3,$w3,$y3,$p7,$D,$q7},$H3);
$s7={};
$t7=q#die#;
$u7=[];
$v7=q#shift; die join " ", @_#;
$w7=bless({$o,$u7,$q,$v7,$s,$t},$u);
$x7=q#io_check#;
$y7=[];
$z7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$A7=bless({$o,$y7,$q,$z7,$s,$t},$u);
$B7=q#io_check_defined#;
$C7=[];
$D7=q#shift->io_check(sub {defined shift}, @_)#;
$E7=bless({$o,$C7,$q,$D7,$s,$t},$u);
$F7=q#io_check_true#;
$G7=[];
$H7=q#shift->io_check(sub {shift}, @_)#;
$I7=bless({$o,$G7,$q,$H7,$s,$t},$u);
$J7={$t7,$w7,$x7,$A7,$B7,$E7,$F7,$I7};
$K7=q#/io/object_checks.b#;
$L7=bless({$D2,$s7,$v3,$w3,$x3,$w3,$y3,$J7,$D,$K7},$H3);
$M7={};
$N7=q#(+#;
$O7=[];
$P7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$Q7=bless({$o,$O7,$q,$P7,$s,$t},$u);
$R7={$N7,$Q7};
$S7=q#/io/object_constructors.b#;
$T7=bless({$D2,$M7,$v3,$w3,$x3,$w3,$y3,$R7,$D,$S7},$H3);
$U7={};
$V7=q#read_all#;
$W7=[];
$X7=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$Y7=bless({$o,$W7,$q,$X7,$s,$t},$u);
$Z7={$V7,$Y7};
$c8=q#/io/object_memory.b#;
$d8=bless({$D2,$U7,$v3,$w3,$x3,$w3,$y3,$Z7,$D,$c8},$H3);
$e8={};
$f8=q#into_sync#;
$g8=[];
$h8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$i8=bless({$o,$g8,$q,$h8,$s,$t},$u);
$j8={$f8,$i8};
$k8=q#/io/object_transfer_sync.b#;
$l8=bless({$D2,$e8,$v3,$w3,$x3,$w3,$y3,$j8,$D,$k8},$H3);
$m8={};
$n8=q#into_async#;
$o8=[];
$p8=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$q8=bless({$o,$o8,$q,$p8,$s,$t},$u);
$r8={$n8,$q8};
$s8=q#/io/object_transfer_async.b#;
$t8=bless({$D2,$m8,$v3,$w3,$x3,$w3,$y3,$r8,$D,$s8},$H3);
$u8=[$k5,$r7,$L7,$T7,$d8,$l8,$t8,$t8,$l8];
$v8=bless({$D2,$j7,$D,$k7,$o3,$u8},$O2);
$w8=q#io/object.c::ctors#;
$x8={};
$y8=q#io#;
$z8=[];
$A8=q#shift->{'io'}#;
$B8=bless({$o,$z8,$q,$A8,$s,$t},$u);
$C8=q#packet_size#;
$D8=[];
$E8=q#shift->{'packet_size'}#;
$F8=bless({$o,$D8,$q,$E8,$s,$t},$u);
$G8={$y8,$B8,$C8,$F8};
$H8=q#/fabric/mio_ro.b#;
$I8=bless({$D2,$x8,$v3,$w3,$x3,$w3,$y3,$G8,$D,$H8},$H3);
$J8={};
$K8=[];
$L8=q#my ($self, $io, %args) = @_;
+{io          => $io,
  packet_size => $args{packet_size} || 32768,
  channel_id  => 0,
  channels    => {}};#;
$M8=bless({$o,$K8,$q,$L8,$s,$t},$u);
$N8={$x4,$M8};
$O8=q#/fabric/mio_init.b#;
$P8=bless({$D2,$J8,$v3,$w3,$x3,$w3,$y3,$N8,$D,$O8},$H3);
$Q8={};
$R8=q#data_packet#;
$S8=[];
$T8=q#my $self       = shift;
my $channel_id = shift;
pack 'NN/a', $channel_id, $_[0];#;
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8=q#eof_packet#;
$W8=[];
$X8=q#my ($self, $channel_id) = @_;
pack 'NN', $channel_id, 0;#;
$Y8=bless({$o,$W8,$q,$X8,$s,$t},$u);
$Z8={$R8,$U8,$V8,$Y8};
$c9=q#/fabric/mio_packet.b#;
$d9=bless({$D2,$Q8,$v3,$w3,$x3,$w3,$y3,$Z8,$D,$c9},$H3);
$e9={};
$f9=q#channel#;
$g9=[];
$h9=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
my $c = ni('ni:/fabric/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$c;#;
$i9=bless({$o,$g9,$q,$h9,$s,$t},$u);
$j9={$f9,$i9};
$k9=q#/fabric/mio_channel.b#;
$l9=bless({$D2,$e9,$v3,$w3,$x3,$w3,$y3,$j9,$D,$k9},$H3);
$m9=[$v8,$I8,$P8,$d9,$l9];
$n9=bless({$D2,$i7,$D,$U,$o3,$m9},$G2);
$o9=q#fabric/mio.c::ctors#;
$p9=q#ni:/fabric/mio.c#;
$q9={$G2,1};
$r9=q#/fabric/mio.c#;
$s9={$G2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1};
$t9=q#/io/object.c#;
$u9=[$V6];
$v9=bless({$D2,$s9,$D,$t9,$o3,$u9},$p3);
$w9=[$v9];
$x9=bless({$D2,$q9,$D,$r9,$o3,$w9},$p3);
$y9=q#ni:/fabric/mio_channel.b#;
$z9=q#ni:/fabric/mio_init.b#;
$A9=q#ni:/fabric/mio_packet.b#;
$B9=q#ni:/fabric/mio_ro.b#;
$C9=q#ni:/fabric/rmi#;
$D9={$E4,1};
$E9=q#/fabric/rmi#;
$F9={};
$G9=[];
$H9=q#my ($class, $io, $quote) = @_;#;
$I9=bless({$o,$G9,$q,$H9,$s,$t},$u);
$J9={$x4,$I9};
$K9=q#/fabric/rmi_init.b#;
$L9=bless({$D2,$F9,$v3,$w3,$x3,$w3,$y3,$J9,$D,$K9},$H3);
$M9=[$k5,$L9];
$N9=bless({$D2,$D9,$D,$E9,$o3,$M9},$H2);
$O9=q#fabric/rmi.c::ctors#;
$P9=q#ni:/fabric/rmi.c#;
$Q9={$H2,1};
$R9=q#/fabric/rmi.c#;
$S9=[$V6];
$T9=bless({$D2,$Q9,$D,$R9,$o3,$S9},$p3);
$U9=q#ni:/fabric/rmi_init.b#;
$V9=q#ni:/io/buffer#;
$W9={$F4,1};
$X9={};
$Y9=[];
$Z9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da={$x4,$ca};
$ea=q#/io/buffer_init.b#;
$fa=bless({$D2,$X9,$v3,$w3,$x3,$w3,$y3,$da,$D,$ea},$H3);
$ga={};
$ha=q#read#;
$ia=[];
$ja=bless({$o,$ia,$q,$t,$s,$t},$u);
$ka=q#write#;
$la=[];
$ma=bless({$o,$la,$q,$t,$s,$t},$u);
$na={$ha,$ja,$ka,$ma};
$oa=q#/io/buffer_io.b#;
$pa=bless({$D2,$ga,$v3,$w3,$x3,$w3,$y3,$na,$D,$oa},$H3);
$qa=[$v8,$fa,$pa];
$ra=bless({$D2,$W9,$D,$i1,$o3,$qa},$I2);
$sa=q#io/buffer.c::ctors#;
$ta=q#ni:/io/buffer.c#;
$ua={$I2,1};
$va=q#/io/buffer.c#;
$wa=[$v9];
$xa=bless({$D2,$ua,$D,$va,$o3,$wa},$p3);
$ya=q#ni:/io/buffer_init.b#;
$za=q#ni:/io/buffer_io.b#;
$Aa=q#ni:/io/cat#;
$Ba={$G4,1};
$Ca={};
$Da=[];
$Ea=q#shift; +{fs => [@_]}#;
$Fa=bless({$o,$Da,$q,$Ea,$s,$t},$u);
$Ga={$x4,$Fa};
$Ha=q#/io/cat_init.b#;
$Ia=bless({$D2,$Ca,$v3,$w3,$x3,$w3,$y3,$Ga,$D,$Ha},$H3);
$Ja={};
$Ka=[];
$La=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na={$ha,$Ma};
$Oa=q#/io/cat_read.b#;
$Pa=bless({$D2,$Ja,$v3,$w3,$x3,$w3,$y3,$Na,$D,$Oa},$H3);
$Qa=[$v8,$Ia,$Pa];
$Ra=bless({$D2,$Ba,$D,$u1,$o3,$Qa},$J2);
$Sa=q#io/cat.c::ctors#;
$Ta=q#ni:/io/cat.c#;
$Ua={$J2,1};
$Va=q#/io/cat.c#;
$Wa=[$v9];
$Xa=bless({$D2,$Ua,$D,$Va,$o3,$Wa},$p3);
$Ya=q#ni:/io/cat_init.b#;
$Za=q#ni:/io/cat_read.b#;
$cb=q#ni:/io/exec#;
$db={$H4,1};
$eb={};
$fb=q#argv#;
$gb=[];
$hb=q#shift->{'argv'}#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb={$fb,$ib};
$kb=q#/io/exec_ro.b#;
$lb=bless({$D2,$eb,$v3,$w3,$x3,$w3,$y3,$jb,$D,$kb},$H3);
$mb={};
$nb=[];
$ob=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$pb=bless({$o,$nb,$q,$ob,$s,$t},$u);
$qb={$x4,$pb};
$rb=q#/io/exec_init.b#;
$sb=bless({$D2,$mb,$v3,$w3,$x3,$w3,$y3,$qb,$D,$rb},$H3);
$tb={};
$ub=q#connect#;
$vb=[];
$wb=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$xb=bless({$o,$vb,$q,$wb,$s,$t},$u);
$yb=q#in_pipe#;
$zb=[];
$Ab=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Bb=bless({$o,$zb,$q,$Ab,$s,$t},$u);
$Cb=q#out_pipe#;
$Db=[];
$Eb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Fb=bless({$o,$Db,$q,$Eb,$s,$t},$u);
$Gb=q#setup_stdio#;
$Hb=[];
$Ib=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Jb=bless({$o,$Hb,$q,$Ib,$s,$t},$u);
$Kb={$ub,$xb,$yb,$Bb,$Cb,$Fb,$Gb,$Jb};
$Lb=q#/io/exec_io_setup.b#;
$Mb=bless({$D2,$tb,$v3,$w3,$x3,$w3,$y3,$Kb,$D,$Lb},$H3);
$Nb={};
$Ob=q#binds_fd#;
$Pb=[];
$Qb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$Rb=bless({$o,$Pb,$q,$Qb,$s,$t},$u);
$Sb=q#fd#;
$Tb=[];
$Ub=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Vb=bless({$o,$Tb,$q,$Ub,$s,$t},$u);
$Wb=q#stderr#;
$Xb=[];
$Yb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Zb=bless({$o,$Xb,$q,$Yb,$s,$t},$u);
$cc=q#stdin#;
$dc=[];
$ec=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$fc=bless({$o,$dc,$q,$ec,$s,$t},$u);
$gc=q#stdout#;
$hc=[];
$ic=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$jc=bless({$o,$hc,$q,$ic,$s,$t},$u);
$kc={$Ob,$Rb,$Sb,$Vb,$Wb,$Zb,$cc,$fc,$gc,$jc};
$lc=q#/io/exec_io_accessors.b#;
$mc=bless({$D2,$Nb,$v3,$w3,$x3,$w3,$y3,$kc,$D,$lc},$H3);
$nc={};
$oc=q#env#;
$pc=[];
$qc=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$rc=bless({$o,$pc,$q,$qc,$s,$t},$u);
$sc={$oc,$rc};
$tc=q#/io/exec_env.b#;
$uc=bless({$D2,$nc,$v3,$w3,$x3,$w3,$y3,$sc,$D,$tc},$H3);
$vc={};
$wc=q#exec#;
$xc=[];
$yc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$zc=bless({$o,$xc,$q,$yc,$s,$t},$u);
$Ac=q#fork#;
$Bc=[];
$Cc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Dc=bless({$o,$Bc,$q,$Cc,$s,$t},$u);
$Ec=q#move_fds#;
$Fc=[];
$Gc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Hc=bless({$o,$Fc,$q,$Gc,$s,$t},$u);
$Ic={$wc,$zc,$Ac,$Dc,$Ec,$Hc};
$Jc=q#/io/exec_fork.b#;
$Kc=bless({$D2,$vc,$v3,$w3,$x3,$w3,$y3,$Ic,$D,$Jc},$H3);
$Lc=[$v8,$lb,$sb,$Mb,$mc,$uc,$Kc];
$Mc=bless({$D2,$db,$D,$G1,$o3,$Lc},$K2);
$Nc=q#io/exec.c::ctors#;
$Oc=q#ni:/io/exec.c#;
$Pc={$K2,1};
$Qc=q#/io/exec.c#;
$Rc=[$v9];
$Sc=bless({$D2,$Pc,$D,$Qc,$o3,$Rc},$p3);
$Tc=q#ni:/io/exec_env.b#;
$Uc=q#ni:/io/exec_fork.b#;
$Vc=q#ni:/io/exec_init.b#;
$Wc=q#ni:/io/exec_io_accessors.b#;
$Xc=q#ni:/io/exec_io_setup.b#;
$Yc=q#ni:/io/exec_ro.b#;
$Zc=q#ni:/io/fd#;
$cd={$I4,1};
$dd=q#/io/fd#;
$ed={};
$fd=[];
$gd=q#shift->{'fd'}#;
$hd=bless({$o,$fd,$q,$gd,$s,$t},$u);
$id={$Sb,$hd};
$jd=q#/io/fd_readers.b#;
$kd=bless({$D2,$ed,$v3,$w3,$x3,$w3,$y3,$id,$D,$jd},$H3);
$ld={};
$md=[];
$nd=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$od=bless({$o,$md,$q,$nd,$s,$t},$u);
$pd={$x4,$od};
$qd=q#/io/fd_init.b#;
$rd=bless({$D2,$ld,$v3,$w3,$x3,$w3,$y3,$pd,$D,$qd},$H3);
$sd={};
$td=q#be#;
$ud=[];
$vd=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd={$td,$wd};
$yd=q#/io/fd_shell.b#;
$zd=bless({$D2,$sd,$v3,$w3,$x3,$w3,$y3,$xd,$D,$yd},$H3);
$Ad={};
$Bd=q#cloexec#;
$Cd=[];
$Dd=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd=q#fcntl_flag#;
$Gd=[];
$Hd=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Id=bless({$o,$Gd,$q,$Hd,$s,$t},$u);
$Jd=q#nonblock#;
$Kd=[];
$Ld=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Md=bless({$o,$Kd,$q,$Ld,$s,$t},$u);
$Nd={$Bd,$Ed,$Fd,$Id,$Jd,$Md};
$Od=q#/io/fd_fcntl.b#;
$Pd=bless({$D2,$Ad,$v3,$w3,$x3,$w3,$y3,$Nd,$D,$Od},$H3);
$Qd={};
$Rd=[];
$Sd=q#shift->close#;
$Td=bless({$o,$Rd,$q,$Sd,$s,$t},$u);
$Ud=q#close#;
$Vd=[];
$Wd=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Xd=bless({$o,$Vd,$q,$Wd,$s,$t},$u);
$Yd={$Ud,$Xd};
$Zd=q#/io/fd_gc.b#;
$ce=bless({$D2,$Qd,$v3,$w3,$x3,$Td,$y3,$Yd,$D,$Zd},$H3);
$de={};
$ee=[];
$fe=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$ge=bless({$o,$ee,$q,$fe,$s,$t},$u);
$he=[];
$ie=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$je=bless({$o,$he,$q,$ie,$s,$t},$u);
$ke={$ha,$ge,$ka,$je};
$le=q#/io/fd_perlio.b#;
$me=bless({$D2,$de,$v3,$w3,$x3,$w3,$y3,$ke,$D,$le},$H3);
$ne=[$v8,$kd,$rd,$zd,$Pd,$ce,$me];
$oe=bless({$D2,$cd,$D,$dd,$o3,$ne},$L2);
$pe=q#io/fd.c::ctors#;
$qe=q#ni:/io/fd.c#;
$re={$L2,1};
$se=q#/io/fd.c#;
$te=[$v9];
$ue=bless({$D2,$re,$D,$se,$o3,$te},$p3);
$ve=q#ni:/io/fd_fcntl.b#;
$we=q#ni:/io/fd_gc.b#;
$xe=q#ni:/io/fd_init.b#;
$ye=q#ni:/io/fd_perlio.b#;
$ze=q#ni:/io/fd_readers.b#;
$Ae=q#ni:/io/fd_shell.b#;
$Be=q#ni:/io/file#;
$Ce={$J4,1};
$De=q#/io/file#;
$Ee={};
$Fe=[];
$Ge=q#shift->{'name'}#;
$He=bless({$o,$Fe,$q,$Ge,$s,$t},$u);
$Ie={$D,$He};
$Je=q#/io/file_readers.b#;
$Ke=bless({$D2,$Ee,$v3,$w3,$x3,$w3,$y3,$Ie,$D,$Je},$H3);
$Le={};
$Me=q#mode#;
$Ne=[];
$Oe=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Pe=bless({$o,$Ne,$q,$Oe,$s,$t},$u);
$Qe={$Me,$Pe};
$Re=q#/io/file_accessors.b#;
$Se=bless({$D2,$Le,$v3,$w3,$x3,$w3,$y3,$Qe,$D,$Re},$H3);
$Te={};
$Ue=[];
$Ve=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$We=bless({$o,$Ue,$q,$Ve,$s,$t},$u);
$Xe={$x4,$We};
$Ye=q#/io/file_init.b#;
$Ze=bless({$D2,$Te,$v3,$w3,$x3,$w3,$y3,$Xe,$D,$Ye},$H3);
$cf={};
$df=q#r#;
$ef=[];
$ff=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$gf=bless({$o,$ef,$q,$ff,$s,$t},$u);
$hf=[];
$if=q#shift->r->read(@_)#;
$jf=bless({$o,$hf,$q,$if,$s,$t},$u);
$kf=q#w#;
$lf=[];
$mf=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$nf=bless({$o,$lf,$q,$mf,$s,$t},$u);
$of=[];
$pf=q#shift->w->write(@_)#;
$qf=bless({$o,$of,$q,$pf,$s,$t},$u);
$rf={$df,$gf,$ha,$jf,$kf,$nf,$ka,$qf};
$sf=q#/io/file_io.b#;
$tf=bless({$D2,$cf,$v3,$w3,$x3,$w3,$y3,$rf,$D,$sf},$H3);
$uf=[$v8,$Ke,$Se,$Ze,$tf];
$vf=bless({$D2,$Ce,$D,$De,$o3,$uf},$M2);
$wf=q#io/file.c::ctors#;
$xf=q#ni:/io/file.c#;
$yf={$M2,1};
$zf=q#/io/file.c#;
$Af=[$v9];
$Bf=bless({$D2,$yf,$D,$zf,$o3,$Af},$p3);
$Cf=q#ni:/io/file_accessors.b#;
$Df=q#ni:/io/file_init.b#;
$Ef=q#ni:/io/file_io.b#;
$Ff=q#ni:/io/file_readers.b#;
$Gf=q#ni:/io/named_io_fns.b#;
$Hf={};
$If=q#fcntl#;
$Jf=[];
$Kf=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Lf=bless({$o,$Jf,$q,$Kf,$s,$t},$u);
$Mf=[];
$Nf=q#CORE::fork#;
$Of=bless({$o,$Mf,$q,$Nf,$s,$t},$u);
$Pf=q#open2#;
$Qf=[];
$Rf=q#CORE::open $_[0], $_[1]#;
$Sf=bless({$o,$Qf,$q,$Rf,$s,$t},$u);
$Tf=q#waitpid#;
$Uf=[];
$Vf=q#CORE::waitpid $_[0], $_[1]#;
$Wf=bless({$o,$Uf,$q,$Vf,$s,$t},$u);
$Xf={$If,$Lf,$Ac,$Of,$Pf,$Sf,$Tf,$Wf};
$Yf=q#/io/named_io_fns.b#;
$Zf=bless({$D2,$Hf,$v3,$w3,$x3,$w3,$y3,$Xf,$D,$Yf},$H3);
$cg=q#main#;
$dg=q#ni:/io/null#;
$eg={$K4,1};
$fg=q#/io/null#;
$gg={};
$hg=[];
$ig=q#+{fd => undef}#;
$jg=bless({$o,$hg,$q,$ig,$s,$t},$u);
$kg={$x4,$jg};
$lg=q#/io/null_init.b#;
$mg=bless({$D2,$gg,$v3,$w3,$x3,$w3,$y3,$kg,$D,$lg},$H3);
$ng={};
$og=[];
$pg=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$qg=bless({$o,$og,$q,$pg,$s,$t},$u);
$rg=[];
$sg=q#shift->fd->read(@_)#;
$tg=bless({$o,$rg,$q,$sg,$s,$t},$u);
$ug=[];
$vg=q#shift->fd->write(@_)#;
$wg=bless({$o,$ug,$q,$vg,$s,$t},$u);
$xg={$Sb,$qg,$ha,$tg,$ka,$wg};
$yg=q#/io/null_io.b#;
$zg=bless({$D2,$ng,$v3,$w3,$x3,$w3,$y3,$xg,$D,$yg},$H3);
$Ag=[$v8,$mg,$zg];
$Bg=bless({$D2,$eg,$D,$fg,$o3,$Ag},$N2);
$Cg=q#io/null.c::ctors#;
$Dg=q#ni:/io/null.c#;
$Eg={$N2,1};
$Fg=q#/io/null.c#;
$Gg=[$v9];
$Hg=bless({$D2,$Eg,$D,$Fg,$o3,$Gg},$p3);
$Ig=q#ni:/io/null_init.b#;
$Jg=q#ni:/io/null_io.b#;
$Kg=q#ni:/io/object#;
$Lg=q#ni:/io/object.c#;
$Mg=q#ni:/io/object_checks.b#;
$Ng=q#ni:/io/object_constructors.b#;
$Og=q#ni:/io/object_memory.b#;
$Pg=q#ni:/io/object_ops.b#;
$Qg=q#ni:/io/object_transfer_async.b#;
$Rg=q#ni:/io/object_transfer_sync.b#;
$Sg=q#ni:/io/pid#;
$Tg={$M4,1};
$Ug={};
$Vg=q#pid#;
$Wg=[];
$Xg=q#shift->{'pid'}#;
$Yg=bless({$o,$Wg,$q,$Xg,$s,$t},$u);
$Zg=q#status#;
$ch=[];
$dh=q#shift->{'status'}#;
$eh=bless({$o,$ch,$q,$dh,$s,$t},$u);
$fh={$Vg,$Yg,$Zg,$eh};
$gh=q#/io/pid_readers.b#;
$hh=bless({$D2,$Ug,$v3,$w3,$x3,$w3,$y3,$fh,$D,$gh},$H3);
$ih={};
$jh=[];
$kh=q#shift->await#;
$lh=bless({$o,$jh,$q,$kh,$s,$t},$u);
$mh=[];
$nh=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$oh=bless({$o,$mh,$q,$nh,$s,$t},$u);
$ph={$x4,$oh};
$qh=q#/io/pid_init.b#;
$rh=bless({$D2,$ih,$v3,$w3,$x3,$lh,$y3,$ph,$D,$qh},$H3);
$sh={};
$th=q#await#;
$uh=[];
$vh=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$wh=bless({$o,$uh,$q,$vh,$s,$t},$u);
$xh=q#running#;
$yh=[];
$zh=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Ah=bless({$o,$yh,$q,$zh,$s,$t},$u);
$Bh={$th,$wh,$xh,$Ah};
$Ch=q#/io/pid_wait.b#;
$Dh=bless({$D2,$sh,$v3,$w3,$x3,$w3,$y3,$Bh,$D,$Ch},$H3);
$Eh={};
$Fh=[];
$Gh=q#shift->stdout->read(@_)#;
$Hh=bless({$o,$Fh,$q,$Gh,$s,$t},$u);
$Ih=[];
$Jh=q#shift->stdin->write(@_)#;
$Kh=bless({$o,$Ih,$q,$Jh,$s,$t},$u);
$Lh={$ha,$Hh,$ka,$Kh};
$Mh=q#/io/pid_io.b#;
$Nh=bless({$D2,$Eh,$v3,$w3,$x3,$w3,$y3,$Lh,$D,$Mh},$H3);
$Oh={};
$Ph=[];
$Qh=q#$_[0]->{external_fds}{$_[1]}#;
$Rh=bless({$o,$Ph,$q,$Qh,$s,$t},$u);
$Sh=[];
$Th=q#shift->fd(2)#;
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh=[];
$Wh=q#shift->fd(0)#;
$Xh=bless({$o,$Vh,$q,$Wh,$s,$t},$u);
$Yh=[];
$Zh=q#shift->fd(1)#;
$ci=bless({$o,$Yh,$q,$Zh,$s,$t},$u);
$di={$Sb,$Rh,$Wb,$Uh,$cc,$Xh,$gc,$ci};
$ei=q#/io/pid_accessors.b#;
$fi=bless({$D2,$Oh,$v3,$w3,$x3,$w3,$y3,$di,$D,$ei},$H3);
$gi=[$v8,$hh,$rh,$Dh,$Nh,$fi];
$hi=bless({$D2,$Tg,$D,$W1,$o3,$gi},$P2);
$ii=q#io/pid.c::ctors#;
$ji=q#ni:/io/pid.c#;
$ki={$P2,1};
$li=q#/io/pid.c#;
$mi=[$v9];
$ni=bless({$D2,$ki,$D,$li,$o3,$mi},$p3);
$oi=q#ni:/io/pid_accessors.b#;
$pi=q#ni:/io/pid_init.b#;
$qi=q#ni:/io/pid_io.b#;
$ri=q#ni:/io/pid_readers.b#;
$si=q#ni:/io/pid_wait.b#;
$ti=q#ni:/io/str#;
$ui={$N4,1};
$vi=q#/io/str#;
$wi={};
$xi=q#data#;
$yi=[];
$zi=q#shift->{'data'}#;
$Ai=bless({$o,$yi,$q,$zi,$s,$t},$u);
$Bi=q#end#;
$Ci=[];
$Di=q#shift->{'end'}#;
$Ei=bless({$o,$Ci,$q,$Di,$s,$t},$u);
$Fi=q#start#;
$Gi=[];
$Hi=q#shift->{'start'}#;
$Ii=bless({$o,$Gi,$q,$Hi,$s,$t},$u);
$Ji={$xi,$Ai,$Bi,$Ei,$Fi,$Ii};
$Ki=q#/io/str_ro.b#;
$Li=bless({$D2,$wi,$v3,$w3,$x3,$w3,$y3,$Ji,$D,$Ki},$H3);
$Mi={};
$Ni=[];
$Oi=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Pi=bless({$o,$Ni,$q,$Oi,$s,$t},$u);
$Qi={$x4,$Pi};
$Ri=q#/io/str_init.b#;
$Si=bless({$D2,$Mi,$v3,$w3,$x3,$w3,$y3,$Qi,$D,$Ri},$H3);
$Ti={};
$Ui=[];
$Vi=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Wi=bless({$o,$Ui,$q,$Vi,$s,$t},$u);
$Xi=q#remaining#;
$Yi=[];
$Zi=q#my $self = shift; $$self{end} - $$self{start}#;
$cj=bless({$o,$Yi,$q,$Zi,$s,$t},$u);
$dj=[];
$ej=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$fj=bless({$o,$dj,$q,$ej,$s,$t},$u);
$gj={$ha,$Wi,$Xi,$cj,$ka,$fj};
$hj=q#/io/str_io.b#;
$ij=bless({$D2,$Ti,$v3,$w3,$x3,$w3,$y3,$gj,$D,$hj},$H3);
$jj=[$v8,$Li,$Si,$ij];
$kj=bless({$D2,$ui,$D,$vi,$o3,$jj},$Q2);
$lj=q#io/str.c::ctors#;
$mj=q#ni:/io/str.c#;
$nj={$Q2,1};
$oj=q#/io/str.c#;
$pj=[$v9];
$qj=bless({$D2,$nj,$D,$oj,$o3,$pj},$p3);
$rj=q#ni:/io/str_init.b#;
$sj=q#ni:/io/str_io.b#;
$tj=q#ni:/io/str_ro.b#;
$uj=q#ni:/io/transfer#;
$vj={$O4,1,$P4,1,$Q4,1};
$wj=q#/io/transfer#;
$xj={$O4,1,$P4,1,$Q4,1,$Y4,1};
$yj=q#/semantic/task#;
$zj={};
$Aj=q#outcome#;
$Bj=[];
$Cj=q#shift->{'outcome'}#;
$Dj=bless({$o,$Bj,$q,$Cj,$s,$t},$u);
$Ej={$Aj,$Dj};
$Fj=q#/semantic/task_ro.b#;
$Gj=bless({$D2,$zj,$v3,$w3,$x3,$w3,$y3,$Ej,$D,$Fj},$H3);
$Hj={};
$Ij=q#failure#;
$Jj=[];
$Kj=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Lj=bless({$o,$Jj,$q,$Kj,$s,$t},$u);
$Mj=q#success#;
$Nj=[];
$Oj=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Pj=bless({$o,$Nj,$q,$Oj,$s,$t},$u);
$Qj={$Ij,$Lj,$Mj,$Pj};
$Rj=q#/semantic/task_outcome.b#;
$Sj=bless({$D2,$Hj,$v3,$w3,$x3,$w3,$y3,$Qj,$D,$Rj},$H3);
$Tj=[$k5,$Gj,$Sj];
$Uj=bless({$D2,$xj,$D,$yj,$o3,$Tj},$m3);
$Vj=q#semantic/task.c::ctors#;
$Wj={};
$Xj=[];
$Yj=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$Zj=bless({$o,$Xj,$q,$Yj,$s,$t},$u);
$ck=[];
$dk=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$ek=bless({$o,$ck,$q,$dk,$s,$t},$u);
$fk=[];
$gk=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$hk=bless({$o,$fk,$q,$gk,$s,$t},$u);
$ik={$ha,$ek,$ka,$hk};
$jk=q#/io/transfer_io_interop.b#;
$kk=bless({$D2,$Wj,$v3,$Zj,$x3,$w3,$y3,$ik,$D,$jk},$H3);
$lk={};
$mk=q#pressure#;
$nk=[];
$ok=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$pk=bless({$o,$nk,$q,$ok,$s,$t},$u);
$qk=q#read_limit_throughput#;
$rk=[];
$sk=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$tk=bless({$o,$rk,$q,$sk,$s,$t},$u);
$uk=q#throughput#;
$vk=[];
$wk=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$xk=bless({$o,$vk,$q,$wk,$s,$t},$u);
$yk=q#write_limit_throughput#;
$zk=[];
$Ak=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$Bk=bless({$o,$zk,$q,$Ak,$s,$t},$u);
$Ck={$mk,$pk,$qk,$tk,$uk,$xk,$yk,$Bk};
$Dk=q#/io/transfer_io_measurement.b#;
$Ek=bless({$D2,$lk,$v3,$w3,$x3,$w3,$y3,$Ck,$D,$Dk},$H3);
$Fk=[$Uj,$kk,$Ek];
$Gk=bless({$D2,$vj,$D,$wj,$o3,$Fk},$R2);
$Hk=q#io/transfer.c::ctors#;
$Ik=q#ni:/io/transfer.c#;
$Jk={$R2,1,$S2,1,$T2,1};
$Kk=q#/io/transfer.c#;
$Lk={$R2,1,$S2,1,$T2,1,$m3,1};
$Mk=q#/semantic/task.c#;
$Nk=[$V6];
$Ok=bless({$D2,$Lk,$D,$Mk,$o3,$Nk},$p3);
$Pk={};
$Qk=[];
$Rk=q#my $self = shift;
ni('ni:/io/object')->def("/io/object_transfer_$1.b",
  "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\\@_)->run})
if $self->name =~ /transfer_(\\w+)$/;#;
$Sk=bless({$o,$Qk,$q,$Rk,$s,$t},$u);
$Tk={};
$Uk=q#/io/transfer.c_into.b#;
$Vk=bless({$D2,$Pk,$v3,$Sk,$x3,$w3,$y3,$Tk,$D,$Uk},$H3);
$Wk=[$Ok,$Vk];
$Xk=bless({$D2,$Jk,$D,$Kk,$o3,$Wk},$p3);
$Yk=q#ni:/io/transfer.c_into.b#;
$Zk=q#ni:/io/transfer_async#;
$cl={$P4,1};
$dl=q#/io/transfer_async#;
$el={};
$fl=[];
$gl=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  id        => $class->new_id};#;
$hl=bless({$o,$fl,$q,$gl,$s,$t},$u);
$il={$x4,$hl};
$jl=q#/io/transfer_async_init.b#;
$kl=bless({$D2,$el,$v3,$w3,$x3,$w3,$y3,$il,$D,$jl},$H3);
$ll={};
$ml=[];
$nl=q#ni('ni:/io/transfer_async')->track(shift)#;
$ol=bless({$o,$ml,$q,$nl,$s,$t},$u);
$pl=[];
$ql=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl={};
$tl=q#/io/transfer_async_lifecycle.b#;
$ul=bless({$D2,$ll,$v3,$ol,$x3,$rl,$y3,$sl,$D,$tl},$H3);
$vl={};
$wl=q#run#;
$xl=[];
$yl=q#shift#;
$zl=bless({$o,$xl,$q,$yl,$s,$t},$u);
$Al=q#run_async#;
$Bl=[];
$Cl=q#my $self = shift;
my $n;
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}
$self;#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El={$wl,$zl,$Al,$Dl};
$Fl=q#/io/transfer_async_run.b#;
$Gl=bless({$D2,$vl,$v3,$w3,$x3,$w3,$y3,$El,$D,$Fl},$H3);
$Hl=[$Gk,$kl,$ul,$Gl];
$Il=bless({$D2,$cl,$D,$dl,$o3,$Hl},$S2);
$Jl=q#io/transfer_async.c::ctors#;
$Kl=q#ni:/io/transfer_async.c#;
$Ll={$S2,1};
$Ml=q#/io/transfer_async.c#;
$Nl=[$Xk];
$Ol=bless({$D2,$Ll,$D,$Ml,$o3,$Nl},$p3);
$Pl=q#ni:/io/transfer_async_init.b#;
$Ql=q#ni:/io/transfer_async_lifecycle.b#;
$Rl=q#ni:/io/transfer_async_run.b#;
$Sl=q#ni:/io/transfer_io_interop.b#;
$Tl=q#ni:/io/transfer_io_measurement.b#;
$Ul=q#ni:/io/transfer_sync#;
$Vl={$Q4,1};
$Wl=q#/io/transfer_sync#;
$Xl={};
$Yl=[];
$Zl=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$cm=bless({$o,$Yl,$q,$Zl,$s,$t},$u);
$dm={$x4,$cm};
$em=q#/io/transfer_sync_init.b#;
$fm=bless({$D2,$Xl,$v3,$w3,$x3,$w3,$y3,$dm,$D,$em},$H3);
$gm={};
$hm=[];
$im=q#my $self = shift;
my $buf;
while ($self->read($buf, 32768)) {
  my $n = $self->write($buf);
  $self->failure($!) unless defined $n;
  while ($n < length $buf) {
    my $n0 = $self->write(substr $buf, $n);
    $self->failure($!) unless defined $n0;
    $n += $n0;
  }
}
$$self{end_time} = time;
$self->success;#;
$jm=bless({$o,$hm,$q,$im,$s,$t},$u);
$km={$wl,$jm};
$lm=q#/io/transfer_sync_run.b#;
$mm=bless({$D2,$gm,$v3,$w3,$x3,$w3,$y3,$km,$D,$lm},$H3);
$nm=[$Gk,$fm,$mm];
$om=bless({$D2,$Vl,$D,$Wl,$o3,$nm},$T2);
$pm=q#io/transfer_sync.c::ctors#;
$qm=q#ni:/io/transfer_sync.c#;
$rm={$T2,1};
$sm=q#/io/transfer_sync.c#;
$tm=[$Xk];
$um=bless({$D2,$rm,$D,$sm,$o3,$tm},$p3);
$vm=q#ni:/io/transfer_sync_init.b#;
$wm=q#ni:/io/transfer_sync_run.b#;
$xm=q#ni:/lib/accessor.b#;
$ym=q#ni:/lib/behavior#;
$zm=q#ni:/lib/behavior.c#;
$Am=q#ni:/lib/branch#;
$Bm={$J3,1};
$Cm=q#/lib/branch#;
$Dm={};
$Em=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Fm=bless({$q,$Em,$s,$t},$u);
$Gm={$x4,$Fm};
$Hm=q#/lib/branch_init.b#;
$Im=bless({$D2,$Dm,$v3,$w3,$x3,$w3,$y3,$Gm,$D,$Hm},$H3);
$Jm=[$v5,$S3,$I3,$Im,$o6];
$Km=bless({$D2,$Bm,$D,$Cm,$o3,$Jm},$V2);
$Lm=q#lib/branch.c::ctors#;
$Mm=q#ni:/lib/branch.b#;
$Nm=q#ni:/lib/branch.c#;
$Om={$V2,1};
$Pm=q#/lib/branch.c#;
$Qm=[$c7];
$Rm=bless({$D2,$Om,$D,$Pm,$o3,$Qm},$p3);
$Sm=q#ni:/lib/branch_init.b#;
$Tm=q#ni:/lib/class_init.b#;
$Um=q#ni:/lib/dataslice#;
$Vm={$S4,1};
$Wm=q#/lib/dataslice#;
$Xm={};
$Ym=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Zm=bless({$q,$Ym,$s,$t},$u);
$cn={$x4,$Zm};
$dn=q#/lib/dataslice_init.b#;
$en=bless({$D2,$Xm,$v3,$w3,$x3,$w3,$y3,$cn,$D,$dn},$H3);
$fn={};
$gn=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$hn=bless({$q,$gn,$s,$t},$u);
$in={$C3,$hn};
$jn=q#/lib/dataslice_apply.b#;
$kn=bless({$D2,$fn,$v3,$w3,$x3,$w3,$y3,$in,$D,$jn},$H3);
$ln=[$v5,$en,$kn];
$mn=bless({$D2,$Vm,$D,$Wm,$o3,$ln},$W2);
$nn=q#lib/dataslice.c::ctors#;
$on=q#ni:/lib/dataslice.c#;
$pn={$W2,1};
$qn=q#/lib/dataslice.c#;
$rn=[$c7];
$sn=bless({$D2,$pn,$D,$qn,$o3,$rn},$p3);
$tn=q#ni:/lib/dataslice_apply.b#;
$un=q#ni:/lib/dataslice_init.b#;
$vn=q#ni:/lib/definition.b#;
$wn=q#ni:/lib/definition_def.b#;
$xn=q#ni:/lib/definition_defdata.b#;
$yn=q#ni:/lib/doc#;
$zn={$F,1};
$An={};
$Bn=q#shift; +{name => shift, doc => []}#;
$Cn=bless({$q,$Bn,$s,$t},$u);
$Dn={$x4,$Cn};
$En=q#/lib/doc_init.b#;
$Fn=bless({$D2,$An,$v3,$w3,$x3,$w3,$y3,$Dn,$D,$En},$H3);
$Gn={};
$Hn=q#'ni.doc'#;
$In=bless({$q,$Hn,$s,$t},$u);
$Jn={$V3,$In};
$Kn=q#/lib/doc_namespace.b#;
$Ln=bless({$D2,$Gn,$v3,$w3,$x3,$w3,$y3,$Jn,$D,$Kn},$H3);
$Mn={};
$Nn=q#AUTOLOAD#;
$On=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Pn=bless({$q,$On,$s,$t},$u);
$Qn={$Nn,$Pn};
$Rn=q#/lib/doc_define.b#;
$Sn=bless({$D2,$Mn,$v3,$w3,$x3,$w3,$y3,$Qn,$D,$Rn},$H3);
$Tn={};
$Un=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Vn=bless({$q,$Un,$s,$t},$u);
$Wn=q#tests#;
$Xn=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Yn=bless({$q,$Xn,$s,$t},$u);
$Zn={$n,$Vn,$Wn,$Yn};
$co=q#/lib/doc_test.b#;
$do=bless({$D2,$Tn,$v3,$w3,$x3,$w3,$y3,$Zn,$D,$co},$H3);
$eo=[$k5,$S3,$Fn,$Ln,$Sn,$do];
$fo=bless({$D2,$zn,$D,$u2,$o3,$eo},$X2);
$go=q#lib/doc.c::ctors#;
$ho=q#ni:/lib/doc.c#;
$io={$X2,1};
$jo=q#/lib/doc.c#;
$ko=[$V6];
$lo=bless({$D2,$io,$D,$jo,$o3,$ko},$p3);
$mo=q#ni:/lib/doc_define.b#;
$no=q#ni:/lib/doc_init.b#;
$oo=q#ni:/lib/doc_namespace.b#;
$po=q#ni:/lib/doc_test.b#;
$qo=q#ni:/lib/documentable.b#;
$ro=q#ni:/lib/fn#;
$so={$u,1};
$to=q#/lib/fn#;
$uo={};
$vo=q#shift->compile#;
$wo=bless({$q,$vo,$s,$t},$u);
$xo=q#compile#;
$yo=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$zo=bless({$q,$yo,$s,$t},$u);
$Ao=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Bo=bless({$q,$Ao,$s,$t},$u);
$Co={$xo,$zo,$x4,$Bo};
$Do=q#/lib/fn_init.b#;
$Eo=bless({$D2,$uo,$v3,$wo,$x3,$w3,$y3,$Co,$D,$Do},$H3);
$Fo={};
$Go=[];
$Ho=q#shift->{'annotations'}#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo=[];
$Ko=q#shift->{'code'}#;
$Lo=bless({$o,$Jo,$q,$Ko,$s,$t},$u);
$Mo=q#fn#;
$No=[];
$Oo=q#shift->{'fn'}#;
$Po=bless({$o,$No,$q,$Oo,$s,$t},$u);
$Qo={$o,$Io,$q,$Lo,$Mo,$Po};
$Ro=q#/lib/fn_ro.b#;
$So=bless({$D2,$Fo,$v3,$w3,$x3,$w3,$y3,$Qo,$D,$Ro},$H3);
$To={};
$Uo=[];
$Vo=q#shift->{code}#;
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo=[];
$Yo=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp={$R5,$Wo,$Y5,$Zo};
$dp=q#/lib/fn_ops.b#;
$ep=bless({$D2,$To,$v3,$w3,$x3,$w3,$y3,$cp,$D,$dp},$H3);
$fp={};
$gp=q#serialize#;
$hp=[];
$ip=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$jp=bless({$o,$hp,$q,$ip,$s,$t},$u);
$kp={$gp,$jp};
$lp=q#/lib/fn_serialize.b#;
$mp=bless({$D2,$fp,$v3,$w3,$x3,$w3,$y3,$kp,$D,$lp},$H3);
$np=[$k5,$C6,$Eo,$So,$ep,$mp];
$op=bless({$D2,$so,$D,$to,$o3,$np},$Y2);
$pp=q#lib/fn.c::ctors#;
$qp=q#ni:/lib/fn.c#;
$rp={$Y2,1};
$sp=q#/lib/fn.c#;
$tp=[$V6];
$up=bless({$D2,$rp,$D,$sp,$o3,$tp},$p3);
$vp=q#ni:/lib/fn_init.b#;
$wp=q#ni:/lib/fn_ops.b#;
$xp=q#ni:/lib/fn_ro.b#;
$yp=q#ni:/lib/fn_serialize.b#;
$zp=q#ni:/lib/gensym_generator_compact.b#;
$Ap={};
$Bp=q#gensym#;
$Cp=[];
$Dp=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Ep=bless({$o,$Cp,$q,$Dp,$s,$t},$u);
$Fp={$Bp,$Ep};
$Gp=q#/lib/gensym_generator_compact.b#;
$Hp=bless({$D2,$Ap,$v3,$w3,$x3,$w3,$y3,$Fp,$D,$Gp},$H3);
$Ip=q#ni:/lib/global_static_test.b#;
$Jp={};
$Kp=q#now#;
$Lp=[];
$Mp=q#ni('ni:/lib/test_value')->new(shift)#;
$Np=q#($)#;
$Op=bless({$o,$Lp,$q,$Mp,$s,$Np},$u);
$Pp={$Kp,$Op};
$Qp=q#/lib/global_static_test.b#;
$Rp=bless({$D2,$Jp,$v3,$w3,$x3,$w3,$y3,$Pp,$D,$Qp},$H3);
$Sp=q#ni:/lib/image#;
$Tp={$T4,1};
$Up=q#/lib/image#;
$Vp={};
$Wp=[];
$Xp=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Yp=bless({$o,$Wp,$q,$Xp,$s,$t},$u);
$Zp={$x4,$Yp};
$cq=q#/lib/image_init.b#;
$dq=bless({$D2,$Vp,$v3,$w3,$x3,$w3,$y3,$Zp,$D,$cq},$H3);
$eq={};
$fq=q#address#;
$gq=[];
$hq=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$iq=bless({$o,$gq,$q,$hq,$s,$t},$u);
$jq=q#allocate_gensym#;
$kq=[];
$lq=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$mq=bless({$o,$kq,$q,$lq,$s,$t},$u);
$nq=q#boot_side_effect#;
$oq=[];
$pq=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$qq=bless({$o,$oq,$q,$pq,$s,$t},$u);
$rq=q#circular_links#;
$sq=[];
$tq=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$uq=bless({$o,$sq,$q,$tq,$s,$t},$u);
$vq=q#finalizer#;
$wq=[];
$xq=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$yq=bless({$o,$wq,$q,$xq,$s,$t},$u);
$zq=q#quote#;
$Aq=[];
$Bq=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Cq=bless({$o,$Aq,$q,$Bq,$s,$t},$u);
$Dq=q#reconstruction#;
$Eq=[];
$Fq=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Gq=bless({$o,$Eq,$q,$Fq,$s,$t},$u);
$Hq=q#side_effect#;
$Iq=[];
$Jq=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Kq=bless({$o,$Iq,$q,$Jq,$s,$t},$u);
$Lq=[];
$Mq=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Nq=bless({$o,$Lq,$q,$Mq,$s,$t},$u);
$Oq={$fq,$iq,$jq,$mq,$nq,$qq,$rq,$uq,$vq,$yq,$zq,$Cq,$Dq,$Gq,$Hq,$Kq,$ka,$Nq};
$Pq=q#/lib/image_quoting.b#;
$Qq=bless({$D2,$eq,$v3,$w3,$x3,$w3,$y3,$Oq,$D,$Pq},$H3);
$Rq={};
$Sq=q#quote_code#;
$Tq=[];
$Uq=q#shift->die('cannot quote perl CODE refs', shift)#;
$Vq=bless({$o,$Tq,$q,$Uq,$s,$t},$u);
$Wq={$Sq,$Vq};
$Xq=q#/lib/quote_code_fail.b#;
$Yq=bless({$D2,$Rq,$v3,$w3,$x3,$w3,$y3,$Wq,$D,$Xq},$H3);
$Zq={};
$cr=q#quote_array#;
$dr=[];
$er=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$fr=bless({$o,$dr,$q,$er,$s,$t},$u);
$gr=q#quote_hash#;
$hr=[];
$ir=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr=q#quote_scalar#;
$lr=[];
$mr=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$nr=bless({$o,$lr,$q,$mr,$s,$t},$u);
$or=q#quote_scalar_ref#;
$pr=[];
$qr=q#'\\\\' . shift->quote(${$_[0]})#;
$rr=bless({$o,$pr,$q,$qr,$s,$t},$u);
$sr=q#quote_value#;
$tr=[];
$ur=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$vr=bless({$o,$tr,$q,$ur,$s,$t},$u);
$wr={$cr,$fr,$gr,$jr,$kr,$nr,$or,$rr,$sr,$vr};
$xr=q#/lib/quote_values.b#;
$yr=bless({$D2,$Zq,$v3,$w3,$x3,$w3,$y3,$wr,$D,$xr},$H3);
$zr={};
$Ar=q#quote_blessed#;
$Br=[];
$Cr=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Dr=bless({$o,$Br,$q,$Cr,$s,$t},$u);
$Er=q#quote_class#;
$Fr=[];
$Gr=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Hr=bless({$o,$Fr,$q,$Gr,$s,$t},$u);
$Ir=q#quote_object#;
$Jr=[];
$Kr=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Lr=bless({$o,$Jr,$q,$Kr,$s,$t},$u);
$Mr={$Ar,$Dr,$Er,$Hr,$Ir,$Lr};
$Nr=q#/lib/quote_objects.b#;
$Or=bless({$D2,$zr,$v3,$w3,$x3,$w3,$y3,$Mr,$D,$Nr},$H3);
$Pr={};
$Qr=q#circular_arrayref#;
$Rr=[];
$Sr=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Tr=bless({$o,$Rr,$q,$Sr,$s,$t},$u);
$Ur=q#circular_hashref#;
$Vr=[];
$Wr=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Xr=bless({$o,$Vr,$q,$Wr,$s,$t},$u);
$Yr=q#is_circular#;
$Zr=[];
$cs=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$ds=bless({$o,$Zr,$q,$cs,$s,$t},$u);
$es={$Qr,$Tr,$Ur,$Xr,$Yr,$ds};
$fs=q#/lib/quote_circular_addressed.b#;
$gs=bless({$D2,$Pr,$v3,$w3,$x3,$w3,$y3,$es,$D,$fs},$H3);
$hs=[$k5,$dq,$Qq,$Yq,$yr,$Or,$gs,$Hp];
$is=bless({$D2,$Tp,$D,$Up,$o3,$hs},$Z2);
$js=q#lib/image.c::ctors#;
$ks=q#ni:/lib/image.c#;
$ls={$Z2,1};
$ms=q#/lib/image.c#;
$ns=[$V6];
$os=bless({$D2,$ls,$D,$ms,$o3,$ns},$p3);
$ps=q#ni:/lib/image_init.b#;
$qs=q#ni:/lib/image_quoting.b#;
$rs=q#ni:/lib/instance.b#;
$ss=q#ni:/lib/instantiable.b#;
$ts=q#ni:/lib/json.b#;
$us={};
$vs=q#json_decode#;
$ws=[];
$xs=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$ys=bless({$o,$ws,$q,$xs,$s,$Np},$u);
$zs=q#json_encode#;
$As=[];
$Bs=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Cs=bless({$o,$As,$q,$Bs,$s,$Np},$u);
$Ds=q#json_escape#;
$Es=[];
$Fs=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Gs=bless({$o,$Es,$q,$Fs,$s,$Np},$u);
$Hs=q#json_unescape#;
$Is=[];
$Js=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Ks=bless({$o,$Is,$q,$Js,$s,$Np},$u);
$Ls=q#json_unescape_one#;
$Ms=[];
$Ns=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Os=bless({$o,$Ms,$q,$Ns,$s,$Np},$u);
$Ps={$vs,$ys,$zs,$Cs,$Ds,$Gs,$Hs,$Ks,$Ls,$Os};
$Qs=q#/lib/json.b#;
$Rs=bless({$D2,$us,$v3,$w3,$x3,$w3,$y3,$Ps,$D,$Qs},$H3);
$Ss=q#ni#;
$Ts=q#ni:/lib/name_as_string.b#;
$Us=q#ni:/lib/named.b#;
$Vs=q#ni:/lib/named_in_ni.b#;
$Ws=q#ni:/lib/namespaced.b#;
$Xs=q#ni:/lib/ni#;
$Ys={$U4,1};
$Zs=q#/lib/ni#;
$ct={};
$dt=q#extend#;
$et=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$ft=bless({$q,$et,$s,$t},$u);
$gt=q#is_mutable#;
$ht=q#$0 ne "-" && -w $0#;
$it=bless({$q,$ht,$s,$t},$u);
$jt=q#modify#;
$kt=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$lt=bless({$q,$kt,$s,$t},$u);
$mt={$dt,$ft,$gt,$it,$jt,$lt};
$nt=q#/lib/ni_self.b#;
$ot=bless({$D2,$ct,$v3,$w3,$x3,$w3,$y3,$mt,$D,$nt},$H3);
$pt={};
$qt=q#--internal/+=#;
$rt=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$st=bless({$q,$rt,$s,$t},$u);
$tt=q#--internal/eval#;
$ut=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$vt=bless({$q,$ut,$s,$t},$u);
$wt=q#--internal/image#;
$xt=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$yt=bless({$q,$xt,$s,$t},$u);
$zt=q#--internal/test#;
$At=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Bt=bless({$q,$At,$s,$t},$u);
$Ct=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Dt=bless({$q,$Ct,$s,$t},$u);
$Et={$qt,$st,$tt,$vt,$wt,$yt,$zt,$Bt,$wl,$Dt};
$Ft=q#/lib/ni_main.b#;
$Gt=bless({$D2,$pt,$v3,$w3,$x3,$w3,$y3,$Et,$D,$Ft},$H3);
$Ht={};
$It=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Jt=bless({$q,$It,$s,$t},$u);
$Kt=q#resolver_for#;
$Lt=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Mt=bless({$q,$Lt,$s,$t},$u);
$Nt={$l4,$Jt,$Kt,$Mt};
$Ot=q#/lib/ni_resolver.b#;
$Pt=bless({$D2,$Ht,$v3,$w3,$x3,$w3,$y3,$Nt,$D,$Ot},$H3);
$Qt={};
$Rt=q#exists#;
$St=q#exists $_[0]->{named}{$_[1]}#;
$Tt=bless({$q,$St,$s,$t},$u);
$Ut=q#quoted#;
$Vt=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Wt=bless({$q,$Vt,$s,$t},$u);
$Xt={$Rt,$Tt,$Ut,$Wt};
$Yt=q#/lib/ni_image.b#;
$Zt=bless({$D2,$Qt,$v3,$w3,$x3,$w3,$y3,$Xt,$D,$Yt},$H3);
$cu=[$k5,$ot,$Gt,$Pt,$Zt];
$du=bless({$D2,$Ys,$D,$Zs,$o3,$cu},$c3);
$eu=q#lib/ni.c::ctors#;
$fu=q#ni:/lib/ni.c#;
$gu={$c3,1};
$hu=q#/lib/ni.c#;
$iu=[$V6];
$ju=bless({$D2,$gu,$D,$hu,$o3,$iu},$p3);
$ku=q#ni:/lib/ni_image.b#;
$lu=q#ni:/lib/ni_main.b#;
$mu=q#ni:/lib/ni_resolver.b#;
$nu=q#ni:/lib/ni_self.b#;
$ou=q#ni:/lib/ni_static_util.b#;
$pu={};
$qu=q#abbrev#;
$ru=[];
$su=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$tu=bless({$o,$ru,$q,$su,$s,$t},$u);
$uu=q#dor#;
$vu=[];
$wu=q#defined $_[0] ? $_[0] : $_[1]#;
$xu=bless({$o,$vu,$q,$wu,$s,$t},$u);
$yu=q#indent#;
$zu=[];
$Au=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Bu=bless({$o,$zu,$q,$Au,$s,$t},$u);
$Cu=q#max#;
$Du=[];
$Eu=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Fu=bless({$o,$Du,$q,$Eu,$s,$t},$u);
$Gu=q#maxstr#;
$Hu=[];
$Iu=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Ju=bless({$o,$Hu,$q,$Iu,$s,$t},$u);
$Ku=q#mean#;
$Lu=[];
$Mu=q#sum(@_) / (@_ || 1)#;
$Nu=bless({$o,$Lu,$q,$Mu,$s,$t},$u);
$Ou=q#min#;
$Pu=[];
$Qu=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Ru=bless({$o,$Pu,$q,$Qu,$s,$t},$u);
$Su=q#minstr#;
$Tu=[];
$Uu=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Vu=bless({$o,$Tu,$q,$Uu,$s,$t},$u);
$Wu=q#sgr#;
$Xu=[];
$Yu=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Zu=bless({$o,$Xu,$q,$Yu,$s,$t},$u);
$cv=q#sr#;
$dv=[];
$ev=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$fv=bless({$o,$dv,$q,$ev,$s,$t},$u);
$gv=q#sum#;
$hv=[];
$iv=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$jv=bless({$o,$hv,$q,$iv,$s,$t},$u);
$kv=q#swap#;
$lv=[];
$mv=q#@_[0, 1] = @_[1, 0]#;
$nv=bless({$o,$lv,$q,$mv,$s,$t},$u);
$ov={$qu,$tu,$uu,$xu,$yu,$Bu,$Cu,$Fu,$Gu,$Ju,$Ku,$Nu,$Ou,$Ru,$Su,$Vu,$Wu,$Zu,$cv,$fv,$gv,$jv,$kv,$nv};
$pv=q#/lib/ni_static_util.b#;
$qv=bless({$D2,$pu,$v3,$w3,$x3,$w3,$y3,$ov,$D,$pv},$H3);
$rv=q#ni:/lib/perlbranch.b#;
$sv=q#ni:/lib/quote_circular_addressed.b#;
$tv=q#ni:/lib/quote_code_fail.b#;
$uv=q#ni:/lib/quote_objects.b#;
$vv=q#ni:/lib/quote_simple#;
$wv={$V4,1};
$xv=q#/lib/quote_simple#;
$yv={};
$zv=[];
$Av=q#+{}#;
$Bv=bless({$o,$zv,$q,$Av,$s,$t},$u);
$Cv={$x4,$Bv};
$Dv=q#/lib/quote_simple_init.b#;
$Ev=bless({$D2,$yv,$v3,$w3,$x3,$w3,$y3,$Cv,$D,$Dv},$H3);
$Fv={};
$Gv=[];
$Hv=bless({$o,$Gv,$q,0,$s,$t},$u);
$Iv=[];
$Jv=q#shift->quote_value(shift)#;
$Kv=bless({$o,$Iv,$q,$Jv,$s,$t},$u);
$Lv={$Yr,$Hv,$zq,$Kv};
$Mv=q#/lib/quote_simple_quote.b#;
$Nv=bless({$D2,$Fv,$v3,$w3,$x3,$w3,$y3,$Lv,$D,$Mv},$H3);
$Ov=[$k5,$Ev,$Nv,$Yq,$yr,$Or];
$Pv=bless({$D2,$wv,$D,$xv,$o3,$Ov},$d3);
$Qv=q#lib/quote_simple.c::ctors#;
$Rv=q#ni:/lib/quote_simple.c#;
$Sv={$d3,1};
$Tv=q#/lib/quote_simple.c#;
$Uv=[$V6];
$Vv=bless({$D2,$Sv,$D,$Tv,$o3,$Uv},$p3);
$Wv=q#ni:/lib/quote_simple_init.b#;
$Xv=q#ni:/lib/quote_simple_quote.b#;
$Yv=q#ni:/lib/quote_values.b#;
$Zv=q#ni:/lib/ref_eq.b#;
$cw=q#ni:/lib/resolver.b#;
$dw=q#ni:/lib/slice#;
$ew={$H3,1};
$fw=q#/lib/slice#;
$gw=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$hw=bless({$q,$gw,$s,$t},$u);
$iw=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$jw=bless({$q,$iw,$s,$t},$u);
$kw=q#lib/slice::apply#;
$lw=q#lib/slice::apply_unsafe#;
$mw={};
$nw=q#apply_unsafe#;
$ow={$C3,$hw,$nw,$jw};
$pw=q#/lib/slice.b#;
$qw=bless({$D2,$mw,$y3,$ow,$D,$pw},$H3);
$rw={};
$sw=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$tw=bless({$q,$sw,$s,$t},$u);
$uw={$x4,$tw};
$vw=q#/lib/slice_init.b#;
$ww=bless({$D2,$rw,$y3,$uw,$D,$vw},$H3);
$xw={};
$yw=[];
$zw=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Aw=bless({$o,$yw,$q,$zw,$s,$t},$u);
$Bw={$gp,$Aw};
$Cw=q#/lib/slice_serialize.b#;
$Dw=bless({$D2,$xw,$v3,$w3,$x3,$w3,$y3,$Bw,$D,$Cw},$H3);
$Ew=[$v5,$S3,$qw,$ww,$Dw];
$Fw=bless({$D2,$ew,$D,$fw,$o3,$Ew},$e3);
$Gw=q#lib/slice.c::ctors#;
$Hw=q#ni:/lib/slice.b#;
$Iw=q#ni:/lib/slice.c#;
$Jw={$e3,1};
$Kw=q#/lib/slice.c#;
$Lw=[$c7];
$Mw=bless({$D2,$Jw,$D,$Kw,$o3,$Lw},$p3);
$Nw=q#ni:/lib/slice_init.b#;
$Ow=q#ni:/lib/slice_serialize.b#;
$Pw=q#ni:/lib/static_fn.b#;
$Qw={};
$Rw=[];
$Sw=q#ni('ni:/lib/fn')->new(@_)#;
$Tw=bless({$o,$Rw,$q,$Sw,$s,$Np},$u);
$Uw=q#fp#;
$Vw=[];
$Ww=q#($$)#;
$Xw=bless({$o,$Vw,$q,$Sw,$s,$Ww},$u);
$Yw={$Mo,$Tw,$Uw,$Xw};
$Zw=q#/lib/static_fn.b#;
$cx=bless({$D2,$Qw,$v3,$w3,$x3,$w3,$y3,$Yw,$D,$Zw},$H3);
$dx=q#ni:/lib/subclass.b#;
$ex=q#ni:/lib/tag#;
$fx={$T3,1};
$gx=q#/lib/tag#;
$hx={};
$ix=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$jx=bless({$q,$ix,$s,$t},$u);
$kx={$C3,$jx};
$lx=q#/lib/tag.b#;
$mx=bless({$D2,$hx,$v3,$w3,$x3,$w3,$y3,$kx,$D,$lx},$H3);
$nx={};
$ox=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$px=bless({$q,$ox,$s,$t},$u);
$qx={$x4,$px};
$rx=q#/lib/tag_init.b#;
$sx=bless({$D2,$nx,$v3,$w3,$x3,$w3,$y3,$qx,$D,$rx},$H3);
$tx=[$v5,$S3,$mx,$sx];
$ux=bless({$D2,$fx,$D,$gx,$o3,$tx},$f3);
$vx=q#lib/tag.c::ctors#;
$wx=q#ni:/lib/tag.b#;
$xx=q#ni:/lib/tag.c#;
$yx={$f3,1};
$zx=q#/lib/tag.c#;
$Ax=[$c7];
$Bx=bless({$D2,$yx,$D,$zx,$o3,$Ax},$p3);
$Cx=q#ni:/lib/tag_init.b#;
$Dx=q#ni:/lib/test_value#;
$Ex={$W4,1};
$Fx=q#/lib/test_value#;
$Gx={};
$Hx=[];
$Ix=q#\\$_[1]#;
$Jx=bless({$o,$Hx,$q,$Ix,$s,$t},$u);
$Kx={$x4,$Jx};
$Lx=q#/lib/test_value_init.b#;
$Mx=bless({$D2,$Gx,$v3,$w3,$x3,$w3,$y3,$Kx,$D,$Lx},$H3);
$Nx={};
$Ox=q#(==#;
$Px=[];
$Qx=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Rx=bless({$o,$Px,$q,$Qx,$s,$t},$u);
$Sx=q#diff#;
$Tx=[];
$Ux=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Vx=bless({$o,$Tx,$q,$Ux,$s,$t},$u);
$Wx={$Ox,$Rx,$Sx,$Vx};
$Xx=q#/lib/test_value_eq.b#;
$Yx=bless({$D2,$Nx,$v3,$w3,$x3,$w3,$y3,$Wx,$D,$Xx},$H3);
$Zx={};
$cy=[];
$dy=q#ni::json_encode ${$_[0]}#;
$ey=bless({$o,$cy,$q,$dy,$s,$t},$u);
$fy={$R5,$ey};
$gy=q#/lib/test_value_str.b#;
$hy=bless({$D2,$Zx,$v3,$w3,$x3,$w3,$y3,$fy,$D,$gy},$H3);
$iy=[$k5,$Mx,$Yx,$hy];
$jy=bless({$D2,$Ex,$D,$Fx,$o3,$iy},$g3);
$ky=q#lib/test_value.c::ctors#;
$ly=q#ni:/lib/test_value.c#;
$my={$g3,1};
$ny=q#/lib/test_value.c#;
$oy=[$V6];
$py=bless({$D2,$my,$D,$ny,$o3,$oy},$p3);
$qy=q#ni:/lib/test_value_eq.b#;
$ry=q#ni:/lib/test_value_init.b#;
$sy=q#ni:/lib/test_value_str.b#;
$ty=q#ni:/metaclass#;
$uy={$p3,1};
$vy=q#/metaclass#;
$wy=[$s4,$C6,$C4,$r6];
$xy=bless({$D2,$uy,$D,$vy,$o3,$wy},$h3);
$yy=q#metaclass.c::ctors#;
$zy=q#ni:/metaclass.c#;
$Ay={$h3,1};
$By=q#/metaclass.c#;
$Cy=[$L6];
$Dy=bless({$D2,$Ay,$D,$By,$o3,$Cy},$p3);
$Ey=q#ni:/module#;
$Fy=q#ni:/module.c#;
$Gy=q#ni:/object#;
$Hy=q#ni:/object.c#;
$Iy=q#ni:/semantic/dimension#;
$Jy={$k3,1};
$Ky=q#/semantic/dimension#;
$Ly=[$L6];
$My=bless({$D2,$Jy,$D,$Ky,$o3,$Ly},$l3);
$Ny=q#semantic/dimension.c::ctors#;
$Oy=q#ni:/semantic/dimension.c#;
$Py={$l3,1};
$Qy=q#/semantic/dimension.c#;
$Ry=[$g7];
$Sy=bless({$D2,$Py,$D,$Qy,$o3,$Ry},$p3);
$Ty=q#ni:/semantic/task#;
$Uy=q#ni:/semantic/task.c#;
$Vy=q#ni:/semantic/task_outcome.b#;
$Wy=q#ni:/semantic/task_ro.b#;
$Xy=q#ni:main#;
$Yy={$cg,1};
$Zy=[$cx,$Rp,$Zf];
$cz=bless({$D2,$Yy,$D,$cg,$o3,$Zy},$q3);
$dz=q#module::ctors#;
$ez=q#ni:ni#;
$fz={$Ss,1};
$gz={$Ss,1};
$hz=q#json_escapes#;
$iz=q##;
$jz=q#b#;
$kz=q#	#;
$lz=q#t#;
$mz=q#
#;
$nz=q#n#;
$oz=q##;
$pz=q#"#;
$qz=q#/#;
$rz=q#\\#;
$sz={$iz,$jz,$kz,$lz,$mz,$nz,$oz,$df,$pz,$pz,$qz,$qz,$rz,$rz};
$tz=q#json_unescapes#;
$uz={$pz,$pz,$qz,$qz,$rz,$rz,$jz,$iz,$nz,$mz,$df,$oz,$lz,$kz};
$vz={$hz,$sz,$tz,$uz};
$wz=q#/lib/json_data.b#;
$xz=bless({$D2,$gz,$xi,$vz,$D,$wz},$S4);
$yz=q#lib/dataslice::ctors#;
$zz=[$xz,$Rs,$qv];
$Az=bless({$D2,$fz,$D,$Ss,$o3,$zz},$q3);
$Bz={$d,$G,$I,$N,$O,$V,$W,$d1,$e1,$j1,$k1,$v1,$w1,$H1,$I1,$X1,$Y1,$f2,$g2,$v2,$w2,$B2,$C2,$L6,$N6,$g7,$h7,$n9,$p9,$x9,$y9,$l9,$z9,$P8,$A9,$d9,$B9,$I8,$C9,$N9,$P9,$T9,$U9,$L9,$V9,$ra,$ta,$xa,$ya,$fa,$za,$pa,$Aa,$Ra,$Ta,$Xa,$Ya,$Ia,$Za,$Pa,$cb,$Mc,$Oc,$Sc,$Tc,$uc,$Uc,$Kc,$Vc,$sb,$Wc,$mc,$Xc,$Mb,$Yc,$lb,$Zc,$oe,$qe,$ue,$ve,$Pd,$we,$ce,$xe,$rd,$ye,$me,$ze,$kd,$Ae,$zd,$Be,$vf,$xf,$Bf,$Cf,$Se,$Df,$Ze,$Ef,$tf,$Ff,$Ke,$Gf,$Zf,$dg,$Bg,$Dg,$Hg,$Ig,$mg,$Jg,$zg,$Kg,$v8,$Lg,$v9,$Mg,$L7,$Ng,$T7,$Og,$d8,$Pg,$r7,$Qg,$t8,$Rg,$l8,$Sg,$hi,$ji,$ni,$oi,$fi,$pi,$rh,$qi,$Nh,$ri,$hh,$si,$Dh,$ti,$kj,$mj,$qj,$rj,$Si,$sj,$ij,$tj,$Li,$uj,$Gk,$Ik,$Xk,$Yk,$Vk,$Zk,$Il,$Kl,$Ol,$Pl,$kl,$Ql,$ul,$Rl,$Gl,$Sl,$kk,$Tl,$Ek,$Ul,$om,$qm,$um,$vm,$fm,$wm,$mm,$xm,$P5,$ym,$v5,$zm,$c7,$Am,$Km,$Mm,$I3,$Nm,$Rm,$Sm,$Im,$Tm,$C4,$Um,$mn,$on,$sn,$tn,$kn,$un,$en,$vn,$o6,$wn,$F5,$xn,$m6,$yn,$fo,$ho,$lo,$mo,$Sn,$no,$Fn,$oo,$Ln,$po,$do,$qo,$t5,$ro,$op,$qp,$up,$vp,$Eo,$wp,$ep,$xp,$So,$yp,$mp,$zp,$Hp,$Ip,$Rp,$Sp,$is,$ks,$os,$ps,$dq,$qs,$Qq,$rs,$i5,$ss,$C6,$ts,$Rs,$Ts,$W5,$Us,$S3,$Vs,$c4,$Ws,$j4,$Xs,$du,$fu,$ju,$ku,$Zt,$lu,$Gt,$mu,$Pt,$nu,$ot,$ou,$qv,$rv,$s4,$sv,$gs,$tv,$Yq,$uv,$Or,$vv,$Pv,$Rv,$Vv,$Wv,$Ev,$Xv,$Nv,$Yv,$yr,$Zv,$f6,$cw,$q4,$dw,$Fw,$Hw,$qw,$Iw,$Mw,$Nw,$ww,$Ow,$Dw,$Pw,$cx,$dx,$J6,$ex,$ux,$wx,$mx,$xx,$Bx,$Cx,$sx,$Dx,$jy,$ly,$py,$qy,$Yx,$ry,$Mx,$sy,$hy,$ty,$xy,$zy,$Dy,$Ey,$r6,$Fy,$e7,$Gy,$k5,$Hy,$V6,$Iy,$My,$Oy,$Sy,$Ty,$Uj,$Uy,$Ok,$Vy,$Sj,$Wy,$Gj,$Xy,$cz,$ez,$Az};
$Cz=q#resolvers#;
$Dz=[];
$Ez=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Fz=bless({$o,$Dz,$q,$Ez,$s,$t},$u);
$Gz=q#file#;
$Hz=[];
$Iz=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Jz=bless({$o,$Hz,$q,$Iz,$s,$t},$u);
$Kz=q#null#;
$Lz=[];
$Mz=q#ni('ni:/io/null')->new#;
$Nz=bless({$o,$Lz,$q,$Mz,$s,$t},$u);
$Oz=q#sh#;
$Pz=[];
$Qz=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Rz=bless({$o,$Pz,$q,$Qz,$s,$t},$u);
$Sz=q#str#;
$Tz=[];
$Uz=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Vz=bless({$o,$Tz,$q,$Uz,$s,$t},$u);
$Wz={$Sb,$Fz,$Gz,$Jz,$Kz,$Nz,$Oz,$Rz,$Sz,$Vz};
$Xz=bless({$c,$Bz,$Cz,$Wz},$U4);
$Yz=q#lib/ni::ctors#;
*$lw=\&$jw;
*$kw=\&$hw;
$I3->apply_unsafe($E2);
$I3->apply_unsafe($F2);
$I3->apply_unsafe($G2);
$I3->apply_unsafe($H2);
$I3->apply_unsafe($I2);
$I3->apply_unsafe($J2);
$I3->apply_unsafe($K2);
$I3->apply_unsafe($L2);
$I3->apply_unsafe($M2);
$I3->apply_unsafe($N2);
$I3->apply_unsafe($O2);
$I3->apply_unsafe($P2);
$I3->apply_unsafe($Q2);
$I3->apply_unsafe($R2);
$I3->apply_unsafe($S2);
$I3->apply_unsafe($T2);
$I3->apply_unsafe($U2);
$I3->apply_unsafe($J3);
$I3->apply_unsafe($V2);
$I3->apply_unsafe($W2);
$I3->apply_unsafe($X2);
$I3->apply_unsafe($Y2);
$I3->apply_unsafe($Z2);
$I3->apply_unsafe($c3);
$I3->apply_unsafe($d3);
$I3->apply_unsafe($e3);
$I3->apply_unsafe($f3);
$I3->apply_unsafe($g3);
$I3->apply_unsafe($p3);
$I3->apply_unsafe($h3);
$I3->apply_unsafe($q3);
$I3->apply_unsafe($i3);
$I3->apply_unsafe($j3);
$I3->apply_unsafe($k3);
$I3->apply_unsafe($l3);
$I3->apply_unsafe($m3);
$S3->apply_unsafe($E2);
$S3->apply_unsafe($F2);
$S3->apply_unsafe($G2);
$S3->apply_unsafe($H2);
$S3->apply_unsafe($I2);
$S3->apply_unsafe($J2);
$S3->apply_unsafe($K2);
$S3->apply_unsafe($L2);
$S3->apply_unsafe($M2);
$S3->apply_unsafe($N2);
$S3->apply_unsafe($O2);
$S3->apply_unsafe($P2);
$S3->apply_unsafe($Q2);
$S3->apply_unsafe($R2);
$S3->apply_unsafe($S2);
$S3->apply_unsafe($T2);
$S3->apply_unsafe($U2);
$S3->apply_unsafe($J3);
$S3->apply_unsafe($V2);
$S3->apply_unsafe($W2);
$S3->apply_unsafe($F);
$S3->apply_unsafe($X2);
$S3->apply_unsafe($Y2);
$S3->apply_unsafe($Z2);
$S3->apply_unsafe($c3);
$S3->apply_unsafe($d3);
$S3->apply_unsafe($H3);
$S3->apply_unsafe($e3);
$S3->apply_unsafe($T3);
$S3->apply_unsafe($f3);
$S3->apply_unsafe($g3);
$S3->apply_unsafe($p3);
$S3->apply_unsafe($h3);
$S3->apply_unsafe($q3);
$S3->apply_unsafe($i3);
$S3->apply_unsafe($j3);
$S3->apply_unsafe($k3);
$S3->apply_unsafe($l3);
$S3->apply_unsafe($m3);
$c4->apply_unsafe($E2);
$c4->apply_unsafe($F2);
$c4->apply_unsafe($G2);
$c4->apply_unsafe($H2);
$c4->apply_unsafe($I2);
$c4->apply_unsafe($J2);
$c4->apply_unsafe($K2);
$c4->apply_unsafe($L2);
$c4->apply_unsafe($M2);
$c4->apply_unsafe($N2);
$c4->apply_unsafe($O2);
$c4->apply_unsafe($P2);
$c4->apply_unsafe($Q2);
$c4->apply_unsafe($R2);
$c4->apply_unsafe($S2);
$c4->apply_unsafe($T2);
$c4->apply_unsafe($U2);
$c4->apply_unsafe($J3);
$c4->apply_unsafe($V2);
$c4->apply_unsafe($W2);
$c4->apply_unsafe($X2);
$c4->apply_unsafe($Y2);
$c4->apply_unsafe($Z2);
$c4->apply_unsafe($c3);
$c4->apply_unsafe($d3);
$c4->apply_unsafe($H3);
$c4->apply_unsafe($e3);
$c4->apply_unsafe($T3);
$c4->apply_unsafe($f3);
$c4->apply_unsafe($g3);
$c4->apply_unsafe($p3);
$c4->apply_unsafe($h3);
$c4->apply_unsafe($q3);
$c4->apply_unsafe($i3);
$c4->apply_unsafe($j3);
$c4->apply_unsafe($k3);
$c4->apply_unsafe($l3);
$c4->apply_unsafe($m3);
$j4->apply_unsafe($E2);
$j4->apply_unsafe($F2);
$j4->apply_unsafe($G2);
$j4->apply_unsafe($H2);
$j4->apply_unsafe($I2);
$j4->apply_unsafe($J2);
$j4->apply_unsafe($K2);
$j4->apply_unsafe($L2);
$j4->apply_unsafe($M2);
$j4->apply_unsafe($N2);
$j4->apply_unsafe($O2);
$j4->apply_unsafe($P2);
$j4->apply_unsafe($Q2);
$j4->apply_unsafe($R2);
$j4->apply_unsafe($S2);
$j4->apply_unsafe($T2);
$j4->apply_unsafe($U2);
$j4->apply_unsafe($J3);
$j4->apply_unsafe($V2);
$j4->apply_unsafe($W2);
$j4->apply_unsafe($X2);
$j4->apply_unsafe($Y2);
$j4->apply_unsafe($Z2);
$j4->apply_unsafe($c3);
$j4->apply_unsafe($d3);
$j4->apply_unsafe($H3);
$j4->apply_unsafe($e3);
$j4->apply_unsafe($T3);
$j4->apply_unsafe($f3);
$j4->apply_unsafe($g3);
$j4->apply_unsafe($p3);
$j4->apply_unsafe($h3);
$j4->apply_unsafe($q3);
$j4->apply_unsafe($i3);
$j4->apply_unsafe($j3);
$j4->apply_unsafe($k3);
$j4->apply_unsafe($l3);
$j4->apply_unsafe($m3);
$q4->apply_unsafe($E2);
$q4->apply_unsafe($F2);
$q4->apply_unsafe($G2);
$q4->apply_unsafe($H2);
$q4->apply_unsafe($I2);
$q4->apply_unsafe($J2);
$q4->apply_unsafe($K2);
$q4->apply_unsafe($L2);
$q4->apply_unsafe($M2);
$q4->apply_unsafe($N2);
$q4->apply_unsafe($O2);
$q4->apply_unsafe($P2);
$q4->apply_unsafe($Q2);
$q4->apply_unsafe($R2);
$q4->apply_unsafe($S2);
$q4->apply_unsafe($T2);
$q4->apply_unsafe($U2);
$q4->apply_unsafe($J3);
$q4->apply_unsafe($V2);
$q4->apply_unsafe($W2);
$q4->apply_unsafe($X2);
$q4->apply_unsafe($Y2);
$q4->apply_unsafe($Z2);
$q4->apply_unsafe($c3);
$q4->apply_unsafe($d3);
$q4->apply_unsafe($e3);
$q4->apply_unsafe($T3);
$q4->apply_unsafe($f3);
$q4->apply_unsafe($g3);
$q4->apply_unsafe($p3);
$q4->apply_unsafe($h3);
$q4->apply_unsafe($q3);
$q4->apply_unsafe($i3);
$q4->apply_unsafe($j3);
$q4->apply_unsafe($k3);
$q4->apply_unsafe($l3);
$q4->apply_unsafe($m3);
$C4->apply_unsafe($E2);
$C4->apply_unsafe($F2);
$C4->apply_unsafe($G2);
$C4->apply_unsafe($H2);
$C4->apply_unsafe($I2);
$C4->apply_unsafe($J2);
$C4->apply_unsafe($K2);
$C4->apply_unsafe($L2);
$C4->apply_unsafe($M2);
$C4->apply_unsafe($N2);
$C4->apply_unsafe($O2);
$C4->apply_unsafe($P2);
$C4->apply_unsafe($Q2);
$C4->apply_unsafe($R2);
$C4->apply_unsafe($S2);
$C4->apply_unsafe($T2);
$C4->apply_unsafe($U2);
$C4->apply_unsafe($V2);
$C4->apply_unsafe($W2);
$C4->apply_unsafe($X2);
$C4->apply_unsafe($Y2);
$C4->apply_unsafe($Z2);
$C4->apply_unsafe($c3);
$C4->apply_unsafe($d3);
$C4->apply_unsafe($e3);
$C4->apply_unsafe($f3);
$C4->apply_unsafe($g3);
$C4->apply_unsafe($p3);
$C4->apply_unsafe($h3);
$C4->apply_unsafe($q3);
$C4->apply_unsafe($i3);
$C4->apply_unsafe($j3);
$C4->apply_unsafe($k3);
$C4->apply_unsafe($l3);
$C4->apply_unsafe($m3);
$i5->apply_unsafe($E2);
$i5->apply_unsafe($F2);
$i5->apply_unsafe($D4);
$i5->apply_unsafe($G2);
$i5->apply_unsafe($E4);
$i5->apply_unsafe($H2);
$i5->apply_unsafe($F4);
$i5->apply_unsafe($I2);
$i5->apply_unsafe($G4);
$i5->apply_unsafe($J2);
$i5->apply_unsafe($H4);
$i5->apply_unsafe($K2);
$i5->apply_unsafe($I4);
$i5->apply_unsafe($L2);
$i5->apply_unsafe($J4);
$i5->apply_unsafe($M2);
$i5->apply_unsafe($K4);
$i5->apply_unsafe($N2);
$i5->apply_unsafe($L4);
$i5->apply_unsafe($O2);
$i5->apply_unsafe($M4);
$i5->apply_unsafe($P2);
$i5->apply_unsafe($N4);
$i5->apply_unsafe($Q2);
$i5->apply_unsafe($O4);
$i5->apply_unsafe($R2);
$i5->apply_unsafe($P4);
$i5->apply_unsafe($S2);
$i5->apply_unsafe($Q4);
$i5->apply_unsafe($T2);
$i5->apply_unsafe($R4);
$i5->apply_unsafe($U2);
$i5->apply_unsafe($J3);
$i5->apply_unsafe($V2);
$i5->apply_unsafe($S4);
$i5->apply_unsafe($W2);
$i5->apply_unsafe($F);
$i5->apply_unsafe($X2);
$i5->apply_unsafe($u);
$i5->apply_unsafe($Y2);
$i5->apply_unsafe($T4);
$i5->apply_unsafe($Z2);
$i5->apply_unsafe($U4);
$i5->apply_unsafe($c3);
$i5->apply_unsafe($V4);
$i5->apply_unsafe($d3);
$i5->apply_unsafe($H3);
$i5->apply_unsafe($e3);
$i5->apply_unsafe($T3);
$i5->apply_unsafe($f3);
$i5->apply_unsafe($W4);
$i5->apply_unsafe($g3);
$i5->apply_unsafe($p3);
$i5->apply_unsafe($h3);
$i5->apply_unsafe($q3);
$i5->apply_unsafe($i3);
$i5->apply_unsafe($X4);
$i5->apply_unsafe($j3);
$i5->apply_unsafe($k3);
$i5->apply_unsafe($l3);
$i5->apply_unsafe($Y4);
$i5->apply_unsafe($m3);
$t5->apply_unsafe($E2);
$t5->apply_unsafe($F2);
$t5->apply_unsafe($G2);
$t5->apply_unsafe($H2);
$t5->apply_unsafe($I2);
$t5->apply_unsafe($J2);
$t5->apply_unsafe($K2);
$t5->apply_unsafe($L2);
$t5->apply_unsafe($M2);
$t5->apply_unsafe($N2);
$t5->apply_unsafe($O2);
$t5->apply_unsafe($P2);
$t5->apply_unsafe($Q2);
$t5->apply_unsafe($R2);
$t5->apply_unsafe($S2);
$t5->apply_unsafe($T2);
$t5->apply_unsafe($R4);
$t5->apply_unsafe($U2);
$t5->apply_unsafe($J3);
$t5->apply_unsafe($V2);
$t5->apply_unsafe($S4);
$t5->apply_unsafe($W2);
$t5->apply_unsafe($X2);
$t5->apply_unsafe($Y2);
$t5->apply_unsafe($Z2);
$t5->apply_unsafe($c3);
$t5->apply_unsafe($d3);
$t5->apply_unsafe($H3);
$t5->apply_unsafe($e3);
$t5->apply_unsafe($T3);
$t5->apply_unsafe($f3);
$t5->apply_unsafe($g3);
$t5->apply_unsafe($p3);
$t5->apply_unsafe($h3);
$t5->apply_unsafe($q3);
$t5->apply_unsafe($i3);
$t5->apply_unsafe($j3);
$t5->apply_unsafe($k3);
$t5->apply_unsafe($l3);
$t5->apply_unsafe($m3);
$F5->apply_unsafe($E2);
$F5->apply_unsafe($F2);
$F5->apply_unsafe($G2);
$F5->apply_unsafe($H2);
$F5->apply_unsafe($I2);
$F5->apply_unsafe($J2);
$F5->apply_unsafe($K2);
$F5->apply_unsafe($L2);
$F5->apply_unsafe($M2);
$F5->apply_unsafe($N2);
$F5->apply_unsafe($O2);
$F5->apply_unsafe($P2);
$F5->apply_unsafe($Q2);
$F5->apply_unsafe($R2);
$F5->apply_unsafe($S2);
$F5->apply_unsafe($T2);
$F5->apply_unsafe($U2);
$F5->apply_unsafe($J3);
$F5->apply_unsafe($V2);
$F5->apply_unsafe($W2);
$F5->apply_unsafe($X2);
$F5->apply_unsafe($Y2);
$F5->apply_unsafe($Z2);
$F5->apply_unsafe($c3);
$F5->apply_unsafe($d3);
$F5->apply_unsafe($e3);
$F5->apply_unsafe($f3);
$F5->apply_unsafe($g3);
$F5->apply_unsafe($p3);
$F5->apply_unsafe($h3);
$F5->apply_unsafe($q3);
$F5->apply_unsafe($i3);
$F5->apply_unsafe($j3);
$F5->apply_unsafe($k3);
$F5->apply_unsafe($l3);
$F5->apply_unsafe($m3);
$P5->apply_unsafe($E2);
$P5->apply_unsafe($F2);
$P5->apply_unsafe($G2);
$P5->apply_unsafe($H2);
$P5->apply_unsafe($I2);
$P5->apply_unsafe($J2);
$P5->apply_unsafe($K2);
$P5->apply_unsafe($L2);
$P5->apply_unsafe($M2);
$P5->apply_unsafe($N2);
$P5->apply_unsafe($O2);
$P5->apply_unsafe($P2);
$P5->apply_unsafe($Q2);
$P5->apply_unsafe($R2);
$P5->apply_unsafe($S2);
$P5->apply_unsafe($T2);
$P5->apply_unsafe($U2);
$P5->apply_unsafe($J3);
$P5->apply_unsafe($V2);
$P5->apply_unsafe($W2);
$P5->apply_unsafe($X2);
$P5->apply_unsafe($Y2);
$P5->apply_unsafe($Z2);
$P5->apply_unsafe($c3);
$P5->apply_unsafe($d3);
$P5->apply_unsafe($e3);
$P5->apply_unsafe($f3);
$P5->apply_unsafe($g3);
$P5->apply_unsafe($p3);
$P5->apply_unsafe($h3);
$P5->apply_unsafe($q3);
$P5->apply_unsafe($i3);
$P5->apply_unsafe($j3);
$P5->apply_unsafe($k3);
$P5->apply_unsafe($l3);
$P5->apply_unsafe($m3);
$W5->apply_unsafe($E2);
$W5->apply_unsafe($F2);
$W5->apply_unsafe($G2);
$W5->apply_unsafe($H2);
$W5->apply_unsafe($I2);
$W5->apply_unsafe($J2);
$W5->apply_unsafe($K2);
$W5->apply_unsafe($L2);
$W5->apply_unsafe($M2);
$W5->apply_unsafe($N2);
$W5->apply_unsafe($O2);
$W5->apply_unsafe($P2);
$W5->apply_unsafe($Q2);
$W5->apply_unsafe($R2);
$W5->apply_unsafe($S2);
$W5->apply_unsafe($T2);
$W5->apply_unsafe($U2);
$W5->apply_unsafe($J3);
$W5->apply_unsafe($V2);
$W5->apply_unsafe($W2);
$W5->apply_unsafe($X2);
$W5->apply_unsafe($Y2);
$W5->apply_unsafe($Z2);
$W5->apply_unsafe($c3);
$W5->apply_unsafe($d3);
$W5->apply_unsafe($e3);
$W5->apply_unsafe($f3);
$W5->apply_unsafe($g3);
$W5->apply_unsafe($p3);
$W5->apply_unsafe($h3);
$W5->apply_unsafe($q3);
$W5->apply_unsafe($i3);
$W5->apply_unsafe($j3);
$W5->apply_unsafe($k3);
$W5->apply_unsafe($l3);
$W5->apply_unsafe($m3);
$f6->apply_unsafe($E2);
$f6->apply_unsafe($F2);
$f6->apply_unsafe($G2);
$f6->apply_unsafe($H2);
$f6->apply_unsafe($I2);
$f6->apply_unsafe($J2);
$f6->apply_unsafe($K2);
$f6->apply_unsafe($L2);
$f6->apply_unsafe($M2);
$f6->apply_unsafe($N2);
$f6->apply_unsafe($O2);
$f6->apply_unsafe($P2);
$f6->apply_unsafe($Q2);
$f6->apply_unsafe($R2);
$f6->apply_unsafe($S2);
$f6->apply_unsafe($T2);
$f6->apply_unsafe($U2);
$f6->apply_unsafe($J3);
$f6->apply_unsafe($V2);
$f6->apply_unsafe($W2);
$f6->apply_unsafe($X2);
$f6->apply_unsafe($Y2);
$f6->apply_unsafe($Z2);
$f6->apply_unsafe($c3);
$f6->apply_unsafe($d3);
$f6->apply_unsafe($e3);
$f6->apply_unsafe($f3);
$f6->apply_unsafe($g3);
$f6->apply_unsafe($p3);
$f6->apply_unsafe($h3);
$f6->apply_unsafe($q3);
$f6->apply_unsafe($i3);
$f6->apply_unsafe($j3);
$f6->apply_unsafe($k3);
$f6->apply_unsafe($l3);
$f6->apply_unsafe($m3);
$m6->apply_unsafe($E2);
$m6->apply_unsafe($F2);
$m6->apply_unsafe($G2);
$m6->apply_unsafe($H2);
$m6->apply_unsafe($I2);
$m6->apply_unsafe($J2);
$m6->apply_unsafe($K2);
$m6->apply_unsafe($L2);
$m6->apply_unsafe($M2);
$m6->apply_unsafe($N2);
$m6->apply_unsafe($O2);
$m6->apply_unsafe($P2);
$m6->apply_unsafe($Q2);
$m6->apply_unsafe($R2);
$m6->apply_unsafe($S2);
$m6->apply_unsafe($T2);
$m6->apply_unsafe($U2);
$m6->apply_unsafe($J3);
$m6->apply_unsafe($V2);
$m6->apply_unsafe($W2);
$m6->apply_unsafe($X2);
$m6->apply_unsafe($Y2);
$m6->apply_unsafe($Z2);
$m6->apply_unsafe($c3);
$m6->apply_unsafe($d3);
$m6->apply_unsafe($e3);
$m6->apply_unsafe($f3);
$m6->apply_unsafe($g3);
$m6->apply_unsafe($p3);
$m6->apply_unsafe($h3);
$m6->apply_unsafe($q3);
$m6->apply_unsafe($i3);
$m6->apply_unsafe($j3);
$m6->apply_unsafe($k3);
$m6->apply_unsafe($l3);
$m6->apply_unsafe($m3);
$C6->apply_unsafe($E2);
$C6->apply_unsafe($F2);
$C6->apply_unsafe($G2);
$C6->apply_unsafe($H2);
$C6->apply_unsafe($I2);
$C6->apply_unsafe($J2);
$C6->apply_unsafe($K2);
$C6->apply_unsafe($L2);
$C6->apply_unsafe($M2);
$C6->apply_unsafe($N2);
$C6->apply_unsafe($O2);
$C6->apply_unsafe($P2);
$C6->apply_unsafe($Q2);
$C6->apply_unsafe($R2);
$C6->apply_unsafe($S2);
$C6->apply_unsafe($T2);
$C6->apply_unsafe($U2);
$C6->apply_unsafe($V2);
$C6->apply_unsafe($W2);
$C6->apply_unsafe($X2);
$C6->apply_unsafe($u);
$C6->apply_unsafe($Y2);
$C6->apply_unsafe($Z2);
$C6->apply_unsafe($c3);
$C6->apply_unsafe($d3);
$C6->apply_unsafe($H3);
$C6->apply_unsafe($e3);
$C6->apply_unsafe($T3);
$C6->apply_unsafe($f3);
$C6->apply_unsafe($g3);
$C6->apply_unsafe($p3);
$C6->apply_unsafe($h3);
$C6->apply_unsafe($i3);
$C6->apply_unsafe($j3);
$C6->apply_unsafe($k3);
$C6->apply_unsafe($l3);
$C6->apply_unsafe($m3);
$J6->apply_unsafe($E2);
$J6->apply_unsafe($F2);
$J6->apply_unsafe($G2);
$J6->apply_unsafe($H2);
$J6->apply_unsafe($I2);
$J6->apply_unsafe($J2);
$J6->apply_unsafe($K2);
$J6->apply_unsafe($L2);
$J6->apply_unsafe($M2);
$J6->apply_unsafe($N2);
$J6->apply_unsafe($O2);
$J6->apply_unsafe($P2);
$J6->apply_unsafe($Q2);
$J6->apply_unsafe($R2);
$J6->apply_unsafe($S2);
$J6->apply_unsafe($T2);
$J6->apply_unsafe($U2);
$J6->apply_unsafe($V2);
$J6->apply_unsafe($W2);
$J6->apply_unsafe($X2);
$J6->apply_unsafe($Y2);
$J6->apply_unsafe($Z2);
$J6->apply_unsafe($c3);
$J6->apply_unsafe($d3);
$J6->apply_unsafe($e3);
$J6->apply_unsafe($f3);
$J6->apply_unsafe($g3);
$J6->apply_unsafe($h3);
$J6->apply_unsafe($i3);
$J6->apply_unsafe($j3);
$J6->apply_unsafe($k3);
$J6->apply_unsafe($l3);
$J6->apply_unsafe($m3);
$r7->apply_unsafe($D4);
$r7->apply_unsafe($F4);
$r7->apply_unsafe($G4);
$r7->apply_unsafe($H4);
$r7->apply_unsafe($I4);
$r7->apply_unsafe($J4);
$r7->apply_unsafe($K4);
$r7->apply_unsafe($L4);
$r7->apply_unsafe($M4);
$r7->apply_unsafe($N4);
$L7->apply_unsafe($D4);
$L7->apply_unsafe($F4);
$L7->apply_unsafe($G4);
$L7->apply_unsafe($H4);
$L7->apply_unsafe($I4);
$L7->apply_unsafe($J4);
$L7->apply_unsafe($K4);
$L7->apply_unsafe($L4);
$L7->apply_unsafe($M4);
$L7->apply_unsafe($N4);
$T7->apply_unsafe($D4);
$T7->apply_unsafe($F4);
$T7->apply_unsafe($G4);
$T7->apply_unsafe($H4);
$T7->apply_unsafe($I4);
$T7->apply_unsafe($J4);
$T7->apply_unsafe($K4);
$T7->apply_unsafe($L4);
$T7->apply_unsafe($M4);
$T7->apply_unsafe($N4);
$d8->apply_unsafe($D4);
$d8->apply_unsafe($F4);
$d8->apply_unsafe($G4);
$d8->apply_unsafe($H4);
$d8->apply_unsafe($I4);
$d8->apply_unsafe($J4);
$d8->apply_unsafe($K4);
$d8->apply_unsafe($L4);
$d8->apply_unsafe($M4);
$d8->apply_unsafe($N4);
$l8->apply_unsafe($D4);
$l8->apply_unsafe($F4);
$l8->apply_unsafe($G4);
$l8->apply_unsafe($H4);
$l8->apply_unsafe($I4);
$l8->apply_unsafe($J4);
$l8->apply_unsafe($K4);
$l8->apply_unsafe($L4);
$l8->apply_unsafe($M4);
$l8->apply_unsafe($N4);
$t8->apply_unsafe($D4);
$t8->apply_unsafe($F4);
$t8->apply_unsafe($G4);
$t8->apply_unsafe($H4);
$t8->apply_unsafe($I4);
$t8->apply_unsafe($J4);
$t8->apply_unsafe($K4);
$t8->apply_unsafe($L4);
$t8->apply_unsafe($M4);
$t8->apply_unsafe($N4);
$I8->apply_unsafe($D4);
$P8->apply_unsafe($D4);
$d9->apply_unsafe($D4);
$l9->apply_unsafe($D4);
$L9->apply_unsafe($E4);
$fa->apply_unsafe($F4);
$pa->apply_unsafe($F4);
$Ia->apply_unsafe($G4);
$Pa->apply_unsafe($G4);
$lb->apply_unsafe($H4);
$sb->apply_unsafe($H4);
$Mb->apply_unsafe($H4);
$mc->apply_unsafe($H4);
$uc->apply_unsafe($H4);
$Kc->apply_unsafe($H4);
$kd->apply_unsafe($I4);
$rd->apply_unsafe($I4);
$zd->apply_unsafe($I4);
$Pd->apply_unsafe($I4);
$ce->apply_unsafe($I4);
$me->apply_unsafe($I4);
$Ke->apply_unsafe($J4);
$Se->apply_unsafe($J4);
$Ze->apply_unsafe($J4);
$tf->apply_unsafe($J4);
$Zf->apply_unsafe($cg);
$mg->apply_unsafe($K4);
$zg->apply_unsafe($K4);
$hh->apply_unsafe($M4);
$rh->apply_unsafe($M4);
$Dh->apply_unsafe($M4);
$Nh->apply_unsafe($M4);
$fi->apply_unsafe($M4);
$Li->apply_unsafe($N4);
$Si->apply_unsafe($N4);
$ij->apply_unsafe($N4);
$Gj->apply_unsafe($O4);
$Gj->apply_unsafe($P4);
$Gj->apply_unsafe($Q4);
$Gj->apply_unsafe($Y4);
$Sj->apply_unsafe($O4);
$Sj->apply_unsafe($P4);
$Sj->apply_unsafe($Q4);
$Sj->apply_unsafe($Y4);
$kk->apply_unsafe($O4);
$kk->apply_unsafe($P4);
$kk->apply_unsafe($Q4);
$Ek->apply_unsafe($O4);
$Ek->apply_unsafe($P4);
$Ek->apply_unsafe($Q4);
$Vk->apply_unsafe($R2);
$Vk->apply_unsafe($S2);
$Vk->apply_unsafe($T2);
$kl->apply_unsafe($P4);
$ul->apply_unsafe($P4);
$Gl->apply_unsafe($P4);
$fm->apply_unsafe($Q4);
$mm->apply_unsafe($Q4);
$Im->apply_unsafe($J3);
$en->apply_unsafe($S4);
$kn->apply_unsafe($S4);
$Fn->apply_unsafe($F);
$Ln->apply_unsafe($F);
$Sn->apply_unsafe($F);
$do->apply_unsafe($F);
$Eo->apply_unsafe($u);
$So->apply_unsafe($u);
$ep->apply_unsafe($u);
$mp->apply_unsafe($u);
$Hp->apply_unsafe($T4);
$Rp->apply_unsafe($cg);
$dq->apply_unsafe($T4);
$Qq->apply_unsafe($T4);
$Yq->apply_unsafe($T4);
$Yq->apply_unsafe($V4);
$yr->apply_unsafe($T4);
$yr->apply_unsafe($V4);
$Or->apply_unsafe($T4);
$Or->apply_unsafe($V4);
$gs->apply_unsafe($T4);
$Rs->apply_unsafe($Ss);
$ot->apply_unsafe($U4);
$Gt->apply_unsafe($U4);
$Pt->apply_unsafe($U4);
$Zt->apply_unsafe($U4);
$qv->apply_unsafe($Ss);
$Ev->apply_unsafe($V4);
$Nv->apply_unsafe($V4);
$qw->apply_unsafe($H3);
$ww->apply_unsafe($H3);
$Dw->apply_unsafe($H3);
$cx->apply_unsafe($cg);
$mx->apply_unsafe($T3);
$sx->apply_unsafe($T3);
$Mx->apply_unsafe($W4);
$Yx->apply_unsafe($W4);
$hy->apply_unsafe($W4);
$ni::self=$Xz;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$H;
&$_($d1)for@$H;
&$_($j1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$H;
&$_($D1)for@$w;
&$_($H1)for@$H;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$H;
&$_($f2)for@$H;
&$_($n2)for@$w;
&$_($r2)for@$w;
&$_($v2)for@$H;
&$_($B2)for@$H;
&$_($B3)for@$w;
&$_($E3)for@$w;
&$_($I3)for@$K3;
&$_($N3)for@$w;
&$_($P3)for@$w;
&$_($S3)for@$K3;
&$_($X3)for@$w;
&$_($c4)for@$K3;
&$_($g4)for@$w;
&$_($j4)for@$K3;
&$_($n4)for@$w;
&$_($q4)for@$K3;
&$_($s4)for@$t4;
&$_($w4)for@$w;
&$_($z4)for@$w;
&$_($C4)for@$K3;
&$_($f5)for@$w;
&$_($i5)for@$K3;
&$_($k5)for@$l5;
&$_($q5)for@$w;
&$_($t5)for@$K3;
&$_($v5)for@$w5;
&$_($C5)for@$w;
&$_($F5)for@$K3;
&$_($J5)for@$w;
&$_($M5)for@$w;
&$_($P5)for@$K3;
&$_($T5)for@$w;
&$_($W5)for@$K3;
&$_($c6)for@$w;
&$_($f6)for@$K3;
&$_($j6)for@$w;
&$_($m6)for@$K3;
&$_($o6)for@$p6;
&$_($r6)for@$s6;
&$_($w6)for@$w;
&$_($z6)for@$w;
&$_($C6)for@$K3;
&$_($G6)for@$w;
&$_($J6)for@$K3;
&$_($L6)for@$M6;
&$_($V6)for@$W6;
&$_($c7)for@$W6;
&$_($e7)for@$W6;
&$_($g7)for@$W6;
&$_($o7)for@$w;
&$_($r7)for@$K3;
&$_($w7)for@$w;
&$_($A7)for@$w;
&$_($E7)for@$w;
&$_($I7)for@$w;
&$_($L7)for@$K3;
&$_($Q7)for@$w;
&$_($T7)for@$K3;
&$_($Y7)for@$w;
&$_($d8)for@$K3;
&$_($i8)for@$w;
&$_($l8)for@$K3;
&$_($q8)for@$w;
&$_($t8)for@$K3;
&$_($v8)for@$w8;
&$_($B8)for@$w;
&$_($F8)for@$w;
&$_($I8)for@$K3;
&$_($M8)for@$w;
&$_($P8)for@$K3;
&$_($U8)for@$w;
&$_($Y8)for@$w;
&$_($d9)for@$K3;
&$_($i9)for@$w;
&$_($l9)for@$K3;
&$_($n9)for@$o9;
&$_($v9)for@$W6;
&$_($x9)for@$W6;
&$_($I9)for@$w;
&$_($L9)for@$K3;
&$_($N9)for@$O9;
&$_($T9)for@$W6;
&$_($ca)for@$w;
&$_($fa)for@$K3;
&$_($ja)for@$w;
&$_($ma)for@$w;
&$_($pa)for@$K3;
&$_($ra)for@$sa;
&$_($xa)for@$W6;
&$_($Fa)for@$w;
&$_($Ia)for@$K3;
&$_($Ma)for@$w;
&$_($Pa)for@$K3;
&$_($Ra)for@$Sa;
&$_($Xa)for@$W6;
&$_($ib)for@$w;
&$_($lb)for@$K3;
&$_($pb)for@$w;
&$_($sb)for@$K3;
&$_($xb)for@$w;
&$_($Bb)for@$w;
&$_($Fb)for@$w;
&$_($Jb)for@$w;
&$_($Mb)for@$K3;
&$_($Rb)for@$w;
&$_($Vb)for@$w;
&$_($Zb)for@$w;
&$_($fc)for@$w;
&$_($jc)for@$w;
&$_($mc)for@$K3;
&$_($rc)for@$w;
&$_($uc)for@$K3;
&$_($zc)for@$w;
&$_($Dc)for@$w;
&$_($Hc)for@$w;
&$_($Kc)for@$K3;
&$_($Mc)for@$Nc;
&$_($Sc)for@$W6;
&$_($hd)for@$w;
&$_($kd)for@$K3;
&$_($od)for@$w;
&$_($rd)for@$K3;
&$_($wd)for@$w;
&$_($zd)for@$K3;
&$_($Ed)for@$w;
&$_($Id)for@$w;
&$_($Md)for@$w;
&$_($Pd)for@$K3;
&$_($Td)for@$w;
&$_($Xd)for@$w;
&$_($ce)for@$K3;
&$_($ge)for@$w;
&$_($je)for@$w;
&$_($me)for@$K3;
&$_($oe)for@$pe;
&$_($ue)for@$W6;
&$_($He)for@$w;
&$_($Ke)for@$K3;
&$_($Pe)for@$w;
&$_($Se)for@$K3;
&$_($We)for@$w;
&$_($Ze)for@$K3;
&$_($gf)for@$w;
&$_($jf)for@$w;
&$_($nf)for@$w;
&$_($qf)for@$w;
&$_($tf)for@$K3;
&$_($vf)for@$wf;
&$_($Bf)for@$W6;
&$_($Lf)for@$w;
&$_($Of)for@$w;
&$_($Sf)for@$w;
&$_($Wf)for@$w;
&$_($Zf)for@$K3;
&$_($jg)for@$w;
&$_($mg)for@$K3;
&$_($qg)for@$w;
&$_($tg)for@$w;
&$_($wg)for@$w;
&$_($zg)for@$K3;
&$_($Bg)for@$Cg;
&$_($Hg)for@$W6;
&$_($Yg)for@$w;
&$_($eh)for@$w;
&$_($hh)for@$K3;
&$_($lh)for@$w;
&$_($oh)for@$w;
&$_($rh)for@$K3;
&$_($wh)for@$w;
&$_($Ah)for@$w;
&$_($Dh)for@$K3;
&$_($Hh)for@$w;
&$_($Kh)for@$w;
&$_($Nh)for@$K3;
&$_($Rh)for@$w;
&$_($Uh)for@$w;
&$_($Xh)for@$w;
&$_($ci)for@$w;
&$_($fi)for@$K3;
&$_($hi)for@$ii;
&$_($ni)for@$W6;
&$_($Ai)for@$w;
&$_($Ei)for@$w;
&$_($Ii)for@$w;
&$_($Li)for@$K3;
&$_($Pi)for@$w;
&$_($Si)for@$K3;
&$_($Wi)for@$w;
&$_($cj)for@$w;
&$_($fj)for@$w;
&$_($ij)for@$K3;
&$_($kj)for@$lj;
&$_($qj)for@$W6;
&$_($Dj)for@$w;
&$_($Gj)for@$K3;
&$_($Lj)for@$w;
&$_($Pj)for@$w;
&$_($Sj)for@$K3;
&$_($Uj)for@$Vj;
&$_($Zj)for@$w;
&$_($ek)for@$w;
&$_($hk)for@$w;
&$_($kk)for@$K3;
&$_($pk)for@$w;
&$_($tk)for@$w;
&$_($xk)for@$w;
&$_($Bk)for@$w;
&$_($Ek)for@$K3;
&$_($Gk)for@$Hk;
&$_($Ok)for@$W6;
&$_($Sk)for@$w;
&$_($Vk)for@$K3;
&$_($Xk)for@$W6;
&$_($hl)for@$w;
&$_($kl)for@$K3;
&$_($ol)for@$w;
&$_($rl)for@$w;
&$_($ul)for@$K3;
&$_($zl)for@$w;
&$_($Dl)for@$w;
&$_($Gl)for@$K3;
&$_($Il)for@$Jl;
&$_($Ol)for@$W6;
&$_($cm)for@$w;
&$_($fm)for@$K3;
&$_($jm)for@$w;
&$_($mm)for@$K3;
&$_($om)for@$pm;
&$_($um)for@$W6;
&$_($Fm)for@$w;
&$_($Im)for@$K3;
&$_($Km)for@$Lm;
&$_($Rm)for@$W6;
&$_($Zm)for@$w;
&$_($en)for@$K3;
&$_($hn)for@$w;
&$_($kn)for@$K3;
&$_($mn)for@$nn;
&$_($sn)for@$W6;
&$_($Cn)for@$w;
&$_($Fn)for@$K3;
&$_($In)for@$w;
&$_($Ln)for@$K3;
&$_($Pn)for@$w;
&$_($Sn)for@$K3;
&$_($Vn)for@$w;
&$_($Yn)for@$w;
&$_($do)for@$K3;
&$_($fo)for@$go;
&$_($lo)for@$W6;
&$_($wo)for@$w;
&$_($zo)for@$w;
&$_($Bo)for@$w;
&$_($Eo)for@$K3;
&$_($Io)for@$w;
&$_($Lo)for@$w;
&$_($Po)for@$w;
&$_($So)for@$K3;
&$_($Wo)for@$w;
&$_($Zo)for@$w;
&$_($ep)for@$K3;
&$_($jp)for@$w;
&$_($mp)for@$K3;
&$_($op)for@$pp;
&$_($up)for@$W6;
&$_($Ep)for@$w;
&$_($Hp)for@$K3;
&$_($Op)for@$w;
&$_($Rp)for@$K3;
&$_($Yp)for@$w;
&$_($dq)for@$K3;
&$_($iq)for@$w;
&$_($mq)for@$w;
&$_($qq)for@$w;
&$_($uq)for@$w;
&$_($yq)for@$w;
&$_($Cq)for@$w;
&$_($Gq)for@$w;
&$_($Kq)for@$w;
&$_($Nq)for@$w;
&$_($Qq)for@$K3;
&$_($Vq)for@$w;
&$_($Yq)for@$K3;
&$_($fr)for@$w;
&$_($jr)for@$w;
&$_($nr)for@$w;
&$_($rr)for@$w;
&$_($vr)for@$w;
&$_($yr)for@$K3;
&$_($Dr)for@$w;
&$_($Hr)for@$w;
&$_($Lr)for@$w;
&$_($Or)for@$K3;
&$_($Tr)for@$w;
&$_($Xr)for@$w;
&$_($ds)for@$w;
&$_($gs)for@$K3;
&$_($is)for@$js;
&$_($os)for@$W6;
&$_($ys)for@$w;
&$_($Cs)for@$w;
&$_($Gs)for@$w;
&$_($Ks)for@$w;
&$_($Os)for@$w;
&$_($Rs)for@$K3;
&$_($ft)for@$w;
&$_($it)for@$w;
&$_($lt)for@$w;
&$_($ot)for@$K3;
&$_($st)for@$w;
&$_($vt)for@$w;
&$_($yt)for@$w;
&$_($Bt)for@$w;
&$_($Dt)for@$w;
&$_($Gt)for@$K3;
&$_($Jt)for@$w;
&$_($Mt)for@$w;
&$_($Pt)for@$K3;
&$_($Tt)for@$w;
&$_($Wt)for@$w;
&$_($Zt)for@$K3;
&$_($du)for@$eu;
&$_($ju)for@$W6;
&$_($tu)for@$w;
&$_($xu)for@$w;
&$_($Bu)for@$w;
&$_($Fu)for@$w;
&$_($Ju)for@$w;
&$_($Nu)for@$w;
&$_($Ru)for@$w;
&$_($Vu)for@$w;
&$_($Zu)for@$w;
&$_($fv)for@$w;
&$_($jv)for@$w;
&$_($nv)for@$w;
&$_($qv)for@$K3;
&$_($Bv)for@$w;
&$_($Ev)for@$K3;
&$_($Hv)for@$w;
&$_($Kv)for@$w;
&$_($Nv)for@$K3;
&$_($Pv)for@$Qv;
&$_($Vv)for@$W6;
&$_($hw)for@$w;
&$_($jw)for@$w;
&$_($qw)for@$K3;
&$_($tw)for@$w;
&$_($ww)for@$K3;
&$_($Aw)for@$w;
&$_($Dw)for@$K3;
&$_($Fw)for@$Gw;
&$_($Mw)for@$W6;
&$_($Tw)for@$w;
&$_($Xw)for@$w;
&$_($cx)for@$K3;
&$_($jx)for@$w;
&$_($mx)for@$K3;
&$_($px)for@$w;
&$_($sx)for@$K3;
&$_($ux)for@$vx;
&$_($Bx)for@$W6;
&$_($Jx)for@$w;
&$_($Mx)for@$K3;
&$_($Rx)for@$w;
&$_($Vx)for@$w;
&$_($Yx)for@$K3;
&$_($ey)for@$w;
&$_($hy)for@$K3;
&$_($jy)for@$ky;
&$_($py)for@$W6;
&$_($xy)for@$yy;
&$_($Dy)for@$W6;
&$_($My)for@$Ny;
&$_($Sy)for@$W6;
&$_($cz)for@$dz;
&$_($xz)for@$yz;
&$_($Az)for@$dz;
&$_($Fz)for@$w;
&$_($Jz)for@$w;
&$_($Nz)for@$w;
&$_($Rz)for@$w;
&$_($Vz)for@$w;
&$_($Xz)for@$Yz;
ni->run(@ARGV);
__DATA__
