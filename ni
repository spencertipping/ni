#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib/doc#;
$L1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$M1=[$f,$L1];
$N1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$O1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$P1=[];
$Q1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$T1=[];
$U1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$V1=bless({$o,$T1,$q,$U1,$s,$t},$u);
$W1=[$i,$N1,$O1,$n,$R1,$S1,$n,$V1];
$X1=[$M1,$W1];
$Y1=q#/lib/doc#;
$Z1=bless({$e,$X1,$D,$Y1},$F);
$c2=q#ni:/class#;
$d2=q#applied_to#;
$e2=q#class#;
$f2=q#class.c#;
$g2=q#io/cat.c#;
$h2=q#io/exec.c#;
$i2=q#io/fd.c#;
$j2=q#io/file.c#;
$k2=q#io/null.c#;
$l2=q#io/object.c#;
$m2=q#io/pid.c#;
$n2=q#io/str.c#;
$o2=q#lib/behavior.c#;
$p2=q#lib/branch.c#;
$q2=q#lib/dataslice.c#;
$r2=q#lib/doc.c#;
$s2=q#lib/fn.c#;
$t2=q#lib/image.c#;
$u2=q#lib/ni.c#;
$v2=q#lib/slice.c#;
$w2=q#lib/tag.c#;
$x2=q#lib/test_value.c#;
$y2=q#metaclass.c#;
$z2=q#module.c#;
$A2=q#object.c#;
$B2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1};
$C2=q#slices#;
$D2=q#metaclass#;
$E2=q#module#;
$F2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$D2,1,$y2,1,$E2,1,$z2,1,$A2,1};
$G2=q#/module#;
$H2=q#/lib/perlbranch.b#;
$I2={};
$J2=q#ctor#;
$K2=undef;
$L2=q#dtor#;
$M2=q#methods#;
$N2=q#add#;
$O2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$P2=bless({$q,$O2,$s,$t},$u);
$Q2=q#apply#;
$R2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$S2=bless({$q,$R2,$s,$t},$u);
$T2={$N2,$P2,$Q2,$S2};
$U2=q#/lib/branch.b#;
$V2=q#lib/slice#;
$W2=bless({$d2,$I2,$J2,$K2,$L2,$K2,$M2,$T2,$D,$U2},$V2);
$X2=q#lib/branch#;
$Y2=q#lib/slice::ctors#;
$Z2={};
$c3=q#my $s = shift; ni->def($s->name, $s)#;
$d3=bless({$q,$c3,$s,$t},$u);
$e3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$f3=bless({$q,$e3,$s,$t},$u);
$g3={$D,$f3};
$h3=q#/lib/named.b#;
$i3=bless({$d2,$Z2,$J2,$d3,$L2,$K2,$M2,$g3,$D,$h3},$V2);
$j3=q#lib/tag#;
$k3={};
$l3=q#namespace#;
$m3=q#'ni'#;
$n3=bless({$q,$m3,$s,$t},$u);
$o3={$l3,$n3};
$p3=q#/lib/named_in_ni.b#;
$q3=bless({$d2,$k3,$J2,$K2,$L2,$K2,$M2,$o3,$D,$p3},$V2);
$r3={};
$s3=q#package#;
$t3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$u3=bless({$q,$t3,$s,$t},$u);
$v3={$s3,$u3};
$w3=q#/lib/namespaced.b#;
$x3=bless({$d2,$r3,$J2,$K2,$L2,$K2,$M2,$v3,$D,$w3},$V2);
$y3={};
$z3=q#resolve#;
$A3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$B3=bless({$q,$A3,$s,$t},$u);
$C3={$z3,$B3};
$D3=q#/lib/resolver.b#;
$E3=bless({$d2,$y3,$J2,$K2,$L2,$K2,$M2,$C3,$D,$D3},$V2);
$F3=[$W2,$i3,$q3,$x3,$E3];
$G3=bless({$D,$H2,$C2,$F3},$j3);
$H3=q#lib/tag::ctors#;
$I3={};
$J3=q#my $s = shift; $s->apply($s->package)#;
$K3=bless({$q,$J3,$s,$t},$u);
$L3=q#instantiate#;
$M3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$N3=bless({$q,$M3,$s,$t},$u);
$O3={$L3,$N3};
$P3=q#/lib/class_init.b#;
$Q3=bless({$d2,$I3,$J2,$K3,$L2,$K2,$M2,$O3,$D,$P3},$V2);
$R3=q#io/cat#;
$S3=q#io/exec#;
$T3=q#io/fd#;
$U3=q#io/file#;
$V3=q#io/null#;
$W3=q#io/object#;
$X3=q#io/pid#;
$Y3=q#io/str#;
$Z3=q#lib/behavior#;
$c4=q#lib/dataslice#;
$d4=q#lib/image#;
$e4=q#lib/ni#;
$f4=q#lib/test_value#;
$g4=q#object#;
$h4={$e2,1,$f2,1,$R3,1,$g2,1,$S3,1,$h2,1,$T3,1,$i2,1,$U3,1,$j2,1,$V3,1,$k2,1,$W3,1,$l2,1,$X3,1,$m2,1,$Y3,1,$n2,1,$Z3,1,$o2,1,$X2,1,$p2,1,$c4,1,$q2,1,$F,1,$r2,1,$u,1,$s2,1,$d4,1,$t2,1,$e4,1,$u2,1,$V2,1,$v2,1,$j3,1,$w2,1,$f4,1,$x2,1,$D2,1,$y2,1,$E2,1,$z2,1,$g4,1,$A2,1};
$i4=q#/object#;
$j4={};
$k4=q#ni 'ni:/' . ref shift#;
$l4=bless({$q,$k4,$s,$t},$u);
$m4={$e2,$l4};
$n4=q#/lib/instance.b#;
$o4=bless({$d2,$j4,$J2,$K2,$L2,$K2,$M2,$m4,$D,$n4},$V2);
$p4=[$o4];
$q4=bless({$d2,$h4,$D,$i4,$C2,$p4},$A2);
$r4=q#object.c::ctors#;
$s4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$Z3,1,$o2,1,$X2,1,$p2,1,$c4,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$V2,1,$v2,1,$j3,1,$w2,1,$x2,1,$D2,1,$y2,1,$E2,1,$z2,1,$A2,1};
$t4=q#/lib/behavior#;
$u4={};
$v4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4={$e,$w4};
$y4=q#/lib/documentable.b#;
$z4=bless({$d2,$u4,$J2,$K2,$L2,$K2,$M2,$x4,$D,$y4},$V2);
$A4=[$q4,$z4];
$B4=bless({$d2,$s4,$D,$t4,$C2,$A4},$o2);
$C4=q#lib/behavior.c::ctors#;
$D4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$X2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$D2,1,$y2,1,$E2,1,$z2,1,$A2,1};
$E4=q#/lib/definition.b#;
$F4={};
$G4=q#def#;
$H4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$I4=bless({$q,$H4,$s,$t},$u);
$J4={$G4,$I4};
$K4=q#/lib/definition_def.b#;
$L4=bless({$d2,$F4,$J2,$K2,$L2,$K2,$M2,$J4,$D,$K4},$V2);
$M4={};
$N4=q#ro#;
$O4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$P4=bless({$q,$O4,$s,$t},$u);
$Q4=q#rw#;
$R4=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$S4=bless({$q,$R4,$s,$t},$u);
$T4={$N4,$P4,$Q4,$S4};
$U4=q#/lib/accessor.b#;
$V4=bless({$d2,$M4,$J2,$K2,$L2,$K2,$M2,$T4,$D,$U4},$V2);
$W4={};
$X4=q#(""#;
$Y4=q#shift->name#;
$Z4=bless({$q,$Y4,$s,$t},$u);
$c5={$X4,$Z4};
$d5=q#/lib/name_as_string.b#;
$e5=bless({$d2,$W4,$J2,$K2,$L2,$K2,$M2,$c5,$D,$d5},$V2);
$f5={};
$g5=q#(eq#;
$h5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$i5=bless({$q,$h5,$s,$t},$u);
$j5={$g5,$i5};
$k5=q#/lib/ref_eq.b#;
$l5=bless({$d2,$f5,$J2,$K2,$L2,$K2,$M2,$j5,$D,$k5},$V2);
$m5={};
$n5=q#defdata#;
$o5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$p5=bless({$q,$o5,$s,$t},$u);
$q5={$n5,$p5};
$r5=q#/lib/definition_defdata.b#;
$s5=bless({$d2,$m5,$J2,$K2,$L2,$K2,$M2,$q5,$D,$r5},$V2);
$t5=[$L4,$V4,$e5,$l5,$s5];
$u5=bless({$d2,$D4,$D,$E4,$C2,$t5},$X2);
$v5=q#lib/branch::ctors#;
$w5=[$G3,$Q3,$q4,$B4,$u5];
$x5=bless({$d2,$F2,$D,$G2,$C2,$w5},$z2);
$y5=q#module.c::ctors#;
$z5={};
$A5=q#DESTROY#;
$B5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$C5=bless({$q,$B5,$s,$t},$u);
$D5=q#new#;
$E5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$F5=bless({$q,$E5,$s,$t},$u);
$G5={$A5,$C5,$D5,$F5};
$H5=q#/lib/instantiable.b#;
$I5=bless({$d2,$z5,$M2,$G5,$D,$H5},$V2);
$J5={};
$K5=q#child#;
$L5=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/subclass.b#;
$P5=bless({$d2,$J5,$J2,$K2,$L2,$K2,$M2,$N5,$D,$O5},$V2);
$Q5=[$x5,$I5,$Q3,$x5,$P5];
$R5=bless({$d2,$B2,$D,$E,$C2,$Q5},$f2);
$S5=q#class.c::ctors#;
$T5=q#ni:/class.c#;
$U5={$f2,1};
$V5=q#/class.c#;
$W5={$f2,1,$z2,1};
$X5=q#/module.c#;
$Y5={$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$z2,1,$A2,1};
$Z5=q#/object.c#;
$c6=[$R5];
$d6=bless({$d2,$Y5,$D,$Z5,$C2,$c6},$D2);
$e6=q#metaclass::ctors#;
$f6={$f2,1,$o2,1,$p2,1,$q2,1,$v2,1,$w2,1,$z2,1};
$g6=q#/lib/behavior.c#;
$h6=[$d6];
$i6=bless({$d2,$f6,$D,$g6,$C2,$h6},$D2);
$j6=[$d6,$I5,$i6];
$k6=bless({$d2,$W5,$D,$X5,$C2,$j6},$D2);
$l6=[$k6];
$m6=bless({$d2,$U5,$D,$V5,$C2,$l6},$D2);
$n6=q#ni:/io/cat#;
$o6={$R3,1};
$p6={$R3,1,$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1};
$q6=q#/io/object#;
$r6={};
$s6=q#(bool#;
$t6=[];
$u6=bless({$o,$t6,$q,1,$s,$t},$u);
$v6={$s6,$u6};
$w6=q#/io/object_ops.b#;
$x6=bless({$d2,$r6,$J2,$K2,$L2,$K2,$M2,$v6,$D,$w6},$V2);
$y6={};
$z6=q#into#;
$A6=[];
$B6=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}
$self;#;
$C6=bless({$o,$A6,$q,$B6,$s,$t},$u);
$D6={$z6,$C6};
$E6=q#/io/object_stream.b#;
$F6=bless({$d2,$y6,$J2,$K2,$L2,$K2,$M2,$D6,$D,$E6},$V2);
$G6={};
$H6=q#die#;
$I6=[];
$J6=q#shift; die join " ", @_#;
$K6=bless({$o,$I6,$q,$J6,$s,$t},$u);
$L6=q#io_check#;
$M6=[];
$N6=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$O6=bless({$o,$M6,$q,$N6,$s,$t},$u);
$P6=q#io_check_defined#;
$Q6=[];
$R6=q#shift->io_check(sub {defined shift}, @_)#;
$S6=bless({$o,$Q6,$q,$R6,$s,$t},$u);
$T6=q#io_check_true#;
$U6=[];
$V6=q#shift->io_check(sub {shift}, @_)#;
$W6=bless({$o,$U6,$q,$V6,$s,$t},$u);
$X6={$H6,$K6,$L6,$O6,$P6,$S6,$T6,$W6};
$Y6=q#/io/object_checks.b#;
$Z6=bless({$d2,$G6,$J2,$K2,$L2,$K2,$M2,$X6,$D,$Y6},$V2);
$c7={};
$d7=q#(+#;
$e7=[];
$f7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$g7=bless({$o,$e7,$q,$f7,$s,$t},$u);
$h7={$d7,$g7};
$i7=q#/io/object_constructors.b#;
$j7=bless({$d2,$c7,$J2,$K2,$L2,$K2,$M2,$h7,$D,$i7},$V2);
$k7={};
$l7=q#read_all#;
$m7=[];
$n7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$o7=bless({$o,$m7,$q,$n7,$s,$t},$u);
$p7={$l7,$o7};
$q7=q#/io/object_memory.b#;
$r7=bless({$d2,$k7,$J2,$K2,$L2,$K2,$M2,$p7,$D,$q7},$V2);
$s7=[$q4,$x6,$F6,$Z6,$j7,$r7];
$t7=bless({$d2,$p6,$D,$q6,$C2,$s7},$l2);
$u7=q#io/object.c::ctors#;
$v7={};
$w7=[];
$x7=q#shift; +{fs => [@_]}#;
$y7=bless({$o,$w7,$q,$x7,$s,$t},$u);
$z7={$L3,$y7};
$A7=q#/io/cat_init.b#;
$B7=bless({$d2,$v7,$J2,$K2,$L2,$K2,$M2,$z7,$D,$A7},$V2);
$C7={};
$D7=q#read#;
$E7=[];
$F7=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$G7=bless({$o,$E7,$q,$F7,$s,$t},$u);
$H7={$D7,$G7};
$I7=q#/io/cat_read.b#;
$J7=bless({$d2,$C7,$J2,$K2,$L2,$K2,$M2,$H7,$D,$I7},$V2);
$K7=[$t7,$B7,$J7];
$L7=bless({$d2,$o6,$D,$g1,$C2,$K7},$g2);
$M7=q#io/cat.c::ctors#;
$N7=q#ni:/io/cat.c#;
$O7={$g2,1};
$P7=q#/io/cat.c#;
$Q7={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1};
$R7=q#/io/object.c#;
$S7=[$d6];
$T7=bless({$d2,$Q7,$D,$R7,$C2,$S7},$D2);
$U7=[$T7];
$V7=bless({$d2,$O7,$D,$P7,$C2,$U7},$D2);
$W7=q#ni:/io/cat_init.b#;
$X7=q#ni:/io/cat_read.b#;
$Y7=q#ni:/io/exec#;
$Z7={$S3,1};
$c8={};
$d8=q#argv#;
$e8=[];
$f8=q#shift->{'argv'}#;
$g8=bless({$o,$e8,$q,$f8,$s,$t},$u);
$h8={$d8,$g8};
$i8=q#/io/exec_ro.b#;
$j8=bless({$d2,$c8,$J2,$K2,$L2,$K2,$M2,$h8,$D,$i8},$V2);
$k8={};
$l8=[];
$m8=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$n8=bless({$o,$l8,$q,$m8,$s,$t},$u);
$o8={$L3,$n8};
$p8=q#/io/exec_init.b#;
$q8=bless({$d2,$k8,$J2,$K2,$L2,$K2,$M2,$o8,$D,$p8},$V2);
$r8={};
$s8=q#connect#;
$t8=[];
$u8=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$v8=bless({$o,$t8,$q,$u8,$s,$t},$u);
$w8=q#in_pipe#;
$x8=[];
$y8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$z8=bless({$o,$x8,$q,$y8,$s,$t},$u);
$A8=q#out_pipe#;
$B8=[];
$C8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$D8=bless({$o,$B8,$q,$C8,$s,$t},$u);
$E8=q#setup_stdio#;
$F8=[];
$G8=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$H8=bless({$o,$F8,$q,$G8,$s,$t},$u);
$I8={$s8,$v8,$w8,$z8,$A8,$D8,$E8,$H8};
$J8=q#/io/exec_io_setup.b#;
$K8=bless({$d2,$r8,$J2,$K2,$L2,$K2,$M2,$I8,$D,$J8},$V2);
$L8={};
$M8=q#binds_fd#;
$N8=[];
$O8=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$P8=bless({$o,$N8,$q,$O8,$s,$t},$u);
$Q8=q#fd#;
$R8=[];
$S8=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$T8=bless({$o,$R8,$q,$S8,$s,$t},$u);
$U8=q#stderr#;
$V8=[];
$W8=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$X8=bless({$o,$V8,$q,$W8,$s,$t},$u);
$Y8=q#stdin#;
$Z8=[];
$c9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$d9=bless({$o,$Z8,$q,$c9,$s,$t},$u);
$e9=q#stdout#;
$f9=[];
$g9=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$h9=bless({$o,$f9,$q,$g9,$s,$t},$u);
$i9={$M8,$P8,$Q8,$T8,$U8,$X8,$Y8,$d9,$e9,$h9};
$j9=q#/io/exec_io_accessors.b#;
$k9=bless({$d2,$L8,$J2,$K2,$L2,$K2,$M2,$i9,$D,$j9},$V2);
$l9={};
$m9=q#env#;
$n9=[];
$o9=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$p9=bless({$o,$n9,$q,$o9,$s,$t},$u);
$q9={$m9,$p9};
$r9=q#/io/exec_env.b#;
$s9=bless({$d2,$l9,$J2,$K2,$L2,$K2,$M2,$q9,$D,$r9},$V2);
$t9={};
$u9=q#exec#;
$v9=[];
$w9=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9=q#fork#;
$z9=[];
$A9=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$B9=bless({$o,$z9,$q,$A9,$s,$t},$u);
$C9=q#move_fds#;
$D9=[];
$E9=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$F9=bless({$o,$D9,$q,$E9,$s,$t},$u);
$G9={$u9,$x9,$y9,$B9,$C9,$F9};
$H9=q#/io/exec_fork.b#;
$I9=bless({$d2,$t9,$J2,$K2,$L2,$K2,$M2,$G9,$D,$H9},$V2);
$J9=[$t7,$j8,$q8,$K8,$k9,$s9,$I9];
$K9=bless({$d2,$Z7,$D,$s1,$C2,$J9},$h2);
$L9=q#io/exec.c::ctors#;
$M9=q#ni:/io/exec.c#;
$N9={$h2,1};
$O9=q#/io/exec.c#;
$P9=[$T7];
$Q9=bless({$d2,$N9,$D,$O9,$C2,$P9},$D2);
$R9=q#ni:/io/exec_env.b#;
$S9=q#ni:/io/exec_fork.b#;
$T9=q#ni:/io/exec_init.b#;
$U9=q#ni:/io/exec_io_accessors.b#;
$V9=q#ni:/io/exec_io_setup.b#;
$W9=q#ni:/io/exec_ro.b#;
$X9=q#ni:/io/fd#;
$Y9={$T3,1};
$Z9=q#/io/fd#;
$ca={};
$da=[];
$ea=q#shift->{'fd'}#;
$fa=bless({$o,$da,$q,$ea,$s,$t},$u);
$ga={$Q8,$fa};
$ha=q#/io/fd_readers.b#;
$ia=bless({$d2,$ca,$J2,$K2,$L2,$K2,$M2,$ga,$D,$ha},$V2);
$ja={};
$ka=[];
$la=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$ma=bless({$o,$ka,$q,$la,$s,$t},$u);
$na={$L3,$ma};
$oa=q#/io/fd_init.b#;
$pa=bless({$d2,$ja,$J2,$K2,$L2,$K2,$M2,$na,$D,$oa},$V2);
$qa={};
$ra=q#be#;
$sa=[];
$ta=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$ua=bless({$o,$sa,$q,$ta,$s,$t},$u);
$va={$ra,$ua};
$wa=q#/io/fd_shell.b#;
$xa=bless({$d2,$qa,$J2,$K2,$L2,$K2,$M2,$va,$D,$wa},$V2);
$ya={};
$za=q#cloexec#;
$Aa=[];
$Ba=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ca=bless({$o,$Aa,$q,$Ba,$s,$t},$u);
$Da=q#fcntl_flag#;
$Ea=[];
$Fa=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Ga=bless({$o,$Ea,$q,$Fa,$s,$t},$u);
$Ha=q#nonblock#;
$Ia=[];
$Ja=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Ka=bless({$o,$Ia,$q,$Ja,$s,$t},$u);
$La={$za,$Ca,$Da,$Ga,$Ha,$Ka};
$Ma=q#/io/fd_fcntl.b#;
$Na=bless({$d2,$ya,$J2,$K2,$L2,$K2,$M2,$La,$D,$Ma},$V2);
$Oa={};
$Pa=[];
$Qa=q#shift->close#;
$Ra=bless({$o,$Pa,$q,$Qa,$s,$t},$u);
$Sa=q#close#;
$Ta=[];
$Ua=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Va=bless({$o,$Ta,$q,$Ua,$s,$t},$u);
$Wa={$Sa,$Va};
$Xa=q#/io/fd_gc.b#;
$Ya=bless({$d2,$Oa,$J2,$K2,$L2,$Ra,$M2,$Wa,$D,$Xa},$V2);
$Za={};
$cb=[];
$db=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q#write#;
$gb=[];
$hb=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb={$D7,$eb,$fb,$ib};
$kb=q#/io/fd_perlio.b#;
$lb=bless({$d2,$Za,$J2,$K2,$L2,$K2,$M2,$jb,$D,$kb},$V2);
$mb=[$t7,$ia,$pa,$xa,$Na,$Ya,$lb];
$nb=bless({$d2,$Y9,$D,$Z9,$C2,$mb},$i2);
$ob=q#io/fd.c::ctors#;
$pb=q#ni:/io/fd.c#;
$qb={$i2,1};
$rb=q#/io/fd.c#;
$sb=[$T7];
$tb=bless({$d2,$qb,$D,$rb,$C2,$sb},$D2);
$ub=q#ni:/io/fd_fcntl.b#;
$vb=q#ni:/io/fd_gc.b#;
$wb=q#ni:/io/fd_init.b#;
$xb=q#ni:/io/fd_perlio.b#;
$yb=q#ni:/io/fd_readers.b#;
$zb=q#ni:/io/fd_shell.b#;
$Ab=q#ni:/io/file#;
$Bb={$U3,1};
$Cb=q#/io/file#;
$Db={};
$Eb=[];
$Fb=q#shift->{'name'}#;
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb={$D,$Gb};
$Ib=q#/io/file_readers.b#;
$Jb=bless({$d2,$Db,$J2,$K2,$L2,$K2,$M2,$Hb,$D,$Ib},$V2);
$Kb={};
$Lb=q#mode#;
$Mb=[];
$Nb=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb={$Lb,$Ob};
$Qb=q#/io/file_accessors.b#;
$Rb=bless({$d2,$Kb,$J2,$K2,$L2,$K2,$M2,$Pb,$D,$Qb},$V2);
$Sb={};
$Tb=[];
$Ub=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Vb=bless({$o,$Tb,$q,$Ub,$s,$t},$u);
$Wb={$L3,$Vb};
$Xb=q#/io/file_init.b#;
$Yb=bless({$d2,$Sb,$J2,$K2,$L2,$K2,$M2,$Wb,$D,$Xb},$V2);
$Zb={};
$cc=q#r#;
$dc=[];
$ec=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$fc=bless({$o,$dc,$q,$ec,$s,$t},$u);
$gc=[];
$hc=q#shift->r->read(@_)#;
$ic=bless({$o,$gc,$q,$hc,$s,$t},$u);
$jc=q#w#;
$kc=[];
$lc=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc=[];
$oc=q#shift->w->write(@_)#;
$pc=bless({$o,$nc,$q,$oc,$s,$t},$u);
$qc={$cc,$fc,$D7,$ic,$jc,$mc,$fb,$pc};
$rc=q#/io/file_io.b#;
$sc=bless({$d2,$Zb,$J2,$K2,$L2,$K2,$M2,$qc,$D,$rc},$V2);
$tc=[$t7,$Jb,$Rb,$Yb,$sc];
$uc=bless({$d2,$Bb,$D,$Cb,$C2,$tc},$j2);
$vc=q#io/file.c::ctors#;
$wc=q#ni:/io/file.c#;
$xc={$j2,1};
$yc=q#/io/file.c#;
$zc=[$T7];
$Ac=bless({$d2,$xc,$D,$yc,$C2,$zc},$D2);
$Bc=q#ni:/io/file_accessors.b#;
$Cc=q#ni:/io/file_init.b#;
$Dc=q#ni:/io/file_io.b#;
$Ec=q#ni:/io/file_readers.b#;
$Fc=q#ni:/io/named_io_fns.b#;
$Gc={};
$Hc=q#fcntl#;
$Ic=[];
$Jc=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Kc=bless({$o,$Ic,$q,$Jc,$s,$t},$u);
$Lc=[];
$Mc=q#CORE::fork#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$t},$u);
$Oc=q#open2#;
$Pc=[];
$Qc=q#CORE::open $_[0], $_[1]#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$t},$u);
$Sc=q#waitpid#;
$Tc=[];
$Uc=q#CORE::waitpid $_[0], $_[1]#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$t},$u);
$Wc={$Hc,$Kc,$y9,$Nc,$Oc,$Rc,$Sc,$Vc};
$Xc=q#/io/named_io_fns.b#;
$Yc=bless({$d2,$Gc,$J2,$K2,$L2,$K2,$M2,$Wc,$D,$Xc},$V2);
$Zc=q#main#;
$cd=q#ni:/io/null#;
$dd={$V3,1};
$ed=q#/io/null#;
$fd={};
$gd=[];
$hd=q#+{fd => undef}#;
$id=bless({$o,$gd,$q,$hd,$s,$t},$u);
$jd={$L3,$id};
$kd=q#/io/null_init.b#;
$ld=bless({$d2,$fd,$J2,$K2,$L2,$K2,$M2,$jd,$D,$kd},$V2);
$md={};
$nd=[];
$od=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$pd=bless({$o,$nd,$q,$od,$s,$t},$u);
$qd=[];
$rd=q#shift->fd->read(@_)#;
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=[];
$ud=q#shift->fd->write(@_)#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd={$Q8,$pd,$D7,$sd,$fb,$vd};
$xd=q#/io/null_io.b#;
$yd=bless({$d2,$md,$J2,$K2,$L2,$K2,$M2,$wd,$D,$xd},$V2);
$zd=[$t7,$ld,$yd];
$Ad=bless({$d2,$dd,$D,$ed,$C2,$zd},$k2);
$Bd=q#io/null.c::ctors#;
$Cd=q#ni:/io/null.c#;
$Dd={$k2,1};
$Ed=q#/io/null.c#;
$Fd=[$T7];
$Gd=bless({$d2,$Dd,$D,$Ed,$C2,$Fd},$D2);
$Hd=q#ni:/io/null_init.b#;
$Id=q#ni:/io/null_io.b#;
$Jd=q#ni:/io/object#;
$Kd=q#ni:/io/object.c#;
$Ld=q#ni:/io/object_checks.b#;
$Md=q#ni:/io/object_constructors.b#;
$Nd=q#ni:/io/object_memory.b#;
$Od=q#ni:/io/object_ops.b#;
$Pd=q#ni:/io/object_stream.b#;
$Qd=q#ni:/io/pid#;
$Rd={$X3,1};
$Sd={};
$Td=q#pid#;
$Ud=[];
$Vd=q#shift->{'pid'}#;
$Wd=bless({$o,$Ud,$q,$Vd,$s,$t},$u);
$Xd=q#status#;
$Yd=[];
$Zd=q#shift->{'status'}#;
$ce=bless({$o,$Yd,$q,$Zd,$s,$t},$u);
$de={$Td,$Wd,$Xd,$ce};
$ee=q#/io/pid_readers.b#;
$fe=bless({$d2,$Sd,$J2,$K2,$L2,$K2,$M2,$de,$D,$ee},$V2);
$ge={};
$he=[];
$ie=q#shift->await#;
$je=bless({$o,$he,$q,$ie,$s,$t},$u);
$ke=[];
$le=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$me=bless({$o,$ke,$q,$le,$s,$t},$u);
$ne={$L3,$me};
$oe=q#/io/pid_init.b#;
$pe=bless({$d2,$ge,$J2,$K2,$L2,$je,$M2,$ne,$D,$oe},$V2);
$qe={};
$re=q#await#;
$se=[];
$te=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$ue=bless({$o,$se,$q,$te,$s,$t},$u);
$ve=q#running#;
$we=[];
$xe=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$ye=bless({$o,$we,$q,$xe,$s,$t},$u);
$ze={$re,$ue,$ve,$ye};
$Ae=q#/io/pid_wait.b#;
$Be=bless({$d2,$qe,$J2,$K2,$L2,$K2,$M2,$ze,$D,$Ae},$V2);
$Ce={};
$De=[];
$Ee=q#shift->stdout->read(@_)#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge=[];
$He=q#shift->stdin->write(@_)#;
$Ie=bless({$o,$Ge,$q,$He,$s,$t},$u);
$Je={$D7,$Fe,$fb,$Ie};
$Ke=q#/io/pid_io.b#;
$Le=bless({$d2,$Ce,$J2,$K2,$L2,$K2,$M2,$Je,$D,$Ke},$V2);
$Me={};
$Ne=[];
$Oe=q#$_[0]->{external_fds}{$_[1]}#;
$Pe=bless({$o,$Ne,$q,$Oe,$s,$t},$u);
$Qe=[];
$Re=q#shift->fd(2)#;
$Se=bless({$o,$Qe,$q,$Re,$s,$t},$u);
$Te=[];
$Ue=q#shift->fd(0)#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We=[];
$Xe=q#shift->fd(1)#;
$Ye=bless({$o,$We,$q,$Xe,$s,$t},$u);
$Ze={$Q8,$Pe,$U8,$Se,$Y8,$Ve,$e9,$Ye};
$cf=q#/io/pid_accessors.b#;
$df=bless({$d2,$Me,$J2,$K2,$L2,$K2,$M2,$Ze,$D,$cf},$V2);
$ef=[$t7,$fe,$pe,$Be,$Le,$df];
$ff=bless({$d2,$Rd,$D,$I1,$C2,$ef},$m2);
$gf=q#io/pid.c::ctors#;
$hf=q#ni:/io/pid.c#;
$if={$m2,1};
$jf=q#/io/pid.c#;
$kf=[$T7];
$lf=bless({$d2,$if,$D,$jf,$C2,$kf},$D2);
$mf=q#ni:/io/pid_accessors.b#;
$nf=q#ni:/io/pid_init.b#;
$of=q#ni:/io/pid_io.b#;
$pf=q#ni:/io/pid_readers.b#;
$qf=q#ni:/io/pid_wait.b#;
$rf=q#ni:/io/str#;
$sf={$Y3,1};
$tf=q#/io/str#;
$uf={};
$vf=q#data#;
$wf=[];
$xf=q#shift->{'data'}#;
$yf=bless({$o,$wf,$q,$xf,$s,$t},$u);
$zf=q#end#;
$Af=[];
$Bf=q#shift->{'end'}#;
$Cf=bless({$o,$Af,$q,$Bf,$s,$t},$u);
$Df=q#start#;
$Ef=[];
$Ff=q#shift->{'start'}#;
$Gf=bless({$o,$Ef,$q,$Ff,$s,$t},$u);
$Hf={$vf,$yf,$zf,$Cf,$Df,$Gf};
$If=q#/io/str_ro.b#;
$Jf=bless({$d2,$uf,$J2,$K2,$L2,$K2,$M2,$Hf,$D,$If},$V2);
$Kf={};
$Lf=[];
$Mf=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of={$L3,$Nf};
$Pf=q#/io/str_init.b#;
$Qf=bless({$d2,$Kf,$J2,$K2,$L2,$K2,$M2,$Of,$D,$Pf},$V2);
$Rf={};
$Sf=[];
$Tf=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Uf=bless({$o,$Sf,$q,$Tf,$s,$t},$u);
$Vf=q#remaining#;
$Wf=[];
$Xf=q#my $self = shift; $$self{end} - $$self{start}#;
$Yf=bless({$o,$Wf,$q,$Xf,$s,$t},$u);
$Zf=[];
$cg=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$dg=bless({$o,$Zf,$q,$cg,$s,$t},$u);
$eg={$D7,$Uf,$Vf,$Yf,$fb,$dg};
$fg=q#/io/str_io.b#;
$gg=bless({$d2,$Rf,$J2,$K2,$L2,$K2,$M2,$eg,$D,$fg},$V2);
$hg=[$t7,$Jf,$Qf,$gg];
$ig=bless({$d2,$sf,$D,$tf,$C2,$hg},$n2);
$jg=q#io/str.c::ctors#;
$kg=q#ni:/io/str.c#;
$lg={$n2,1};
$mg=q#/io/str.c#;
$ng=[$T7];
$og=bless({$d2,$lg,$D,$mg,$C2,$ng},$D2);
$pg=q#ni:/io/str_init.b#;
$qg=q#ni:/io/str_io.b#;
$rg=q#ni:/io/str_ro.b#;
$sg=q#ni:/lib/accessor.b#;
$tg=q#ni:/lib/behavior#;
$ug=q#ni:/lib/behavior.c#;
$vg=q#ni:/lib/branch#;
$wg={$X2,1};
$xg=q#/lib/branch#;
$yg={};
$zg=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Ag=bless({$q,$zg,$s,$t},$u);
$Bg={$L3,$Ag};
$Cg=q#/lib/branch_init.b#;
$Dg=bless({$d2,$yg,$J2,$K2,$L2,$K2,$M2,$Bg,$D,$Cg},$V2);
$Eg=[$B4,$i3,$W2,$Dg,$u5];
$Fg=bless({$d2,$wg,$D,$xg,$C2,$Eg},$p2);
$Gg=q#lib/branch.c::ctors#;
$Hg=q#ni:/lib/branch.b#;
$Ig=q#ni:/lib/branch.c#;
$Jg={$p2,1};
$Kg=q#/lib/branch.c#;
$Lg=[$i6];
$Mg=bless({$d2,$Jg,$D,$Kg,$C2,$Lg},$D2);
$Ng=q#ni:/lib/branch_init.b#;
$Og=q#ni:/lib/class_init.b#;
$Pg=q#ni:/lib/dataslice#;
$Qg={$c4,1};
$Rg=q#/lib/dataslice#;
$Sg={};
$Tg=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Ug=bless({$q,$Tg,$s,$t},$u);
$Vg={$L3,$Ug};
$Wg=q#/lib/dataslice_init.b#;
$Xg=bless({$d2,$Sg,$J2,$K2,$L2,$K2,$M2,$Vg,$D,$Wg},$V2);
$Yg={};
$Zg=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$ch=bless({$q,$Zg,$s,$t},$u);
$dh={$Q2,$ch};
$eh=q#/lib/dataslice_apply.b#;
$fh=bless({$d2,$Yg,$J2,$K2,$L2,$K2,$M2,$dh,$D,$eh},$V2);
$gh=[$B4,$Xg,$fh];
$hh=bless({$d2,$Qg,$D,$Rg,$C2,$gh},$q2);
$ih=q#lib/dataslice.c::ctors#;
$jh=q#ni:/lib/dataslice.c#;
$kh={$q2,1};
$lh=q#/lib/dataslice.c#;
$mh=[$i6];
$nh=bless({$d2,$kh,$D,$lh,$C2,$mh},$D2);
$oh=q#ni:/lib/dataslice_apply.b#;
$ph=q#ni:/lib/dataslice_init.b#;
$qh=q#ni:/lib/definition.b#;
$rh=q#ni:/lib/definition_def.b#;
$sh=q#ni:/lib/definition_defdata.b#;
$th=q#ni:/lib/doc#;
$uh={$F,1};
$vh={};
$wh=q#shift; +{name => shift, doc => []}#;
$xh=bless({$q,$wh,$s,$t},$u);
$yh={$L3,$xh};
$zh=q#/lib/doc_init.b#;
$Ah=bless({$d2,$vh,$J2,$K2,$L2,$K2,$M2,$yh,$D,$zh},$V2);
$Bh={};
$Ch=q#'ni.doc'#;
$Dh=bless({$q,$Ch,$s,$t},$u);
$Eh={$l3,$Dh};
$Fh=q#/lib/doc_namespace.b#;
$Gh=bless({$d2,$Bh,$J2,$K2,$L2,$K2,$M2,$Eh,$D,$Fh},$V2);
$Hh={};
$Ih=q#AUTOLOAD#;
$Jh=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Kh=bless({$q,$Jh,$s,$t},$u);
$Lh={$Ih,$Kh};
$Mh=q#/lib/doc_define.b#;
$Nh=bless({$d2,$Hh,$J2,$K2,$L2,$K2,$M2,$Lh,$D,$Mh},$V2);
$Oh={};
$Ph=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Qh=bless({$q,$Ph,$s,$t},$u);
$Rh=q#tests#;
$Sh=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Th=bless({$q,$Sh,$s,$t},$u);
$Uh={$n,$Qh,$Rh,$Th};
$Vh=q#/lib/doc_test.b#;
$Wh=bless({$d2,$Oh,$J2,$K2,$L2,$K2,$M2,$Uh,$D,$Vh},$V2);
$Xh=[$q4,$i3,$Ah,$Gh,$Nh,$Wh];
$Yh=bless({$d2,$uh,$D,$Y1,$C2,$Xh},$r2);
$Zh=q#lib/doc.c::ctors#;
$ci=q#ni:/lib/doc.c#;
$di={$r2,1};
$ei=q#/lib/doc.c#;
$fi=[$d6];
$gi=bless({$d2,$di,$D,$ei,$C2,$fi},$D2);
$hi=q#ni:/lib/doc_define.b#;
$ii=q#ni:/lib/doc_init.b#;
$ji=q#ni:/lib/doc_namespace.b#;
$ki=q#ni:/lib/doc_test.b#;
$li=q#ni:/lib/documentable.b#;
$mi=q#ni:/lib/fn#;
$ni={$u,1};
$oi=q#/lib/fn#;
$pi={};
$qi=q#shift->compile#;
$ri=bless({$q,$qi,$s,$t},$u);
$si=q#compile#;
$ti=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$ui=bless({$q,$ti,$s,$t},$u);
$vi=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$wi=bless({$q,$vi,$s,$t},$u);
$xi={$si,$ui,$L3,$wi};
$yi=q#/lib/fn_init.b#;
$zi=bless({$d2,$pi,$J2,$ri,$L2,$K2,$M2,$xi,$D,$yi},$V2);
$Ai={};
$Bi=[];
$Ci=q#shift->{'annotations'}#;
$Di=bless({$o,$Bi,$q,$Ci,$s,$t},$u);
$Ei=[];
$Fi=q#shift->{'code'}#;
$Gi=bless({$o,$Ei,$q,$Fi,$s,$t},$u);
$Hi=q#fn#;
$Ii=[];
$Ji=q#shift->{'fn'}#;
$Ki=bless({$o,$Ii,$q,$Ji,$s,$t},$u);
$Li={$o,$Di,$q,$Gi,$Hi,$Ki};
$Mi=q#/lib/fn_ro.b#;
$Ni=bless({$d2,$Ai,$J2,$K2,$L2,$K2,$M2,$Li,$D,$Mi},$V2);
$Oi={};
$Pi=[];
$Qi=q#shift->{code}#;
$Ri=bless({$o,$Pi,$q,$Qi,$s,$t},$u);
$Si=[];
$Ti=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Ui=bless({$o,$Si,$q,$Ti,$s,$t},$u);
$Vi={$X4,$Ri,$g5,$Ui};
$Wi=q#/lib/fn_ops.b#;
$Xi=bless({$d2,$Oi,$J2,$K2,$L2,$K2,$M2,$Vi,$D,$Wi},$V2);
$Yi={};
$Zi=q#serialize#;
$cj=[];
$dj=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$ej=bless({$o,$cj,$q,$dj,$s,$t},$u);
$fj={$Zi,$ej};
$gj=q#/lib/fn_serialize.b#;
$hj=bless({$d2,$Yi,$J2,$K2,$L2,$K2,$M2,$fj,$D,$gj},$V2);
$ij=[$q4,$I5,$zi,$Ni,$Xi,$hj];
$jj=bless({$d2,$ni,$D,$oi,$C2,$ij},$s2);
$kj=q#lib/fn.c::ctors#;
$lj=q#ni:/lib/fn.c#;
$mj={$s2,1};
$nj=q#/lib/fn.c#;
$oj=[$d6];
$pj=bless({$d2,$mj,$D,$nj,$C2,$oj},$D2);
$qj=q#ni:/lib/fn_init.b#;
$rj=q#ni:/lib/fn_ops.b#;
$sj=q#ni:/lib/fn_ro.b#;
$tj=q#ni:/lib/fn_serialize.b#;
$uj=q#ni:/lib/global_static_test.b#;
$vj={};
$wj=q#now#;
$xj=[];
$yj=q#ni('ni:/lib/test_value')->new(shift)#;
$zj=q#($)#;
$Aj=bless({$o,$xj,$q,$yj,$s,$zj},$u);
$Bj={$wj,$Aj};
$Cj=q#/lib/global_static_test.b#;
$Dj=bless({$d2,$vj,$J2,$K2,$L2,$K2,$M2,$Bj,$D,$Cj},$V2);
$Ej=q#ni:/lib/image#;
$Fj={$d4,1};
$Gj=q#/lib/image#;
$Hj={};
$Ij=[];
$Jj=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Kj=bless({$o,$Ij,$q,$Jj,$s,$t},$u);
$Lj={$L3,$Kj};
$Mj=q#/lib/image_init.b#;
$Nj=bless({$d2,$Hj,$J2,$K2,$L2,$K2,$M2,$Lj,$D,$Mj},$V2);
$Oj={};
$Pj=q#address#;
$Qj=[];
$Rj=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Sj=bless({$o,$Qj,$q,$Rj,$s,$t},$u);
$Tj=q#allocate_gensym#;
$Uj=[];
$Vj=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Wj=bless({$o,$Uj,$q,$Vj,$s,$t},$u);
$Xj=q#boot_side_effect#;
$Yj=[];
$Zj=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$ck=bless({$o,$Yj,$q,$Zj,$s,$t},$u);
$dk=q#circular_arrayref#;
$ek=[];
$fk=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$gk=bless({$o,$ek,$q,$fk,$s,$t},$u);
$hk=q#circular_hashref#;
$ik=[];
$jk=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$kk=bless({$o,$ik,$q,$jk,$s,$t},$u);
$lk=q#circular_links#;
$mk=[];
$nk=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$ok=bless({$o,$mk,$q,$nk,$s,$t},$u);
$pk=q#finalizer#;
$qk=[];
$rk=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk=q#gensym#;
$uk=[];
$vk=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$wk=bless({$o,$uk,$q,$vk,$s,$t},$u);
$xk=q#is_circular#;
$yk=[];
$zk=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$Ak=bless({$o,$yk,$q,$zk,$s,$t},$u);
$Bk=q#quote#;
$Ck=[];
$Dk=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ek=bless({$o,$Ck,$q,$Dk,$s,$t},$u);
$Fk=q#reconstruction#;
$Gk=[];
$Hk=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ik=bless({$o,$Gk,$q,$Hk,$s,$t},$u);
$Jk=q#side_effect#;
$Kk=[];
$Lk=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Mk=bless({$o,$Kk,$q,$Lk,$s,$t},$u);
$Nk=[];
$Ok=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Pk=bless({$o,$Nk,$q,$Ok,$s,$t},$u);
$Qk={$Pj,$Sj,$Tj,$Wj,$Xj,$ck,$dk,$gk,$hk,$kk,$lk,$ok,$pk,$sk,$tk,$wk,$xk,$Ak,$Bk,$Ek,$Fk,$Ik,$Jk,$Mk,$fb,$Pk};
$Rk=q#/lib/image_quoting.b#;
$Sk=bless({$d2,$Oj,$J2,$K2,$L2,$K2,$M2,$Qk,$D,$Rk},$V2);
$Tk={};
$Uk=q#quote_code#;
$Vk=[];
$Wk=q#shift->die('cannot quote perl CODE refs', shift)#;
$Xk=bless({$o,$Vk,$q,$Wk,$s,$t},$u);
$Yk={$Uk,$Xk};
$Zk=q#/lib/no_code_quoting.b#;
$cl=bless({$d2,$Tk,$J2,$K2,$L2,$K2,$M2,$Yk,$D,$Zk},$V2);
$dl={};
$el=q#quote_array#;
$fl=[];
$gl=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$hl=bless({$o,$fl,$q,$gl,$s,$t},$u);
$il=q#quote_hash#;
$jl=[];
$kl=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$ll=bless({$o,$jl,$q,$kl,$s,$t},$u);
$ml=q#quote_scalar#;
$nl=[];
$ol=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$pl=bless({$o,$nl,$q,$ol,$s,$t},$u);
$ql=q#quote_scalar_ref#;
$rl=[];
$sl=q#'\\\\' . shift->quote(${$_[0]})#;
$tl=bless({$o,$rl,$q,$sl,$s,$t},$u);
$ul=q#quote_value#;
$vl=[];
$wl=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$xl=bless({$o,$vl,$q,$wl,$s,$t},$u);
$yl={$el,$hl,$il,$ll,$ml,$pl,$ql,$tl,$ul,$xl};
$zl=q#/lib/quote_values.b#;
$Al=bless({$d2,$dl,$J2,$K2,$L2,$K2,$M2,$yl,$D,$zl},$V2);
$Bl={};
$Cl=q#quote_blessed#;
$Dl=[];
$El=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Fl=bless({$o,$Dl,$q,$El,$s,$t},$u);
$Gl=q#quote_class#;
$Hl=[];
$Il=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Jl=bless({$o,$Hl,$q,$Il,$s,$t},$u);
$Kl=q#quote_object#;
$Ll=[];
$Ml=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Nl=bless({$o,$Ll,$q,$Ml,$s,$t},$u);
$Ol={$Cl,$Fl,$Gl,$Jl,$Kl,$Nl};
$Pl=q#/lib/quote_objects.b#;
$Ql=bless({$d2,$Bl,$J2,$K2,$L2,$K2,$M2,$Ol,$D,$Pl},$V2);
$Rl=[$q4,$Nj,$Sk,$cl,$Al,$Ql];
$Sl=bless({$d2,$Fj,$D,$Gj,$C2,$Rl},$t2);
$Tl=q#lib/image.c::ctors#;
$Ul=q#ni:/lib/image.c#;
$Vl={$t2,1};
$Wl=q#/lib/image.c#;
$Xl=[$d6];
$Yl=bless({$d2,$Vl,$D,$Wl,$C2,$Xl},$D2);
$Zl=q#ni:/lib/image_init.b#;
$cm=q#ni:/lib/image_quoting.b#;
$dm=q#ni:/lib/instance.b#;
$em=q#ni:/lib/instantiable.b#;
$fm=q#ni:/lib/json.b#;
$gm={};
$hm=q#json_decode#;
$im=[];
$jm=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$km=bless({$o,$im,$q,$jm,$s,$zj},$u);
$lm=q#json_encode#;
$mm=[];
$nm=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$om=bless({$o,$mm,$q,$nm,$s,$zj},$u);
$pm=q#json_escape#;
$qm=[];
$rm=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$sm=bless({$o,$qm,$q,$rm,$s,$zj},$u);
$tm=q#json_unescape#;
$um=[];
$vm=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$wm=bless({$o,$um,$q,$vm,$s,$zj},$u);
$xm=q#json_unescape_one#;
$ym=[];
$zm=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Am=bless({$o,$ym,$q,$zm,$s,$zj},$u);
$Bm={$hm,$km,$lm,$om,$pm,$sm,$tm,$wm,$xm,$Am};
$Cm=q#/lib/json.b#;
$Dm=bless({$d2,$gm,$J2,$K2,$L2,$K2,$M2,$Bm,$D,$Cm},$V2);
$Em=q#ni#;
$Fm=q#ni:/lib/name_as_string.b#;
$Gm=q#ni:/lib/named.b#;
$Hm=q#ni:/lib/named_in_ni.b#;
$Im=q#ni:/lib/namespaced.b#;
$Jm=q#ni:/lib/ni#;
$Km={$e4,1};
$Lm=q#/lib/ni#;
$Mm={};
$Nm=q#extend#;
$Om=[];
$Pm=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Qm=bless({$o,$Om,$q,$Pm,$s,$t},$u);
$Rm=q#is_mutable#;
$Sm=[];
$Tm=q#$0 ne "-" && -w $0#;
$Um=bless({$o,$Sm,$q,$Tm,$s,$t},$u);
$Vm=q#modify#;
$Wm=[];
$Xm=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Ym=bless({$o,$Wm,$q,$Xm,$s,$t},$u);
$Zm={$Nm,$Qm,$Rm,$Um,$Vm,$Ym};
$cn=q#/lib/ni_self.b#;
$dn=bless({$d2,$Mm,$J2,$K2,$L2,$K2,$M2,$Zm,$D,$cn},$V2);
$en={};
$fn=q#exists#;
$gn=[];
$hn=q#exists $_[0]->{named}{$_[1]}#;
$in=bless({$o,$gn,$q,$hn,$s,$t},$u);
$jn=q#quoted#;
$kn=[];
$ln=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$mn=bless({$o,$kn,$q,$ln,$s,$t},$u);
$nn={$fn,$in,$jn,$mn};
$on=q#/lib/ni_image.b#;
$pn=bless({$d2,$en,$J2,$K2,$L2,$K2,$M2,$nn,$D,$on},$V2);
$qn={};
$rn=q#--internal/+=#;
$sn=[];
$tn=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$un=bless({$o,$sn,$q,$tn,$s,$t},$u);
$vn=q#--internal/eval#;
$wn=[];
$xn=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$yn=bless({$o,$wn,$q,$xn,$s,$t},$u);
$zn=q#--internal/image#;
$An=[];
$Bn=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Cn=bless({$o,$An,$q,$Bn,$s,$t},$u);
$Dn=q#--internal/test#;
$En=[];
$Fn=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Gn=bless({$o,$En,$q,$Fn,$s,$t},$u);
$Hn=q#run#;
$In=[];
$Jn=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Kn=bless({$o,$In,$q,$Jn,$s,$t},$u);
$Ln={$rn,$un,$vn,$yn,$zn,$Cn,$Dn,$Gn,$Hn,$Kn};
$Mn=q#/lib/ni_main.b#;
$Nn=bless({$d2,$qn,$J2,$K2,$L2,$K2,$M2,$Ln,$D,$Mn},$V2);
$On={};
$Pn=[];
$Qn=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Rn=bless({$o,$Pn,$q,$Qn,$s,$t},$u);
$Sn=q#resolver_for#;
$Tn=[];
$Un=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Vn=bless({$o,$Tn,$q,$Un,$s,$t},$u);
$Wn={$z3,$Rn,$Sn,$Vn};
$Xn=q#/lib/ni_resolver.b#;
$Yn=bless({$d2,$On,$J2,$K2,$L2,$K2,$M2,$Wn,$D,$Xn},$V2);
$Zn=[$q4,$dn,$pn,$Nn,$Yn];
$co=bless({$d2,$Km,$D,$Lm,$C2,$Zn},$u2);
$do=q#lib/ni.c::ctors#;
$eo=q#ni:/lib/ni.c#;
$fo={$u2,1};
$go=q#/lib/ni.c#;
$ho=[$d6];
$io=bless({$d2,$fo,$D,$go,$C2,$ho},$D2);
$jo=q#ni:/lib/ni_image.b#;
$ko=q#ni:/lib/ni_main.b#;
$lo=q#ni:/lib/ni_resolver.b#;
$mo=q#ni:/lib/ni_self.b#;
$no=q#ni:/lib/ni_static_util.b#;
$oo={};
$po=q#abbrev#;
$qo=[];
$ro=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$so=bless({$o,$qo,$q,$ro,$s,$t},$u);
$to=q#dor#;
$uo=[];
$vo=q#defined $_[0] ? $_[0] : $_[1]#;
$wo=bless({$o,$uo,$q,$vo,$s,$t},$u);
$xo=q#indent#;
$yo=[];
$zo=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Ao=bless({$o,$yo,$q,$zo,$s,$t},$u);
$Bo=q#max#;
$Co=[];
$Do=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Eo=bless({$o,$Co,$q,$Do,$s,$t},$u);
$Fo=q#maxstr#;
$Go=[];
$Ho=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo=q#mean#;
$Ko=[];
$Lo=q#sum(@_) / (@_ || 1)#;
$Mo=bless({$o,$Ko,$q,$Lo,$s,$t},$u);
$No=q#min#;
$Oo=[];
$Po=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Qo=bless({$o,$Oo,$q,$Po,$s,$t},$u);
$Ro=q#minstr#;
$So=[];
$To=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Uo=bless({$o,$So,$q,$To,$s,$t},$u);
$Vo=q#sgr#;
$Wo=[];
$Xo=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Yo=bless({$o,$Wo,$q,$Xo,$s,$t},$u);
$Zo=q#sr#;
$cp=[];
$dp=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$ep=bless({$o,$cp,$q,$dp,$s,$t},$u);
$fp=q#sum#;
$gp=[];
$hp=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$ip=bless({$o,$gp,$q,$hp,$s,$t},$u);
$jp=q#swap#;
$kp=[];
$lp=q#@_[0, 1] = @_[1, 0]#;
$mp=bless({$o,$kp,$q,$lp,$s,$t},$u);
$np={$po,$so,$to,$wo,$xo,$Ao,$Bo,$Eo,$Fo,$Io,$Jo,$Mo,$No,$Qo,$Ro,$Uo,$Vo,$Yo,$Zo,$ep,$fp,$ip,$jp,$mp};
$op=q#/lib/ni_static_util.b#;
$pp=bless({$d2,$oo,$J2,$K2,$L2,$K2,$M2,$np,$D,$op},$V2);
$qp=q#ni:/lib/no_code_quoting.b#;
$rp=q#ni:/lib/perlbranch.b#;
$sp=q#ni:/lib/quote_objects.b#;
$tp=q#ni:/lib/quote_values.b#;
$up=q#ni:/lib/ref_eq.b#;
$vp=q#ni:/lib/resolver.b#;
$wp=q#ni:/lib/slice#;
$xp={$V2,1};
$yp=q#/lib/slice#;
$zp=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Ap=bless({$q,$zp,$s,$t},$u);
$Bp=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Cp=bless({$q,$Bp,$s,$t},$u);
$Dp=q#lib/slice::apply#;
$Ep=q#lib/slice::apply_unsafe#;
$Fp={};
$Gp=q#apply_unsafe#;
$Hp={$Q2,$Ap,$Gp,$Cp};
$Ip=q#/lib/slice.b#;
$Jp=bless({$d2,$Fp,$M2,$Hp,$D,$Ip},$V2);
$Kp={};
$Lp=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Mp=bless({$q,$Lp,$s,$t},$u);
$Np={$L3,$Mp};
$Op=q#/lib/slice_init.b#;
$Pp=bless({$d2,$Kp,$M2,$Np,$D,$Op},$V2);
$Qp={};
$Rp=[];
$Sp=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Tp=bless({$o,$Rp,$q,$Sp,$s,$t},$u);
$Up={$Zi,$Tp};
$Vp=q#/lib/slice_serialize.b#;
$Wp=bless({$d2,$Qp,$J2,$K2,$L2,$K2,$M2,$Up,$D,$Vp},$V2);
$Xp=[$B4,$i3,$Jp,$Pp,$Wp];
$Yp=bless({$d2,$xp,$D,$yp,$C2,$Xp},$v2);
$Zp=q#lib/slice.c::ctors#;
$cq=q#ni:/lib/slice.b#;
$dq=q#ni:/lib/slice.c#;
$eq={$v2,1};
$fq=q#/lib/slice.c#;
$gq=[$i6];
$hq=bless({$d2,$eq,$D,$fq,$C2,$gq},$D2);
$iq=q#ni:/lib/slice_init.b#;
$jq=q#ni:/lib/slice_serialize.b#;
$kq=q#ni:/lib/static_fn.b#;
$lq={};
$mq=[];
$nq=q#ni('ni:/lib/fn')->new(@_)#;
$oq=bless({$o,$mq,$q,$nq,$s,$zj},$u);
$pq=q#fp#;
$qq=[];
$rq=q#($$)#;
$sq=bless({$o,$qq,$q,$nq,$s,$rq},$u);
$tq={$Hi,$oq,$pq,$sq};
$uq=q#/lib/static_fn.b#;
$vq=bless({$d2,$lq,$J2,$K2,$L2,$K2,$M2,$tq,$D,$uq},$V2);
$wq=q#ni:/lib/subclass.b#;
$xq=q#ni:/lib/tag#;
$yq={$j3,1};
$zq=q#/lib/tag#;
$Aq={};
$Bq=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Cq=bless({$q,$Bq,$s,$t},$u);
$Dq={$Q2,$Cq};
$Eq=q#/lib/tag.b#;
$Fq=bless({$d2,$Aq,$J2,$K2,$L2,$K2,$M2,$Dq,$D,$Eq},$V2);
$Gq={};
$Hq=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Iq=bless({$q,$Hq,$s,$t},$u);
$Jq={$L3,$Iq};
$Kq=q#/lib/tag_init.b#;
$Lq=bless({$d2,$Gq,$J2,$K2,$L2,$K2,$M2,$Jq,$D,$Kq},$V2);
$Mq=[$B4,$i3,$Fq,$Lq];
$Nq=bless({$d2,$yq,$D,$zq,$C2,$Mq},$w2);
$Oq=q#lib/tag.c::ctors#;
$Pq=q#ni:/lib/tag.b#;
$Qq=q#ni:/lib/tag.c#;
$Rq={$w2,1};
$Sq=q#/lib/tag.c#;
$Tq=[$i6];
$Uq=bless({$d2,$Rq,$D,$Sq,$C2,$Tq},$D2);
$Vq=q#ni:/lib/tag_init.b#;
$Wq=q#ni:/lib/test_value#;
$Xq={$f4,1};
$Yq=q#/lib/test_value#;
$Zq={};
$cr=[];
$dr=q#\\$_[1]#;
$er=bless({$o,$cr,$q,$dr,$s,$t},$u);
$fr={$L3,$er};
$gr=q#/lib/test_value_init.b#;
$hr=bless({$d2,$Zq,$J2,$K2,$L2,$K2,$M2,$fr,$D,$gr},$V2);
$ir={};
$jr=q#(==#;
$kr=[];
$lr=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$mr=bless({$o,$kr,$q,$lr,$s,$t},$u);
$nr=q#diff#;
$or=[];
$pr=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$qr=bless({$o,$or,$q,$pr,$s,$t},$u);
$rr={$jr,$mr,$nr,$qr};
$sr=q#/lib/test_value_eq.b#;
$tr=bless({$d2,$ir,$J2,$K2,$L2,$K2,$M2,$rr,$D,$sr},$V2);
$ur={};
$vr=[];
$wr=q#ni::json_encode ${$_[0]}#;
$xr=bless({$o,$vr,$q,$wr,$s,$t},$u);
$yr={$X4,$xr};
$zr=q#/lib/test_value_str.b#;
$Ar=bless({$d2,$ur,$J2,$K2,$L2,$K2,$M2,$yr,$D,$zr},$V2);
$Br=[$q4,$hr,$tr,$Ar];
$Cr=bless({$d2,$Xq,$D,$Yq,$C2,$Br},$x2);
$Dr=q#lib/test_value.c::ctors#;
$Er=q#ni:/lib/test_value.c#;
$Fr={$x2,1};
$Gr=q#/lib/test_value.c#;
$Hr=[$d6];
$Ir=bless({$d2,$Fr,$D,$Gr,$C2,$Hr},$D2);
$Jr=q#ni:/lib/test_value_eq.b#;
$Kr=q#ni:/lib/test_value_init.b#;
$Lr=q#ni:/lib/test_value_str.b#;
$Mr=q#ni:/metaclass#;
$Nr={$D2,1};
$Or=q#/metaclass#;
$Pr=[$G3,$I5,$Q3,$x5];
$Qr=bless({$d2,$Nr,$D,$Or,$C2,$Pr},$y2);
$Rr=q#metaclass.c::ctors#;
$Sr=q#ni:/metaclass.c#;
$Tr={$y2,1};
$Ur=q#/metaclass.c#;
$Vr=[$R5];
$Wr=bless({$d2,$Tr,$D,$Ur,$C2,$Vr},$D2);
$Xr=q#ni:/module#;
$Yr=q#ni:/module.c#;
$Zr=q#ni:/object#;
$cs=q#ni:/object.c#;
$ds=q#ni:main#;
$es={$Zc,1};
$fs=[$vq,$Dj,$Yc];
$gs=bless({$d2,$es,$D,$Zc,$C2,$fs},$E2);
$hs=q#module::ctors#;
$is=q#ni:ni#;
$js={$Em,1};
$ks={$Em,1};
$ls=q#json_escapes#;
$ms=q##;
$ns=q#b#;
$os=q#	#;
$ps=q#t#;
$qs=q#
#;
$rs=q#n#;
$ss=q##;
$ts=q#"#;
$us=q#/#;
$vs=q#\\#;
$ws={$ms,$ns,$os,$ps,$qs,$rs,$ss,$cc,$ts,$ts,$us,$us,$vs,$vs};
$xs=q#json_unescapes#;
$ys={$ts,$ts,$us,$us,$vs,$vs,$ns,$ms,$rs,$qs,$cc,$ss,$ps,$os};
$zs={$ls,$ws,$xs,$ys};
$As=q#/lib/json_data.b#;
$Bs=bless({$d2,$ks,$vf,$zs,$D,$As},$c4);
$Cs=q#lib/dataslice::ctors#;
$Ds=[$Bs,$Dm,$pp];
$Es=bless({$d2,$js,$D,$Em,$C2,$Ds},$E2);
$Fs={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$Z1,$c2,$R5,$T5,$m6,$n6,$L7,$N7,$V7,$W7,$B7,$X7,$J7,$Y7,$K9,$M9,$Q9,$R9,$s9,$S9,$I9,$T9,$q8,$U9,$k9,$V9,$K8,$W9,$j8,$X9,$nb,$pb,$tb,$ub,$Na,$vb,$Ya,$wb,$pa,$xb,$lb,$yb,$ia,$zb,$xa,$Ab,$uc,$wc,$Ac,$Bc,$Rb,$Cc,$Yb,$Dc,$sc,$Ec,$Jb,$Fc,$Yc,$cd,$Ad,$Cd,$Gd,$Hd,$ld,$Id,$yd,$Jd,$t7,$Kd,$T7,$Ld,$Z6,$Md,$j7,$Nd,$r7,$Od,$x6,$Pd,$F6,$Qd,$ff,$hf,$lf,$mf,$df,$nf,$pe,$of,$Le,$pf,$fe,$qf,$Be,$rf,$ig,$kg,$og,$pg,$Qf,$qg,$gg,$rg,$Jf,$sg,$V4,$tg,$B4,$ug,$i6,$vg,$Fg,$Hg,$W2,$Ig,$Mg,$Ng,$Dg,$Og,$Q3,$Pg,$hh,$jh,$nh,$oh,$fh,$ph,$Xg,$qh,$u5,$rh,$L4,$sh,$s5,$th,$Yh,$ci,$gi,$hi,$Nh,$ii,$Ah,$ji,$Gh,$ki,$Wh,$li,$z4,$mi,$jj,$lj,$pj,$qj,$zi,$rj,$Xi,$sj,$Ni,$tj,$hj,$uj,$Dj,$Ej,$Sl,$Ul,$Yl,$Zl,$Nj,$cm,$Sk,$dm,$o4,$em,$I5,$fm,$Dm,$Fm,$e5,$Gm,$i3,$Hm,$q3,$Im,$x3,$Jm,$co,$eo,$io,$jo,$pn,$ko,$Nn,$lo,$Yn,$mo,$dn,$no,$pp,$qp,$cl,$rp,$G3,$sp,$Ql,$tp,$Al,$up,$l5,$vp,$E3,$wp,$Yp,$cq,$Jp,$dq,$hq,$iq,$Pp,$jq,$Wp,$kq,$vq,$wq,$P5,$xq,$Nq,$Pq,$Fq,$Qq,$Uq,$Vq,$Lq,$Wq,$Cr,$Er,$Ir,$Jr,$tr,$Kr,$hr,$Lr,$Ar,$Mr,$Qr,$Sr,$Wr,$Xr,$x5,$Yr,$k6,$Zr,$q4,$cs,$d6,$ds,$gs,$is,$Es};
$Gs=q#resolvers#;
$Hs=[];
$Is=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Js=bless({$o,$Hs,$q,$Is,$s,$t},$u);
$Ks=q#file#;
$Ls=[];
$Ms=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Ns=bless({$o,$Ls,$q,$Ms,$s,$t},$u);
$Os=q#null#;
$Ps=[];
$Qs=q#ni('ni:/io/null')->new#;
$Rs=bless({$o,$Ps,$q,$Qs,$s,$t},$u);
$Ss=q#sh#;
$Ts=[];
$Us=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Vs=bless({$o,$Ts,$q,$Us,$s,$t},$u);
$Ws=q#str#;
$Xs=[];
$Ys=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Zs=bless({$o,$Xs,$q,$Ys,$s,$t},$u);
$ct={$Q8,$Js,$Ks,$Ns,$Os,$Rs,$Ss,$Vs,$Ws,$Zs};
$dt=bless({$c,$Fs,$Gs,$ct},$e4);
$et=q#lib/ni::ctors#;
*$Ep=\&$Cp;
*$Dp=\&$Ap;
$W2->apply_unsafe($e2);
$W2->apply_unsafe($f2);
$W2->apply_unsafe($g2);
$W2->apply_unsafe($h2);
$W2->apply_unsafe($i2);
$W2->apply_unsafe($j2);
$W2->apply_unsafe($k2);
$W2->apply_unsafe($l2);
$W2->apply_unsafe($m2);
$W2->apply_unsafe($n2);
$W2->apply_unsafe($o2);
$W2->apply_unsafe($X2);
$W2->apply_unsafe($p2);
$W2->apply_unsafe($q2);
$W2->apply_unsafe($r2);
$W2->apply_unsafe($s2);
$W2->apply_unsafe($t2);
$W2->apply_unsafe($u2);
$W2->apply_unsafe($v2);
$W2->apply_unsafe($w2);
$W2->apply_unsafe($x2);
$W2->apply_unsafe($D2);
$W2->apply_unsafe($y2);
$W2->apply_unsafe($E2);
$W2->apply_unsafe($z2);
$W2->apply_unsafe($A2);
$i3->apply_unsafe($e2);
$i3->apply_unsafe($f2);
$i3->apply_unsafe($g2);
$i3->apply_unsafe($h2);
$i3->apply_unsafe($i2);
$i3->apply_unsafe($j2);
$i3->apply_unsafe($k2);
$i3->apply_unsafe($l2);
$i3->apply_unsafe($m2);
$i3->apply_unsafe($n2);
$i3->apply_unsafe($o2);
$i3->apply_unsafe($X2);
$i3->apply_unsafe($p2);
$i3->apply_unsafe($q2);
$i3->apply_unsafe($F);
$i3->apply_unsafe($r2);
$i3->apply_unsafe($s2);
$i3->apply_unsafe($t2);
$i3->apply_unsafe($u2);
$i3->apply_unsafe($V2);
$i3->apply_unsafe($v2);
$i3->apply_unsafe($j3);
$i3->apply_unsafe($w2);
$i3->apply_unsafe($x2);
$i3->apply_unsafe($D2);
$i3->apply_unsafe($y2);
$i3->apply_unsafe($E2);
$i3->apply_unsafe($z2);
$i3->apply_unsafe($A2);
$q3->apply_unsafe($e2);
$q3->apply_unsafe($f2);
$q3->apply_unsafe($g2);
$q3->apply_unsafe($h2);
$q3->apply_unsafe($i2);
$q3->apply_unsafe($j2);
$q3->apply_unsafe($k2);
$q3->apply_unsafe($l2);
$q3->apply_unsafe($m2);
$q3->apply_unsafe($n2);
$q3->apply_unsafe($o2);
$q3->apply_unsafe($X2);
$q3->apply_unsafe($p2);
$q3->apply_unsafe($q2);
$q3->apply_unsafe($r2);
$q3->apply_unsafe($s2);
$q3->apply_unsafe($t2);
$q3->apply_unsafe($u2);
$q3->apply_unsafe($V2);
$q3->apply_unsafe($v2);
$q3->apply_unsafe($j3);
$q3->apply_unsafe($w2);
$q3->apply_unsafe($x2);
$q3->apply_unsafe($D2);
$q3->apply_unsafe($y2);
$q3->apply_unsafe($E2);
$q3->apply_unsafe($z2);
$q3->apply_unsafe($A2);
$x3->apply_unsafe($e2);
$x3->apply_unsafe($f2);
$x3->apply_unsafe($g2);
$x3->apply_unsafe($h2);
$x3->apply_unsafe($i2);
$x3->apply_unsafe($j2);
$x3->apply_unsafe($k2);
$x3->apply_unsafe($l2);
$x3->apply_unsafe($m2);
$x3->apply_unsafe($n2);
$x3->apply_unsafe($o2);
$x3->apply_unsafe($X2);
$x3->apply_unsafe($p2);
$x3->apply_unsafe($q2);
$x3->apply_unsafe($r2);
$x3->apply_unsafe($s2);
$x3->apply_unsafe($t2);
$x3->apply_unsafe($u2);
$x3->apply_unsafe($V2);
$x3->apply_unsafe($v2);
$x3->apply_unsafe($j3);
$x3->apply_unsafe($w2);
$x3->apply_unsafe($x2);
$x3->apply_unsafe($D2);
$x3->apply_unsafe($y2);
$x3->apply_unsafe($E2);
$x3->apply_unsafe($z2);
$x3->apply_unsafe($A2);
$E3->apply_unsafe($e2);
$E3->apply_unsafe($f2);
$E3->apply_unsafe($g2);
$E3->apply_unsafe($h2);
$E3->apply_unsafe($i2);
$E3->apply_unsafe($j2);
$E3->apply_unsafe($k2);
$E3->apply_unsafe($l2);
$E3->apply_unsafe($m2);
$E3->apply_unsafe($n2);
$E3->apply_unsafe($o2);
$E3->apply_unsafe($X2);
$E3->apply_unsafe($p2);
$E3->apply_unsafe($q2);
$E3->apply_unsafe($r2);
$E3->apply_unsafe($s2);
$E3->apply_unsafe($t2);
$E3->apply_unsafe($u2);
$E3->apply_unsafe($v2);
$E3->apply_unsafe($j3);
$E3->apply_unsafe($w2);
$E3->apply_unsafe($x2);
$E3->apply_unsafe($D2);
$E3->apply_unsafe($y2);
$E3->apply_unsafe($E2);
$E3->apply_unsafe($z2);
$E3->apply_unsafe($A2);
$Q3->apply_unsafe($e2);
$Q3->apply_unsafe($f2);
$Q3->apply_unsafe($g2);
$Q3->apply_unsafe($h2);
$Q3->apply_unsafe($i2);
$Q3->apply_unsafe($j2);
$Q3->apply_unsafe($k2);
$Q3->apply_unsafe($l2);
$Q3->apply_unsafe($m2);
$Q3->apply_unsafe($n2);
$Q3->apply_unsafe($o2);
$Q3->apply_unsafe($p2);
$Q3->apply_unsafe($q2);
$Q3->apply_unsafe($r2);
$Q3->apply_unsafe($s2);
$Q3->apply_unsafe($t2);
$Q3->apply_unsafe($u2);
$Q3->apply_unsafe($v2);
$Q3->apply_unsafe($w2);
$Q3->apply_unsafe($x2);
$Q3->apply_unsafe($D2);
$Q3->apply_unsafe($y2);
$Q3->apply_unsafe($E2);
$Q3->apply_unsafe($z2);
$Q3->apply_unsafe($A2);
$o4->apply_unsafe($e2);
$o4->apply_unsafe($f2);
$o4->apply_unsafe($R3);
$o4->apply_unsafe($g2);
$o4->apply_unsafe($S3);
$o4->apply_unsafe($h2);
$o4->apply_unsafe($T3);
$o4->apply_unsafe($i2);
$o4->apply_unsafe($U3);
$o4->apply_unsafe($j2);
$o4->apply_unsafe($V3);
$o4->apply_unsafe($k2);
$o4->apply_unsafe($W3);
$o4->apply_unsafe($l2);
$o4->apply_unsafe($X3);
$o4->apply_unsafe($m2);
$o4->apply_unsafe($Y3);
$o4->apply_unsafe($n2);
$o4->apply_unsafe($Z3);
$o4->apply_unsafe($o2);
$o4->apply_unsafe($X2);
$o4->apply_unsafe($p2);
$o4->apply_unsafe($c4);
$o4->apply_unsafe($q2);
$o4->apply_unsafe($F);
$o4->apply_unsafe($r2);
$o4->apply_unsafe($u);
$o4->apply_unsafe($s2);
$o4->apply_unsafe($d4);
$o4->apply_unsafe($t2);
$o4->apply_unsafe($e4);
$o4->apply_unsafe($u2);
$o4->apply_unsafe($V2);
$o4->apply_unsafe($v2);
$o4->apply_unsafe($j3);
$o4->apply_unsafe($w2);
$o4->apply_unsafe($f4);
$o4->apply_unsafe($x2);
$o4->apply_unsafe($D2);
$o4->apply_unsafe($y2);
$o4->apply_unsafe($E2);
$o4->apply_unsafe($z2);
$o4->apply_unsafe($g4);
$o4->apply_unsafe($A2);
$z4->apply_unsafe($e2);
$z4->apply_unsafe($f2);
$z4->apply_unsafe($g2);
$z4->apply_unsafe($h2);
$z4->apply_unsafe($i2);
$z4->apply_unsafe($j2);
$z4->apply_unsafe($k2);
$z4->apply_unsafe($l2);
$z4->apply_unsafe($m2);
$z4->apply_unsafe($n2);
$z4->apply_unsafe($Z3);
$z4->apply_unsafe($o2);
$z4->apply_unsafe($X2);
$z4->apply_unsafe($p2);
$z4->apply_unsafe($c4);
$z4->apply_unsafe($q2);
$z4->apply_unsafe($r2);
$z4->apply_unsafe($s2);
$z4->apply_unsafe($t2);
$z4->apply_unsafe($u2);
$z4->apply_unsafe($V2);
$z4->apply_unsafe($v2);
$z4->apply_unsafe($j3);
$z4->apply_unsafe($w2);
$z4->apply_unsafe($x2);
$z4->apply_unsafe($D2);
$z4->apply_unsafe($y2);
$z4->apply_unsafe($E2);
$z4->apply_unsafe($z2);
$z4->apply_unsafe($A2);
$L4->apply_unsafe($e2);
$L4->apply_unsafe($f2);
$L4->apply_unsafe($g2);
$L4->apply_unsafe($h2);
$L4->apply_unsafe($i2);
$L4->apply_unsafe($j2);
$L4->apply_unsafe($k2);
$L4->apply_unsafe($l2);
$L4->apply_unsafe($m2);
$L4->apply_unsafe($n2);
$L4->apply_unsafe($o2);
$L4->apply_unsafe($X2);
$L4->apply_unsafe($p2);
$L4->apply_unsafe($q2);
$L4->apply_unsafe($r2);
$L4->apply_unsafe($s2);
$L4->apply_unsafe($t2);
$L4->apply_unsafe($u2);
$L4->apply_unsafe($v2);
$L4->apply_unsafe($w2);
$L4->apply_unsafe($x2);
$L4->apply_unsafe($D2);
$L4->apply_unsafe($y2);
$L4->apply_unsafe($E2);
$L4->apply_unsafe($z2);
$L4->apply_unsafe($A2);
$V4->apply_unsafe($e2);
$V4->apply_unsafe($f2);
$V4->apply_unsafe($g2);
$V4->apply_unsafe($h2);
$V4->apply_unsafe($i2);
$V4->apply_unsafe($j2);
$V4->apply_unsafe($k2);
$V4->apply_unsafe($l2);
$V4->apply_unsafe($m2);
$V4->apply_unsafe($n2);
$V4->apply_unsafe($o2);
$V4->apply_unsafe($X2);
$V4->apply_unsafe($p2);
$V4->apply_unsafe($q2);
$V4->apply_unsafe($r2);
$V4->apply_unsafe($s2);
$V4->apply_unsafe($t2);
$V4->apply_unsafe($u2);
$V4->apply_unsafe($v2);
$V4->apply_unsafe($w2);
$V4->apply_unsafe($x2);
$V4->apply_unsafe($D2);
$V4->apply_unsafe($y2);
$V4->apply_unsafe($E2);
$V4->apply_unsafe($z2);
$V4->apply_unsafe($A2);
$e5->apply_unsafe($e2);
$e5->apply_unsafe($f2);
$e5->apply_unsafe($g2);
$e5->apply_unsafe($h2);
$e5->apply_unsafe($i2);
$e5->apply_unsafe($j2);
$e5->apply_unsafe($k2);
$e5->apply_unsafe($l2);
$e5->apply_unsafe($m2);
$e5->apply_unsafe($n2);
$e5->apply_unsafe($o2);
$e5->apply_unsafe($X2);
$e5->apply_unsafe($p2);
$e5->apply_unsafe($q2);
$e5->apply_unsafe($r2);
$e5->apply_unsafe($s2);
$e5->apply_unsafe($t2);
$e5->apply_unsafe($u2);
$e5->apply_unsafe($v2);
$e5->apply_unsafe($w2);
$e5->apply_unsafe($x2);
$e5->apply_unsafe($D2);
$e5->apply_unsafe($y2);
$e5->apply_unsafe($E2);
$e5->apply_unsafe($z2);
$e5->apply_unsafe($A2);
$l5->apply_unsafe($e2);
$l5->apply_unsafe($f2);
$l5->apply_unsafe($g2);
$l5->apply_unsafe($h2);
$l5->apply_unsafe($i2);
$l5->apply_unsafe($j2);
$l5->apply_unsafe($k2);
$l5->apply_unsafe($l2);
$l5->apply_unsafe($m2);
$l5->apply_unsafe($n2);
$l5->apply_unsafe($o2);
$l5->apply_unsafe($X2);
$l5->apply_unsafe($p2);
$l5->apply_unsafe($q2);
$l5->apply_unsafe($r2);
$l5->apply_unsafe($s2);
$l5->apply_unsafe($t2);
$l5->apply_unsafe($u2);
$l5->apply_unsafe($v2);
$l5->apply_unsafe($w2);
$l5->apply_unsafe($x2);
$l5->apply_unsafe($D2);
$l5->apply_unsafe($y2);
$l5->apply_unsafe($E2);
$l5->apply_unsafe($z2);
$l5->apply_unsafe($A2);
$s5->apply_unsafe($e2);
$s5->apply_unsafe($f2);
$s5->apply_unsafe($g2);
$s5->apply_unsafe($h2);
$s5->apply_unsafe($i2);
$s5->apply_unsafe($j2);
$s5->apply_unsafe($k2);
$s5->apply_unsafe($l2);
$s5->apply_unsafe($m2);
$s5->apply_unsafe($n2);
$s5->apply_unsafe($o2);
$s5->apply_unsafe($X2);
$s5->apply_unsafe($p2);
$s5->apply_unsafe($q2);
$s5->apply_unsafe($r2);
$s5->apply_unsafe($s2);
$s5->apply_unsafe($t2);
$s5->apply_unsafe($u2);
$s5->apply_unsafe($v2);
$s5->apply_unsafe($w2);
$s5->apply_unsafe($x2);
$s5->apply_unsafe($D2);
$s5->apply_unsafe($y2);
$s5->apply_unsafe($E2);
$s5->apply_unsafe($z2);
$s5->apply_unsafe($A2);
$I5->apply_unsafe($e2);
$I5->apply_unsafe($f2);
$I5->apply_unsafe($g2);
$I5->apply_unsafe($h2);
$I5->apply_unsafe($i2);
$I5->apply_unsafe($j2);
$I5->apply_unsafe($k2);
$I5->apply_unsafe($l2);
$I5->apply_unsafe($m2);
$I5->apply_unsafe($n2);
$I5->apply_unsafe($o2);
$I5->apply_unsafe($p2);
$I5->apply_unsafe($q2);
$I5->apply_unsafe($r2);
$I5->apply_unsafe($u);
$I5->apply_unsafe($s2);
$I5->apply_unsafe($t2);
$I5->apply_unsafe($u2);
$I5->apply_unsafe($V2);
$I5->apply_unsafe($v2);
$I5->apply_unsafe($j3);
$I5->apply_unsafe($w2);
$I5->apply_unsafe($x2);
$I5->apply_unsafe($D2);
$I5->apply_unsafe($y2);
$I5->apply_unsafe($z2);
$I5->apply_unsafe($A2);
$P5->apply_unsafe($e2);
$P5->apply_unsafe($f2);
$P5->apply_unsafe($g2);
$P5->apply_unsafe($h2);
$P5->apply_unsafe($i2);
$P5->apply_unsafe($j2);
$P5->apply_unsafe($k2);
$P5->apply_unsafe($l2);
$P5->apply_unsafe($m2);
$P5->apply_unsafe($n2);
$P5->apply_unsafe($o2);
$P5->apply_unsafe($p2);
$P5->apply_unsafe($q2);
$P5->apply_unsafe($r2);
$P5->apply_unsafe($s2);
$P5->apply_unsafe($t2);
$P5->apply_unsafe($u2);
$P5->apply_unsafe($v2);
$P5->apply_unsafe($w2);
$P5->apply_unsafe($x2);
$P5->apply_unsafe($y2);
$P5->apply_unsafe($z2);
$P5->apply_unsafe($A2);
$x6->apply_unsafe($R3);
$x6->apply_unsafe($S3);
$x6->apply_unsafe($T3);
$x6->apply_unsafe($U3);
$x6->apply_unsafe($V3);
$x6->apply_unsafe($W3);
$x6->apply_unsafe($X3);
$x6->apply_unsafe($Y3);
$F6->apply_unsafe($R3);
$F6->apply_unsafe($S3);
$F6->apply_unsafe($T3);
$F6->apply_unsafe($U3);
$F6->apply_unsafe($V3);
$F6->apply_unsafe($W3);
$F6->apply_unsafe($X3);
$F6->apply_unsafe($Y3);
$Z6->apply_unsafe($R3);
$Z6->apply_unsafe($S3);
$Z6->apply_unsafe($T3);
$Z6->apply_unsafe($U3);
$Z6->apply_unsafe($V3);
$Z6->apply_unsafe($W3);
$Z6->apply_unsafe($X3);
$Z6->apply_unsafe($Y3);
$j7->apply_unsafe($R3);
$j7->apply_unsafe($S3);
$j7->apply_unsafe($T3);
$j7->apply_unsafe($U3);
$j7->apply_unsafe($V3);
$j7->apply_unsafe($W3);
$j7->apply_unsafe($X3);
$j7->apply_unsafe($Y3);
$r7->apply_unsafe($R3);
$r7->apply_unsafe($S3);
$r7->apply_unsafe($T3);
$r7->apply_unsafe($U3);
$r7->apply_unsafe($V3);
$r7->apply_unsafe($W3);
$r7->apply_unsafe($X3);
$r7->apply_unsafe($Y3);
$B7->apply_unsafe($R3);
$J7->apply_unsafe($R3);
$j8->apply_unsafe($S3);
$q8->apply_unsafe($S3);
$K8->apply_unsafe($S3);
$k9->apply_unsafe($S3);
$s9->apply_unsafe($S3);
$I9->apply_unsafe($S3);
$ia->apply_unsafe($T3);
$pa->apply_unsafe($T3);
$xa->apply_unsafe($T3);
$Na->apply_unsafe($T3);
$Ya->apply_unsafe($T3);
$lb->apply_unsafe($T3);
$Jb->apply_unsafe($U3);
$Rb->apply_unsafe($U3);
$Yb->apply_unsafe($U3);
$sc->apply_unsafe($U3);
$Yc->apply_unsafe($Zc);
$ld->apply_unsafe($V3);
$yd->apply_unsafe($V3);
$fe->apply_unsafe($X3);
$pe->apply_unsafe($X3);
$Be->apply_unsafe($X3);
$Le->apply_unsafe($X3);
$df->apply_unsafe($X3);
$Jf->apply_unsafe($Y3);
$Qf->apply_unsafe($Y3);
$gg->apply_unsafe($Y3);
$Dg->apply_unsafe($X2);
$Xg->apply_unsafe($c4);
$fh->apply_unsafe($c4);
$Ah->apply_unsafe($F);
$Gh->apply_unsafe($F);
$Nh->apply_unsafe($F);
$Wh->apply_unsafe($F);
$zi->apply_unsafe($u);
$Ni->apply_unsafe($u);
$Xi->apply_unsafe($u);
$hj->apply_unsafe($u);
$Dj->apply_unsafe($Zc);
$Nj->apply_unsafe($d4);
$Sk->apply_unsafe($d4);
$cl->apply_unsafe($d4);
$Al->apply_unsafe($d4);
$Ql->apply_unsafe($d4);
$Dm->apply_unsafe($Em);
$dn->apply_unsafe($e4);
$pn->apply_unsafe($e4);
$Nn->apply_unsafe($e4);
$Yn->apply_unsafe($e4);
$pp->apply_unsafe($Em);
$Jp->apply_unsafe($V2);
$Pp->apply_unsafe($V2);
$Wp->apply_unsafe($V2);
$vq->apply_unsafe($Zc);
$Fq->apply_unsafe($j3);
$Lq->apply_unsafe($j3);
$hr->apply_unsafe($f4);
$tr->apply_unsafe($f4);
$Ar->apply_unsafe($f4);
$ni::self=$dt;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$w;
&$_($Z1)for@$H;
&$_($P2)for@$w;
&$_($S2)for@$w;
&$_($W2)for@$Y2;
&$_($d3)for@$w;
&$_($f3)for@$w;
&$_($i3)for@$Y2;
&$_($n3)for@$w;
&$_($q3)for@$Y2;
&$_($u3)for@$w;
&$_($x3)for@$Y2;
&$_($B3)for@$w;
&$_($E3)for@$Y2;
&$_($G3)for@$H3;
&$_($K3)for@$w;
&$_($N3)for@$w;
&$_($Q3)for@$Y2;
&$_($l4)for@$w;
&$_($o4)for@$Y2;
&$_($q4)for@$r4;
&$_($w4)for@$w;
&$_($z4)for@$Y2;
&$_($B4)for@$C4;
&$_($I4)for@$w;
&$_($L4)for@$Y2;
&$_($P4)for@$w;
&$_($S4)for@$w;
&$_($V4)for@$Y2;
&$_($Z4)for@$w;
&$_($e5)for@$Y2;
&$_($i5)for@$w;
&$_($l5)for@$Y2;
&$_($p5)for@$w;
&$_($s5)for@$Y2;
&$_($u5)for@$v5;
&$_($x5)for@$y5;
&$_($C5)for@$w;
&$_($F5)for@$w;
&$_($I5)for@$Y2;
&$_($M5)for@$w;
&$_($P5)for@$Y2;
&$_($R5)for@$S5;
&$_($d6)for@$e6;
&$_($i6)for@$e6;
&$_($k6)for@$e6;
&$_($m6)for@$e6;
&$_($u6)for@$w;
&$_($x6)for@$Y2;
&$_($C6)for@$w;
&$_($F6)for@$Y2;
&$_($K6)for@$w;
&$_($O6)for@$w;
&$_($S6)for@$w;
&$_($W6)for@$w;
&$_($Z6)for@$Y2;
&$_($g7)for@$w;
&$_($j7)for@$Y2;
&$_($o7)for@$w;
&$_($r7)for@$Y2;
&$_($t7)for@$u7;
&$_($y7)for@$w;
&$_($B7)for@$Y2;
&$_($G7)for@$w;
&$_($J7)for@$Y2;
&$_($L7)for@$M7;
&$_($T7)for@$e6;
&$_($V7)for@$e6;
&$_($g8)for@$w;
&$_($j8)for@$Y2;
&$_($n8)for@$w;
&$_($q8)for@$Y2;
&$_($v8)for@$w;
&$_($z8)for@$w;
&$_($D8)for@$w;
&$_($H8)for@$w;
&$_($K8)for@$Y2;
&$_($P8)for@$w;
&$_($T8)for@$w;
&$_($X8)for@$w;
&$_($d9)for@$w;
&$_($h9)for@$w;
&$_($k9)for@$Y2;
&$_($p9)for@$w;
&$_($s9)for@$Y2;
&$_($x9)for@$w;
&$_($B9)for@$w;
&$_($F9)for@$w;
&$_($I9)for@$Y2;
&$_($K9)for@$L9;
&$_($Q9)for@$e6;
&$_($fa)for@$w;
&$_($ia)for@$Y2;
&$_($ma)for@$w;
&$_($pa)for@$Y2;
&$_($ua)for@$w;
&$_($xa)for@$Y2;
&$_($Ca)for@$w;
&$_($Ga)for@$w;
&$_($Ka)for@$w;
&$_($Na)for@$Y2;
&$_($Ra)for@$w;
&$_($Va)for@$w;
&$_($Ya)for@$Y2;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($lb)for@$Y2;
&$_($nb)for@$ob;
&$_($tb)for@$e6;
&$_($Gb)for@$w;
&$_($Jb)for@$Y2;
&$_($Ob)for@$w;
&$_($Rb)for@$Y2;
&$_($Vb)for@$w;
&$_($Yb)for@$Y2;
&$_($fc)for@$w;
&$_($ic)for@$w;
&$_($mc)for@$w;
&$_($pc)for@$w;
&$_($sc)for@$Y2;
&$_($uc)for@$vc;
&$_($Ac)for@$e6;
&$_($Kc)for@$w;
&$_($Nc)for@$w;
&$_($Rc)for@$w;
&$_($Vc)for@$w;
&$_($Yc)for@$Y2;
&$_($id)for@$w;
&$_($ld)for@$Y2;
&$_($pd)for@$w;
&$_($sd)for@$w;
&$_($vd)for@$w;
&$_($yd)for@$Y2;
&$_($Ad)for@$Bd;
&$_($Gd)for@$e6;
&$_($Wd)for@$w;
&$_($ce)for@$w;
&$_($fe)for@$Y2;
&$_($je)for@$w;
&$_($me)for@$w;
&$_($pe)for@$Y2;
&$_($ue)for@$w;
&$_($ye)for@$w;
&$_($Be)for@$Y2;
&$_($Fe)for@$w;
&$_($Ie)for@$w;
&$_($Le)for@$Y2;
&$_($Pe)for@$w;
&$_($Se)for@$w;
&$_($Ve)for@$w;
&$_($Ye)for@$w;
&$_($df)for@$Y2;
&$_($ff)for@$gf;
&$_($lf)for@$e6;
&$_($yf)for@$w;
&$_($Cf)for@$w;
&$_($Gf)for@$w;
&$_($Jf)for@$Y2;
&$_($Nf)for@$w;
&$_($Qf)for@$Y2;
&$_($Uf)for@$w;
&$_($Yf)for@$w;
&$_($dg)for@$w;
&$_($gg)for@$Y2;
&$_($ig)for@$jg;
&$_($og)for@$e6;
&$_($Ag)for@$w;
&$_($Dg)for@$Y2;
&$_($Fg)for@$Gg;
&$_($Mg)for@$e6;
&$_($Ug)for@$w;
&$_($Xg)for@$Y2;
&$_($ch)for@$w;
&$_($fh)for@$Y2;
&$_($hh)for@$ih;
&$_($nh)for@$e6;
&$_($xh)for@$w;
&$_($Ah)for@$Y2;
&$_($Dh)for@$w;
&$_($Gh)for@$Y2;
&$_($Kh)for@$w;
&$_($Nh)for@$Y2;
&$_($Qh)for@$w;
&$_($Th)for@$w;
&$_($Wh)for@$Y2;
&$_($Yh)for@$Zh;
&$_($gi)for@$e6;
&$_($ri)for@$w;
&$_($ui)for@$w;
&$_($wi)for@$w;
&$_($zi)for@$Y2;
&$_($Di)for@$w;
&$_($Gi)for@$w;
&$_($Ki)for@$w;
&$_($Ni)for@$Y2;
&$_($Ri)for@$w;
&$_($Ui)for@$w;
&$_($Xi)for@$Y2;
&$_($ej)for@$w;
&$_($hj)for@$Y2;
&$_($jj)for@$kj;
&$_($pj)for@$e6;
&$_($Aj)for@$w;
&$_($Dj)for@$Y2;
&$_($Kj)for@$w;
&$_($Nj)for@$Y2;
&$_($Sj)for@$w;
&$_($Wj)for@$w;
&$_($ck)for@$w;
&$_($gk)for@$w;
&$_($kk)for@$w;
&$_($ok)for@$w;
&$_($sk)for@$w;
&$_($wk)for@$w;
&$_($Ak)for@$w;
&$_($Ek)for@$w;
&$_($Ik)for@$w;
&$_($Mk)for@$w;
&$_($Pk)for@$w;
&$_($Sk)for@$Y2;
&$_($Xk)for@$w;
&$_($cl)for@$Y2;
&$_($hl)for@$w;
&$_($ll)for@$w;
&$_($pl)for@$w;
&$_($tl)for@$w;
&$_($xl)for@$w;
&$_($Al)for@$Y2;
&$_($Fl)for@$w;
&$_($Jl)for@$w;
&$_($Nl)for@$w;
&$_($Ql)for@$Y2;
&$_($Sl)for@$Tl;
&$_($Yl)for@$e6;
&$_($km)for@$w;
&$_($om)for@$w;
&$_($sm)for@$w;
&$_($wm)for@$w;
&$_($Am)for@$w;
&$_($Dm)for@$Y2;
&$_($Qm)for@$w;
&$_($Um)for@$w;
&$_($Ym)for@$w;
&$_($dn)for@$Y2;
&$_($in)for@$w;
&$_($mn)for@$w;
&$_($pn)for@$Y2;
&$_($un)for@$w;
&$_($yn)for@$w;
&$_($Cn)for@$w;
&$_($Gn)for@$w;
&$_($Kn)for@$w;
&$_($Nn)for@$Y2;
&$_($Rn)for@$w;
&$_($Vn)for@$w;
&$_($Yn)for@$Y2;
&$_($co)for@$do;
&$_($io)for@$e6;
&$_($so)for@$w;
&$_($wo)for@$w;
&$_($Ao)for@$w;
&$_($Eo)for@$w;
&$_($Io)for@$w;
&$_($Mo)for@$w;
&$_($Qo)for@$w;
&$_($Uo)for@$w;
&$_($Yo)for@$w;
&$_($ep)for@$w;
&$_($ip)for@$w;
&$_($mp)for@$w;
&$_($pp)for@$Y2;
&$_($Ap)for@$w;
&$_($Cp)for@$w;
&$_($Jp)for@$Y2;
&$_($Mp)for@$w;
&$_($Pp)for@$Y2;
&$_($Tp)for@$w;
&$_($Wp)for@$Y2;
&$_($Yp)for@$Zp;
&$_($hq)for@$e6;
&$_($oq)for@$w;
&$_($sq)for@$w;
&$_($vq)for@$Y2;
&$_($Cq)for@$w;
&$_($Fq)for@$Y2;
&$_($Iq)for@$w;
&$_($Lq)for@$Y2;
&$_($Nq)for@$Oq;
&$_($Uq)for@$e6;
&$_($er)for@$w;
&$_($hr)for@$Y2;
&$_($mr)for@$w;
&$_($qr)for@$w;
&$_($tr)for@$Y2;
&$_($xr)for@$w;
&$_($Ar)for@$Y2;
&$_($Cr)for@$Dr;
&$_($Ir)for@$e6;
&$_($Qr)for@$Rr;
&$_($Wr)for@$e6;
&$_($gs)for@$hs;
&$_($Bs)for@$Cs;
&$_($Es)for@$hs;
&$_($Js)for@$w;
&$_($Ns)for@$w;
&$_($Rs)for@$w;
&$_($Vs)for@$w;
&$_($Zs)for@$w;
&$_($dt)for@$et;
ni->run(@ARGV);
__DATA__
