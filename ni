#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib#;
$L1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$M1=[$i,$L1];
$N1=[$M1];
$O1=q#/lib#;
$P1=bless({$e,$N1,$D,$O1},$F);
$Q1=q#ni.doc:/lib/doc#;
$R1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$S1=[$f,$R1];
$T1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$U1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$V1=[];
$W1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$X1=bless({$o,$V1,$q,$W1,$s,$t},$u);
$Y1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$Z1=[];
$c2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$d2=bless({$o,$Z1,$q,$c2,$s,$t},$u);
$e2=[$i,$T1,$U1,$n,$X1,$Y1,$n,$d2];
$f2=[$S1,$e2];
$g2=q#/lib/doc#;
$h2=bless({$e,$f2,$D,$g2},$F);
$i2=q#ni:/class#;
$j2=q#applied_to#;
$k2=q#class#;
$l2=q#class.c#;
$m2=q#io/cat.c#;
$n2=q#io/exec.c#;
$o2=q#io/fd.c#;
$p2=q#io/file.c#;
$q2=q#io/null.c#;
$r2=q#io/object.c#;
$s2=q#io/pid.c#;
$t2=q#io/str.c#;
$u2=q#lib/behavior.c#;
$v2=q#lib/branch.c#;
$w2=q#lib/dataslice.c#;
$x2=q#lib/doc.c#;
$y2=q#lib/fn.c#;
$z2=q#lib/image.c#;
$A2=q#lib/ni.c#;
$B2=q#lib/quote_simple.c#;
$C2=q#lib/slice.c#;
$D2=q#lib/tag.c#;
$E2=q#lib/test_value.c#;
$F2=q#metaclass.c#;
$G2=q#module.c#;
$H2=q#object.c#;
$I2={$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1};
$J2=q#slices#;
$K2=q#metaclass#;
$L2=q#module#;
$M2={$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$K2,1,$F2,1,$L2,1,$G2,1,$H2,1};
$N2=q#/module#;
$O2=q#/lib/perlbranch.b#;
$P2={};
$Q2=q#ctor#;
$R2=undef;
$S2=q#dtor#;
$T2=q#methods#;
$U2=q#add#;
$V2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$W2=bless({$q,$V2,$s,$t},$u);
$X2=q#apply#;
$Y2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Z2=bless({$q,$Y2,$s,$t},$u);
$c3={$U2,$W2,$X2,$Z2};
$d3=q#/lib/branch.b#;
$e3=q#lib/slice#;
$f3=bless({$j2,$P2,$Q2,$R2,$S2,$R2,$T2,$c3,$D,$d3},$e3);
$g3=q#lib/branch#;
$h3=q#lib/slice::ctors#;
$i3={};
$j3=q#my $s = shift; ni->def($s->name, $s)#;
$k3=bless({$q,$j3,$s,$t},$u);
$l3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$m3=bless({$q,$l3,$s,$t},$u);
$n3={$D,$m3};
$o3=q#/lib/named.b#;
$p3=bless({$j2,$i3,$Q2,$k3,$S2,$R2,$T2,$n3,$D,$o3},$e3);
$q3=q#lib/tag#;
$r3={};
$s3=q#namespace#;
$t3=q#'ni'#;
$u3=bless({$q,$t3,$s,$t},$u);
$v3={$s3,$u3};
$w3=q#/lib/named_in_ni.b#;
$x3=bless({$j2,$r3,$Q2,$R2,$S2,$R2,$T2,$v3,$D,$w3},$e3);
$y3={};
$z3=q#package#;
$A3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$B3=bless({$q,$A3,$s,$t},$u);
$C3={$z3,$B3};
$D3=q#/lib/namespaced.b#;
$E3=bless({$j2,$y3,$Q2,$R2,$S2,$R2,$T2,$C3,$D,$D3},$e3);
$F3={};
$G3=q#resolve#;
$H3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$I3=bless({$q,$H3,$s,$t},$u);
$J3={$G3,$I3};
$K3=q#/lib/resolver.b#;
$L3=bless({$j2,$F3,$Q2,$R2,$S2,$R2,$T2,$J3,$D,$K3},$e3);
$M3=[$f3,$p3,$x3,$E3,$L3];
$N3=bless({$D,$O2,$J2,$M3},$q3);
$O3=q#lib/tag::ctors#;
$P3={};
$Q3=q#my $s = shift; $s->apply($s->package)#;
$R3=bless({$q,$Q3,$s,$t},$u);
$S3=q#instantiate#;
$T3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$U3=bless({$q,$T3,$s,$t},$u);
$V3={$S3,$U3};
$W3=q#/lib/class_init.b#;
$X3=bless({$j2,$P3,$Q2,$R3,$S2,$R2,$T2,$V3,$D,$W3},$e3);
$Y3=q#io/cat#;
$Z3=q#io/exec#;
$c4=q#io/fd#;
$d4=q#io/file#;
$e4=q#io/null#;
$f4=q#io/object#;
$g4=q#io/pid#;
$h4=q#io/str#;
$i4=q#lib/behavior#;
$j4=q#lib/dataslice#;
$k4=q#lib/image#;
$l4=q#lib/ni#;
$m4=q#lib/quote_simple#;
$n4=q#lib/test_value#;
$o4=q#object#;
$p4={$k2,1,$l2,1,$Y3,1,$m2,1,$Z3,1,$n2,1,$c4,1,$o2,1,$d4,1,$p2,1,$e4,1,$q2,1,$f4,1,$r2,1,$g4,1,$s2,1,$h4,1,$t2,1,$i4,1,$u2,1,$g3,1,$v2,1,$j4,1,$w2,1,$F,1,$x2,1,$u,1,$y2,1,$k4,1,$z2,1,$l4,1,$A2,1,$m4,1,$B2,1,$e3,1,$C2,1,$q3,1,$D2,1,$n4,1,$E2,1,$K2,1,$F2,1,$L2,1,$G2,1,$o4,1,$H2,1};
$q4=q#/object#;
$r4={};
$s4=q#ni 'ni:/' . ref shift#;
$t4=bless({$q,$s4,$s,$t},$u);
$u4={$k2,$t4};
$v4=q#/lib/instance.b#;
$w4=bless({$j2,$r4,$Q2,$R2,$S2,$R2,$T2,$u4,$D,$v4},$e3);
$x4=[$w4];
$y4=bless({$j2,$p4,$D,$q4,$J2,$x4},$H2);
$z4=q#object.c::ctors#;
$A4={$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$i4,1,$u2,1,$g3,1,$v2,1,$j4,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$e3,1,$C2,1,$q3,1,$D2,1,$E2,1,$K2,1,$F2,1,$L2,1,$G2,1,$H2,1};
$B4=q#/lib/behavior#;
$C4={};
$D4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$E4=bless({$q,$D4,$s,$t},$u);
$F4={$e,$E4};
$G4=q#/lib/documentable.b#;
$H4=bless({$j2,$C4,$Q2,$R2,$S2,$R2,$T2,$F4,$D,$G4},$e3);
$I4=[$y4,$H4];
$J4=bless({$j2,$A4,$D,$B4,$J2,$I4},$u2);
$K4=q#lib/behavior.c::ctors#;
$L4={$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$g3,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$K2,1,$F2,1,$L2,1,$G2,1,$H2,1};
$M4=q#/lib/definition.b#;
$N4={};
$O4=q#def#;
$P4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$Q4=bless({$q,$P4,$s,$t},$u);
$R4={$O4,$Q4};
$S4=q#/lib/definition_def.b#;
$T4=bless({$j2,$N4,$Q2,$R2,$S2,$R2,$T2,$R4,$D,$S4},$e3);
$U4={};
$V4=q#ro#;
$W4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$X4=bless({$q,$W4,$s,$t},$u);
$Y4=q#rw#;
$Z4=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$c5=bless({$q,$Z4,$s,$t},$u);
$d5={$V4,$X4,$Y4,$c5};
$e5=q#/lib/accessor.b#;
$f5=bless({$j2,$U4,$Q2,$R2,$S2,$R2,$T2,$d5,$D,$e5},$e3);
$g5={};
$h5=q#(""#;
$i5=q#shift->name#;
$j5=bless({$q,$i5,$s,$t},$u);
$k5={$h5,$j5};
$l5=q#/lib/name_as_string.b#;
$m5=bless({$j2,$g5,$Q2,$R2,$S2,$R2,$T2,$k5,$D,$l5},$e3);
$n5={};
$o5=q#(eq#;
$p5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$o5,$q5};
$s5=q#/lib/ref_eq.b#;
$t5=bless({$j2,$n5,$Q2,$R2,$S2,$R2,$T2,$r5,$D,$s5},$e3);
$u5={};
$v5=q#defdata#;
$w5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$x5=bless({$q,$w5,$s,$t},$u);
$y5={$v5,$x5};
$z5=q#/lib/definition_defdata.b#;
$A5=bless({$j2,$u5,$Q2,$R2,$S2,$R2,$T2,$y5,$D,$z5},$e3);
$B5=[$T4,$f5,$m5,$t5,$A5];
$C5=bless({$j2,$L4,$D,$M4,$J2,$B5},$g3);
$D5=q#lib/branch::ctors#;
$E5=[$N3,$X3,$y4,$J4,$C5];
$F5=bless({$j2,$M2,$D,$N2,$J2,$E5},$G2);
$G5=q#module.c::ctors#;
$H5={};
$I5=q#DESTROY#;
$J5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$K5=bless({$q,$J5,$s,$t},$u);
$L5=q#new#;
$M5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$N5=bless({$q,$M5,$s,$t},$u);
$O5={$I5,$K5,$L5,$N5};
$P5=q#/lib/instantiable.b#;
$Q5=bless({$j2,$H5,$T2,$O5,$D,$P5},$e3);
$R5={};
$S5=q#child#;
$T5=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$U5=bless({$q,$T5,$s,$t},$u);
$V5={$S5,$U5};
$W5=q#/lib/subclass.b#;
$X5=bless({$j2,$R5,$Q2,$R2,$S2,$R2,$T2,$V5,$D,$W5},$e3);
$Y5=[$F5,$Q5,$X3,$F5,$X5];
$Z5=bless({$j2,$I2,$D,$E,$J2,$Y5},$l2);
$c6=q#class.c::ctors#;
$d6=q#ni:/class.c#;
$e6={$l2,1};
$f6=q#/class.c#;
$g6={$l2,1,$G2,1};
$h6=q#/module.c#;
$i6={$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$G2,1,$H2,1};
$j6=q#/object.c#;
$k6=[$Z5];
$l6=bless({$j2,$i6,$D,$j6,$J2,$k6},$K2);
$m6=q#metaclass::ctors#;
$n6={$l2,1,$u2,1,$v2,1,$w2,1,$C2,1,$D2,1,$G2,1};
$o6=q#/lib/behavior.c#;
$p6=[$l6];
$q6=bless({$j2,$n6,$D,$o6,$J2,$p6},$K2);
$r6=[$l6,$Q5,$q6];
$s6=bless({$j2,$g6,$D,$h6,$J2,$r6},$K2);
$t6=[$s6];
$u6=bless({$j2,$e6,$D,$f6,$J2,$t6},$K2);
$v6=q#ni:/io/cat#;
$w6={$Y3,1};
$x6={$Y3,1,$Z3,1,$c4,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1};
$y6=q#/io/object#;
$z6={};
$A6=q#(bool#;
$B6=[];
$C6=bless({$o,$B6,$q,1,$s,$t},$u);
$D6={$A6,$C6};
$E6=q#/io/object_ops.b#;
$F6=bless({$j2,$z6,$Q2,$R2,$S2,$R2,$T2,$D6,$D,$E6},$e3);
$G6={};
$H6=q#into#;
$I6=[];
$J6=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}
$self;#;
$K6=bless({$o,$I6,$q,$J6,$s,$t},$u);
$L6={$H6,$K6};
$M6=q#/io/object_stream.b#;
$N6=bless({$j2,$G6,$Q2,$R2,$S2,$R2,$T2,$L6,$D,$M6},$e3);
$O6={};
$P6=q#die#;
$Q6=[];
$R6=q#shift; die join " ", @_#;
$S6=bless({$o,$Q6,$q,$R6,$s,$t},$u);
$T6=q#io_check#;
$U6=[];
$V6=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$W6=bless({$o,$U6,$q,$V6,$s,$t},$u);
$X6=q#io_check_defined#;
$Y6=[];
$Z6=q#shift->io_check(sub {defined shift}, @_)#;
$c7=bless({$o,$Y6,$q,$Z6,$s,$t},$u);
$d7=q#io_check_true#;
$e7=[];
$f7=q#shift->io_check(sub {shift}, @_)#;
$g7=bless({$o,$e7,$q,$f7,$s,$t},$u);
$h7={$P6,$S6,$T6,$W6,$X6,$c7,$d7,$g7};
$i7=q#/io/object_checks.b#;
$j7=bless({$j2,$O6,$Q2,$R2,$S2,$R2,$T2,$h7,$D,$i7},$e3);
$k7={};
$l7=q#(+#;
$m7=[];
$n7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$o7=bless({$o,$m7,$q,$n7,$s,$t},$u);
$p7={$l7,$o7};
$q7=q#/io/object_constructors.b#;
$r7=bless({$j2,$k7,$Q2,$R2,$S2,$R2,$T2,$p7,$D,$q7},$e3);
$s7={};
$t7=q#read_all#;
$u7=[];
$v7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$w7=bless({$o,$u7,$q,$v7,$s,$t},$u);
$x7={$t7,$w7};
$y7=q#/io/object_memory.b#;
$z7=bless({$j2,$s7,$Q2,$R2,$S2,$R2,$T2,$x7,$D,$y7},$e3);
$A7=[$y4,$F6,$N6,$j7,$r7,$z7];
$B7=bless({$j2,$x6,$D,$y6,$J2,$A7},$r2);
$C7=q#io/object.c::ctors#;
$D7={};
$E7=[];
$F7=q#shift; +{fs => [@_]}#;
$G7=bless({$o,$E7,$q,$F7,$s,$t},$u);
$H7={$S3,$G7};
$I7=q#/io/cat_init.b#;
$J7=bless({$j2,$D7,$Q2,$R2,$S2,$R2,$T2,$H7,$D,$I7},$e3);
$K7={};
$L7=q#read#;
$M7=[];
$N7=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$O7=bless({$o,$M7,$q,$N7,$s,$t},$u);
$P7={$L7,$O7};
$Q7=q#/io/cat_read.b#;
$R7=bless({$j2,$K7,$Q2,$R2,$S2,$R2,$T2,$P7,$D,$Q7},$e3);
$S7=[$B7,$J7,$R7];
$T7=bless({$j2,$w6,$D,$g1,$J2,$S7},$m2);
$U7=q#io/cat.c::ctors#;
$V7=q#ni:/io/cat.c#;
$W7={$m2,1};
$X7=q#/io/cat.c#;
$Y7={$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1};
$Z7=q#/io/object.c#;
$c8=[$l6];
$d8=bless({$j2,$Y7,$D,$Z7,$J2,$c8},$K2);
$e8=[$d8];
$f8=bless({$j2,$W7,$D,$X7,$J2,$e8},$K2);
$g8=q#ni:/io/cat_init.b#;
$h8=q#ni:/io/cat_read.b#;
$i8=q#ni:/io/exec#;
$j8={$Z3,1};
$k8={};
$l8=q#argv#;
$m8=[];
$n8=q#shift->{'argv'}#;
$o8=bless({$o,$m8,$q,$n8,$s,$t},$u);
$p8={$l8,$o8};
$q8=q#/io/exec_ro.b#;
$r8=bless({$j2,$k8,$Q2,$R2,$S2,$R2,$T2,$p8,$D,$q8},$e3);
$s8={};
$t8=[];
$u8=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$v8=bless({$o,$t8,$q,$u8,$s,$t},$u);
$w8={$S3,$v8};
$x8=q#/io/exec_init.b#;
$y8=bless({$j2,$s8,$Q2,$R2,$S2,$R2,$T2,$w8,$D,$x8},$e3);
$z8={};
$A8=q#connect#;
$B8=[];
$C8=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$D8=bless({$o,$B8,$q,$C8,$s,$t},$u);
$E8=q#in_pipe#;
$F8=[];
$G8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$H8=bless({$o,$F8,$q,$G8,$s,$t},$u);
$I8=q#out_pipe#;
$J8=[];
$K8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$L8=bless({$o,$J8,$q,$K8,$s,$t},$u);
$M8=q#setup_stdio#;
$N8=[];
$O8=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$P8=bless({$o,$N8,$q,$O8,$s,$t},$u);
$Q8={$A8,$D8,$E8,$H8,$I8,$L8,$M8,$P8};
$R8=q#/io/exec_io_setup.b#;
$S8=bless({$j2,$z8,$Q2,$R2,$S2,$R2,$T2,$Q8,$D,$R8},$e3);
$T8={};
$U8=q#binds_fd#;
$V8=[];
$W8=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$X8=bless({$o,$V8,$q,$W8,$s,$t},$u);
$Y8=q#fd#;
$Z8=[];
$c9=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$d9=bless({$o,$Z8,$q,$c9,$s,$t},$u);
$e9=q#stderr#;
$f9=[];
$g9=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$h9=bless({$o,$f9,$q,$g9,$s,$t},$u);
$i9=q#stdin#;
$j9=[];
$k9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$l9=bless({$o,$j9,$q,$k9,$s,$t},$u);
$m9=q#stdout#;
$n9=[];
$o9=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$p9=bless({$o,$n9,$q,$o9,$s,$t},$u);
$q9={$U8,$X8,$Y8,$d9,$e9,$h9,$i9,$l9,$m9,$p9};
$r9=q#/io/exec_io_accessors.b#;
$s9=bless({$j2,$T8,$Q2,$R2,$S2,$R2,$T2,$q9,$D,$r9},$e3);
$t9={};
$u9=q#env#;
$v9=[];
$w9=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9={$u9,$x9};
$z9=q#/io/exec_env.b#;
$A9=bless({$j2,$t9,$Q2,$R2,$S2,$R2,$T2,$y9,$D,$z9},$e3);
$B9={};
$C9=q#exec#;
$D9=[];
$E9=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$F9=bless({$o,$D9,$q,$E9,$s,$t},$u);
$G9=q#fork#;
$H9=[];
$I9=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$J9=bless({$o,$H9,$q,$I9,$s,$t},$u);
$K9=q#move_fds#;
$L9=[];
$M9=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$N9=bless({$o,$L9,$q,$M9,$s,$t},$u);
$O9={$C9,$F9,$G9,$J9,$K9,$N9};
$P9=q#/io/exec_fork.b#;
$Q9=bless({$j2,$B9,$Q2,$R2,$S2,$R2,$T2,$O9,$D,$P9},$e3);
$R9=[$B7,$r8,$y8,$S8,$s9,$A9,$Q9];
$S9=bless({$j2,$j8,$D,$s1,$J2,$R9},$n2);
$T9=q#io/exec.c::ctors#;
$U9=q#ni:/io/exec.c#;
$V9={$n2,1};
$W9=q#/io/exec.c#;
$X9=[$d8];
$Y9=bless({$j2,$V9,$D,$W9,$J2,$X9},$K2);
$Z9=q#ni:/io/exec_env.b#;
$ca=q#ni:/io/exec_fork.b#;
$da=q#ni:/io/exec_init.b#;
$ea=q#ni:/io/exec_io_accessors.b#;
$fa=q#ni:/io/exec_io_setup.b#;
$ga=q#ni:/io/exec_ro.b#;
$ha=q#ni:/io/fd#;
$ia={$c4,1};
$ja=q#/io/fd#;
$ka={};
$la=[];
$ma=q#shift->{'fd'}#;
$na=bless({$o,$la,$q,$ma,$s,$t},$u);
$oa={$Y8,$na};
$pa=q#/io/fd_readers.b#;
$qa=bless({$j2,$ka,$Q2,$R2,$S2,$R2,$T2,$oa,$D,$pa},$e3);
$ra={};
$sa=[];
$ta=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$ua=bless({$o,$sa,$q,$ta,$s,$t},$u);
$va={$S3,$ua};
$wa=q#/io/fd_init.b#;
$xa=bless({$j2,$ra,$Q2,$R2,$S2,$R2,$T2,$va,$D,$wa},$e3);
$ya={};
$za=q#be#;
$Aa=[];
$Ba=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Ca=bless({$o,$Aa,$q,$Ba,$s,$t},$u);
$Da={$za,$Ca};
$Ea=q#/io/fd_shell.b#;
$Fa=bless({$j2,$ya,$Q2,$R2,$S2,$R2,$T2,$Da,$D,$Ea},$e3);
$Ga={};
$Ha=q#cloexec#;
$Ia=[];
$Ja=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ka=bless({$o,$Ia,$q,$Ja,$s,$t},$u);
$La=q#fcntl_flag#;
$Ma=[];
$Na=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Oa=bless({$o,$Ma,$q,$Na,$s,$t},$u);
$Pa=q#nonblock#;
$Qa=[];
$Ra=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta={$Ha,$Ka,$La,$Oa,$Pa,$Sa};
$Ua=q#/io/fd_fcntl.b#;
$Va=bless({$j2,$Ga,$Q2,$R2,$S2,$R2,$T2,$Ta,$D,$Ua},$e3);
$Wa={};
$Xa=[];
$Ya=q#shift->close#;
$Za=bless({$o,$Xa,$q,$Ya,$s,$t},$u);
$cb=q#close#;
$db=[];
$eb=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$fb=bless({$o,$db,$q,$eb,$s,$t},$u);
$gb={$cb,$fb};
$hb=q#/io/fd_gc.b#;
$ib=bless({$j2,$Wa,$Q2,$R2,$S2,$Za,$T2,$gb,$D,$hb},$e3);
$jb={};
$kb=[];
$lb=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q#write#;
$ob=[];
$pb=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb={$L7,$mb,$nb,$qb};
$sb=q#/io/fd_perlio.b#;
$tb=bless({$j2,$jb,$Q2,$R2,$S2,$R2,$T2,$rb,$D,$sb},$e3);
$ub=[$B7,$qa,$xa,$Fa,$Va,$ib,$tb];
$vb=bless({$j2,$ia,$D,$ja,$J2,$ub},$o2);
$wb=q#io/fd.c::ctors#;
$xb=q#ni:/io/fd.c#;
$yb={$o2,1};
$zb=q#/io/fd.c#;
$Ab=[$d8];
$Bb=bless({$j2,$yb,$D,$zb,$J2,$Ab},$K2);
$Cb=q#ni:/io/fd_fcntl.b#;
$Db=q#ni:/io/fd_gc.b#;
$Eb=q#ni:/io/fd_init.b#;
$Fb=q#ni:/io/fd_perlio.b#;
$Gb=q#ni:/io/fd_readers.b#;
$Hb=q#ni:/io/fd_shell.b#;
$Ib=q#ni:/io/file#;
$Jb={$d4,1};
$Kb=q#/io/file#;
$Lb={};
$Mb=[];
$Nb=q#shift->{'name'}#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb={$D,$Ob};
$Qb=q#/io/file_readers.b#;
$Rb=bless({$j2,$Lb,$Q2,$R2,$S2,$R2,$T2,$Pb,$D,$Qb},$e3);
$Sb={};
$Tb=q#mode#;
$Ub=[];
$Vb=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb={$Tb,$Wb};
$Yb=q#/io/file_accessors.b#;
$Zb=bless({$j2,$Sb,$Q2,$R2,$S2,$R2,$T2,$Xb,$D,$Yb},$e3);
$cc={};
$dc=[];
$ec=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$fc=bless({$o,$dc,$q,$ec,$s,$t},$u);
$gc={$S3,$fc};
$hc=q#/io/file_init.b#;
$ic=bless({$j2,$cc,$Q2,$R2,$S2,$R2,$T2,$gc,$D,$hc},$e3);
$jc={};
$kc=q#r#;
$lc=[];
$mc=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$nc=bless({$o,$lc,$q,$mc,$s,$t},$u);
$oc=[];
$pc=q#shift->r->read(@_)#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc=q#w#;
$sc=[];
$tc=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$uc=bless({$o,$sc,$q,$tc,$s,$t},$u);
$vc=[];
$wc=q#shift->w->write(@_)#;
$xc=bless({$o,$vc,$q,$wc,$s,$t},$u);
$yc={$kc,$nc,$L7,$qc,$rc,$uc,$nb,$xc};
$zc=q#/io/file_io.b#;
$Ac=bless({$j2,$jc,$Q2,$R2,$S2,$R2,$T2,$yc,$D,$zc},$e3);
$Bc=[$B7,$Rb,$Zb,$ic,$Ac];
$Cc=bless({$j2,$Jb,$D,$Kb,$J2,$Bc},$p2);
$Dc=q#io/file.c::ctors#;
$Ec=q#ni:/io/file.c#;
$Fc={$p2,1};
$Gc=q#/io/file.c#;
$Hc=[$d8];
$Ic=bless({$j2,$Fc,$D,$Gc,$J2,$Hc},$K2);
$Jc=q#ni:/io/file_accessors.b#;
$Kc=q#ni:/io/file_init.b#;
$Lc=q#ni:/io/file_io.b#;
$Mc=q#ni:/io/file_readers.b#;
$Nc=q#ni:/io/named_io_fns.b#;
$Oc={};
$Pc=q#fcntl#;
$Qc=[];
$Rc=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Sc=bless({$o,$Qc,$q,$Rc,$s,$t},$u);
$Tc=[];
$Uc=q#CORE::fork#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$t},$u);
$Wc=q#open2#;
$Xc=[];
$Yc=q#CORE::open $_[0], $_[1]#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd=q#waitpid#;
$dd=[];
$ed=q#CORE::waitpid $_[0], $_[1]#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd={$Pc,$Sc,$G9,$Vc,$Wc,$Zc,$cd,$fd};
$hd=q#/io/named_io_fns.b#;
$id=bless({$j2,$Oc,$Q2,$R2,$S2,$R2,$T2,$gd,$D,$hd},$e3);
$jd=q#main#;
$kd=q#ni:/io/null#;
$ld={$e4,1};
$md=q#/io/null#;
$nd={};
$od=[];
$pd=q#+{fd => undef}#;
$qd=bless({$o,$od,$q,$pd,$s,$t},$u);
$rd={$S3,$qd};
$sd=q#/io/null_init.b#;
$td=bless({$j2,$nd,$Q2,$R2,$S2,$R2,$T2,$rd,$D,$sd},$e3);
$ud={};
$vd=[];
$wd=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$xd=bless({$o,$vd,$q,$wd,$s,$t},$u);
$yd=[];
$zd=q#shift->fd->read(@_)#;
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=[];
$Cd=q#shift->fd->write(@_)#;
$Dd=bless({$o,$Bd,$q,$Cd,$s,$t},$u);
$Ed={$Y8,$xd,$L7,$Ad,$nb,$Dd};
$Fd=q#/io/null_io.b#;
$Gd=bless({$j2,$ud,$Q2,$R2,$S2,$R2,$T2,$Ed,$D,$Fd},$e3);
$Hd=[$B7,$td,$Gd];
$Id=bless({$j2,$ld,$D,$md,$J2,$Hd},$q2);
$Jd=q#io/null.c::ctors#;
$Kd=q#ni:/io/null.c#;
$Ld={$q2,1};
$Md=q#/io/null.c#;
$Nd=[$d8];
$Od=bless({$j2,$Ld,$D,$Md,$J2,$Nd},$K2);
$Pd=q#ni:/io/null_init.b#;
$Qd=q#ni:/io/null_io.b#;
$Rd=q#ni:/io/object#;
$Sd=q#ni:/io/object.c#;
$Td=q#ni:/io/object_checks.b#;
$Ud=q#ni:/io/object_constructors.b#;
$Vd=q#ni:/io/object_memory.b#;
$Wd=q#ni:/io/object_ops.b#;
$Xd=q#ni:/io/object_stream.b#;
$Yd=q#ni:/io/pid#;
$Zd={$g4,1};
$ce={};
$de=q#pid#;
$ee=[];
$fe=q#shift->{'pid'}#;
$ge=bless({$o,$ee,$q,$fe,$s,$t},$u);
$he=q#status#;
$ie=[];
$je=q#shift->{'status'}#;
$ke=bless({$o,$ie,$q,$je,$s,$t},$u);
$le={$de,$ge,$he,$ke};
$me=q#/io/pid_readers.b#;
$ne=bless({$j2,$ce,$Q2,$R2,$S2,$R2,$T2,$le,$D,$me},$e3);
$oe={};
$pe=[];
$qe=q#shift->await#;
$re=bless({$o,$pe,$q,$qe,$s,$t},$u);
$se=[];
$te=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$ue=bless({$o,$se,$q,$te,$s,$t},$u);
$ve={$S3,$ue};
$we=q#/io/pid_init.b#;
$xe=bless({$j2,$oe,$Q2,$R2,$S2,$re,$T2,$ve,$D,$we},$e3);
$ye={};
$ze=q#await#;
$Ae=[];
$Be=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Ce=bless({$o,$Ae,$q,$Be,$s,$t},$u);
$De=q#running#;
$Ee=[];
$Fe=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Ge=bless({$o,$Ee,$q,$Fe,$s,$t},$u);
$He={$ze,$Ce,$De,$Ge};
$Ie=q#/io/pid_wait.b#;
$Je=bless({$j2,$ye,$Q2,$R2,$S2,$R2,$T2,$He,$D,$Ie},$e3);
$Ke={};
$Le=[];
$Me=q#shift->stdout->read(@_)#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe=[];
$Pe=q#shift->stdin->write(@_)#;
$Qe=bless({$o,$Oe,$q,$Pe,$s,$t},$u);
$Re={$L7,$Ne,$nb,$Qe};
$Se=q#/io/pid_io.b#;
$Te=bless({$j2,$Ke,$Q2,$R2,$S2,$R2,$T2,$Re,$D,$Se},$e3);
$Ue={};
$Ve=[];
$We=q#$_[0]->{external_fds}{$_[1]}#;
$Xe=bless({$o,$Ve,$q,$We,$s,$t},$u);
$Ye=[];
$Ze=q#shift->fd(2)#;
$cf=bless({$o,$Ye,$q,$Ze,$s,$t},$u);
$df=[];
$ef=q#shift->fd(0)#;
$ff=bless({$o,$df,$q,$ef,$s,$t},$u);
$gf=[];
$hf=q#shift->fd(1)#;
$if=bless({$o,$gf,$q,$hf,$s,$t},$u);
$jf={$Y8,$Xe,$e9,$cf,$i9,$ff,$m9,$if};
$kf=q#/io/pid_accessors.b#;
$lf=bless({$j2,$Ue,$Q2,$R2,$S2,$R2,$T2,$jf,$D,$kf},$e3);
$mf=[$B7,$ne,$xe,$Je,$Te,$lf];
$nf=bless({$j2,$Zd,$D,$I1,$J2,$mf},$s2);
$of=q#io/pid.c::ctors#;
$pf=q#ni:/io/pid.c#;
$qf={$s2,1};
$rf=q#/io/pid.c#;
$sf=[$d8];
$tf=bless({$j2,$qf,$D,$rf,$J2,$sf},$K2);
$uf=q#ni:/io/pid_accessors.b#;
$vf=q#ni:/io/pid_init.b#;
$wf=q#ni:/io/pid_io.b#;
$xf=q#ni:/io/pid_readers.b#;
$yf=q#ni:/io/pid_wait.b#;
$zf=q#ni:/io/str#;
$Af={$h4,1};
$Bf=q#/io/str#;
$Cf={};
$Df=q#data#;
$Ef=[];
$Ff=q#shift->{'data'}#;
$Gf=bless({$o,$Ef,$q,$Ff,$s,$t},$u);
$Hf=q#end#;
$If=[];
$Jf=q#shift->{'end'}#;
$Kf=bless({$o,$If,$q,$Jf,$s,$t},$u);
$Lf=q#start#;
$Mf=[];
$Nf=q#shift->{'start'}#;
$Of=bless({$o,$Mf,$q,$Nf,$s,$t},$u);
$Pf={$Df,$Gf,$Hf,$Kf,$Lf,$Of};
$Qf=q#/io/str_ro.b#;
$Rf=bless({$j2,$Cf,$Q2,$R2,$S2,$R2,$T2,$Pf,$D,$Qf},$e3);
$Sf={};
$Tf=[];
$Uf=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Vf=bless({$o,$Tf,$q,$Uf,$s,$t},$u);
$Wf={$S3,$Vf};
$Xf=q#/io/str_init.b#;
$Yf=bless({$j2,$Sf,$Q2,$R2,$S2,$R2,$T2,$Wf,$D,$Xf},$e3);
$Zf={};
$cg=[];
$dg=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$eg=bless({$o,$cg,$q,$dg,$s,$t},$u);
$fg=q#remaining#;
$gg=[];
$hg=q#my $self = shift; $$self{end} - $$self{start}#;
$ig=bless({$o,$gg,$q,$hg,$s,$t},$u);
$jg=[];
$kg=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$lg=bless({$o,$jg,$q,$kg,$s,$t},$u);
$mg={$L7,$eg,$fg,$ig,$nb,$lg};
$ng=q#/io/str_io.b#;
$og=bless({$j2,$Zf,$Q2,$R2,$S2,$R2,$T2,$mg,$D,$ng},$e3);
$pg=[$B7,$Rf,$Yf,$og];
$qg=bless({$j2,$Af,$D,$Bf,$J2,$pg},$t2);
$rg=q#io/str.c::ctors#;
$sg=q#ni:/io/str.c#;
$tg={$t2,1};
$ug=q#/io/str.c#;
$vg=[$d8];
$wg=bless({$j2,$tg,$D,$ug,$J2,$vg},$K2);
$xg=q#ni:/io/str_init.b#;
$yg=q#ni:/io/str_io.b#;
$zg=q#ni:/io/str_ro.b#;
$Ag=q#ni:/lib/accessor.b#;
$Bg=q#ni:/lib/behavior#;
$Cg=q#ni:/lib/behavior.c#;
$Dg=q#ni:/lib/branch#;
$Eg={$g3,1};
$Fg=q#/lib/branch#;
$Gg={};
$Hg=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Ig=bless({$q,$Hg,$s,$t},$u);
$Jg={$S3,$Ig};
$Kg=q#/lib/branch_init.b#;
$Lg=bless({$j2,$Gg,$Q2,$R2,$S2,$R2,$T2,$Jg,$D,$Kg},$e3);
$Mg=[$J4,$p3,$f3,$Lg,$C5];
$Ng=bless({$j2,$Eg,$D,$Fg,$J2,$Mg},$v2);
$Og=q#lib/branch.c::ctors#;
$Pg=q#ni:/lib/branch.b#;
$Qg=q#ni:/lib/branch.c#;
$Rg={$v2,1};
$Sg=q#/lib/branch.c#;
$Tg=[$q6];
$Ug=bless({$j2,$Rg,$D,$Sg,$J2,$Tg},$K2);
$Vg=q#ni:/lib/branch_init.b#;
$Wg=q#ni:/lib/class_init.b#;
$Xg=q#ni:/lib/dataslice#;
$Yg={$j4,1};
$Zg=q#/lib/dataslice#;
$ch={};
$dh=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$eh=bless({$q,$dh,$s,$t},$u);
$fh={$S3,$eh};
$gh=q#/lib/dataslice_init.b#;
$hh=bless({$j2,$ch,$Q2,$R2,$S2,$R2,$T2,$fh,$D,$gh},$e3);
$ih={};
$jh=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$kh=bless({$q,$jh,$s,$t},$u);
$lh={$X2,$kh};
$mh=q#/lib/dataslice_apply.b#;
$nh=bless({$j2,$ih,$Q2,$R2,$S2,$R2,$T2,$lh,$D,$mh},$e3);
$oh=[$J4,$hh,$nh];
$ph=bless({$j2,$Yg,$D,$Zg,$J2,$oh},$w2);
$qh=q#lib/dataslice.c::ctors#;
$rh=q#ni:/lib/dataslice.c#;
$sh={$w2,1};
$th=q#/lib/dataslice.c#;
$uh=[$q6];
$vh=bless({$j2,$sh,$D,$th,$J2,$uh},$K2);
$wh=q#ni:/lib/dataslice_apply.b#;
$xh=q#ni:/lib/dataslice_init.b#;
$yh=q#ni:/lib/definition.b#;
$zh=q#ni:/lib/definition_def.b#;
$Ah=q#ni:/lib/definition_defdata.b#;
$Bh=q#ni:/lib/doc#;
$Ch={$F,1};
$Dh={};
$Eh=q#shift; +{name => shift, doc => []}#;
$Fh=bless({$q,$Eh,$s,$t},$u);
$Gh={$S3,$Fh};
$Hh=q#/lib/doc_init.b#;
$Ih=bless({$j2,$Dh,$Q2,$R2,$S2,$R2,$T2,$Gh,$D,$Hh},$e3);
$Jh={};
$Kh=q#'ni.doc'#;
$Lh=bless({$q,$Kh,$s,$t},$u);
$Mh={$s3,$Lh};
$Nh=q#/lib/doc_namespace.b#;
$Oh=bless({$j2,$Jh,$Q2,$R2,$S2,$R2,$T2,$Mh,$D,$Nh},$e3);
$Ph={};
$Qh=q#AUTOLOAD#;
$Rh=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Sh=bless({$q,$Rh,$s,$t},$u);
$Th={$Qh,$Sh};
$Uh=q#/lib/doc_define.b#;
$Vh=bless({$j2,$Ph,$Q2,$R2,$S2,$R2,$T2,$Th,$D,$Uh},$e3);
$Wh={};
$Xh=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Yh=bless({$q,$Xh,$s,$t},$u);
$Zh=q#tests#;
$ci=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$di=bless({$q,$ci,$s,$t},$u);
$ei={$n,$Yh,$Zh,$di};
$fi=q#/lib/doc_test.b#;
$gi=bless({$j2,$Wh,$Q2,$R2,$S2,$R2,$T2,$ei,$D,$fi},$e3);
$hi=[$y4,$p3,$Ih,$Oh,$Vh,$gi];
$ii=bless({$j2,$Ch,$D,$g2,$J2,$hi},$x2);
$ji=q#lib/doc.c::ctors#;
$ki=q#ni:/lib/doc.c#;
$li={$x2,1};
$mi=q#/lib/doc.c#;
$ni=[$l6];
$oi=bless({$j2,$li,$D,$mi,$J2,$ni},$K2);
$pi=q#ni:/lib/doc_define.b#;
$qi=q#ni:/lib/doc_init.b#;
$ri=q#ni:/lib/doc_namespace.b#;
$si=q#ni:/lib/doc_test.b#;
$ti=q#ni:/lib/documentable.b#;
$ui=q#ni:/lib/fn#;
$vi={$u,1};
$wi=q#/lib/fn#;
$xi={};
$yi=q#shift->compile#;
$zi=bless({$q,$yi,$s,$t},$u);
$Ai=q#compile#;
$Bi=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Ci=bless({$q,$Bi,$s,$t},$u);
$Di=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Ei=bless({$q,$Di,$s,$t},$u);
$Fi={$Ai,$Ci,$S3,$Ei};
$Gi=q#/lib/fn_init.b#;
$Hi=bless({$j2,$xi,$Q2,$zi,$S2,$R2,$T2,$Fi,$D,$Gi},$e3);
$Ii={};
$Ji=[];
$Ki=q#shift->{'annotations'}#;
$Li=bless({$o,$Ji,$q,$Ki,$s,$t},$u);
$Mi=[];
$Ni=q#shift->{'code'}#;
$Oi=bless({$o,$Mi,$q,$Ni,$s,$t},$u);
$Pi=q#fn#;
$Qi=[];
$Ri=q#shift->{'fn'}#;
$Si=bless({$o,$Qi,$q,$Ri,$s,$t},$u);
$Ti={$o,$Li,$q,$Oi,$Pi,$Si};
$Ui=q#/lib/fn_ro.b#;
$Vi=bless({$j2,$Ii,$Q2,$R2,$S2,$R2,$T2,$Ti,$D,$Ui},$e3);
$Wi={};
$Xi=[];
$Yi=q#shift->{code}#;
$Zi=bless({$o,$Xi,$q,$Yi,$s,$t},$u);
$cj=[];
$dj=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$ej=bless({$o,$cj,$q,$dj,$s,$t},$u);
$fj={$h5,$Zi,$o5,$ej};
$gj=q#/lib/fn_ops.b#;
$hj=bless({$j2,$Wi,$Q2,$R2,$S2,$R2,$T2,$fj,$D,$gj},$e3);
$ij={};
$jj=q#serialize#;
$kj=[];
$lj=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$mj=bless({$o,$kj,$q,$lj,$s,$t},$u);
$nj={$jj,$mj};
$oj=q#/lib/fn_serialize.b#;
$pj=bless({$j2,$ij,$Q2,$R2,$S2,$R2,$T2,$nj,$D,$oj},$e3);
$qj=[$y4,$Q5,$Hi,$Vi,$hj,$pj];
$rj=bless({$j2,$vi,$D,$wi,$J2,$qj},$y2);
$sj=q#lib/fn.c::ctors#;
$tj=q#ni:/lib/fn.c#;
$uj={$y2,1};
$vj=q#/lib/fn.c#;
$wj=[$l6];
$xj=bless({$j2,$uj,$D,$vj,$J2,$wj},$K2);
$yj=q#ni:/lib/fn_init.b#;
$zj=q#ni:/lib/fn_ops.b#;
$Aj=q#ni:/lib/fn_ro.b#;
$Bj=q#ni:/lib/fn_serialize.b#;
$Cj=q#ni:/lib/global_static_test.b#;
$Dj={};
$Ej=q#now#;
$Fj=[];
$Gj=q#ni('ni:/lib/test_value')->new(shift)#;
$Hj=q#($)#;
$Ij=bless({$o,$Fj,$q,$Gj,$s,$Hj},$u);
$Jj={$Ej,$Ij};
$Kj=q#/lib/global_static_test.b#;
$Lj=bless({$j2,$Dj,$Q2,$R2,$S2,$R2,$T2,$Jj,$D,$Kj},$e3);
$Mj=q#ni:/lib/image#;
$Nj={$k4,1};
$Oj=q#/lib/image#;
$Pj={};
$Qj=[];
$Rj=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Sj=bless({$o,$Qj,$q,$Rj,$s,$t},$u);
$Tj={$S3,$Sj};
$Uj=q#/lib/image_init.b#;
$Vj=bless({$j2,$Pj,$Q2,$R2,$S2,$R2,$T2,$Tj,$D,$Uj},$e3);
$Wj={};
$Xj=q#address#;
$Yj=[];
$Zj=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$ck=bless({$o,$Yj,$q,$Zj,$s,$t},$u);
$dk=q#allocate_gensym#;
$ek=[];
$fk=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$gk=bless({$o,$ek,$q,$fk,$s,$t},$u);
$hk=q#boot_side_effect#;
$ik=[];
$jk=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$kk=bless({$o,$ik,$q,$jk,$s,$t},$u);
$lk=q#circular_links#;
$mk=[];
$nk=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$ok=bless({$o,$mk,$q,$nk,$s,$t},$u);
$pk=q#finalizer#;
$qk=[];
$rk=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk=q#gensym#;
$uk=[];
$vk=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$wk=bless({$o,$uk,$q,$vk,$s,$t},$u);
$xk=q#quote#;
$yk=[];
$zk=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ak=bless({$o,$yk,$q,$zk,$s,$t},$u);
$Bk=q#reconstruction#;
$Ck=[];
$Dk=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ek=bless({$o,$Ck,$q,$Dk,$s,$t},$u);
$Fk=q#side_effect#;
$Gk=[];
$Hk=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ik=bless({$o,$Gk,$q,$Hk,$s,$t},$u);
$Jk=[];
$Kk=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Lk=bless({$o,$Jk,$q,$Kk,$s,$t},$u);
$Mk={$Xj,$ck,$dk,$gk,$hk,$kk,$lk,$ok,$pk,$sk,$tk,$wk,$xk,$Ak,$Bk,$Ek,$Fk,$Ik,$nb,$Lk};
$Nk=q#/lib/image_quoting.b#;
$Ok=bless({$j2,$Wj,$Q2,$R2,$S2,$R2,$T2,$Mk,$D,$Nk},$e3);
$Pk={};
$Qk=q#quote_code#;
$Rk=[];
$Sk=q#shift->die('cannot quote perl CODE refs', shift)#;
$Tk=bless({$o,$Rk,$q,$Sk,$s,$t},$u);
$Uk={$Qk,$Tk};
$Vk=q#/lib/quote_code_fail.b#;
$Wk=bless({$j2,$Pk,$Q2,$R2,$S2,$R2,$T2,$Uk,$D,$Vk},$e3);
$Xk={};
$Yk=q#quote_array#;
$Zk=[];
$cl=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$dl=bless({$o,$Zk,$q,$cl,$s,$t},$u);
$el=q#quote_hash#;
$fl=[];
$gl=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$hl=bless({$o,$fl,$q,$gl,$s,$t},$u);
$il=q#quote_scalar#;
$jl=[];
$kl=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$ll=bless({$o,$jl,$q,$kl,$s,$t},$u);
$ml=q#quote_scalar_ref#;
$nl=[];
$ol=q#'\\\\' . shift->quote(${$_[0]})#;
$pl=bless({$o,$nl,$q,$ol,$s,$t},$u);
$ql=q#quote_value#;
$rl=[];
$sl=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$tl=bless({$o,$rl,$q,$sl,$s,$t},$u);
$ul={$Yk,$dl,$el,$hl,$il,$ll,$ml,$pl,$ql,$tl};
$vl=q#/lib/quote_values.b#;
$wl=bless({$j2,$Xk,$Q2,$R2,$S2,$R2,$T2,$ul,$D,$vl},$e3);
$xl={};
$yl=q#quote_blessed#;
$zl=[];
$Al=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Bl=bless({$o,$zl,$q,$Al,$s,$t},$u);
$Cl=q#quote_class#;
$Dl=[];
$El=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Fl=bless({$o,$Dl,$q,$El,$s,$t},$u);
$Gl=q#quote_object#;
$Hl=[];
$Il=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Jl=bless({$o,$Hl,$q,$Il,$s,$t},$u);
$Kl={$yl,$Bl,$Cl,$Fl,$Gl,$Jl};
$Ll=q#/lib/quote_objects.b#;
$Ml=bless({$j2,$xl,$Q2,$R2,$S2,$R2,$T2,$Kl,$D,$Ll},$e3);
$Nl={};
$Ol=q#circular_arrayref#;
$Pl=[];
$Ql=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Rl=bless({$o,$Pl,$q,$Ql,$s,$t},$u);
$Sl=q#circular_hashref#;
$Tl=[];
$Ul=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Vl=bless({$o,$Tl,$q,$Ul,$s,$t},$u);
$Wl=q#is_circular#;
$Xl=[];
$Yl=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Zl=bless({$o,$Xl,$q,$Yl,$s,$t},$u);
$cm={$Ol,$Rl,$Sl,$Vl,$Wl,$Zl};
$dm=q#/lib/quote_circular_addressed.b#;
$em=bless({$j2,$Nl,$Q2,$R2,$S2,$R2,$T2,$cm,$D,$dm},$e3);
$fm=[$y4,$Vj,$Ok,$Wk,$wl,$Ml,$em];
$gm=bless({$j2,$Nj,$D,$Oj,$J2,$fm},$z2);
$hm=q#lib/image.c::ctors#;
$im=q#ni:/lib/image.c#;
$jm={$z2,1};
$km=q#/lib/image.c#;
$lm=[$l6];
$mm=bless({$j2,$jm,$D,$km,$J2,$lm},$K2);
$nm=q#ni:/lib/image_init.b#;
$om=q#ni:/lib/image_quoting.b#;
$pm=q#ni:/lib/instance.b#;
$qm=q#ni:/lib/instantiable.b#;
$rm=q#ni:/lib/json.b#;
$sm={};
$tm=q#json_decode#;
$um=[];
$vm=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$wm=bless({$o,$um,$q,$vm,$s,$Hj},$u);
$xm=q#json_encode#;
$ym=[];
$zm=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Am=bless({$o,$ym,$q,$zm,$s,$Hj},$u);
$Bm=q#json_escape#;
$Cm=[];
$Dm=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Em=bless({$o,$Cm,$q,$Dm,$s,$Hj},$u);
$Fm=q#json_unescape#;
$Gm=[];
$Hm=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Im=bless({$o,$Gm,$q,$Hm,$s,$Hj},$u);
$Jm=q#json_unescape_one#;
$Km=[];
$Lm=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Mm=bless({$o,$Km,$q,$Lm,$s,$Hj},$u);
$Nm={$tm,$wm,$xm,$Am,$Bm,$Em,$Fm,$Im,$Jm,$Mm};
$Om=q#/lib/json.b#;
$Pm=bless({$j2,$sm,$Q2,$R2,$S2,$R2,$T2,$Nm,$D,$Om},$e3);
$Qm=q#ni#;
$Rm=q#ni:/lib/name_as_string.b#;
$Sm=q#ni:/lib/named.b#;
$Tm=q#ni:/lib/named_in_ni.b#;
$Um=q#ni:/lib/namespaced.b#;
$Vm=q#ni:/lib/ni#;
$Wm={$l4,1};
$Xm=q#/lib/ni#;
$Ym={};
$Zm=q#extend#;
$cn=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$dn=bless({$q,$cn,$s,$t},$u);
$en=q#is_mutable#;
$fn=q#$0 ne "-" && -w $0#;
$gn=bless({$q,$fn,$s,$t},$u);
$hn=q#modify#;
$in=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$jn=bless({$q,$in,$s,$t},$u);
$kn={$Zm,$dn,$en,$gn,$hn,$jn};
$ln=q#/lib/ni_self.b#;
$mn=bless({$j2,$Ym,$Q2,$R2,$S2,$R2,$T2,$kn,$D,$ln},$e3);
$nn={};
$on=q#exists#;
$pn=q#exists $_[0]->{named}{$_[1]}#;
$qn=bless({$q,$pn,$s,$t},$u);
$rn=q#quoted#;
$sn=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$tn=bless({$q,$sn,$s,$t},$u);
$un={$on,$qn,$rn,$tn};
$vn=q#/lib/ni_image.b#;
$wn=bless({$j2,$nn,$Q2,$R2,$S2,$R2,$T2,$un,$D,$vn},$e3);
$xn={};
$yn=q#--internal/+=#;
$zn=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$An=bless({$q,$zn,$s,$t},$u);
$Bn=q#--internal/eval#;
$Cn=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Dn=bless({$q,$Cn,$s,$t},$u);
$En=q#--internal/image#;
$Fn=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Gn=bless({$q,$Fn,$s,$t},$u);
$Hn=q#--internal/test#;
$In=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Jn=bless({$q,$In,$s,$t},$u);
$Kn=q#run#;
$Ln=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Mn=bless({$q,$Ln,$s,$t},$u);
$Nn={$yn,$An,$Bn,$Dn,$En,$Gn,$Hn,$Jn,$Kn,$Mn};
$On=q#/lib/ni_main.b#;
$Pn=bless({$j2,$xn,$Q2,$R2,$S2,$R2,$T2,$Nn,$D,$On},$e3);
$Qn={};
$Rn=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Sn=bless({$q,$Rn,$s,$t},$u);
$Tn=q#resolver_for#;
$Un=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Vn=bless({$q,$Un,$s,$t},$u);
$Wn={$G3,$Sn,$Tn,$Vn};
$Xn=q#/lib/ni_resolver.b#;
$Yn=bless({$j2,$Qn,$Q2,$R2,$S2,$R2,$T2,$Wn,$D,$Xn},$e3);
$Zn=[$y4,$mn,$wn,$Pn,$Yn];
$co=bless({$j2,$Wm,$D,$Xm,$J2,$Zn},$A2);
$do=q#lib/ni.c::ctors#;
$eo=q#ni:/lib/ni.c#;
$fo={$A2,1};
$go=q#/lib/ni.c#;
$ho=[$l6];
$io=bless({$j2,$fo,$D,$go,$J2,$ho},$K2);
$jo=q#ni:/lib/ni_image.b#;
$ko=q#ni:/lib/ni_main.b#;
$lo=q#ni:/lib/ni_resolver.b#;
$mo=q#ni:/lib/ni_self.b#;
$no=q#ni:/lib/ni_static_util.b#;
$oo={};
$po=q#abbrev#;
$qo=[];
$ro=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$so=bless({$o,$qo,$q,$ro,$s,$t},$u);
$to=q#dor#;
$uo=[];
$vo=q#defined $_[0] ? $_[0] : $_[1]#;
$wo=bless({$o,$uo,$q,$vo,$s,$t},$u);
$xo=q#indent#;
$yo=[];
$zo=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Ao=bless({$o,$yo,$q,$zo,$s,$t},$u);
$Bo=q#max#;
$Co=[];
$Do=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Eo=bless({$o,$Co,$q,$Do,$s,$t},$u);
$Fo=q#maxstr#;
$Go=[];
$Ho=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo=q#mean#;
$Ko=[];
$Lo=q#sum(@_) / (@_ || 1)#;
$Mo=bless({$o,$Ko,$q,$Lo,$s,$t},$u);
$No=q#min#;
$Oo=[];
$Po=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Qo=bless({$o,$Oo,$q,$Po,$s,$t},$u);
$Ro=q#minstr#;
$So=[];
$To=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Uo=bless({$o,$So,$q,$To,$s,$t},$u);
$Vo=q#sgr#;
$Wo=[];
$Xo=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Yo=bless({$o,$Wo,$q,$Xo,$s,$t},$u);
$Zo=q#sr#;
$cp=[];
$dp=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$ep=bless({$o,$cp,$q,$dp,$s,$t},$u);
$fp=q#sum#;
$gp=[];
$hp=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$ip=bless({$o,$gp,$q,$hp,$s,$t},$u);
$jp=q#swap#;
$kp=[];
$lp=q#@_[0, 1] = @_[1, 0]#;
$mp=bless({$o,$kp,$q,$lp,$s,$t},$u);
$np={$po,$so,$to,$wo,$xo,$Ao,$Bo,$Eo,$Fo,$Io,$Jo,$Mo,$No,$Qo,$Ro,$Uo,$Vo,$Yo,$Zo,$ep,$fp,$ip,$jp,$mp};
$op=q#/lib/ni_static_util.b#;
$pp=bless({$j2,$oo,$Q2,$R2,$S2,$R2,$T2,$np,$D,$op},$e3);
$qp=q#ni:/lib/perlbranch.b#;
$rp=q#ni:/lib/quote_circular_addressed.b#;
$sp=q#ni:/lib/quote_code_fail.b#;
$tp=q#ni:/lib/quote_objects.b#;
$up=q#ni:/lib/quote_simple#;
$vp={$m4,1};
$wp=q#/lib/quote_simple#;
$xp={};
$yp=[];
$zp=q#+{}#;
$Ap=bless({$o,$yp,$q,$zp,$s,$t},$u);
$Bp={$S3,$Ap};
$Cp=q#/lib/quote_simple_init.b#;
$Dp=bless({$j2,$xp,$Q2,$R2,$S2,$R2,$T2,$Bp,$D,$Cp},$e3);
$Ep={};
$Fp=[];
$Gp=bless({$o,$Fp,$q,0,$s,$t},$u);
$Hp=[];
$Ip=q#shift->quote_value(shift)#;
$Jp=bless({$o,$Hp,$q,$Ip,$s,$t},$u);
$Kp={$Wl,$Gp,$xk,$Jp};
$Lp=q#/lib/quote_simple_quote.b#;
$Mp=bless({$j2,$Ep,$Q2,$R2,$S2,$R2,$T2,$Kp,$D,$Lp},$e3);
$Np=[$y4,$Dp,$Mp,$Wk,$wl,$Ml];
$Op=bless({$j2,$vp,$D,$wp,$J2,$Np},$B2);
$Pp=q#lib/quote_simple.c::ctors#;
$Qp=q#ni:/lib/quote_simple.c#;
$Rp={$B2,1};
$Sp=q#/lib/quote_simple.c#;
$Tp=[$l6];
$Up=bless({$j2,$Rp,$D,$Sp,$J2,$Tp},$K2);
$Vp=q#ni:/lib/quote_simple_init.b#;
$Wp=q#ni:/lib/quote_simple_quote.b#;
$Xp=q#ni:/lib/quote_values.b#;
$Yp=q#ni:/lib/ref_eq.b#;
$Zp=q#ni:/lib/resolver.b#;
$cq=q#ni:/lib/slice#;
$dq={$e3,1};
$eq=q#/lib/slice#;
$fq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$gq=bless({$q,$fq,$s,$t},$u);
$hq=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$iq=bless({$q,$hq,$s,$t},$u);
$jq=q#lib/slice::apply#;
$kq=q#lib/slice::apply_unsafe#;
$lq={};
$mq=q#apply_unsafe#;
$nq={$X2,$gq,$mq,$iq};
$oq=q#/lib/slice.b#;
$pq=bless({$j2,$lq,$T2,$nq,$D,$oq},$e3);
$qq={};
$rq=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$sq=bless({$q,$rq,$s,$t},$u);
$tq={$S3,$sq};
$uq=q#/lib/slice_init.b#;
$vq=bless({$j2,$qq,$T2,$tq,$D,$uq},$e3);
$wq={};
$xq=[];
$yq=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$zq=bless({$o,$xq,$q,$yq,$s,$t},$u);
$Aq={$jj,$zq};
$Bq=q#/lib/slice_serialize.b#;
$Cq=bless({$j2,$wq,$Q2,$R2,$S2,$R2,$T2,$Aq,$D,$Bq},$e3);
$Dq=[$J4,$p3,$pq,$vq,$Cq];
$Eq=bless({$j2,$dq,$D,$eq,$J2,$Dq},$C2);
$Fq=q#lib/slice.c::ctors#;
$Gq=q#ni:/lib/slice.b#;
$Hq=q#ni:/lib/slice.c#;
$Iq={$C2,1};
$Jq=q#/lib/slice.c#;
$Kq=[$q6];
$Lq=bless({$j2,$Iq,$D,$Jq,$J2,$Kq},$K2);
$Mq=q#ni:/lib/slice_init.b#;
$Nq=q#ni:/lib/slice_serialize.b#;
$Oq=q#ni:/lib/static_fn.b#;
$Pq={};
$Qq=[];
$Rq=q#ni('ni:/lib/fn')->new(@_)#;
$Sq=bless({$o,$Qq,$q,$Rq,$s,$Hj},$u);
$Tq=q#fp#;
$Uq=[];
$Vq=q#($$)#;
$Wq=bless({$o,$Uq,$q,$Rq,$s,$Vq},$u);
$Xq={$Pi,$Sq,$Tq,$Wq};
$Yq=q#/lib/static_fn.b#;
$Zq=bless({$j2,$Pq,$Q2,$R2,$S2,$R2,$T2,$Xq,$D,$Yq},$e3);
$cr=q#ni:/lib/subclass.b#;
$dr=q#ni:/lib/tag#;
$er={$q3,1};
$fr=q#/lib/tag#;
$gr={};
$hr=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$ir=bless({$q,$hr,$s,$t},$u);
$jr={$X2,$ir};
$kr=q#/lib/tag.b#;
$lr=bless({$j2,$gr,$Q2,$R2,$S2,$R2,$T2,$jr,$D,$kr},$e3);
$mr={};
$nr=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$or=bless({$q,$nr,$s,$t},$u);
$pr={$S3,$or};
$qr=q#/lib/tag_init.b#;
$rr=bless({$j2,$mr,$Q2,$R2,$S2,$R2,$T2,$pr,$D,$qr},$e3);
$sr=[$J4,$p3,$lr,$rr];
$tr=bless({$j2,$er,$D,$fr,$J2,$sr},$D2);
$ur=q#lib/tag.c::ctors#;
$vr=q#ni:/lib/tag.b#;
$wr=q#ni:/lib/tag.c#;
$xr={$D2,1};
$yr=q#/lib/tag.c#;
$zr=[$q6];
$Ar=bless({$j2,$xr,$D,$yr,$J2,$zr},$K2);
$Br=q#ni:/lib/tag_init.b#;
$Cr=q#ni:/lib/test_value#;
$Dr={$n4,1};
$Er=q#/lib/test_value#;
$Fr={};
$Gr=[];
$Hr=q#\\$_[1]#;
$Ir=bless({$o,$Gr,$q,$Hr,$s,$t},$u);
$Jr={$S3,$Ir};
$Kr=q#/lib/test_value_init.b#;
$Lr=bless({$j2,$Fr,$Q2,$R2,$S2,$R2,$T2,$Jr,$D,$Kr},$e3);
$Mr={};
$Nr=q#(==#;
$Or=[];
$Pr=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Qr=bless({$o,$Or,$q,$Pr,$s,$t},$u);
$Rr=q#diff#;
$Sr=[];
$Tr=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Ur=bless({$o,$Sr,$q,$Tr,$s,$t},$u);
$Vr={$Nr,$Qr,$Rr,$Ur};
$Wr=q#/lib/test_value_eq.b#;
$Xr=bless({$j2,$Mr,$Q2,$R2,$S2,$R2,$T2,$Vr,$D,$Wr},$e3);
$Yr={};
$Zr=[];
$cs=q#ni::json_encode ${$_[0]}#;
$ds=bless({$o,$Zr,$q,$cs,$s,$t},$u);
$es={$h5,$ds};
$fs=q#/lib/test_value_str.b#;
$gs=bless({$j2,$Yr,$Q2,$R2,$S2,$R2,$T2,$es,$D,$fs},$e3);
$hs=[$y4,$Lr,$Xr,$gs];
$is=bless({$j2,$Dr,$D,$Er,$J2,$hs},$E2);
$js=q#lib/test_value.c::ctors#;
$ks=q#ni:/lib/test_value.c#;
$ls={$E2,1};
$ms=q#/lib/test_value.c#;
$ns=[$l6];
$os=bless({$j2,$ls,$D,$ms,$J2,$ns},$K2);
$ps=q#ni:/lib/test_value_eq.b#;
$qs=q#ni:/lib/test_value_init.b#;
$rs=q#ni:/lib/test_value_str.b#;
$ss=q#ni:/metaclass#;
$ts={$K2,1};
$us=q#/metaclass#;
$vs=[$N3,$Q5,$X3,$F5];
$ws=bless({$j2,$ts,$D,$us,$J2,$vs},$F2);
$xs=q#metaclass.c::ctors#;
$ys=q#ni:/metaclass.c#;
$zs={$F2,1};
$As=q#/metaclass.c#;
$Bs=[$Z5];
$Cs=bless({$j2,$zs,$D,$As,$J2,$Bs},$K2);
$Ds=q#ni:/module#;
$Es=q#ni:/module.c#;
$Fs=q#ni:/object#;
$Gs=q#ni:/object.c#;
$Hs=q#ni:main#;
$Is={$jd,1};
$Js=[$Zq,$Lj,$id];
$Ks=bless({$j2,$Is,$D,$jd,$J2,$Js},$L2);
$Ls=q#module::ctors#;
$Ms=q#ni:ni#;
$Ns={$Qm,1};
$Os={$Qm,1};
$Ps=q#json_escapes#;
$Qs=q##;
$Rs=q#b#;
$Ss=q#	#;
$Ts=q#t#;
$Us=q#
#;
$Vs=q#n#;
$Ws=q##;
$Xs=q#"#;
$Ys=q#/#;
$Zs=q#\\#;
$ct={$Qs,$Rs,$Ss,$Ts,$Us,$Vs,$Ws,$kc,$Xs,$Xs,$Ys,$Ys,$Zs,$Zs};
$dt=q#json_unescapes#;
$et={$Xs,$Xs,$Ys,$Ys,$Zs,$Zs,$Rs,$Qs,$Vs,$Us,$kc,$Ws,$Ts,$Ss};
$ft={$Ps,$ct,$dt,$et};
$gt=q#/lib/json_data.b#;
$ht=bless({$j2,$Os,$Df,$ft,$D,$gt},$j4);
$it=q#lib/dataslice::ctors#;
$jt=[$ht,$Pm,$pp];
$kt=bless({$j2,$Ns,$D,$Qm,$J2,$jt},$L2);
$lt={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$P1,$Q1,$h2,$i2,$Z5,$d6,$u6,$v6,$T7,$V7,$f8,$g8,$J7,$h8,$R7,$i8,$S9,$U9,$Y9,$Z9,$A9,$ca,$Q9,$da,$y8,$ea,$s9,$fa,$S8,$ga,$r8,$ha,$vb,$xb,$Bb,$Cb,$Va,$Db,$ib,$Eb,$xa,$Fb,$tb,$Gb,$qa,$Hb,$Fa,$Ib,$Cc,$Ec,$Ic,$Jc,$Zb,$Kc,$ic,$Lc,$Ac,$Mc,$Rb,$Nc,$id,$kd,$Id,$Kd,$Od,$Pd,$td,$Qd,$Gd,$Rd,$B7,$Sd,$d8,$Td,$j7,$Ud,$r7,$Vd,$z7,$Wd,$F6,$Xd,$N6,$Yd,$nf,$pf,$tf,$uf,$lf,$vf,$xe,$wf,$Te,$xf,$ne,$yf,$Je,$zf,$qg,$sg,$wg,$xg,$Yf,$yg,$og,$zg,$Rf,$Ag,$f5,$Bg,$J4,$Cg,$q6,$Dg,$Ng,$Pg,$f3,$Qg,$Ug,$Vg,$Lg,$Wg,$X3,$Xg,$ph,$rh,$vh,$wh,$nh,$xh,$hh,$yh,$C5,$zh,$T4,$Ah,$A5,$Bh,$ii,$ki,$oi,$pi,$Vh,$qi,$Ih,$ri,$Oh,$si,$gi,$ti,$H4,$ui,$rj,$tj,$xj,$yj,$Hi,$zj,$hj,$Aj,$Vi,$Bj,$pj,$Cj,$Lj,$Mj,$gm,$im,$mm,$nm,$Vj,$om,$Ok,$pm,$w4,$qm,$Q5,$rm,$Pm,$Rm,$m5,$Sm,$p3,$Tm,$x3,$Um,$E3,$Vm,$co,$eo,$io,$jo,$wn,$ko,$Pn,$lo,$Yn,$mo,$mn,$no,$pp,$qp,$N3,$rp,$em,$sp,$Wk,$tp,$Ml,$up,$Op,$Qp,$Up,$Vp,$Dp,$Wp,$Mp,$Xp,$wl,$Yp,$t5,$Zp,$L3,$cq,$Eq,$Gq,$pq,$Hq,$Lq,$Mq,$vq,$Nq,$Cq,$Oq,$Zq,$cr,$X5,$dr,$tr,$vr,$lr,$wr,$Ar,$Br,$rr,$Cr,$is,$ks,$os,$ps,$Xr,$qs,$Lr,$rs,$gs,$ss,$ws,$ys,$Cs,$Ds,$F5,$Es,$s6,$Fs,$y4,$Gs,$l6,$Hs,$Ks,$Ms,$kt};
$mt=q#resolvers#;
$nt=[];
$ot=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$pt=bless({$o,$nt,$q,$ot,$s,$t},$u);
$qt=q#file#;
$rt=[];
$st=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$tt=bless({$o,$rt,$q,$st,$s,$t},$u);
$ut=q#null#;
$vt=[];
$wt=q#ni('ni:/io/null')->new#;
$xt=bless({$o,$vt,$q,$wt,$s,$t},$u);
$yt=q#sh#;
$zt=[];
$At=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Bt=bless({$o,$zt,$q,$At,$s,$t},$u);
$Ct=q#str#;
$Dt=[];
$Et=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Ft=bless({$o,$Dt,$q,$Et,$s,$t},$u);
$Gt={$Y8,$pt,$qt,$tt,$ut,$xt,$yt,$Bt,$Ct,$Ft};
$Ht=bless({$c,$lt,$mt,$Gt},$l4);
$It=q#lib/ni::ctors#;
*$kq=\&$iq;
*$jq=\&$gq;
$f3->apply_unsafe($k2);
$f3->apply_unsafe($l2);
$f3->apply_unsafe($m2);
$f3->apply_unsafe($n2);
$f3->apply_unsafe($o2);
$f3->apply_unsafe($p2);
$f3->apply_unsafe($q2);
$f3->apply_unsafe($r2);
$f3->apply_unsafe($s2);
$f3->apply_unsafe($t2);
$f3->apply_unsafe($u2);
$f3->apply_unsafe($g3);
$f3->apply_unsafe($v2);
$f3->apply_unsafe($w2);
$f3->apply_unsafe($x2);
$f3->apply_unsafe($y2);
$f3->apply_unsafe($z2);
$f3->apply_unsafe($A2);
$f3->apply_unsafe($B2);
$f3->apply_unsafe($C2);
$f3->apply_unsafe($D2);
$f3->apply_unsafe($E2);
$f3->apply_unsafe($K2);
$f3->apply_unsafe($F2);
$f3->apply_unsafe($L2);
$f3->apply_unsafe($G2);
$f3->apply_unsafe($H2);
$p3->apply_unsafe($k2);
$p3->apply_unsafe($l2);
$p3->apply_unsafe($m2);
$p3->apply_unsafe($n2);
$p3->apply_unsafe($o2);
$p3->apply_unsafe($p2);
$p3->apply_unsafe($q2);
$p3->apply_unsafe($r2);
$p3->apply_unsafe($s2);
$p3->apply_unsafe($t2);
$p3->apply_unsafe($u2);
$p3->apply_unsafe($g3);
$p3->apply_unsafe($v2);
$p3->apply_unsafe($w2);
$p3->apply_unsafe($F);
$p3->apply_unsafe($x2);
$p3->apply_unsafe($y2);
$p3->apply_unsafe($z2);
$p3->apply_unsafe($A2);
$p3->apply_unsafe($B2);
$p3->apply_unsafe($e3);
$p3->apply_unsafe($C2);
$p3->apply_unsafe($q3);
$p3->apply_unsafe($D2);
$p3->apply_unsafe($E2);
$p3->apply_unsafe($K2);
$p3->apply_unsafe($F2);
$p3->apply_unsafe($L2);
$p3->apply_unsafe($G2);
$p3->apply_unsafe($H2);
$x3->apply_unsafe($k2);
$x3->apply_unsafe($l2);
$x3->apply_unsafe($m2);
$x3->apply_unsafe($n2);
$x3->apply_unsafe($o2);
$x3->apply_unsafe($p2);
$x3->apply_unsafe($q2);
$x3->apply_unsafe($r2);
$x3->apply_unsafe($s2);
$x3->apply_unsafe($t2);
$x3->apply_unsafe($u2);
$x3->apply_unsafe($g3);
$x3->apply_unsafe($v2);
$x3->apply_unsafe($w2);
$x3->apply_unsafe($x2);
$x3->apply_unsafe($y2);
$x3->apply_unsafe($z2);
$x3->apply_unsafe($A2);
$x3->apply_unsafe($B2);
$x3->apply_unsafe($e3);
$x3->apply_unsafe($C2);
$x3->apply_unsafe($q3);
$x3->apply_unsafe($D2);
$x3->apply_unsafe($E2);
$x3->apply_unsafe($K2);
$x3->apply_unsafe($F2);
$x3->apply_unsafe($L2);
$x3->apply_unsafe($G2);
$x3->apply_unsafe($H2);
$E3->apply_unsafe($k2);
$E3->apply_unsafe($l2);
$E3->apply_unsafe($m2);
$E3->apply_unsafe($n2);
$E3->apply_unsafe($o2);
$E3->apply_unsafe($p2);
$E3->apply_unsafe($q2);
$E3->apply_unsafe($r2);
$E3->apply_unsafe($s2);
$E3->apply_unsafe($t2);
$E3->apply_unsafe($u2);
$E3->apply_unsafe($g3);
$E3->apply_unsafe($v2);
$E3->apply_unsafe($w2);
$E3->apply_unsafe($x2);
$E3->apply_unsafe($y2);
$E3->apply_unsafe($z2);
$E3->apply_unsafe($A2);
$E3->apply_unsafe($B2);
$E3->apply_unsafe($e3);
$E3->apply_unsafe($C2);
$E3->apply_unsafe($q3);
$E3->apply_unsafe($D2);
$E3->apply_unsafe($E2);
$E3->apply_unsafe($K2);
$E3->apply_unsafe($F2);
$E3->apply_unsafe($L2);
$E3->apply_unsafe($G2);
$E3->apply_unsafe($H2);
$L3->apply_unsafe($k2);
$L3->apply_unsafe($l2);
$L3->apply_unsafe($m2);
$L3->apply_unsafe($n2);
$L3->apply_unsafe($o2);
$L3->apply_unsafe($p2);
$L3->apply_unsafe($q2);
$L3->apply_unsafe($r2);
$L3->apply_unsafe($s2);
$L3->apply_unsafe($t2);
$L3->apply_unsafe($u2);
$L3->apply_unsafe($g3);
$L3->apply_unsafe($v2);
$L3->apply_unsafe($w2);
$L3->apply_unsafe($x2);
$L3->apply_unsafe($y2);
$L3->apply_unsafe($z2);
$L3->apply_unsafe($A2);
$L3->apply_unsafe($B2);
$L3->apply_unsafe($C2);
$L3->apply_unsafe($q3);
$L3->apply_unsafe($D2);
$L3->apply_unsafe($E2);
$L3->apply_unsafe($K2);
$L3->apply_unsafe($F2);
$L3->apply_unsafe($L2);
$L3->apply_unsafe($G2);
$L3->apply_unsafe($H2);
$X3->apply_unsafe($k2);
$X3->apply_unsafe($l2);
$X3->apply_unsafe($m2);
$X3->apply_unsafe($n2);
$X3->apply_unsafe($o2);
$X3->apply_unsafe($p2);
$X3->apply_unsafe($q2);
$X3->apply_unsafe($r2);
$X3->apply_unsafe($s2);
$X3->apply_unsafe($t2);
$X3->apply_unsafe($u2);
$X3->apply_unsafe($v2);
$X3->apply_unsafe($w2);
$X3->apply_unsafe($x2);
$X3->apply_unsafe($y2);
$X3->apply_unsafe($z2);
$X3->apply_unsafe($A2);
$X3->apply_unsafe($B2);
$X3->apply_unsafe($C2);
$X3->apply_unsafe($D2);
$X3->apply_unsafe($E2);
$X3->apply_unsafe($K2);
$X3->apply_unsafe($F2);
$X3->apply_unsafe($L2);
$X3->apply_unsafe($G2);
$X3->apply_unsafe($H2);
$w4->apply_unsafe($k2);
$w4->apply_unsafe($l2);
$w4->apply_unsafe($Y3);
$w4->apply_unsafe($m2);
$w4->apply_unsafe($Z3);
$w4->apply_unsafe($n2);
$w4->apply_unsafe($c4);
$w4->apply_unsafe($o2);
$w4->apply_unsafe($d4);
$w4->apply_unsafe($p2);
$w4->apply_unsafe($e4);
$w4->apply_unsafe($q2);
$w4->apply_unsafe($f4);
$w4->apply_unsafe($r2);
$w4->apply_unsafe($g4);
$w4->apply_unsafe($s2);
$w4->apply_unsafe($h4);
$w4->apply_unsafe($t2);
$w4->apply_unsafe($i4);
$w4->apply_unsafe($u2);
$w4->apply_unsafe($g3);
$w4->apply_unsafe($v2);
$w4->apply_unsafe($j4);
$w4->apply_unsafe($w2);
$w4->apply_unsafe($F);
$w4->apply_unsafe($x2);
$w4->apply_unsafe($u);
$w4->apply_unsafe($y2);
$w4->apply_unsafe($k4);
$w4->apply_unsafe($z2);
$w4->apply_unsafe($l4);
$w4->apply_unsafe($A2);
$w4->apply_unsafe($m4);
$w4->apply_unsafe($B2);
$w4->apply_unsafe($e3);
$w4->apply_unsafe($C2);
$w4->apply_unsafe($q3);
$w4->apply_unsafe($D2);
$w4->apply_unsafe($n4);
$w4->apply_unsafe($E2);
$w4->apply_unsafe($K2);
$w4->apply_unsafe($F2);
$w4->apply_unsafe($L2);
$w4->apply_unsafe($G2);
$w4->apply_unsafe($o4);
$w4->apply_unsafe($H2);
$H4->apply_unsafe($k2);
$H4->apply_unsafe($l2);
$H4->apply_unsafe($m2);
$H4->apply_unsafe($n2);
$H4->apply_unsafe($o2);
$H4->apply_unsafe($p2);
$H4->apply_unsafe($q2);
$H4->apply_unsafe($r2);
$H4->apply_unsafe($s2);
$H4->apply_unsafe($t2);
$H4->apply_unsafe($i4);
$H4->apply_unsafe($u2);
$H4->apply_unsafe($g3);
$H4->apply_unsafe($v2);
$H4->apply_unsafe($j4);
$H4->apply_unsafe($w2);
$H4->apply_unsafe($x2);
$H4->apply_unsafe($y2);
$H4->apply_unsafe($z2);
$H4->apply_unsafe($A2);
$H4->apply_unsafe($B2);
$H4->apply_unsafe($e3);
$H4->apply_unsafe($C2);
$H4->apply_unsafe($q3);
$H4->apply_unsafe($D2);
$H4->apply_unsafe($E2);
$H4->apply_unsafe($K2);
$H4->apply_unsafe($F2);
$H4->apply_unsafe($L2);
$H4->apply_unsafe($G2);
$H4->apply_unsafe($H2);
$T4->apply_unsafe($k2);
$T4->apply_unsafe($l2);
$T4->apply_unsafe($m2);
$T4->apply_unsafe($n2);
$T4->apply_unsafe($o2);
$T4->apply_unsafe($p2);
$T4->apply_unsafe($q2);
$T4->apply_unsafe($r2);
$T4->apply_unsafe($s2);
$T4->apply_unsafe($t2);
$T4->apply_unsafe($u2);
$T4->apply_unsafe($g3);
$T4->apply_unsafe($v2);
$T4->apply_unsafe($w2);
$T4->apply_unsafe($x2);
$T4->apply_unsafe($y2);
$T4->apply_unsafe($z2);
$T4->apply_unsafe($A2);
$T4->apply_unsafe($B2);
$T4->apply_unsafe($C2);
$T4->apply_unsafe($D2);
$T4->apply_unsafe($E2);
$T4->apply_unsafe($K2);
$T4->apply_unsafe($F2);
$T4->apply_unsafe($L2);
$T4->apply_unsafe($G2);
$T4->apply_unsafe($H2);
$f5->apply_unsafe($k2);
$f5->apply_unsafe($l2);
$f5->apply_unsafe($m2);
$f5->apply_unsafe($n2);
$f5->apply_unsafe($o2);
$f5->apply_unsafe($p2);
$f5->apply_unsafe($q2);
$f5->apply_unsafe($r2);
$f5->apply_unsafe($s2);
$f5->apply_unsafe($t2);
$f5->apply_unsafe($u2);
$f5->apply_unsafe($g3);
$f5->apply_unsafe($v2);
$f5->apply_unsafe($w2);
$f5->apply_unsafe($x2);
$f5->apply_unsafe($y2);
$f5->apply_unsafe($z2);
$f5->apply_unsafe($A2);
$f5->apply_unsafe($B2);
$f5->apply_unsafe($C2);
$f5->apply_unsafe($D2);
$f5->apply_unsafe($E2);
$f5->apply_unsafe($K2);
$f5->apply_unsafe($F2);
$f5->apply_unsafe($L2);
$f5->apply_unsafe($G2);
$f5->apply_unsafe($H2);
$m5->apply_unsafe($k2);
$m5->apply_unsafe($l2);
$m5->apply_unsafe($m2);
$m5->apply_unsafe($n2);
$m5->apply_unsafe($o2);
$m5->apply_unsafe($p2);
$m5->apply_unsafe($q2);
$m5->apply_unsafe($r2);
$m5->apply_unsafe($s2);
$m5->apply_unsafe($t2);
$m5->apply_unsafe($u2);
$m5->apply_unsafe($g3);
$m5->apply_unsafe($v2);
$m5->apply_unsafe($w2);
$m5->apply_unsafe($x2);
$m5->apply_unsafe($y2);
$m5->apply_unsafe($z2);
$m5->apply_unsafe($A2);
$m5->apply_unsafe($B2);
$m5->apply_unsafe($C2);
$m5->apply_unsafe($D2);
$m5->apply_unsafe($E2);
$m5->apply_unsafe($K2);
$m5->apply_unsafe($F2);
$m5->apply_unsafe($L2);
$m5->apply_unsafe($G2);
$m5->apply_unsafe($H2);
$t5->apply_unsafe($k2);
$t5->apply_unsafe($l2);
$t5->apply_unsafe($m2);
$t5->apply_unsafe($n2);
$t5->apply_unsafe($o2);
$t5->apply_unsafe($p2);
$t5->apply_unsafe($q2);
$t5->apply_unsafe($r2);
$t5->apply_unsafe($s2);
$t5->apply_unsafe($t2);
$t5->apply_unsafe($u2);
$t5->apply_unsafe($g3);
$t5->apply_unsafe($v2);
$t5->apply_unsafe($w2);
$t5->apply_unsafe($x2);
$t5->apply_unsafe($y2);
$t5->apply_unsafe($z2);
$t5->apply_unsafe($A2);
$t5->apply_unsafe($B2);
$t5->apply_unsafe($C2);
$t5->apply_unsafe($D2);
$t5->apply_unsafe($E2);
$t5->apply_unsafe($K2);
$t5->apply_unsafe($F2);
$t5->apply_unsafe($L2);
$t5->apply_unsafe($G2);
$t5->apply_unsafe($H2);
$A5->apply_unsafe($k2);
$A5->apply_unsafe($l2);
$A5->apply_unsafe($m2);
$A5->apply_unsafe($n2);
$A5->apply_unsafe($o2);
$A5->apply_unsafe($p2);
$A5->apply_unsafe($q2);
$A5->apply_unsafe($r2);
$A5->apply_unsafe($s2);
$A5->apply_unsafe($t2);
$A5->apply_unsafe($u2);
$A5->apply_unsafe($g3);
$A5->apply_unsafe($v2);
$A5->apply_unsafe($w2);
$A5->apply_unsafe($x2);
$A5->apply_unsafe($y2);
$A5->apply_unsafe($z2);
$A5->apply_unsafe($A2);
$A5->apply_unsafe($B2);
$A5->apply_unsafe($C2);
$A5->apply_unsafe($D2);
$A5->apply_unsafe($E2);
$A5->apply_unsafe($K2);
$A5->apply_unsafe($F2);
$A5->apply_unsafe($L2);
$A5->apply_unsafe($G2);
$A5->apply_unsafe($H2);
$Q5->apply_unsafe($k2);
$Q5->apply_unsafe($l2);
$Q5->apply_unsafe($m2);
$Q5->apply_unsafe($n2);
$Q5->apply_unsafe($o2);
$Q5->apply_unsafe($p2);
$Q5->apply_unsafe($q2);
$Q5->apply_unsafe($r2);
$Q5->apply_unsafe($s2);
$Q5->apply_unsafe($t2);
$Q5->apply_unsafe($u2);
$Q5->apply_unsafe($v2);
$Q5->apply_unsafe($w2);
$Q5->apply_unsafe($x2);
$Q5->apply_unsafe($u);
$Q5->apply_unsafe($y2);
$Q5->apply_unsafe($z2);
$Q5->apply_unsafe($A2);
$Q5->apply_unsafe($B2);
$Q5->apply_unsafe($e3);
$Q5->apply_unsafe($C2);
$Q5->apply_unsafe($q3);
$Q5->apply_unsafe($D2);
$Q5->apply_unsafe($E2);
$Q5->apply_unsafe($K2);
$Q5->apply_unsafe($F2);
$Q5->apply_unsafe($G2);
$Q5->apply_unsafe($H2);
$X5->apply_unsafe($k2);
$X5->apply_unsafe($l2);
$X5->apply_unsafe($m2);
$X5->apply_unsafe($n2);
$X5->apply_unsafe($o2);
$X5->apply_unsafe($p2);
$X5->apply_unsafe($q2);
$X5->apply_unsafe($r2);
$X5->apply_unsafe($s2);
$X5->apply_unsafe($t2);
$X5->apply_unsafe($u2);
$X5->apply_unsafe($v2);
$X5->apply_unsafe($w2);
$X5->apply_unsafe($x2);
$X5->apply_unsafe($y2);
$X5->apply_unsafe($z2);
$X5->apply_unsafe($A2);
$X5->apply_unsafe($B2);
$X5->apply_unsafe($C2);
$X5->apply_unsafe($D2);
$X5->apply_unsafe($E2);
$X5->apply_unsafe($F2);
$X5->apply_unsafe($G2);
$X5->apply_unsafe($H2);
$F6->apply_unsafe($Y3);
$F6->apply_unsafe($Z3);
$F6->apply_unsafe($c4);
$F6->apply_unsafe($d4);
$F6->apply_unsafe($e4);
$F6->apply_unsafe($f4);
$F6->apply_unsafe($g4);
$F6->apply_unsafe($h4);
$N6->apply_unsafe($Y3);
$N6->apply_unsafe($Z3);
$N6->apply_unsafe($c4);
$N6->apply_unsafe($d4);
$N6->apply_unsafe($e4);
$N6->apply_unsafe($f4);
$N6->apply_unsafe($g4);
$N6->apply_unsafe($h4);
$j7->apply_unsafe($Y3);
$j7->apply_unsafe($Z3);
$j7->apply_unsafe($c4);
$j7->apply_unsafe($d4);
$j7->apply_unsafe($e4);
$j7->apply_unsafe($f4);
$j7->apply_unsafe($g4);
$j7->apply_unsafe($h4);
$r7->apply_unsafe($Y3);
$r7->apply_unsafe($Z3);
$r7->apply_unsafe($c4);
$r7->apply_unsafe($d4);
$r7->apply_unsafe($e4);
$r7->apply_unsafe($f4);
$r7->apply_unsafe($g4);
$r7->apply_unsafe($h4);
$z7->apply_unsafe($Y3);
$z7->apply_unsafe($Z3);
$z7->apply_unsafe($c4);
$z7->apply_unsafe($d4);
$z7->apply_unsafe($e4);
$z7->apply_unsafe($f4);
$z7->apply_unsafe($g4);
$z7->apply_unsafe($h4);
$J7->apply_unsafe($Y3);
$R7->apply_unsafe($Y3);
$r8->apply_unsafe($Z3);
$y8->apply_unsafe($Z3);
$S8->apply_unsafe($Z3);
$s9->apply_unsafe($Z3);
$A9->apply_unsafe($Z3);
$Q9->apply_unsafe($Z3);
$qa->apply_unsafe($c4);
$xa->apply_unsafe($c4);
$Fa->apply_unsafe($c4);
$Va->apply_unsafe($c4);
$ib->apply_unsafe($c4);
$tb->apply_unsafe($c4);
$Rb->apply_unsafe($d4);
$Zb->apply_unsafe($d4);
$ic->apply_unsafe($d4);
$Ac->apply_unsafe($d4);
$id->apply_unsafe($jd);
$td->apply_unsafe($e4);
$Gd->apply_unsafe($e4);
$ne->apply_unsafe($g4);
$xe->apply_unsafe($g4);
$Je->apply_unsafe($g4);
$Te->apply_unsafe($g4);
$lf->apply_unsafe($g4);
$Rf->apply_unsafe($h4);
$Yf->apply_unsafe($h4);
$og->apply_unsafe($h4);
$Lg->apply_unsafe($g3);
$hh->apply_unsafe($j4);
$nh->apply_unsafe($j4);
$Ih->apply_unsafe($F);
$Oh->apply_unsafe($F);
$Vh->apply_unsafe($F);
$gi->apply_unsafe($F);
$Hi->apply_unsafe($u);
$Vi->apply_unsafe($u);
$hj->apply_unsafe($u);
$pj->apply_unsafe($u);
$Lj->apply_unsafe($jd);
$Vj->apply_unsafe($k4);
$Ok->apply_unsafe($k4);
$Wk->apply_unsafe($k4);
$Wk->apply_unsafe($m4);
$wl->apply_unsafe($k4);
$wl->apply_unsafe($m4);
$Ml->apply_unsafe($k4);
$Ml->apply_unsafe($m4);
$em->apply_unsafe($k4);
$Pm->apply_unsafe($Qm);
$mn->apply_unsafe($l4);
$wn->apply_unsafe($l4);
$Pn->apply_unsafe($l4);
$Yn->apply_unsafe($l4);
$pp->apply_unsafe($Qm);
$Dp->apply_unsafe($m4);
$Mp->apply_unsafe($m4);
$pq->apply_unsafe($e3);
$vq->apply_unsafe($e3);
$Cq->apply_unsafe($e3);
$Zq->apply_unsafe($jd);
$lr->apply_unsafe($q3);
$rr->apply_unsafe($q3);
$Lr->apply_unsafe($n4);
$Xr->apply_unsafe($n4);
$gs->apply_unsafe($n4);
$ni::self=$Ht;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($P1)for@$H;
&$_($X1)for@$w;
&$_($d2)for@$w;
&$_($h2)for@$H;
&$_($W2)for@$w;
&$_($Z2)for@$w;
&$_($f3)for@$h3;
&$_($k3)for@$w;
&$_($m3)for@$w;
&$_($p3)for@$h3;
&$_($u3)for@$w;
&$_($x3)for@$h3;
&$_($B3)for@$w;
&$_($E3)for@$h3;
&$_($I3)for@$w;
&$_($L3)for@$h3;
&$_($N3)for@$O3;
&$_($R3)for@$w;
&$_($U3)for@$w;
&$_($X3)for@$h3;
&$_($t4)for@$w;
&$_($w4)for@$h3;
&$_($y4)for@$z4;
&$_($E4)for@$w;
&$_($H4)for@$h3;
&$_($J4)for@$K4;
&$_($Q4)for@$w;
&$_($T4)for@$h3;
&$_($X4)for@$w;
&$_($c5)for@$w;
&$_($f5)for@$h3;
&$_($j5)for@$w;
&$_($m5)for@$h3;
&$_($q5)for@$w;
&$_($t5)for@$h3;
&$_($x5)for@$w;
&$_($A5)for@$h3;
&$_($C5)for@$D5;
&$_($F5)for@$G5;
&$_($K5)for@$w;
&$_($N5)for@$w;
&$_($Q5)for@$h3;
&$_($U5)for@$w;
&$_($X5)for@$h3;
&$_($Z5)for@$c6;
&$_($l6)for@$m6;
&$_($q6)for@$m6;
&$_($s6)for@$m6;
&$_($u6)for@$m6;
&$_($C6)for@$w;
&$_($F6)for@$h3;
&$_($K6)for@$w;
&$_($N6)for@$h3;
&$_($S6)for@$w;
&$_($W6)for@$w;
&$_($c7)for@$w;
&$_($g7)for@$w;
&$_($j7)for@$h3;
&$_($o7)for@$w;
&$_($r7)for@$h3;
&$_($w7)for@$w;
&$_($z7)for@$h3;
&$_($B7)for@$C7;
&$_($G7)for@$w;
&$_($J7)for@$h3;
&$_($O7)for@$w;
&$_($R7)for@$h3;
&$_($T7)for@$U7;
&$_($d8)for@$m6;
&$_($f8)for@$m6;
&$_($o8)for@$w;
&$_($r8)for@$h3;
&$_($v8)for@$w;
&$_($y8)for@$h3;
&$_($D8)for@$w;
&$_($H8)for@$w;
&$_($L8)for@$w;
&$_($P8)for@$w;
&$_($S8)for@$h3;
&$_($X8)for@$w;
&$_($d9)for@$w;
&$_($h9)for@$w;
&$_($l9)for@$w;
&$_($p9)for@$w;
&$_($s9)for@$h3;
&$_($x9)for@$w;
&$_($A9)for@$h3;
&$_($F9)for@$w;
&$_($J9)for@$w;
&$_($N9)for@$w;
&$_($Q9)for@$h3;
&$_($S9)for@$T9;
&$_($Y9)for@$m6;
&$_($na)for@$w;
&$_($qa)for@$h3;
&$_($ua)for@$w;
&$_($xa)for@$h3;
&$_($Ca)for@$w;
&$_($Fa)for@$h3;
&$_($Ka)for@$w;
&$_($Oa)for@$w;
&$_($Sa)for@$w;
&$_($Va)for@$h3;
&$_($Za)for@$w;
&$_($fb)for@$w;
&$_($ib)for@$h3;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($tb)for@$h3;
&$_($vb)for@$wb;
&$_($Bb)for@$m6;
&$_($Ob)for@$w;
&$_($Rb)for@$h3;
&$_($Wb)for@$w;
&$_($Zb)for@$h3;
&$_($fc)for@$w;
&$_($ic)for@$h3;
&$_($nc)for@$w;
&$_($qc)for@$w;
&$_($uc)for@$w;
&$_($xc)for@$w;
&$_($Ac)for@$h3;
&$_($Cc)for@$Dc;
&$_($Ic)for@$m6;
&$_($Sc)for@$w;
&$_($Vc)for@$w;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($id)for@$h3;
&$_($qd)for@$w;
&$_($td)for@$h3;
&$_($xd)for@$w;
&$_($Ad)for@$w;
&$_($Dd)for@$w;
&$_($Gd)for@$h3;
&$_($Id)for@$Jd;
&$_($Od)for@$m6;
&$_($ge)for@$w;
&$_($ke)for@$w;
&$_($ne)for@$h3;
&$_($re)for@$w;
&$_($ue)for@$w;
&$_($xe)for@$h3;
&$_($Ce)for@$w;
&$_($Ge)for@$w;
&$_($Je)for@$h3;
&$_($Ne)for@$w;
&$_($Qe)for@$w;
&$_($Te)for@$h3;
&$_($Xe)for@$w;
&$_($cf)for@$w;
&$_($ff)for@$w;
&$_($if)for@$w;
&$_($lf)for@$h3;
&$_($nf)for@$of;
&$_($tf)for@$m6;
&$_($Gf)for@$w;
&$_($Kf)for@$w;
&$_($Of)for@$w;
&$_($Rf)for@$h3;
&$_($Vf)for@$w;
&$_($Yf)for@$h3;
&$_($eg)for@$w;
&$_($ig)for@$w;
&$_($lg)for@$w;
&$_($og)for@$h3;
&$_($qg)for@$rg;
&$_($wg)for@$m6;
&$_($Ig)for@$w;
&$_($Lg)for@$h3;
&$_($Ng)for@$Og;
&$_($Ug)for@$m6;
&$_($eh)for@$w;
&$_($hh)for@$h3;
&$_($kh)for@$w;
&$_($nh)for@$h3;
&$_($ph)for@$qh;
&$_($vh)for@$m6;
&$_($Fh)for@$w;
&$_($Ih)for@$h3;
&$_($Lh)for@$w;
&$_($Oh)for@$h3;
&$_($Sh)for@$w;
&$_($Vh)for@$h3;
&$_($Yh)for@$w;
&$_($di)for@$w;
&$_($gi)for@$h3;
&$_($ii)for@$ji;
&$_($oi)for@$m6;
&$_($zi)for@$w;
&$_($Ci)for@$w;
&$_($Ei)for@$w;
&$_($Hi)for@$h3;
&$_($Li)for@$w;
&$_($Oi)for@$w;
&$_($Si)for@$w;
&$_($Vi)for@$h3;
&$_($Zi)for@$w;
&$_($ej)for@$w;
&$_($hj)for@$h3;
&$_($mj)for@$w;
&$_($pj)for@$h3;
&$_($rj)for@$sj;
&$_($xj)for@$m6;
&$_($Ij)for@$w;
&$_($Lj)for@$h3;
&$_($Sj)for@$w;
&$_($Vj)for@$h3;
&$_($ck)for@$w;
&$_($gk)for@$w;
&$_($kk)for@$w;
&$_($ok)for@$w;
&$_($sk)for@$w;
&$_($wk)for@$w;
&$_($Ak)for@$w;
&$_($Ek)for@$w;
&$_($Ik)for@$w;
&$_($Lk)for@$w;
&$_($Ok)for@$h3;
&$_($Tk)for@$w;
&$_($Wk)for@$h3;
&$_($dl)for@$w;
&$_($hl)for@$w;
&$_($ll)for@$w;
&$_($pl)for@$w;
&$_($tl)for@$w;
&$_($wl)for@$h3;
&$_($Bl)for@$w;
&$_($Fl)for@$w;
&$_($Jl)for@$w;
&$_($Ml)for@$h3;
&$_($Rl)for@$w;
&$_($Vl)for@$w;
&$_($Zl)for@$w;
&$_($em)for@$h3;
&$_($gm)for@$hm;
&$_($mm)for@$m6;
&$_($wm)for@$w;
&$_($Am)for@$w;
&$_($Em)for@$w;
&$_($Im)for@$w;
&$_($Mm)for@$w;
&$_($Pm)for@$h3;
&$_($dn)for@$w;
&$_($gn)for@$w;
&$_($jn)for@$w;
&$_($mn)for@$h3;
&$_($qn)for@$w;
&$_($tn)for@$w;
&$_($wn)for@$h3;
&$_($An)for@$w;
&$_($Dn)for@$w;
&$_($Gn)for@$w;
&$_($Jn)for@$w;
&$_($Mn)for@$w;
&$_($Pn)for@$h3;
&$_($Sn)for@$w;
&$_($Vn)for@$w;
&$_($Yn)for@$h3;
&$_($co)for@$do;
&$_($io)for@$m6;
&$_($so)for@$w;
&$_($wo)for@$w;
&$_($Ao)for@$w;
&$_($Eo)for@$w;
&$_($Io)for@$w;
&$_($Mo)for@$w;
&$_($Qo)for@$w;
&$_($Uo)for@$w;
&$_($Yo)for@$w;
&$_($ep)for@$w;
&$_($ip)for@$w;
&$_($mp)for@$w;
&$_($pp)for@$h3;
&$_($Ap)for@$w;
&$_($Dp)for@$h3;
&$_($Gp)for@$w;
&$_($Jp)for@$w;
&$_($Mp)for@$h3;
&$_($Op)for@$Pp;
&$_($Up)for@$m6;
&$_($gq)for@$w;
&$_($iq)for@$w;
&$_($pq)for@$h3;
&$_($sq)for@$w;
&$_($vq)for@$h3;
&$_($zq)for@$w;
&$_($Cq)for@$h3;
&$_($Eq)for@$Fq;
&$_($Lq)for@$m6;
&$_($Sq)for@$w;
&$_($Wq)for@$w;
&$_($Zq)for@$h3;
&$_($ir)for@$w;
&$_($lr)for@$h3;
&$_($or)for@$w;
&$_($rr)for@$h3;
&$_($tr)for@$ur;
&$_($Ar)for@$m6;
&$_($Ir)for@$w;
&$_($Lr)for@$h3;
&$_($Qr)for@$w;
&$_($Ur)for@$w;
&$_($Xr)for@$h3;
&$_($ds)for@$w;
&$_($gs)for@$h3;
&$_($is)for@$js;
&$_($os)for@$m6;
&$_($ws)for@$xs;
&$_($Cs)for@$m6;
&$_($Ks)for@$Ls;
&$_($ht)for@$it;
&$_($kt)for@$Ls;
&$_($pt)for@$w;
&$_($tt)for@$w;
&$_($xt)for@$w;
&$_($Bt)for@$w;
&$_($Ft)for@$w;
&$_($Ht)for@$It;
ni->run(@ARGV);
__DATA__
