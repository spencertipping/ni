#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/mio#;
$P=q#
    my $mio = ni("ni:/fabric/mio")->new;
    my $channel1 = $mio->channel;
    my $channel2 = $mio->channel;
    $channel1->write("8MB data" x 1000000);
    $channel2->write("short string");
    $mio->into($socket_or_something);#;
$Q=[$f,$P];
$R=q#Provides a multiplexed interface around a single possibly-bidirectional
      IO channel.#;
$S=[$i,$R];
$T=[$Q,$S];
$U=q#/fabric/mio#;
$V=bless({$e,$T,$D,$U},$F);
$W=q#ni.doc:/io#;
$X=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Y=[$i,$X];
$Z=[$Y];
$c1=q#/io#;
$d1=bless({$e,$Z,$D,$c1},$F);
$e1=q#ni.doc:/io/buffer#;
$f1=q#
    my $buf = ni("ni:/io/buffer")->new(1048576);
    $buf->write("foo")#;
$g1=[$f,$f1];
$h1=[$g1];
$i1=q#/io/buffer#;
$j1=bless({$e,$h1,$D,$i1},$F);
$k1=q#ni.doc:/io/cat#;
$l1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$m1=[$f,$l1];
$n1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$o1=[$i,$n1];
$p1=[];
$q1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[$m1,$o1,$s1];
$u1=q#/io/cat#;
$v1=bless({$e,$t1,$D,$u1},$F);
$w1=q#ni.doc:/io/exec#;
$x1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$y1=[$f,$x1];
$z1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$A1=[$i,$z1];
$B1=[];
$C1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$D1=bless({$o,$B1,$q,$C1,$s,$t},$u);
$E1=[$n,$D1];
$F1=[$y1,$A1,$E1];
$G1=q#/io/exec#;
$H1=bless({$e,$F1,$D,$G1},$F);
$I1=q#ni.doc:/io/pid#;
$J1=[];
$K1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[$M1,$Q1,$U1];
$W1=q#/io/pid#;
$X1=bless({$e,$V1,$D,$W1},$F);
$Y1=q#ni.doc:/lib#;
$Z1=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$c2=[$i,$Z1];
$d2=[$c2];
$e2=q#/lib#;
$f2=bless({$e,$d2,$D,$e2},$F);
$g2=q#ni.doc:/lib/doc#;
$h2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$i2=[$f,$h2];
$j2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$k2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$l2=[];
$m2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$n2=bless({$o,$l2,$q,$m2,$s,$t},$u);
$o2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$p2=[];
$q2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$r2=bless({$o,$p2,$q,$q2,$s,$t},$u);
$s2=[$i,$j2,$k2,$n,$n2,$o2,$n,$r2];
$t2=[$i2,$s2];
$u2=q#/lib/doc#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni:/class#;
$x2=q#applied_to#;
$y2=q#class#;
$z2=q#class.c#;
$A2=q#fabric/mio.c#;
$B2=q#fabric/rmi.c#;
$C2=q#io/buffer.c#;
$D2=q#io/cat.c#;
$E2=q#io/exec.c#;
$F2=q#io/fd.c#;
$G2=q#io/file.c#;
$H2=q#io/null.c#;
$I2=q#io/object.c#;
$J2=q#io/pid.c#;
$K2=q#io/str.c#;
$L2=q#lib/behavior.c#;
$M2=q#lib/branch.c#;
$N2=q#lib/dataslice.c#;
$O2=q#lib/doc.c#;
$P2=q#lib/fn.c#;
$Q2=q#lib/image.c#;
$R2=q#lib/ni.c#;
$S2=q#lib/quote_simple.c#;
$T2=q#lib/slice.c#;
$U2=q#lib/tag.c#;
$V2=q#lib/test_value.c#;
$W2=q#metaclass.c#;
$X2=q#module.c#;
$Y2=q#object.c#;
$Z2={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1};
$c3=q#slices#;
$d3=q#metaclass#;
$e3=q#module#;
$f3={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$d3,1,$W2,1,$e3,1,$X2,1,$Y2,1};
$g3=q#/module#;
$h3=q#/lib/perlbranch.b#;
$i3={};
$j3=q#ctor#;
$k3=undef;
$l3=q#dtor#;
$m3=q#methods#;
$n3=q#add#;
$o3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$p3=bless({$q,$o3,$s,$t},$u);
$q3=q#apply#;
$r3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$s3=bless({$q,$r3,$s,$t},$u);
$t3={$n3,$p3,$q3,$s3};
$u3=q#/lib/branch.b#;
$v3=q#lib/slice#;
$w3=bless({$x2,$i3,$j3,$k3,$l3,$k3,$m3,$t3,$D,$u3},$v3);
$x3=q#lib/branch#;
$y3=q#lib/slice::ctors#;
$z3={};
$A3=q#my $s = shift; ni->def($s->name, $s)#;
$B3=bless({$q,$A3,$s,$t},$u);
$C3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$D3=bless({$q,$C3,$s,$t},$u);
$E3={$D,$D3};
$F3=q#/lib/named.b#;
$G3=bless({$x2,$z3,$j3,$B3,$l3,$k3,$m3,$E3,$D,$F3},$v3);
$H3=q#lib/tag#;
$I3={};
$J3=q#namespace#;
$K3=q#'ni'#;
$L3=bless({$q,$K3,$s,$t},$u);
$M3={$J3,$L3};
$N3=q#/lib/named_in_ni.b#;
$O3=bless({$x2,$I3,$j3,$k3,$l3,$k3,$m3,$M3,$D,$N3},$v3);
$P3={};
$Q3=q#package#;
$R3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$S3=bless({$q,$R3,$s,$t},$u);
$T3={$Q3,$S3};
$U3=q#/lib/namespaced.b#;
$V3=bless({$x2,$P3,$j3,$k3,$l3,$k3,$m3,$T3,$D,$U3},$v3);
$W3={};
$X3=q#resolve#;
$Y3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$Z3=bless({$q,$Y3,$s,$t},$u);
$c4={$X3,$Z3};
$d4=q#/lib/resolver.b#;
$e4=bless({$x2,$W3,$j3,$k3,$l3,$k3,$m3,$c4,$D,$d4},$v3);
$f4=[$w3,$G3,$O3,$V3,$e4];
$g4=bless({$D,$h3,$c3,$f4},$H3);
$h4=q#lib/tag::ctors#;
$i4={};
$j4=q#my $s = shift; $s->apply($s->package)#;
$k4=bless({$q,$j4,$s,$t},$u);
$l4=q#instantiate#;
$m4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$n4=bless({$q,$m4,$s,$t},$u);
$o4={$l4,$n4};
$p4=q#/lib/class_init.b#;
$q4=bless({$x2,$i4,$j3,$k4,$l3,$k3,$m3,$o4,$D,$p4},$v3);
$r4=q#fabric/mio#;
$s4=q#fabric/rmi#;
$t4=q#io/buffer#;
$u4=q#io/cat#;
$v4=q#io/exec#;
$w4=q#io/fd#;
$x4=q#io/file#;
$y4=q#io/null#;
$z4=q#io/object#;
$A4=q#io/pid#;
$B4=q#io/str#;
$C4=q#lib/behavior#;
$D4=q#lib/dataslice#;
$E4=q#lib/image#;
$F4=q#lib/ni#;
$G4=q#lib/quote_simple#;
$H4=q#lib/test_value#;
$I4=q#object#;
$J4={$y2,1,$z2,1,$r4,1,$A2,1,$s4,1,$B2,1,$t4,1,$C2,1,$u4,1,$D2,1,$v4,1,$E2,1,$w4,1,$F2,1,$x4,1,$G2,1,$y4,1,$H2,1,$z4,1,$I2,1,$A4,1,$J2,1,$B4,1,$K2,1,$C4,1,$L2,1,$x3,1,$M2,1,$D4,1,$N2,1,$F,1,$O2,1,$u,1,$P2,1,$E4,1,$Q2,1,$F4,1,$R2,1,$G4,1,$S2,1,$v3,1,$T2,1,$H3,1,$U2,1,$H4,1,$V2,1,$d3,1,$W2,1,$e3,1,$X2,1,$I4,1,$Y2,1};
$K4=q#/object#;
$L4={};
$M4=q#ni 'ni:/' . ref shift#;
$N4=bless({$q,$M4,$s,$t},$u);
$O4={$y2,$N4};
$P4=q#/lib/instance.b#;
$Q4=bless({$x2,$L4,$j3,$k3,$l3,$k3,$m3,$O4,$D,$P4},$v3);
$R4=[$Q4];
$S4=bless({$x2,$J4,$D,$K4,$c3,$R4},$Y2);
$T4=q#object.c::ctors#;
$U4={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$C4,1,$L2,1,$x3,1,$M2,1,$D4,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$v3,1,$T2,1,$H3,1,$U2,1,$V2,1,$d3,1,$W2,1,$e3,1,$X2,1,$Y2,1};
$V4=q#/lib/behavior#;
$W4={};
$X4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$Y4=bless({$q,$X4,$s,$t},$u);
$Z4={$e,$Y4};
$c5=q#/lib/documentable.b#;
$d5=bless({$x2,$W4,$j3,$k3,$l3,$k3,$m3,$Z4,$D,$c5},$v3);
$e5=[$S4,$d5];
$f5=bless({$x2,$U4,$D,$V4,$c3,$e5},$L2);
$g5=q#lib/behavior.c::ctors#;
$h5={$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$x3,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$d3,1,$W2,1,$e3,1,$X2,1,$Y2,1};
$i5=q#/lib/definition.b#;
$j5={};
$k5=q#def#;
$l5=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$m5=bless({$q,$l5,$s,$t},$u);
$n5={$k5,$m5};
$o5=q#/lib/definition_def.b#;
$p5=bless({$x2,$j5,$j3,$k3,$l3,$k3,$m3,$n5,$D,$o5},$v3);
$q5={};
$r5=q#ro#;
$s5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$t5=bless({$q,$s5,$s,$t},$u);
$u5=q#rw#;
$v5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$w5=bless({$q,$v5,$s,$t},$u);
$x5={$r5,$t5,$u5,$w5};
$y5=q#/lib/accessor.b#;
$z5=bless({$x2,$q5,$j3,$k3,$l3,$k3,$m3,$x5,$D,$y5},$v3);
$A5={};
$B5=q#(""#;
$C5=q#shift->name#;
$D5=bless({$q,$C5,$s,$t},$u);
$E5={$B5,$D5};
$F5=q#/lib/name_as_string.b#;
$G5=bless({$x2,$A5,$j3,$k3,$l3,$k3,$m3,$E5,$D,$F5},$v3);
$H5={};
$I5=q#(eq#;
$J5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$K5=bless({$q,$J5,$s,$t},$u);
$L5={$I5,$K5};
$M5=q#/lib/ref_eq.b#;
$N5=bless({$x2,$H5,$j3,$k3,$l3,$k3,$m3,$L5,$D,$M5},$v3);
$O5={};
$P5=q#defdata#;
$Q5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$R5=bless({$q,$Q5,$s,$t},$u);
$S5={$P5,$R5};
$T5=q#/lib/definition_defdata.b#;
$U5=bless({$x2,$O5,$j3,$k3,$l3,$k3,$m3,$S5,$D,$T5},$v3);
$V5=[$p5,$z5,$G5,$N5,$U5];
$W5=bless({$x2,$h5,$D,$i5,$c3,$V5},$x3);
$X5=q#lib/branch::ctors#;
$Y5=[$g4,$q4,$S4,$f5,$W5];
$Z5=bless({$x2,$f3,$D,$g3,$c3,$Y5},$X2);
$c6=q#module.c::ctors#;
$d6={};
$e6=q#DESTROY#;
$f6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$g6=bless({$q,$f6,$s,$t},$u);
$h6=q#new#;
$i6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$j6=bless({$q,$i6,$s,$t},$u);
$k6={$e6,$g6,$h6,$j6};
$l6=q#/lib/instantiable.b#;
$m6=bless({$x2,$d6,$m3,$k6,$D,$l6},$v3);
$n6={};
$o6=q#child#;
$p6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$q6=bless({$q,$p6,$s,$t},$u);
$r6={$o6,$q6};
$s6=q#/lib/subclass.b#;
$t6=bless({$x2,$n6,$j3,$k3,$l3,$k3,$m3,$r6,$D,$s6},$v3);
$u6=[$Z5,$m6,$q4,$Z5,$t6];
$v6=bless({$x2,$Z2,$D,$E,$c3,$u6},$z2);
$w6=q#class.c::ctors#;
$x6=q#ni:/class.c#;
$y6={$z2,1};
$z6=q#/class.c#;
$A6={$z2,1,$X2,1};
$B6=q#/module.c#;
$C6={$z2,1,$A2,1,$B2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1,$L2,1,$M2,1,$N2,1,$O2,1,$P2,1,$Q2,1,$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$X2,1,$Y2,1};
$D6=q#/object.c#;
$E6=[$v6];
$F6=bless({$x2,$C6,$D,$D6,$c3,$E6},$d3);
$G6=q#metaclass::ctors#;
$H6={$z2,1,$L2,1,$M2,1,$N2,1,$T2,1,$U2,1,$X2,1};
$I6=q#/lib/behavior.c#;
$J6=[$F6];
$K6=bless({$x2,$H6,$D,$I6,$c3,$J6},$d3);
$L6=[$F6,$m6,$K6];
$M6=bless({$x2,$A6,$D,$B6,$c3,$L6},$d3);
$N6=[$M6];
$O6=bless({$x2,$y6,$D,$z6,$c3,$N6},$d3);
$P6=q#ni:/fabric/mio#;
$Q6={$r4,1};
$R6={$r4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1};
$S6=q#/io/object#;
$T6={};
$U6=q#(bool#;
$V6=[];
$W6=bless({$o,$V6,$q,1,$s,$t},$u);
$X6={$U6,$W6};
$Y6=q#/io/object_ops.b#;
$Z6=bless({$x2,$T6,$j3,$k3,$l3,$k3,$m3,$X6,$D,$Y6},$v3);
$c7={};
$d7=q#into#;
$e7=[];
$f7=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
\# TODO: fix this; we need to formalize error handling.
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}#;
$g7=bless({$o,$e7,$q,$f7,$s,$t},$u);
$h7={$d7,$g7};
$i7=q#/io/object_stream.b#;
$j7=bless({$x2,$c7,$j3,$k3,$l3,$k3,$m3,$h7,$D,$i7},$v3);
$k7={};
$l7=q#die#;
$m7=[];
$n7=q#shift; die join " ", @_#;
$o7=bless({$o,$m7,$q,$n7,$s,$t},$u);
$p7=q#io_check#;
$q7=[];
$r7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$s7=bless({$o,$q7,$q,$r7,$s,$t},$u);
$t7=q#io_check_defined#;
$u7=[];
$v7=q#shift->io_check(sub {defined shift}, @_)#;
$w7=bless({$o,$u7,$q,$v7,$s,$t},$u);
$x7=q#io_check_true#;
$y7=[];
$z7=q#shift->io_check(sub {shift}, @_)#;
$A7=bless({$o,$y7,$q,$z7,$s,$t},$u);
$B7={$l7,$o7,$p7,$s7,$t7,$w7,$x7,$A7};
$C7=q#/io/object_checks.b#;
$D7=bless({$x2,$k7,$j3,$k3,$l3,$k3,$m3,$B7,$D,$C7},$v3);
$E7={};
$F7=q#(+#;
$G7=[];
$H7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$I7=bless({$o,$G7,$q,$H7,$s,$t},$u);
$J7={$F7,$I7};
$K7=q#/io/object_constructors.b#;
$L7=bless({$x2,$E7,$j3,$k3,$l3,$k3,$m3,$J7,$D,$K7},$v3);
$M7={};
$N7=q#read_all#;
$O7=[];
$P7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$Q7=bless({$o,$O7,$q,$P7,$s,$t},$u);
$R7={$N7,$Q7};
$S7=q#/io/object_memory.b#;
$T7=bless({$x2,$M7,$j3,$k3,$l3,$k3,$m3,$R7,$D,$S7},$v3);
$U7=[$S4,$Z6,$j7,$D7,$L7,$T7];
$V7=bless({$x2,$R6,$D,$S6,$c3,$U7},$I2);
$W7=q#io/object.c::ctors#;
$X7={};
$Y7=q#io#;
$Z7=[];
$c8=q#shift->{'io'}#;
$d8=bless({$o,$Z7,$q,$c8,$s,$t},$u);
$e8=q#packet_size#;
$f8=[];
$g8=q#shift->{'packet_size'}#;
$h8=bless({$o,$f8,$q,$g8,$s,$t},$u);
$i8={$Y7,$d8,$e8,$h8};
$j8=q#/fabric/mio_ro.b#;
$k8=bless({$x2,$X7,$j3,$k3,$l3,$k3,$m3,$i8,$D,$j8},$v3);
$l8={};
$m8=[];
$n8=q#my ($self, $io, %args) = @_;
+{io          => $io,
  packet_size => $args{packet_size} || 32768,
  channel_id  => 0,
  channels    => {}};#;
$o8=bless({$o,$m8,$q,$n8,$s,$t},$u);
$p8={$l4,$o8};
$q8=q#/fabric/mio_init.b#;
$r8=bless({$x2,$l8,$j3,$k3,$l3,$k3,$m3,$p8,$D,$q8},$v3);
$s8={};
$t8=q#data_packet#;
$u8=[];
$v8=q#my $self      = shift;
my $stream_id = shift;
pack 'NN/a', $stream_id, $_[0];#;
$w8=bless({$o,$u8,$q,$v8,$s,$t},$u);
$x8=q#eof_packet#;
$y8=[];
$z8=q#my ($self, $stream_id) = @_;
pack 'NN', $stream_id, 0;#;
$A8=bless({$o,$y8,$q,$z8,$s,$t},$u);
$B8={$t8,$w8,$x8,$A8};
$C8=q#/fabric/mio_packet.b#;
$D8=bless({$x2,$s8,$j3,$k3,$l3,$k3,$m3,$B8,$D,$C8},$v3);
$E8=[$V7,$k8,$r8,$D8];
$F8=bless({$x2,$Q6,$D,$U,$c3,$E8},$A2);
$G8=q#fabric/mio.c::ctors#;
$H8=q#ni:/fabric/mio.c#;
$I8={$A2,1};
$J8=q#/fabric/mio.c#;
$K8={$A2,1,$C2,1,$D2,1,$E2,1,$F2,1,$G2,1,$H2,1,$I2,1,$J2,1,$K2,1};
$L8=q#/io/object.c#;
$M8=[$F6];
$N8=bless({$x2,$K8,$D,$L8,$c3,$M8},$d3);
$O8=[$N8];
$P8=bless({$x2,$I8,$D,$J8,$c3,$O8},$d3);
$Q8=q#ni:/fabric/mio_init.b#;
$R8=q#ni:/fabric/mio_packet.b#;
$S8=q#ni:/fabric/mio_ro.b#;
$T8=q#ni:/fabric/rmi#;
$U8={$s4,1};
$V8=q#/fabric/rmi#;
$W8={};
$X8=[];
$Y8=q#my ($class, $io, $quote) = @_;#;
$Z8=bless({$o,$X8,$q,$Y8,$s,$t},$u);
$c9={$l4,$Z8};
$d9=q#/fabric/rmi_init.b#;
$e9=bless({$x2,$W8,$j3,$k3,$l3,$k3,$m3,$c9,$D,$d9},$v3);
$f9=[$S4,$e9];
$g9=bless({$x2,$U8,$D,$V8,$c3,$f9},$B2);
$h9=q#fabric/rmi.c::ctors#;
$i9=q#ni:/fabric/rmi.c#;
$j9={$B2,1};
$k9=q#/fabric/rmi.c#;
$l9=[$F6];
$m9=bless({$x2,$j9,$D,$k9,$c3,$l9},$d3);
$n9=q#ni:/fabric/rmi_init.b#;
$o9=q#ni:/io/buffer#;
$p9={$t4,1};
$q9={};
$r9=[];
$s9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$t9=bless({$o,$r9,$q,$s9,$s,$t},$u);
$u9={$l4,$t9};
$v9=q#/io/buffer_init.b#;
$w9=bless({$x2,$q9,$j3,$k3,$l3,$k3,$m3,$u9,$D,$v9},$v3);
$x9={};
$y9=q#read#;
$z9=[];
$A9=bless({$o,$z9,$q,$t,$s,$t},$u);
$B9=q#write#;
$C9=[];
$D9=bless({$o,$C9,$q,$t,$s,$t},$u);
$E9={$y9,$A9,$B9,$D9};
$F9=q#/io/buffer_io.b#;
$G9=bless({$x2,$x9,$j3,$k3,$l3,$k3,$m3,$E9,$D,$F9},$v3);
$H9=[$V7,$w9,$G9];
$I9=bless({$x2,$p9,$D,$i1,$c3,$H9},$C2);
$J9=q#io/buffer.c::ctors#;
$K9=q#ni:/io/buffer.c#;
$L9={$C2,1};
$M9=q#/io/buffer.c#;
$N9=[$N8];
$O9=bless({$x2,$L9,$D,$M9,$c3,$N9},$d3);
$P9=q#ni:/io/buffer_init.b#;
$Q9=q#ni:/io/buffer_io.b#;
$R9=q#ni:/io/cat#;
$S9={$u4,1};
$T9={};
$U9=[];
$V9=q#shift; +{fs => [@_]}#;
$W9=bless({$o,$U9,$q,$V9,$s,$t},$u);
$X9={$l4,$W9};
$Y9=q#/io/cat_init.b#;
$Z9=bless({$x2,$T9,$j3,$k3,$l3,$k3,$m3,$X9,$D,$Y9},$v3);
$ca={};
$da=[];
$ea=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$fa=bless({$o,$da,$q,$ea,$s,$t},$u);
$ga={$y9,$fa};
$ha=q#/io/cat_read.b#;
$ia=bless({$x2,$ca,$j3,$k3,$l3,$k3,$m3,$ga,$D,$ha},$v3);
$ja=[$V7,$Z9,$ia];
$ka=bless({$x2,$S9,$D,$u1,$c3,$ja},$D2);
$la=q#io/cat.c::ctors#;
$ma=q#ni:/io/cat.c#;
$na={$D2,1};
$oa=q#/io/cat.c#;
$pa=[$N8];
$qa=bless({$x2,$na,$D,$oa,$c3,$pa},$d3);
$ra=q#ni:/io/cat_init.b#;
$sa=q#ni:/io/cat_read.b#;
$ta=q#ni:/io/exec#;
$ua={$v4,1};
$va={};
$wa=q#argv#;
$xa=[];
$ya=q#shift->{'argv'}#;
$za=bless({$o,$xa,$q,$ya,$s,$t},$u);
$Aa={$wa,$za};
$Ba=q#/io/exec_ro.b#;
$Ca=bless({$x2,$va,$j3,$k3,$l3,$k3,$m3,$Aa,$D,$Ba},$v3);
$Da={};
$Ea=[];
$Fa=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Ga=bless({$o,$Ea,$q,$Fa,$s,$t},$u);
$Ha={$l4,$Ga};
$Ia=q#/io/exec_init.b#;
$Ja=bless({$x2,$Da,$j3,$k3,$l3,$k3,$m3,$Ha,$D,$Ia},$v3);
$Ka={};
$La=q#connect#;
$Ma=[];
$Na=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Oa=bless({$o,$Ma,$q,$Na,$s,$t},$u);
$Pa=q#in_pipe#;
$Qa=[];
$Ra=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta=q#out_pipe#;
$Ua=[];
$Va=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#setup_stdio#;
$Ya=[];
$Za=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db={$La,$Oa,$Pa,$Sa,$Ta,$Wa,$Xa,$cb};
$eb=q#/io/exec_io_setup.b#;
$fb=bless({$x2,$Ka,$j3,$k3,$l3,$k3,$m3,$db,$D,$eb},$v3);
$gb={};
$hb=q#binds_fd#;
$ib=[];
$jb=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb=q#fd#;
$mb=[];
$nb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#stderr#;
$qb=[];
$rb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#stdin#;
$ub=[];
$vb=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#stdout#;
$yb=[];
$zb=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb={$hb,$kb,$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab};
$Cb=q#/io/exec_io_accessors.b#;
$Db=bless({$x2,$gb,$j3,$k3,$l3,$k3,$m3,$Bb,$D,$Cb},$v3);
$Eb={};
$Fb=q#env#;
$Gb=[];
$Hb=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb={$Fb,$Ib};
$Kb=q#/io/exec_env.b#;
$Lb=bless({$x2,$Eb,$j3,$k3,$l3,$k3,$m3,$Jb,$D,$Kb},$v3);
$Mb={};
$Nb=q#exec#;
$Ob=[];
$Pb=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb=q#fork#;
$Sb=[];
$Tb=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#move_fds#;
$Wb=[];
$Xb=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb={$Nb,$Qb,$Rb,$Ub,$Vb,$Yb};
$cc=q#/io/exec_fork.b#;
$dc=bless({$x2,$Mb,$j3,$k3,$l3,$k3,$m3,$Zb,$D,$cc},$v3);
$ec=[$V7,$Ca,$Ja,$fb,$Db,$Lb,$dc];
$fc=bless({$x2,$ua,$D,$G1,$c3,$ec},$E2);
$gc=q#io/exec.c::ctors#;
$hc=q#ni:/io/exec.c#;
$ic={$E2,1};
$jc=q#/io/exec.c#;
$kc=[$N8];
$lc=bless({$x2,$ic,$D,$jc,$c3,$kc},$d3);
$mc=q#ni:/io/exec_env.b#;
$nc=q#ni:/io/exec_fork.b#;
$oc=q#ni:/io/exec_init.b#;
$pc=q#ni:/io/exec_io_accessors.b#;
$qc=q#ni:/io/exec_io_setup.b#;
$rc=q#ni:/io/exec_ro.b#;
$sc=q#ni:/io/fd#;
$tc={$w4,1};
$uc=q#/io/fd#;
$vc={};
$wc=[];
$xc=q#shift->{'fd'}#;
$yc=bless({$o,$wc,$q,$xc,$s,$t},$u);
$zc={$lb,$yc};
$Ac=q#/io/fd_readers.b#;
$Bc=bless({$x2,$vc,$j3,$k3,$l3,$k3,$m3,$zc,$D,$Ac},$v3);
$Cc={};
$Dc=[];
$Ec=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Fc=bless({$o,$Dc,$q,$Ec,$s,$t},$u);
$Gc={$l4,$Fc};
$Hc=q#/io/fd_init.b#;
$Ic=bless({$x2,$Cc,$j3,$k3,$l3,$k3,$m3,$Gc,$D,$Hc},$v3);
$Jc={};
$Kc=q#be#;
$Lc=[];
$Mc=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$t},$u);
$Oc={$Kc,$Nc};
$Pc=q#/io/fd_shell.b#;
$Qc=bless({$x2,$Jc,$j3,$k3,$l3,$k3,$m3,$Oc,$D,$Pc},$v3);
$Rc={};
$Sc=q#cloexec#;
$Tc=[];
$Uc=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$t},$u);
$Wc=q#fcntl_flag#;
$Xc=[];
$Yc=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd=q#nonblock#;
$dd=[];
$ed=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd={$Sc,$Vc,$Wc,$Zc,$cd,$fd};
$hd=q#/io/fd_fcntl.b#;
$id=bless({$x2,$Rc,$j3,$k3,$l3,$k3,$m3,$gd,$D,$hd},$v3);
$jd={};
$kd=[];
$ld=q#shift->close#;
$md=bless({$o,$kd,$q,$ld,$s,$t},$u);
$nd=q#close#;
$od=[];
$pd=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$qd=bless({$o,$od,$q,$pd,$s,$t},$u);
$rd={$nd,$qd};
$sd=q#/io/fd_gc.b#;
$td=bless({$x2,$jd,$j3,$k3,$l3,$md,$m3,$rd,$D,$sd},$v3);
$ud={};
$vd=[];
$wd=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$xd=bless({$o,$vd,$q,$wd,$s,$t},$u);
$yd=[];
$zd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd={$y9,$xd,$B9,$Ad};
$Cd=q#/io/fd_perlio.b#;
$Dd=bless({$x2,$ud,$j3,$k3,$l3,$k3,$m3,$Bd,$D,$Cd},$v3);
$Ed=[$V7,$Bc,$Ic,$Qc,$id,$td,$Dd];
$Fd=bless({$x2,$tc,$D,$uc,$c3,$Ed},$F2);
$Gd=q#io/fd.c::ctors#;
$Hd=q#ni:/io/fd.c#;
$Id={$F2,1};
$Jd=q#/io/fd.c#;
$Kd=[$N8];
$Ld=bless({$x2,$Id,$D,$Jd,$c3,$Kd},$d3);
$Md=q#ni:/io/fd_fcntl.b#;
$Nd=q#ni:/io/fd_gc.b#;
$Od=q#ni:/io/fd_init.b#;
$Pd=q#ni:/io/fd_perlio.b#;
$Qd=q#ni:/io/fd_readers.b#;
$Rd=q#ni:/io/fd_shell.b#;
$Sd=q#ni:/io/file#;
$Td={$x4,1};
$Ud=q#/io/file#;
$Vd={};
$Wd=[];
$Xd=q#shift->{'name'}#;
$Yd=bless({$o,$Wd,$q,$Xd,$s,$t},$u);
$Zd={$D,$Yd};
$ce=q#/io/file_readers.b#;
$de=bless({$x2,$Vd,$j3,$k3,$l3,$k3,$m3,$Zd,$D,$ce},$v3);
$ee={};
$fe=q#mode#;
$ge=[];
$he=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$ie=bless({$o,$ge,$q,$he,$s,$t},$u);
$je={$fe,$ie};
$ke=q#/io/file_accessors.b#;
$le=bless({$x2,$ee,$j3,$k3,$l3,$k3,$m3,$je,$D,$ke},$v3);
$me={};
$ne=[];
$oe=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$pe=bless({$o,$ne,$q,$oe,$s,$t},$u);
$qe={$l4,$pe};
$re=q#/io/file_init.b#;
$se=bless({$x2,$me,$j3,$k3,$l3,$k3,$m3,$qe,$D,$re},$v3);
$te={};
$ue=q#r#;
$ve=[];
$we=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$xe=bless({$o,$ve,$q,$we,$s,$t},$u);
$ye=[];
$ze=q#shift->r->read(@_)#;
$Ae=bless({$o,$ye,$q,$ze,$s,$t},$u);
$Be=q#w#;
$Ce=[];
$De=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe=[];
$Ge=q#shift->w->write(@_)#;
$He=bless({$o,$Fe,$q,$Ge,$s,$t},$u);
$Ie={$ue,$xe,$y9,$Ae,$Be,$Ee,$B9,$He};
$Je=q#/io/file_io.b#;
$Ke=bless({$x2,$te,$j3,$k3,$l3,$k3,$m3,$Ie,$D,$Je},$v3);
$Le=[$V7,$de,$le,$se,$Ke];
$Me=bless({$x2,$Td,$D,$Ud,$c3,$Le},$G2);
$Ne=q#io/file.c::ctors#;
$Oe=q#ni:/io/file.c#;
$Pe={$G2,1};
$Qe=q#/io/file.c#;
$Re=[$N8];
$Se=bless({$x2,$Pe,$D,$Qe,$c3,$Re},$d3);
$Te=q#ni:/io/file_accessors.b#;
$Ue=q#ni:/io/file_init.b#;
$Ve=q#ni:/io/file_io.b#;
$We=q#ni:/io/file_readers.b#;
$Xe=q#ni:/io/named_io_fns.b#;
$Ye={};
$Ze=q#fcntl#;
$cf=[];
$df=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$ef=bless({$o,$cf,$q,$df,$s,$t},$u);
$ff=[];
$gf=q#CORE::fork#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if=q#open2#;
$jf=[];
$kf=q#CORE::open $_[0], $_[1]#;
$lf=bless({$o,$jf,$q,$kf,$s,$t},$u);
$mf=q#waitpid#;
$nf=[];
$of=q#CORE::waitpid $_[0], $_[1]#;
$pf=bless({$o,$nf,$q,$of,$s,$t},$u);
$qf={$Ze,$ef,$Rb,$hf,$if,$lf,$mf,$pf};
$rf=q#/io/named_io_fns.b#;
$sf=bless({$x2,$Ye,$j3,$k3,$l3,$k3,$m3,$qf,$D,$rf},$v3);
$tf=q#main#;
$uf=q#ni:/io/null#;
$vf={$y4,1};
$wf=q#/io/null#;
$xf={};
$yf=[];
$zf=q#+{fd => undef}#;
$Af=bless({$o,$yf,$q,$zf,$s,$t},$u);
$Bf={$l4,$Af};
$Cf=q#/io/null_init.b#;
$Df=bless({$x2,$xf,$j3,$k3,$l3,$k3,$m3,$Bf,$D,$Cf},$v3);
$Ef={};
$Ff=[];
$Gf=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Hf=bless({$o,$Ff,$q,$Gf,$s,$t},$u);
$If=[];
$Jf=q#shift->fd->read(@_)#;
$Kf=bless({$o,$If,$q,$Jf,$s,$t},$u);
$Lf=[];
$Mf=q#shift->fd->write(@_)#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of={$lb,$Hf,$y9,$Kf,$B9,$Nf};
$Pf=q#/io/null_io.b#;
$Qf=bless({$x2,$Ef,$j3,$k3,$l3,$k3,$m3,$Of,$D,$Pf},$v3);
$Rf=[$V7,$Df,$Qf];
$Sf=bless({$x2,$vf,$D,$wf,$c3,$Rf},$H2);
$Tf=q#io/null.c::ctors#;
$Uf=q#ni:/io/null.c#;
$Vf={$H2,1};
$Wf=q#/io/null.c#;
$Xf=[$N8];
$Yf=bless({$x2,$Vf,$D,$Wf,$c3,$Xf},$d3);
$Zf=q#ni:/io/null_init.b#;
$cg=q#ni:/io/null_io.b#;
$dg=q#ni:/io/object#;
$eg=q#ni:/io/object.c#;
$fg=q#ni:/io/object_checks.b#;
$gg=q#ni:/io/object_constructors.b#;
$hg=q#ni:/io/object_memory.b#;
$ig=q#ni:/io/object_ops.b#;
$jg=q#ni:/io/object_stream.b#;
$kg=q#ni:/io/pid#;
$lg={$A4,1};
$mg={};
$ng=q#pid#;
$og=[];
$pg=q#shift->{'pid'}#;
$qg=bless({$o,$og,$q,$pg,$s,$t},$u);
$rg=q#status#;
$sg=[];
$tg=q#shift->{'status'}#;
$ug=bless({$o,$sg,$q,$tg,$s,$t},$u);
$vg={$ng,$qg,$rg,$ug};
$wg=q#/io/pid_readers.b#;
$xg=bless({$x2,$mg,$j3,$k3,$l3,$k3,$m3,$vg,$D,$wg},$v3);
$yg={};
$zg=[];
$Ag=q#shift->await#;
$Bg=bless({$o,$zg,$q,$Ag,$s,$t},$u);
$Cg=[];
$Dg=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Eg=bless({$o,$Cg,$q,$Dg,$s,$t},$u);
$Fg={$l4,$Eg};
$Gg=q#/io/pid_init.b#;
$Hg=bless({$x2,$yg,$j3,$k3,$l3,$Bg,$m3,$Fg,$D,$Gg},$v3);
$Ig={};
$Jg=q#await#;
$Kg=[];
$Lg=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Mg=bless({$o,$Kg,$q,$Lg,$s,$t},$u);
$Ng=q#running#;
$Og=[];
$Pg=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Qg=bless({$o,$Og,$q,$Pg,$s,$t},$u);
$Rg={$Jg,$Mg,$Ng,$Qg};
$Sg=q#/io/pid_wait.b#;
$Tg=bless({$x2,$Ig,$j3,$k3,$l3,$k3,$m3,$Rg,$D,$Sg},$v3);
$Ug={};
$Vg=[];
$Wg=q#shift->stdout->read(@_)#;
$Xg=bless({$o,$Vg,$q,$Wg,$s,$t},$u);
$Yg=[];
$Zg=q#shift->stdin->write(@_)#;
$ch=bless({$o,$Yg,$q,$Zg,$s,$t},$u);
$dh={$y9,$Xg,$B9,$ch};
$eh=q#/io/pid_io.b#;
$fh=bless({$x2,$Ug,$j3,$k3,$l3,$k3,$m3,$dh,$D,$eh},$v3);
$gh={};
$hh=[];
$ih=q#$_[0]->{external_fds}{$_[1]}#;
$jh=bless({$o,$hh,$q,$ih,$s,$t},$u);
$kh=[];
$lh=q#shift->fd(2)#;
$mh=bless({$o,$kh,$q,$lh,$s,$t},$u);
$nh=[];
$oh=q#shift->fd(0)#;
$ph=bless({$o,$nh,$q,$oh,$s,$t},$u);
$qh=[];
$rh=q#shift->fd(1)#;
$sh=bless({$o,$qh,$q,$rh,$s,$t},$u);
$th={$lb,$jh,$pb,$mh,$tb,$ph,$xb,$sh};
$uh=q#/io/pid_accessors.b#;
$vh=bless({$x2,$gh,$j3,$k3,$l3,$k3,$m3,$th,$D,$uh},$v3);
$wh=[$V7,$xg,$Hg,$Tg,$fh,$vh];
$xh=bless({$x2,$lg,$D,$W1,$c3,$wh},$J2);
$yh=q#io/pid.c::ctors#;
$zh=q#ni:/io/pid.c#;
$Ah={$J2,1};
$Bh=q#/io/pid.c#;
$Ch=[$N8];
$Dh=bless({$x2,$Ah,$D,$Bh,$c3,$Ch},$d3);
$Eh=q#ni:/io/pid_accessors.b#;
$Fh=q#ni:/io/pid_init.b#;
$Gh=q#ni:/io/pid_io.b#;
$Hh=q#ni:/io/pid_readers.b#;
$Ih=q#ni:/io/pid_wait.b#;
$Jh=q#ni:/io/str#;
$Kh={$B4,1};
$Lh=q#/io/str#;
$Mh={};
$Nh=q#data#;
$Oh=[];
$Ph=q#shift->{'data'}#;
$Qh=bless({$o,$Oh,$q,$Ph,$s,$t},$u);
$Rh=q#end#;
$Sh=[];
$Th=q#shift->{'end'}#;
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh=q#start#;
$Wh=[];
$Xh=q#shift->{'start'}#;
$Yh=bless({$o,$Wh,$q,$Xh,$s,$t},$u);
$Zh={$Nh,$Qh,$Rh,$Uh,$Vh,$Yh};
$ci=q#/io/str_ro.b#;
$di=bless({$x2,$Mh,$j3,$k3,$l3,$k3,$m3,$Zh,$D,$ci},$v3);
$ei={};
$fi=[];
$gi=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$hi=bless({$o,$fi,$q,$gi,$s,$t},$u);
$ii={$l4,$hi};
$ji=q#/io/str_init.b#;
$ki=bless({$x2,$ei,$j3,$k3,$l3,$k3,$m3,$ii,$D,$ji},$v3);
$li={};
$mi=[];
$ni=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$oi=bless({$o,$mi,$q,$ni,$s,$t},$u);
$pi=q#remaining#;
$qi=[];
$ri=q#my $self = shift; $$self{end} - $$self{start}#;
$si=bless({$o,$qi,$q,$ri,$s,$t},$u);
$ti=[];
$ui=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$vi=bless({$o,$ti,$q,$ui,$s,$t},$u);
$wi={$y9,$oi,$pi,$si,$B9,$vi};
$xi=q#/io/str_io.b#;
$yi=bless({$x2,$li,$j3,$k3,$l3,$k3,$m3,$wi,$D,$xi},$v3);
$zi=[$V7,$di,$ki,$yi];
$Ai=bless({$x2,$Kh,$D,$Lh,$c3,$zi},$K2);
$Bi=q#io/str.c::ctors#;
$Ci=q#ni:/io/str.c#;
$Di={$K2,1};
$Ei=q#/io/str.c#;
$Fi=[$N8];
$Gi=bless({$x2,$Di,$D,$Ei,$c3,$Fi},$d3);
$Hi=q#ni:/io/str_init.b#;
$Ii=q#ni:/io/str_io.b#;
$Ji=q#ni:/io/str_ro.b#;
$Ki=q#ni:/lib/accessor.b#;
$Li=q#ni:/lib/behavior#;
$Mi=q#ni:/lib/behavior.c#;
$Ni=q#ni:/lib/branch#;
$Oi={$x3,1};
$Pi=q#/lib/branch#;
$Qi={};
$Ri=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Si=bless({$q,$Ri,$s,$t},$u);
$Ti={$l4,$Si};
$Ui=q#/lib/branch_init.b#;
$Vi=bless({$x2,$Qi,$j3,$k3,$l3,$k3,$m3,$Ti,$D,$Ui},$v3);
$Wi=[$f5,$G3,$w3,$Vi,$W5];
$Xi=bless({$x2,$Oi,$D,$Pi,$c3,$Wi},$M2);
$Yi=q#lib/branch.c::ctors#;
$Zi=q#ni:/lib/branch.b#;
$cj=q#ni:/lib/branch.c#;
$dj={$M2,1};
$ej=q#/lib/branch.c#;
$fj=[$K6];
$gj=bless({$x2,$dj,$D,$ej,$c3,$fj},$d3);
$hj=q#ni:/lib/branch_init.b#;
$ij=q#ni:/lib/class_init.b#;
$jj=q#ni:/lib/dataslice#;
$kj={$D4,1};
$lj=q#/lib/dataslice#;
$mj={};
$nj=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$oj=bless({$q,$nj,$s,$t},$u);
$pj={$l4,$oj};
$qj=q#/lib/dataslice_init.b#;
$rj=bless({$x2,$mj,$j3,$k3,$l3,$k3,$m3,$pj,$D,$qj},$v3);
$sj={};
$tj=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$uj=bless({$q,$tj,$s,$t},$u);
$vj={$q3,$uj};
$wj=q#/lib/dataslice_apply.b#;
$xj=bless({$x2,$sj,$j3,$k3,$l3,$k3,$m3,$vj,$D,$wj},$v3);
$yj=[$f5,$rj,$xj];
$zj=bless({$x2,$kj,$D,$lj,$c3,$yj},$N2);
$Aj=q#lib/dataslice.c::ctors#;
$Bj=q#ni:/lib/dataslice.c#;
$Cj={$N2,1};
$Dj=q#/lib/dataslice.c#;
$Ej=[$K6];
$Fj=bless({$x2,$Cj,$D,$Dj,$c3,$Ej},$d3);
$Gj=q#ni:/lib/dataslice_apply.b#;
$Hj=q#ni:/lib/dataslice_init.b#;
$Ij=q#ni:/lib/definition.b#;
$Jj=q#ni:/lib/definition_def.b#;
$Kj=q#ni:/lib/definition_defdata.b#;
$Lj=q#ni:/lib/doc#;
$Mj={$F,1};
$Nj={};
$Oj=q#shift; +{name => shift, doc => []}#;
$Pj=bless({$q,$Oj,$s,$t},$u);
$Qj={$l4,$Pj};
$Rj=q#/lib/doc_init.b#;
$Sj=bless({$x2,$Nj,$j3,$k3,$l3,$k3,$m3,$Qj,$D,$Rj},$v3);
$Tj={};
$Uj=q#'ni.doc'#;
$Vj=bless({$q,$Uj,$s,$t},$u);
$Wj={$J3,$Vj};
$Xj=q#/lib/doc_namespace.b#;
$Yj=bless({$x2,$Tj,$j3,$k3,$l3,$k3,$m3,$Wj,$D,$Xj},$v3);
$Zj={};
$ck=q#AUTOLOAD#;
$dk=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$ek=bless({$q,$dk,$s,$t},$u);
$fk={$ck,$ek};
$gk=q#/lib/doc_define.b#;
$hk=bless({$x2,$Zj,$j3,$k3,$l3,$k3,$m3,$fk,$D,$gk},$v3);
$ik={};
$jk=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$kk=bless({$q,$jk,$s,$t},$u);
$lk=q#tests#;
$mk=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$nk=bless({$q,$mk,$s,$t},$u);
$ok={$n,$kk,$lk,$nk};
$pk=q#/lib/doc_test.b#;
$qk=bless({$x2,$ik,$j3,$k3,$l3,$k3,$m3,$ok,$D,$pk},$v3);
$rk=[$S4,$G3,$Sj,$Yj,$hk,$qk];
$sk=bless({$x2,$Mj,$D,$u2,$c3,$rk},$O2);
$tk=q#lib/doc.c::ctors#;
$uk=q#ni:/lib/doc.c#;
$vk={$O2,1};
$wk=q#/lib/doc.c#;
$xk=[$F6];
$yk=bless({$x2,$vk,$D,$wk,$c3,$xk},$d3);
$zk=q#ni:/lib/doc_define.b#;
$Ak=q#ni:/lib/doc_init.b#;
$Bk=q#ni:/lib/doc_namespace.b#;
$Ck=q#ni:/lib/doc_test.b#;
$Dk=q#ni:/lib/documentable.b#;
$Ek=q#ni:/lib/fn#;
$Fk={$u,1};
$Gk=q#/lib/fn#;
$Hk={};
$Ik=q#shift->compile#;
$Jk=bless({$q,$Ik,$s,$t},$u);
$Kk=q#compile#;
$Lk=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Mk=bless({$q,$Lk,$s,$t},$u);
$Nk=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Ok=bless({$q,$Nk,$s,$t},$u);
$Pk={$Kk,$Mk,$l4,$Ok};
$Qk=q#/lib/fn_init.b#;
$Rk=bless({$x2,$Hk,$j3,$Jk,$l3,$k3,$m3,$Pk,$D,$Qk},$v3);
$Sk={};
$Tk=[];
$Uk=q#shift->{'annotations'}#;
$Vk=bless({$o,$Tk,$q,$Uk,$s,$t},$u);
$Wk=[];
$Xk=q#shift->{'code'}#;
$Yk=bless({$o,$Wk,$q,$Xk,$s,$t},$u);
$Zk=q#fn#;
$cl=[];
$dl=q#shift->{'fn'}#;
$el=bless({$o,$cl,$q,$dl,$s,$t},$u);
$fl={$o,$Vk,$q,$Yk,$Zk,$el};
$gl=q#/lib/fn_ro.b#;
$hl=bless({$x2,$Sk,$j3,$k3,$l3,$k3,$m3,$fl,$D,$gl},$v3);
$il={};
$jl=[];
$kl=q#shift->{code}#;
$ll=bless({$o,$jl,$q,$kl,$s,$t},$u);
$ml=[];
$nl=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$ol=bless({$o,$ml,$q,$nl,$s,$t},$u);
$pl={$B5,$ll,$I5,$ol};
$ql=q#/lib/fn_ops.b#;
$rl=bless({$x2,$il,$j3,$k3,$l3,$k3,$m3,$pl,$D,$ql},$v3);
$sl={};
$tl=q#serialize#;
$ul=[];
$vl=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$wl=bless({$o,$ul,$q,$vl,$s,$t},$u);
$xl={$tl,$wl};
$yl=q#/lib/fn_serialize.b#;
$zl=bless({$x2,$sl,$j3,$k3,$l3,$k3,$m3,$xl,$D,$yl},$v3);
$Al=[$S4,$m6,$Rk,$hl,$rl,$zl];
$Bl=bless({$x2,$Fk,$D,$Gk,$c3,$Al},$P2);
$Cl=q#lib/fn.c::ctors#;
$Dl=q#ni:/lib/fn.c#;
$El={$P2,1};
$Fl=q#/lib/fn.c#;
$Gl=[$F6];
$Hl=bless({$x2,$El,$D,$Fl,$c3,$Gl},$d3);
$Il=q#ni:/lib/fn_init.b#;
$Jl=q#ni:/lib/fn_ops.b#;
$Kl=q#ni:/lib/fn_ro.b#;
$Ll=q#ni:/lib/fn_serialize.b#;
$Ml=q#ni:/lib/gensym_generator_compact.b#;
$Nl={};
$Ol=q#gensym#;
$Pl=[];
$Ql=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Rl=bless({$o,$Pl,$q,$Ql,$s,$t},$u);
$Sl={$Ol,$Rl};
$Tl=q#/lib/gensym_generator_compact.b#;
$Ul=bless({$x2,$Nl,$j3,$k3,$l3,$k3,$m3,$Sl,$D,$Tl},$v3);
$Vl=q#ni:/lib/global_static_test.b#;
$Wl={};
$Xl=q#now#;
$Yl=[];
$Zl=q#ni('ni:/lib/test_value')->new(shift)#;
$cm=q#($)#;
$dm=bless({$o,$Yl,$q,$Zl,$s,$cm},$u);
$em={$Xl,$dm};
$fm=q#/lib/global_static_test.b#;
$gm=bless({$x2,$Wl,$j3,$k3,$l3,$k3,$m3,$em,$D,$fm},$v3);
$hm=q#ni:/lib/image#;
$im={$E4,1};
$jm=q#/lib/image#;
$km={};
$lm=[];
$mm=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$nm=bless({$o,$lm,$q,$mm,$s,$t},$u);
$om={$l4,$nm};
$pm=q#/lib/image_init.b#;
$qm=bless({$x2,$km,$j3,$k3,$l3,$k3,$m3,$om,$D,$pm},$v3);
$rm={};
$sm=q#address#;
$tm=[];
$um=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$vm=bless({$o,$tm,$q,$um,$s,$t},$u);
$wm=q#allocate_gensym#;
$xm=[];
$ym=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$zm=bless({$o,$xm,$q,$ym,$s,$t},$u);
$Am=q#boot_side_effect#;
$Bm=[];
$Cm=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Dm=bless({$o,$Bm,$q,$Cm,$s,$t},$u);
$Em=q#circular_links#;
$Fm=[];
$Gm=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Hm=bless({$o,$Fm,$q,$Gm,$s,$t},$u);
$Im=q#finalizer#;
$Jm=[];
$Km=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Lm=bless({$o,$Jm,$q,$Km,$s,$t},$u);
$Mm=q#quote#;
$Nm=[];
$Om=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Pm=bless({$o,$Nm,$q,$Om,$s,$t},$u);
$Qm=q#reconstruction#;
$Rm=[];
$Sm=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Tm=bless({$o,$Rm,$q,$Sm,$s,$t},$u);
$Um=q#side_effect#;
$Vm=[];
$Wm=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Xm=bless({$o,$Vm,$q,$Wm,$s,$t},$u);
$Ym=[];
$Zm=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$cn=bless({$o,$Ym,$q,$Zm,$s,$t},$u);
$dn={$sm,$vm,$wm,$zm,$Am,$Dm,$Em,$Hm,$Im,$Lm,$Mm,$Pm,$Qm,$Tm,$Um,$Xm,$B9,$cn};
$en=q#/lib/image_quoting.b#;
$fn=bless({$x2,$rm,$j3,$k3,$l3,$k3,$m3,$dn,$D,$en},$v3);
$gn={};
$hn=q#quote_code#;
$in=[];
$jn=q#shift->die('cannot quote perl CODE refs', shift)#;
$kn=bless({$o,$in,$q,$jn,$s,$t},$u);
$ln={$hn,$kn};
$mn=q#/lib/quote_code_fail.b#;
$nn=bless({$x2,$gn,$j3,$k3,$l3,$k3,$m3,$ln,$D,$mn},$v3);
$on={};
$pn=q#quote_array#;
$qn=[];
$rn=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$sn=bless({$o,$qn,$q,$rn,$s,$t},$u);
$tn=q#quote_hash#;
$un=[];
$vn=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$wn=bless({$o,$un,$q,$vn,$s,$t},$u);
$xn=q#quote_scalar#;
$yn=[];
$zn=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$An=bless({$o,$yn,$q,$zn,$s,$t},$u);
$Bn=q#quote_scalar_ref#;
$Cn=[];
$Dn=q#'\\\\' . shift->quote(${$_[0]})#;
$En=bless({$o,$Cn,$q,$Dn,$s,$t},$u);
$Fn=q#quote_value#;
$Gn=[];
$Hn=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$In=bless({$o,$Gn,$q,$Hn,$s,$t},$u);
$Jn={$pn,$sn,$tn,$wn,$xn,$An,$Bn,$En,$Fn,$In};
$Kn=q#/lib/quote_values.b#;
$Ln=bless({$x2,$on,$j3,$k3,$l3,$k3,$m3,$Jn,$D,$Kn},$v3);
$Mn={};
$Nn=q#quote_blessed#;
$On=[];
$Pn=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Qn=bless({$o,$On,$q,$Pn,$s,$t},$u);
$Rn=q#quote_class#;
$Sn=[];
$Tn=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Un=bless({$o,$Sn,$q,$Tn,$s,$t},$u);
$Vn=q#quote_object#;
$Wn=[];
$Xn=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Yn=bless({$o,$Wn,$q,$Xn,$s,$t},$u);
$Zn={$Nn,$Qn,$Rn,$Un,$Vn,$Yn};
$co=q#/lib/quote_objects.b#;
$do=bless({$x2,$Mn,$j3,$k3,$l3,$k3,$m3,$Zn,$D,$co},$v3);
$eo={};
$fo=q#circular_arrayref#;
$go=[];
$ho=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$io=bless({$o,$go,$q,$ho,$s,$t},$u);
$jo=q#circular_hashref#;
$ko=[];
$lo=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$mo=bless({$o,$ko,$q,$lo,$s,$t},$u);
$no=q#is_circular#;
$oo=[];
$po=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$qo=bless({$o,$oo,$q,$po,$s,$t},$u);
$ro={$fo,$io,$jo,$mo,$no,$qo};
$so=q#/lib/quote_circular_addressed.b#;
$to=bless({$x2,$eo,$j3,$k3,$l3,$k3,$m3,$ro,$D,$so},$v3);
$uo=[$S4,$qm,$fn,$nn,$Ln,$do,$to,$Ul];
$vo=bless({$x2,$im,$D,$jm,$c3,$uo},$Q2);
$wo=q#lib/image.c::ctors#;
$xo=q#ni:/lib/image.c#;
$yo={$Q2,1};
$zo=q#/lib/image.c#;
$Ao=[$F6];
$Bo=bless({$x2,$yo,$D,$zo,$c3,$Ao},$d3);
$Co=q#ni:/lib/image_init.b#;
$Do=q#ni:/lib/image_quoting.b#;
$Eo=q#ni:/lib/instance.b#;
$Fo=q#ni:/lib/instantiable.b#;
$Go=q#ni:/lib/json.b#;
$Ho={};
$Io=q#json_decode#;
$Jo=[];
$Ko=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Lo=bless({$o,$Jo,$q,$Ko,$s,$cm},$u);
$Mo=q#json_encode#;
$No=[];
$Oo=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Po=bless({$o,$No,$q,$Oo,$s,$cm},$u);
$Qo=q#json_escape#;
$Ro=[];
$So=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$To=bless({$o,$Ro,$q,$So,$s,$cm},$u);
$Uo=q#json_unescape#;
$Vo=[];
$Wo=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Xo=bless({$o,$Vo,$q,$Wo,$s,$cm},$u);
$Yo=q#json_unescape_one#;
$Zo=[];
$cp=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$dp=bless({$o,$Zo,$q,$cp,$s,$cm},$u);
$ep={$Io,$Lo,$Mo,$Po,$Qo,$To,$Uo,$Xo,$Yo,$dp};
$fp=q#/lib/json.b#;
$gp=bless({$x2,$Ho,$j3,$k3,$l3,$k3,$m3,$ep,$D,$fp},$v3);
$hp=q#ni#;
$ip=q#ni:/lib/name_as_string.b#;
$jp=q#ni:/lib/named.b#;
$kp=q#ni:/lib/named_in_ni.b#;
$lp=q#ni:/lib/namespaced.b#;
$mp=q#ni:/lib/ni#;
$np={$F4,1};
$op=q#/lib/ni#;
$pp={};
$qp=q#extend#;
$rp=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$sp=bless({$q,$rp,$s,$t},$u);
$tp=q#is_mutable#;
$up=q#$0 ne "-" && -w $0#;
$vp=bless({$q,$up,$s,$t},$u);
$wp=q#modify#;
$xp=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$yp=bless({$q,$xp,$s,$t},$u);
$zp={$qp,$sp,$tp,$vp,$wp,$yp};
$Ap=q#/lib/ni_self.b#;
$Bp=bless({$x2,$pp,$j3,$k3,$l3,$k3,$m3,$zp,$D,$Ap},$v3);
$Cp={};
$Dp=q#exists#;
$Ep=q#exists $_[0]->{named}{$_[1]}#;
$Fp=bless({$q,$Ep,$s,$t},$u);
$Gp=q#quoted#;
$Hp=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Ip=bless({$q,$Hp,$s,$t},$u);
$Jp={$Dp,$Fp,$Gp,$Ip};
$Kp=q#/lib/ni_image.b#;
$Lp=bless({$x2,$Cp,$j3,$k3,$l3,$k3,$m3,$Jp,$D,$Kp},$v3);
$Mp={};
$Np=q#--internal/+=#;
$Op=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Pp=bless({$q,$Op,$s,$t},$u);
$Qp=q#--internal/eval#;
$Rp=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Sp=bless({$q,$Rp,$s,$t},$u);
$Tp=q#--internal/image#;
$Up=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Vp=bless({$q,$Up,$s,$t},$u);
$Wp=q#--internal/test#;
$Xp=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Yp=bless({$q,$Xp,$s,$t},$u);
$Zp=q#run#;
$cq=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$dq=bless({$q,$cq,$s,$t},$u);
$eq={$Np,$Pp,$Qp,$Sp,$Tp,$Vp,$Wp,$Yp,$Zp,$dq};
$fq=q#/lib/ni_main.b#;
$gq=bless({$x2,$Mp,$j3,$k3,$l3,$k3,$m3,$eq,$D,$fq},$v3);
$hq={};
$iq=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$jq=bless({$q,$iq,$s,$t},$u);
$kq=q#resolver_for#;
$lq=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$mq=bless({$q,$lq,$s,$t},$u);
$nq={$X3,$jq,$kq,$mq};
$oq=q#/lib/ni_resolver.b#;
$pq=bless({$x2,$hq,$j3,$k3,$l3,$k3,$m3,$nq,$D,$oq},$v3);
$qq=[$S4,$Bp,$Lp,$gq,$pq];
$rq=bless({$x2,$np,$D,$op,$c3,$qq},$R2);
$sq=q#lib/ni.c::ctors#;
$tq=q#ni:/lib/ni.c#;
$uq={$R2,1};
$vq=q#/lib/ni.c#;
$wq=[$F6];
$xq=bless({$x2,$uq,$D,$vq,$c3,$wq},$d3);
$yq=q#ni:/lib/ni_image.b#;
$zq=q#ni:/lib/ni_main.b#;
$Aq=q#ni:/lib/ni_resolver.b#;
$Bq=q#ni:/lib/ni_self.b#;
$Cq=q#ni:/lib/ni_static_util.b#;
$Dq={};
$Eq=q#abbrev#;
$Fq=[];
$Gq=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Hq=bless({$o,$Fq,$q,$Gq,$s,$t},$u);
$Iq=q#dor#;
$Jq=[];
$Kq=q#defined $_[0] ? $_[0] : $_[1]#;
$Lq=bless({$o,$Jq,$q,$Kq,$s,$t},$u);
$Mq=q#indent#;
$Nq=[];
$Oq=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Pq=bless({$o,$Nq,$q,$Oq,$s,$t},$u);
$Qq=q#max#;
$Rq=[];
$Sq=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Tq=bless({$o,$Rq,$q,$Sq,$s,$t},$u);
$Uq=q#maxstr#;
$Vq=[];
$Wq=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Xq=bless({$o,$Vq,$q,$Wq,$s,$t},$u);
$Yq=q#mean#;
$Zq=[];
$cr=q#sum(@_) / (@_ || 1)#;
$dr=bless({$o,$Zq,$q,$cr,$s,$t},$u);
$er=q#min#;
$fr=[];
$gr=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$hr=bless({$o,$fr,$q,$gr,$s,$t},$u);
$ir=q#minstr#;
$jr=[];
$kr=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$lr=bless({$o,$jr,$q,$kr,$s,$t},$u);
$mr=q#sgr#;
$nr=[];
$or=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$pr=bless({$o,$nr,$q,$or,$s,$t},$u);
$qr=q#sr#;
$rr=[];
$sr=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$tr=bless({$o,$rr,$q,$sr,$s,$t},$u);
$ur=q#sum#;
$vr=[];
$wr=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$xr=bless({$o,$vr,$q,$wr,$s,$t},$u);
$yr=q#swap#;
$zr=[];
$Ar=q#@_[0, 1] = @_[1, 0]#;
$Br=bless({$o,$zr,$q,$Ar,$s,$t},$u);
$Cr={$Eq,$Hq,$Iq,$Lq,$Mq,$Pq,$Qq,$Tq,$Uq,$Xq,$Yq,$dr,$er,$hr,$ir,$lr,$mr,$pr,$qr,$tr,$ur,$xr,$yr,$Br};
$Dr=q#/lib/ni_static_util.b#;
$Er=bless({$x2,$Dq,$j3,$k3,$l3,$k3,$m3,$Cr,$D,$Dr},$v3);
$Fr=q#ni:/lib/perlbranch.b#;
$Gr=q#ni:/lib/quote_circular_addressed.b#;
$Hr=q#ni:/lib/quote_code_fail.b#;
$Ir=q#ni:/lib/quote_objects.b#;
$Jr=q#ni:/lib/quote_simple#;
$Kr={$G4,1};
$Lr=q#/lib/quote_simple#;
$Mr={};
$Nr=[];
$Or=q#+{}#;
$Pr=bless({$o,$Nr,$q,$Or,$s,$t},$u);
$Qr={$l4,$Pr};
$Rr=q#/lib/quote_simple_init.b#;
$Sr=bless({$x2,$Mr,$j3,$k3,$l3,$k3,$m3,$Qr,$D,$Rr},$v3);
$Tr={};
$Ur=[];
$Vr=bless({$o,$Ur,$q,0,$s,$t},$u);
$Wr=[];
$Xr=q#shift->quote_value(shift)#;
$Yr=bless({$o,$Wr,$q,$Xr,$s,$t},$u);
$Zr={$no,$Vr,$Mm,$Yr};
$cs=q#/lib/quote_simple_quote.b#;
$ds=bless({$x2,$Tr,$j3,$k3,$l3,$k3,$m3,$Zr,$D,$cs},$v3);
$es=[$S4,$Sr,$ds,$nn,$Ln,$do];
$fs=bless({$x2,$Kr,$D,$Lr,$c3,$es},$S2);
$gs=q#lib/quote_simple.c::ctors#;
$hs=q#ni:/lib/quote_simple.c#;
$is={$S2,1};
$js=q#/lib/quote_simple.c#;
$ks=[$F6];
$ls=bless({$x2,$is,$D,$js,$c3,$ks},$d3);
$ms=q#ni:/lib/quote_simple_init.b#;
$ns=q#ni:/lib/quote_simple_quote.b#;
$os=q#ni:/lib/quote_values.b#;
$ps=q#ni:/lib/ref_eq.b#;
$qs=q#ni:/lib/resolver.b#;
$rs=q#ni:/lib/slice#;
$ss={$v3,1};
$ts=q#/lib/slice#;
$us=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$vs=bless({$q,$us,$s,$t},$u);
$ws=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$xs=bless({$q,$ws,$s,$t},$u);
$ys=q#lib/slice::apply#;
$zs=q#lib/slice::apply_unsafe#;
$As={};
$Bs=q#apply_unsafe#;
$Cs={$q3,$vs,$Bs,$xs};
$Ds=q#/lib/slice.b#;
$Es=bless({$x2,$As,$m3,$Cs,$D,$Ds},$v3);
$Fs={};
$Gs=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Hs=bless({$q,$Gs,$s,$t},$u);
$Is={$l4,$Hs};
$Js=q#/lib/slice_init.b#;
$Ks=bless({$x2,$Fs,$m3,$Is,$D,$Js},$v3);
$Ls={};
$Ms=[];
$Ns=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Os=bless({$o,$Ms,$q,$Ns,$s,$t},$u);
$Ps={$tl,$Os};
$Qs=q#/lib/slice_serialize.b#;
$Rs=bless({$x2,$Ls,$j3,$k3,$l3,$k3,$m3,$Ps,$D,$Qs},$v3);
$Ss=[$f5,$G3,$Es,$Ks,$Rs];
$Ts=bless({$x2,$ss,$D,$ts,$c3,$Ss},$T2);
$Us=q#lib/slice.c::ctors#;
$Vs=q#ni:/lib/slice.b#;
$Ws=q#ni:/lib/slice.c#;
$Xs={$T2,1};
$Ys=q#/lib/slice.c#;
$Zs=[$K6];
$ct=bless({$x2,$Xs,$D,$Ys,$c3,$Zs},$d3);
$dt=q#ni:/lib/slice_init.b#;
$et=q#ni:/lib/slice_serialize.b#;
$ft=q#ni:/lib/static_fn.b#;
$gt={};
$ht=[];
$it=q#ni('ni:/lib/fn')->new(@_)#;
$jt=bless({$o,$ht,$q,$it,$s,$cm},$u);
$kt=q#fp#;
$lt=[];
$mt=q#($$)#;
$nt=bless({$o,$lt,$q,$it,$s,$mt},$u);
$ot={$Zk,$jt,$kt,$nt};
$pt=q#/lib/static_fn.b#;
$qt=bless({$x2,$gt,$j3,$k3,$l3,$k3,$m3,$ot,$D,$pt},$v3);
$rt=q#ni:/lib/subclass.b#;
$st=q#ni:/lib/tag#;
$tt={$H3,1};
$ut=q#/lib/tag#;
$vt={};
$wt=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$xt=bless({$q,$wt,$s,$t},$u);
$yt={$q3,$xt};
$zt=q#/lib/tag.b#;
$At=bless({$x2,$vt,$j3,$k3,$l3,$k3,$m3,$yt,$D,$zt},$v3);
$Bt={};
$Ct=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Dt=bless({$q,$Ct,$s,$t},$u);
$Et={$l4,$Dt};
$Ft=q#/lib/tag_init.b#;
$Gt=bless({$x2,$Bt,$j3,$k3,$l3,$k3,$m3,$Et,$D,$Ft},$v3);
$Ht=[$f5,$G3,$At,$Gt];
$It=bless({$x2,$tt,$D,$ut,$c3,$Ht},$U2);
$Jt=q#lib/tag.c::ctors#;
$Kt=q#ni:/lib/tag.b#;
$Lt=q#ni:/lib/tag.c#;
$Mt={$U2,1};
$Nt=q#/lib/tag.c#;
$Ot=[$K6];
$Pt=bless({$x2,$Mt,$D,$Nt,$c3,$Ot},$d3);
$Qt=q#ni:/lib/tag_init.b#;
$Rt=q#ni:/lib/test_value#;
$St={$H4,1};
$Tt=q#/lib/test_value#;
$Ut={};
$Vt=[];
$Wt=q#\\$_[1]#;
$Xt=bless({$o,$Vt,$q,$Wt,$s,$t},$u);
$Yt={$l4,$Xt};
$Zt=q#/lib/test_value_init.b#;
$cu=bless({$x2,$Ut,$j3,$k3,$l3,$k3,$m3,$Yt,$D,$Zt},$v3);
$du={};
$eu=q#(==#;
$fu=[];
$gu=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$hu=bless({$o,$fu,$q,$gu,$s,$t},$u);
$iu=q#diff#;
$ju=[];
$ku=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$lu=bless({$o,$ju,$q,$ku,$s,$t},$u);
$mu={$eu,$hu,$iu,$lu};
$nu=q#/lib/test_value_eq.b#;
$ou=bless({$x2,$du,$j3,$k3,$l3,$k3,$m3,$mu,$D,$nu},$v3);
$pu={};
$qu=[];
$ru=q#ni::json_encode ${$_[0]}#;
$su=bless({$o,$qu,$q,$ru,$s,$t},$u);
$tu={$B5,$su};
$uu=q#/lib/test_value_str.b#;
$vu=bless({$x2,$pu,$j3,$k3,$l3,$k3,$m3,$tu,$D,$uu},$v3);
$wu=[$S4,$cu,$ou,$vu];
$xu=bless({$x2,$St,$D,$Tt,$c3,$wu},$V2);
$yu=q#lib/test_value.c::ctors#;
$zu=q#ni:/lib/test_value.c#;
$Au={$V2,1};
$Bu=q#/lib/test_value.c#;
$Cu=[$F6];
$Du=bless({$x2,$Au,$D,$Bu,$c3,$Cu},$d3);
$Eu=q#ni:/lib/test_value_eq.b#;
$Fu=q#ni:/lib/test_value_init.b#;
$Gu=q#ni:/lib/test_value_str.b#;
$Hu=q#ni:/metaclass#;
$Iu={$d3,1};
$Ju=q#/metaclass#;
$Ku=[$g4,$m6,$q4,$Z5];
$Lu=bless({$x2,$Iu,$D,$Ju,$c3,$Ku},$W2);
$Mu=q#metaclass.c::ctors#;
$Nu=q#ni:/metaclass.c#;
$Ou={$W2,1};
$Pu=q#/metaclass.c#;
$Qu=[$v6];
$Ru=bless({$x2,$Ou,$D,$Pu,$c3,$Qu},$d3);
$Su=q#ni:/module#;
$Tu=q#ni:/module.c#;
$Uu=q#ni:/object#;
$Vu=q#ni:/object.c#;
$Wu=q#ni:main#;
$Xu={$tf,1};
$Yu=[$qt,$gm,$sf];
$Zu=bless({$x2,$Xu,$D,$tf,$c3,$Yu},$e3);
$cv=q#module::ctors#;
$dv=q#ni:ni#;
$ev={$hp,1};
$fv={$hp,1};
$gv=q#json_escapes#;
$hv=q##;
$iv=q#b#;
$jv=q#	#;
$kv=q#t#;
$lv=q#
#;
$mv=q#n#;
$nv=q##;
$ov=q#"#;
$pv=q#/#;
$qv=q#\\#;
$rv={$hv,$iv,$jv,$kv,$lv,$mv,$nv,$ue,$ov,$ov,$pv,$pv,$qv,$qv};
$sv=q#json_unescapes#;
$tv={$ov,$ov,$pv,$pv,$qv,$qv,$iv,$hv,$mv,$lv,$ue,$nv,$kv,$jv};
$uv={$gv,$rv,$sv,$tv};
$vv=q#/lib/json_data.b#;
$wv=bless({$x2,$fv,$Nh,$uv,$D,$vv},$D4);
$xv=q#lib/dataslice::ctors#;
$yv=[$wv,$gp,$Er];
$zv=bless({$x2,$ev,$D,$hp,$c3,$yv},$e3);
$Av={$d,$G,$I,$N,$O,$V,$W,$d1,$e1,$j1,$k1,$v1,$w1,$H1,$I1,$X1,$Y1,$f2,$g2,$v2,$w2,$v6,$x6,$O6,$P6,$F8,$H8,$P8,$Q8,$r8,$R8,$D8,$S8,$k8,$T8,$g9,$i9,$m9,$n9,$e9,$o9,$I9,$K9,$O9,$P9,$w9,$Q9,$G9,$R9,$ka,$ma,$qa,$ra,$Z9,$sa,$ia,$ta,$fc,$hc,$lc,$mc,$Lb,$nc,$dc,$oc,$Ja,$pc,$Db,$qc,$fb,$rc,$Ca,$sc,$Fd,$Hd,$Ld,$Md,$id,$Nd,$td,$Od,$Ic,$Pd,$Dd,$Qd,$Bc,$Rd,$Qc,$Sd,$Me,$Oe,$Se,$Te,$le,$Ue,$se,$Ve,$Ke,$We,$de,$Xe,$sf,$uf,$Sf,$Uf,$Yf,$Zf,$Df,$cg,$Qf,$dg,$V7,$eg,$N8,$fg,$D7,$gg,$L7,$hg,$T7,$ig,$Z6,$jg,$j7,$kg,$xh,$zh,$Dh,$Eh,$vh,$Fh,$Hg,$Gh,$fh,$Hh,$xg,$Ih,$Tg,$Jh,$Ai,$Ci,$Gi,$Hi,$ki,$Ii,$yi,$Ji,$di,$Ki,$z5,$Li,$f5,$Mi,$K6,$Ni,$Xi,$Zi,$w3,$cj,$gj,$hj,$Vi,$ij,$q4,$jj,$zj,$Bj,$Fj,$Gj,$xj,$Hj,$rj,$Ij,$W5,$Jj,$p5,$Kj,$U5,$Lj,$sk,$uk,$yk,$zk,$hk,$Ak,$Sj,$Bk,$Yj,$Ck,$qk,$Dk,$d5,$Ek,$Bl,$Dl,$Hl,$Il,$Rk,$Jl,$rl,$Kl,$hl,$Ll,$zl,$Ml,$Ul,$Vl,$gm,$hm,$vo,$xo,$Bo,$Co,$qm,$Do,$fn,$Eo,$Q4,$Fo,$m6,$Go,$gp,$ip,$G5,$jp,$G3,$kp,$O3,$lp,$V3,$mp,$rq,$tq,$xq,$yq,$Lp,$zq,$gq,$Aq,$pq,$Bq,$Bp,$Cq,$Er,$Fr,$g4,$Gr,$to,$Hr,$nn,$Ir,$do,$Jr,$fs,$hs,$ls,$ms,$Sr,$ns,$ds,$os,$Ln,$ps,$N5,$qs,$e4,$rs,$Ts,$Vs,$Es,$Ws,$ct,$dt,$Ks,$et,$Rs,$ft,$qt,$rt,$t6,$st,$It,$Kt,$At,$Lt,$Pt,$Qt,$Gt,$Rt,$xu,$zu,$Du,$Eu,$ou,$Fu,$cu,$Gu,$vu,$Hu,$Lu,$Nu,$Ru,$Su,$Z5,$Tu,$M6,$Uu,$S4,$Vu,$F6,$Wu,$Zu,$dv,$zv};
$Bv=q#resolvers#;
$Cv=[];
$Dv=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Ev=bless({$o,$Cv,$q,$Dv,$s,$t},$u);
$Fv=q#file#;
$Gv=[];
$Hv=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Iv=bless({$o,$Gv,$q,$Hv,$s,$t},$u);
$Jv=q#null#;
$Kv=[];
$Lv=q#ni('ni:/io/null')->new#;
$Mv=bless({$o,$Kv,$q,$Lv,$s,$t},$u);
$Nv=q#sh#;
$Ov=[];
$Pv=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Qv=bless({$o,$Ov,$q,$Pv,$s,$t},$u);
$Rv=q#str#;
$Sv=[];
$Tv=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Uv=bless({$o,$Sv,$q,$Tv,$s,$t},$u);
$Vv={$lb,$Ev,$Fv,$Iv,$Jv,$Mv,$Nv,$Qv,$Rv,$Uv};
$Wv=bless({$c,$Av,$Bv,$Vv},$F4);
$Xv=q#lib/ni::ctors#;
*$zs=\&$xs;
*$ys=\&$vs;
$w3->apply_unsafe($y2);
$w3->apply_unsafe($z2);
$w3->apply_unsafe($A2);
$w3->apply_unsafe($B2);
$w3->apply_unsafe($C2);
$w3->apply_unsafe($D2);
$w3->apply_unsafe($E2);
$w3->apply_unsafe($F2);
$w3->apply_unsafe($G2);
$w3->apply_unsafe($H2);
$w3->apply_unsafe($I2);
$w3->apply_unsafe($J2);
$w3->apply_unsafe($K2);
$w3->apply_unsafe($L2);
$w3->apply_unsafe($x3);
$w3->apply_unsafe($M2);
$w3->apply_unsafe($N2);
$w3->apply_unsafe($O2);
$w3->apply_unsafe($P2);
$w3->apply_unsafe($Q2);
$w3->apply_unsafe($R2);
$w3->apply_unsafe($S2);
$w3->apply_unsafe($T2);
$w3->apply_unsafe($U2);
$w3->apply_unsafe($V2);
$w3->apply_unsafe($d3);
$w3->apply_unsafe($W2);
$w3->apply_unsafe($e3);
$w3->apply_unsafe($X2);
$w3->apply_unsafe($Y2);
$G3->apply_unsafe($y2);
$G3->apply_unsafe($z2);
$G3->apply_unsafe($A2);
$G3->apply_unsafe($B2);
$G3->apply_unsafe($C2);
$G3->apply_unsafe($D2);
$G3->apply_unsafe($E2);
$G3->apply_unsafe($F2);
$G3->apply_unsafe($G2);
$G3->apply_unsafe($H2);
$G3->apply_unsafe($I2);
$G3->apply_unsafe($J2);
$G3->apply_unsafe($K2);
$G3->apply_unsafe($L2);
$G3->apply_unsafe($x3);
$G3->apply_unsafe($M2);
$G3->apply_unsafe($N2);
$G3->apply_unsafe($F);
$G3->apply_unsafe($O2);
$G3->apply_unsafe($P2);
$G3->apply_unsafe($Q2);
$G3->apply_unsafe($R2);
$G3->apply_unsafe($S2);
$G3->apply_unsafe($v3);
$G3->apply_unsafe($T2);
$G3->apply_unsafe($H3);
$G3->apply_unsafe($U2);
$G3->apply_unsafe($V2);
$G3->apply_unsafe($d3);
$G3->apply_unsafe($W2);
$G3->apply_unsafe($e3);
$G3->apply_unsafe($X2);
$G3->apply_unsafe($Y2);
$O3->apply_unsafe($y2);
$O3->apply_unsafe($z2);
$O3->apply_unsafe($A2);
$O3->apply_unsafe($B2);
$O3->apply_unsafe($C2);
$O3->apply_unsafe($D2);
$O3->apply_unsafe($E2);
$O3->apply_unsafe($F2);
$O3->apply_unsafe($G2);
$O3->apply_unsafe($H2);
$O3->apply_unsafe($I2);
$O3->apply_unsafe($J2);
$O3->apply_unsafe($K2);
$O3->apply_unsafe($L2);
$O3->apply_unsafe($x3);
$O3->apply_unsafe($M2);
$O3->apply_unsafe($N2);
$O3->apply_unsafe($O2);
$O3->apply_unsafe($P2);
$O3->apply_unsafe($Q2);
$O3->apply_unsafe($R2);
$O3->apply_unsafe($S2);
$O3->apply_unsafe($v3);
$O3->apply_unsafe($T2);
$O3->apply_unsafe($H3);
$O3->apply_unsafe($U2);
$O3->apply_unsafe($V2);
$O3->apply_unsafe($d3);
$O3->apply_unsafe($W2);
$O3->apply_unsafe($e3);
$O3->apply_unsafe($X2);
$O3->apply_unsafe($Y2);
$V3->apply_unsafe($y2);
$V3->apply_unsafe($z2);
$V3->apply_unsafe($A2);
$V3->apply_unsafe($B2);
$V3->apply_unsafe($C2);
$V3->apply_unsafe($D2);
$V3->apply_unsafe($E2);
$V3->apply_unsafe($F2);
$V3->apply_unsafe($G2);
$V3->apply_unsafe($H2);
$V3->apply_unsafe($I2);
$V3->apply_unsafe($J2);
$V3->apply_unsafe($K2);
$V3->apply_unsafe($L2);
$V3->apply_unsafe($x3);
$V3->apply_unsafe($M2);
$V3->apply_unsafe($N2);
$V3->apply_unsafe($O2);
$V3->apply_unsafe($P2);
$V3->apply_unsafe($Q2);
$V3->apply_unsafe($R2);
$V3->apply_unsafe($S2);
$V3->apply_unsafe($v3);
$V3->apply_unsafe($T2);
$V3->apply_unsafe($H3);
$V3->apply_unsafe($U2);
$V3->apply_unsafe($V2);
$V3->apply_unsafe($d3);
$V3->apply_unsafe($W2);
$V3->apply_unsafe($e3);
$V3->apply_unsafe($X2);
$V3->apply_unsafe($Y2);
$e4->apply_unsafe($y2);
$e4->apply_unsafe($z2);
$e4->apply_unsafe($A2);
$e4->apply_unsafe($B2);
$e4->apply_unsafe($C2);
$e4->apply_unsafe($D2);
$e4->apply_unsafe($E2);
$e4->apply_unsafe($F2);
$e4->apply_unsafe($G2);
$e4->apply_unsafe($H2);
$e4->apply_unsafe($I2);
$e4->apply_unsafe($J2);
$e4->apply_unsafe($K2);
$e4->apply_unsafe($L2);
$e4->apply_unsafe($x3);
$e4->apply_unsafe($M2);
$e4->apply_unsafe($N2);
$e4->apply_unsafe($O2);
$e4->apply_unsafe($P2);
$e4->apply_unsafe($Q2);
$e4->apply_unsafe($R2);
$e4->apply_unsafe($S2);
$e4->apply_unsafe($T2);
$e4->apply_unsafe($H3);
$e4->apply_unsafe($U2);
$e4->apply_unsafe($V2);
$e4->apply_unsafe($d3);
$e4->apply_unsafe($W2);
$e4->apply_unsafe($e3);
$e4->apply_unsafe($X2);
$e4->apply_unsafe($Y2);
$q4->apply_unsafe($y2);
$q4->apply_unsafe($z2);
$q4->apply_unsafe($A2);
$q4->apply_unsafe($B2);
$q4->apply_unsafe($C2);
$q4->apply_unsafe($D2);
$q4->apply_unsafe($E2);
$q4->apply_unsafe($F2);
$q4->apply_unsafe($G2);
$q4->apply_unsafe($H2);
$q4->apply_unsafe($I2);
$q4->apply_unsafe($J2);
$q4->apply_unsafe($K2);
$q4->apply_unsafe($L2);
$q4->apply_unsafe($M2);
$q4->apply_unsafe($N2);
$q4->apply_unsafe($O2);
$q4->apply_unsafe($P2);
$q4->apply_unsafe($Q2);
$q4->apply_unsafe($R2);
$q4->apply_unsafe($S2);
$q4->apply_unsafe($T2);
$q4->apply_unsafe($U2);
$q4->apply_unsafe($V2);
$q4->apply_unsafe($d3);
$q4->apply_unsafe($W2);
$q4->apply_unsafe($e3);
$q4->apply_unsafe($X2);
$q4->apply_unsafe($Y2);
$Q4->apply_unsafe($y2);
$Q4->apply_unsafe($z2);
$Q4->apply_unsafe($r4);
$Q4->apply_unsafe($A2);
$Q4->apply_unsafe($s4);
$Q4->apply_unsafe($B2);
$Q4->apply_unsafe($t4);
$Q4->apply_unsafe($C2);
$Q4->apply_unsafe($u4);
$Q4->apply_unsafe($D2);
$Q4->apply_unsafe($v4);
$Q4->apply_unsafe($E2);
$Q4->apply_unsafe($w4);
$Q4->apply_unsafe($F2);
$Q4->apply_unsafe($x4);
$Q4->apply_unsafe($G2);
$Q4->apply_unsafe($y4);
$Q4->apply_unsafe($H2);
$Q4->apply_unsafe($z4);
$Q4->apply_unsafe($I2);
$Q4->apply_unsafe($A4);
$Q4->apply_unsafe($J2);
$Q4->apply_unsafe($B4);
$Q4->apply_unsafe($K2);
$Q4->apply_unsafe($C4);
$Q4->apply_unsafe($L2);
$Q4->apply_unsafe($x3);
$Q4->apply_unsafe($M2);
$Q4->apply_unsafe($D4);
$Q4->apply_unsafe($N2);
$Q4->apply_unsafe($F);
$Q4->apply_unsafe($O2);
$Q4->apply_unsafe($u);
$Q4->apply_unsafe($P2);
$Q4->apply_unsafe($E4);
$Q4->apply_unsafe($Q2);
$Q4->apply_unsafe($F4);
$Q4->apply_unsafe($R2);
$Q4->apply_unsafe($G4);
$Q4->apply_unsafe($S2);
$Q4->apply_unsafe($v3);
$Q4->apply_unsafe($T2);
$Q4->apply_unsafe($H3);
$Q4->apply_unsafe($U2);
$Q4->apply_unsafe($H4);
$Q4->apply_unsafe($V2);
$Q4->apply_unsafe($d3);
$Q4->apply_unsafe($W2);
$Q4->apply_unsafe($e3);
$Q4->apply_unsafe($X2);
$Q4->apply_unsafe($I4);
$Q4->apply_unsafe($Y2);
$d5->apply_unsafe($y2);
$d5->apply_unsafe($z2);
$d5->apply_unsafe($A2);
$d5->apply_unsafe($B2);
$d5->apply_unsafe($C2);
$d5->apply_unsafe($D2);
$d5->apply_unsafe($E2);
$d5->apply_unsafe($F2);
$d5->apply_unsafe($G2);
$d5->apply_unsafe($H2);
$d5->apply_unsafe($I2);
$d5->apply_unsafe($J2);
$d5->apply_unsafe($K2);
$d5->apply_unsafe($C4);
$d5->apply_unsafe($L2);
$d5->apply_unsafe($x3);
$d5->apply_unsafe($M2);
$d5->apply_unsafe($D4);
$d5->apply_unsafe($N2);
$d5->apply_unsafe($O2);
$d5->apply_unsafe($P2);
$d5->apply_unsafe($Q2);
$d5->apply_unsafe($R2);
$d5->apply_unsafe($S2);
$d5->apply_unsafe($v3);
$d5->apply_unsafe($T2);
$d5->apply_unsafe($H3);
$d5->apply_unsafe($U2);
$d5->apply_unsafe($V2);
$d5->apply_unsafe($d3);
$d5->apply_unsafe($W2);
$d5->apply_unsafe($e3);
$d5->apply_unsafe($X2);
$d5->apply_unsafe($Y2);
$p5->apply_unsafe($y2);
$p5->apply_unsafe($z2);
$p5->apply_unsafe($A2);
$p5->apply_unsafe($B2);
$p5->apply_unsafe($C2);
$p5->apply_unsafe($D2);
$p5->apply_unsafe($E2);
$p5->apply_unsafe($F2);
$p5->apply_unsafe($G2);
$p5->apply_unsafe($H2);
$p5->apply_unsafe($I2);
$p5->apply_unsafe($J2);
$p5->apply_unsafe($K2);
$p5->apply_unsafe($L2);
$p5->apply_unsafe($x3);
$p5->apply_unsafe($M2);
$p5->apply_unsafe($N2);
$p5->apply_unsafe($O2);
$p5->apply_unsafe($P2);
$p5->apply_unsafe($Q2);
$p5->apply_unsafe($R2);
$p5->apply_unsafe($S2);
$p5->apply_unsafe($T2);
$p5->apply_unsafe($U2);
$p5->apply_unsafe($V2);
$p5->apply_unsafe($d3);
$p5->apply_unsafe($W2);
$p5->apply_unsafe($e3);
$p5->apply_unsafe($X2);
$p5->apply_unsafe($Y2);
$z5->apply_unsafe($y2);
$z5->apply_unsafe($z2);
$z5->apply_unsafe($A2);
$z5->apply_unsafe($B2);
$z5->apply_unsafe($C2);
$z5->apply_unsafe($D2);
$z5->apply_unsafe($E2);
$z5->apply_unsafe($F2);
$z5->apply_unsafe($G2);
$z5->apply_unsafe($H2);
$z5->apply_unsafe($I2);
$z5->apply_unsafe($J2);
$z5->apply_unsafe($K2);
$z5->apply_unsafe($L2);
$z5->apply_unsafe($x3);
$z5->apply_unsafe($M2);
$z5->apply_unsafe($N2);
$z5->apply_unsafe($O2);
$z5->apply_unsafe($P2);
$z5->apply_unsafe($Q2);
$z5->apply_unsafe($R2);
$z5->apply_unsafe($S2);
$z5->apply_unsafe($T2);
$z5->apply_unsafe($U2);
$z5->apply_unsafe($V2);
$z5->apply_unsafe($d3);
$z5->apply_unsafe($W2);
$z5->apply_unsafe($e3);
$z5->apply_unsafe($X2);
$z5->apply_unsafe($Y2);
$G5->apply_unsafe($y2);
$G5->apply_unsafe($z2);
$G5->apply_unsafe($A2);
$G5->apply_unsafe($B2);
$G5->apply_unsafe($C2);
$G5->apply_unsafe($D2);
$G5->apply_unsafe($E2);
$G5->apply_unsafe($F2);
$G5->apply_unsafe($G2);
$G5->apply_unsafe($H2);
$G5->apply_unsafe($I2);
$G5->apply_unsafe($J2);
$G5->apply_unsafe($K2);
$G5->apply_unsafe($L2);
$G5->apply_unsafe($x3);
$G5->apply_unsafe($M2);
$G5->apply_unsafe($N2);
$G5->apply_unsafe($O2);
$G5->apply_unsafe($P2);
$G5->apply_unsafe($Q2);
$G5->apply_unsafe($R2);
$G5->apply_unsafe($S2);
$G5->apply_unsafe($T2);
$G5->apply_unsafe($U2);
$G5->apply_unsafe($V2);
$G5->apply_unsafe($d3);
$G5->apply_unsafe($W2);
$G5->apply_unsafe($e3);
$G5->apply_unsafe($X2);
$G5->apply_unsafe($Y2);
$N5->apply_unsafe($y2);
$N5->apply_unsafe($z2);
$N5->apply_unsafe($A2);
$N5->apply_unsafe($B2);
$N5->apply_unsafe($C2);
$N5->apply_unsafe($D2);
$N5->apply_unsafe($E2);
$N5->apply_unsafe($F2);
$N5->apply_unsafe($G2);
$N5->apply_unsafe($H2);
$N5->apply_unsafe($I2);
$N5->apply_unsafe($J2);
$N5->apply_unsafe($K2);
$N5->apply_unsafe($L2);
$N5->apply_unsafe($x3);
$N5->apply_unsafe($M2);
$N5->apply_unsafe($N2);
$N5->apply_unsafe($O2);
$N5->apply_unsafe($P2);
$N5->apply_unsafe($Q2);
$N5->apply_unsafe($R2);
$N5->apply_unsafe($S2);
$N5->apply_unsafe($T2);
$N5->apply_unsafe($U2);
$N5->apply_unsafe($V2);
$N5->apply_unsafe($d3);
$N5->apply_unsafe($W2);
$N5->apply_unsafe($e3);
$N5->apply_unsafe($X2);
$N5->apply_unsafe($Y2);
$U5->apply_unsafe($y2);
$U5->apply_unsafe($z2);
$U5->apply_unsafe($A2);
$U5->apply_unsafe($B2);
$U5->apply_unsafe($C2);
$U5->apply_unsafe($D2);
$U5->apply_unsafe($E2);
$U5->apply_unsafe($F2);
$U5->apply_unsafe($G2);
$U5->apply_unsafe($H2);
$U5->apply_unsafe($I2);
$U5->apply_unsafe($J2);
$U5->apply_unsafe($K2);
$U5->apply_unsafe($L2);
$U5->apply_unsafe($x3);
$U5->apply_unsafe($M2);
$U5->apply_unsafe($N2);
$U5->apply_unsafe($O2);
$U5->apply_unsafe($P2);
$U5->apply_unsafe($Q2);
$U5->apply_unsafe($R2);
$U5->apply_unsafe($S2);
$U5->apply_unsafe($T2);
$U5->apply_unsafe($U2);
$U5->apply_unsafe($V2);
$U5->apply_unsafe($d3);
$U5->apply_unsafe($W2);
$U5->apply_unsafe($e3);
$U5->apply_unsafe($X2);
$U5->apply_unsafe($Y2);
$m6->apply_unsafe($y2);
$m6->apply_unsafe($z2);
$m6->apply_unsafe($A2);
$m6->apply_unsafe($B2);
$m6->apply_unsafe($C2);
$m6->apply_unsafe($D2);
$m6->apply_unsafe($E2);
$m6->apply_unsafe($F2);
$m6->apply_unsafe($G2);
$m6->apply_unsafe($H2);
$m6->apply_unsafe($I2);
$m6->apply_unsafe($J2);
$m6->apply_unsafe($K2);
$m6->apply_unsafe($L2);
$m6->apply_unsafe($M2);
$m6->apply_unsafe($N2);
$m6->apply_unsafe($O2);
$m6->apply_unsafe($u);
$m6->apply_unsafe($P2);
$m6->apply_unsafe($Q2);
$m6->apply_unsafe($R2);
$m6->apply_unsafe($S2);
$m6->apply_unsafe($v3);
$m6->apply_unsafe($T2);
$m6->apply_unsafe($H3);
$m6->apply_unsafe($U2);
$m6->apply_unsafe($V2);
$m6->apply_unsafe($d3);
$m6->apply_unsafe($W2);
$m6->apply_unsafe($X2);
$m6->apply_unsafe($Y2);
$t6->apply_unsafe($y2);
$t6->apply_unsafe($z2);
$t6->apply_unsafe($A2);
$t6->apply_unsafe($B2);
$t6->apply_unsafe($C2);
$t6->apply_unsafe($D2);
$t6->apply_unsafe($E2);
$t6->apply_unsafe($F2);
$t6->apply_unsafe($G2);
$t6->apply_unsafe($H2);
$t6->apply_unsafe($I2);
$t6->apply_unsafe($J2);
$t6->apply_unsafe($K2);
$t6->apply_unsafe($L2);
$t6->apply_unsafe($M2);
$t6->apply_unsafe($N2);
$t6->apply_unsafe($O2);
$t6->apply_unsafe($P2);
$t6->apply_unsafe($Q2);
$t6->apply_unsafe($R2);
$t6->apply_unsafe($S2);
$t6->apply_unsafe($T2);
$t6->apply_unsafe($U2);
$t6->apply_unsafe($V2);
$t6->apply_unsafe($W2);
$t6->apply_unsafe($X2);
$t6->apply_unsafe($Y2);
$Z6->apply_unsafe($r4);
$Z6->apply_unsafe($t4);
$Z6->apply_unsafe($u4);
$Z6->apply_unsafe($v4);
$Z6->apply_unsafe($w4);
$Z6->apply_unsafe($x4);
$Z6->apply_unsafe($y4);
$Z6->apply_unsafe($z4);
$Z6->apply_unsafe($A4);
$Z6->apply_unsafe($B4);
$j7->apply_unsafe($r4);
$j7->apply_unsafe($t4);
$j7->apply_unsafe($u4);
$j7->apply_unsafe($v4);
$j7->apply_unsafe($w4);
$j7->apply_unsafe($x4);
$j7->apply_unsafe($y4);
$j7->apply_unsafe($z4);
$j7->apply_unsafe($A4);
$j7->apply_unsafe($B4);
$D7->apply_unsafe($r4);
$D7->apply_unsafe($t4);
$D7->apply_unsafe($u4);
$D7->apply_unsafe($v4);
$D7->apply_unsafe($w4);
$D7->apply_unsafe($x4);
$D7->apply_unsafe($y4);
$D7->apply_unsafe($z4);
$D7->apply_unsafe($A4);
$D7->apply_unsafe($B4);
$L7->apply_unsafe($r4);
$L7->apply_unsafe($t4);
$L7->apply_unsafe($u4);
$L7->apply_unsafe($v4);
$L7->apply_unsafe($w4);
$L7->apply_unsafe($x4);
$L7->apply_unsafe($y4);
$L7->apply_unsafe($z4);
$L7->apply_unsafe($A4);
$L7->apply_unsafe($B4);
$T7->apply_unsafe($r4);
$T7->apply_unsafe($t4);
$T7->apply_unsafe($u4);
$T7->apply_unsafe($v4);
$T7->apply_unsafe($w4);
$T7->apply_unsafe($x4);
$T7->apply_unsafe($y4);
$T7->apply_unsafe($z4);
$T7->apply_unsafe($A4);
$T7->apply_unsafe($B4);
$k8->apply_unsafe($r4);
$r8->apply_unsafe($r4);
$D8->apply_unsafe($r4);
$e9->apply_unsafe($s4);
$w9->apply_unsafe($t4);
$G9->apply_unsafe($t4);
$Z9->apply_unsafe($u4);
$ia->apply_unsafe($u4);
$Ca->apply_unsafe($v4);
$Ja->apply_unsafe($v4);
$fb->apply_unsafe($v4);
$Db->apply_unsafe($v4);
$Lb->apply_unsafe($v4);
$dc->apply_unsafe($v4);
$Bc->apply_unsafe($w4);
$Ic->apply_unsafe($w4);
$Qc->apply_unsafe($w4);
$id->apply_unsafe($w4);
$td->apply_unsafe($w4);
$Dd->apply_unsafe($w4);
$de->apply_unsafe($x4);
$le->apply_unsafe($x4);
$se->apply_unsafe($x4);
$Ke->apply_unsafe($x4);
$sf->apply_unsafe($tf);
$Df->apply_unsafe($y4);
$Qf->apply_unsafe($y4);
$xg->apply_unsafe($A4);
$Hg->apply_unsafe($A4);
$Tg->apply_unsafe($A4);
$fh->apply_unsafe($A4);
$vh->apply_unsafe($A4);
$di->apply_unsafe($B4);
$ki->apply_unsafe($B4);
$yi->apply_unsafe($B4);
$Vi->apply_unsafe($x3);
$rj->apply_unsafe($D4);
$xj->apply_unsafe($D4);
$Sj->apply_unsafe($F);
$Yj->apply_unsafe($F);
$hk->apply_unsafe($F);
$qk->apply_unsafe($F);
$Rk->apply_unsafe($u);
$hl->apply_unsafe($u);
$rl->apply_unsafe($u);
$zl->apply_unsafe($u);
$Ul->apply_unsafe($E4);
$gm->apply_unsafe($tf);
$qm->apply_unsafe($E4);
$fn->apply_unsafe($E4);
$nn->apply_unsafe($E4);
$nn->apply_unsafe($G4);
$Ln->apply_unsafe($E4);
$Ln->apply_unsafe($G4);
$do->apply_unsafe($E4);
$do->apply_unsafe($G4);
$to->apply_unsafe($E4);
$gp->apply_unsafe($hp);
$Bp->apply_unsafe($F4);
$Lp->apply_unsafe($F4);
$gq->apply_unsafe($F4);
$pq->apply_unsafe($F4);
$Er->apply_unsafe($hp);
$Sr->apply_unsafe($G4);
$ds->apply_unsafe($G4);
$Es->apply_unsafe($v3);
$Ks->apply_unsafe($v3);
$Rs->apply_unsafe($v3);
$qt->apply_unsafe($tf);
$At->apply_unsafe($H3);
$Gt->apply_unsafe($H3);
$cu->apply_unsafe($H4);
$ou->apply_unsafe($H4);
$vu->apply_unsafe($H4);
$ni::self=$Wv;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$H;
&$_($d1)for@$H;
&$_($j1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$H;
&$_($D1)for@$w;
&$_($H1)for@$H;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$H;
&$_($f2)for@$H;
&$_($n2)for@$w;
&$_($r2)for@$w;
&$_($v2)for@$H;
&$_($p3)for@$w;
&$_($s3)for@$w;
&$_($w3)for@$y3;
&$_($B3)for@$w;
&$_($D3)for@$w;
&$_($G3)for@$y3;
&$_($L3)for@$w;
&$_($O3)for@$y3;
&$_($S3)for@$w;
&$_($V3)for@$y3;
&$_($Z3)for@$w;
&$_($e4)for@$y3;
&$_($g4)for@$h4;
&$_($k4)for@$w;
&$_($n4)for@$w;
&$_($q4)for@$y3;
&$_($N4)for@$w;
&$_($Q4)for@$y3;
&$_($S4)for@$T4;
&$_($Y4)for@$w;
&$_($d5)for@$y3;
&$_($f5)for@$g5;
&$_($m5)for@$w;
&$_($p5)for@$y3;
&$_($t5)for@$w;
&$_($w5)for@$w;
&$_($z5)for@$y3;
&$_($D5)for@$w;
&$_($G5)for@$y3;
&$_($K5)for@$w;
&$_($N5)for@$y3;
&$_($R5)for@$w;
&$_($U5)for@$y3;
&$_($W5)for@$X5;
&$_($Z5)for@$c6;
&$_($g6)for@$w;
&$_($j6)for@$w;
&$_($m6)for@$y3;
&$_($q6)for@$w;
&$_($t6)for@$y3;
&$_($v6)for@$w6;
&$_($F6)for@$G6;
&$_($K6)for@$G6;
&$_($M6)for@$G6;
&$_($O6)for@$G6;
&$_($W6)for@$w;
&$_($Z6)for@$y3;
&$_($g7)for@$w;
&$_($j7)for@$y3;
&$_($o7)for@$w;
&$_($s7)for@$w;
&$_($w7)for@$w;
&$_($A7)for@$w;
&$_($D7)for@$y3;
&$_($I7)for@$w;
&$_($L7)for@$y3;
&$_($Q7)for@$w;
&$_($T7)for@$y3;
&$_($V7)for@$W7;
&$_($d8)for@$w;
&$_($h8)for@$w;
&$_($k8)for@$y3;
&$_($o8)for@$w;
&$_($r8)for@$y3;
&$_($w8)for@$w;
&$_($A8)for@$w;
&$_($D8)for@$y3;
&$_($F8)for@$G8;
&$_($N8)for@$G6;
&$_($P8)for@$G6;
&$_($Z8)for@$w;
&$_($e9)for@$y3;
&$_($g9)for@$h9;
&$_($m9)for@$G6;
&$_($t9)for@$w;
&$_($w9)for@$y3;
&$_($A9)for@$w;
&$_($D9)for@$w;
&$_($G9)for@$y3;
&$_($I9)for@$J9;
&$_($O9)for@$G6;
&$_($W9)for@$w;
&$_($Z9)for@$y3;
&$_($fa)for@$w;
&$_($ia)for@$y3;
&$_($ka)for@$la;
&$_($qa)for@$G6;
&$_($za)for@$w;
&$_($Ca)for@$y3;
&$_($Ga)for@$w;
&$_($Ja)for@$y3;
&$_($Oa)for@$w;
&$_($Sa)for@$w;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($fb)for@$y3;
&$_($kb)for@$w;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Db)for@$y3;
&$_($Ib)for@$w;
&$_($Lb)for@$y3;
&$_($Qb)for@$w;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($dc)for@$y3;
&$_($fc)for@$gc;
&$_($lc)for@$G6;
&$_($yc)for@$w;
&$_($Bc)for@$y3;
&$_($Fc)for@$w;
&$_($Ic)for@$y3;
&$_($Nc)for@$w;
&$_($Qc)for@$y3;
&$_($Vc)for@$w;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($id)for@$y3;
&$_($md)for@$w;
&$_($qd)for@$w;
&$_($td)for@$y3;
&$_($xd)for@$w;
&$_($Ad)for@$w;
&$_($Dd)for@$y3;
&$_($Fd)for@$Gd;
&$_($Ld)for@$G6;
&$_($Yd)for@$w;
&$_($de)for@$y3;
&$_($ie)for@$w;
&$_($le)for@$y3;
&$_($pe)for@$w;
&$_($se)for@$y3;
&$_($xe)for@$w;
&$_($Ae)for@$w;
&$_($Ee)for@$w;
&$_($He)for@$w;
&$_($Ke)for@$y3;
&$_($Me)for@$Ne;
&$_($Se)for@$G6;
&$_($ef)for@$w;
&$_($hf)for@$w;
&$_($lf)for@$w;
&$_($pf)for@$w;
&$_($sf)for@$y3;
&$_($Af)for@$w;
&$_($Df)for@$y3;
&$_($Hf)for@$w;
&$_($Kf)for@$w;
&$_($Nf)for@$w;
&$_($Qf)for@$y3;
&$_($Sf)for@$Tf;
&$_($Yf)for@$G6;
&$_($qg)for@$w;
&$_($ug)for@$w;
&$_($xg)for@$y3;
&$_($Bg)for@$w;
&$_($Eg)for@$w;
&$_($Hg)for@$y3;
&$_($Mg)for@$w;
&$_($Qg)for@$w;
&$_($Tg)for@$y3;
&$_($Xg)for@$w;
&$_($ch)for@$w;
&$_($fh)for@$y3;
&$_($jh)for@$w;
&$_($mh)for@$w;
&$_($ph)for@$w;
&$_($sh)for@$w;
&$_($vh)for@$y3;
&$_($xh)for@$yh;
&$_($Dh)for@$G6;
&$_($Qh)for@$w;
&$_($Uh)for@$w;
&$_($Yh)for@$w;
&$_($di)for@$y3;
&$_($hi)for@$w;
&$_($ki)for@$y3;
&$_($oi)for@$w;
&$_($si)for@$w;
&$_($vi)for@$w;
&$_($yi)for@$y3;
&$_($Ai)for@$Bi;
&$_($Gi)for@$G6;
&$_($Si)for@$w;
&$_($Vi)for@$y3;
&$_($Xi)for@$Yi;
&$_($gj)for@$G6;
&$_($oj)for@$w;
&$_($rj)for@$y3;
&$_($uj)for@$w;
&$_($xj)for@$y3;
&$_($zj)for@$Aj;
&$_($Fj)for@$G6;
&$_($Pj)for@$w;
&$_($Sj)for@$y3;
&$_($Vj)for@$w;
&$_($Yj)for@$y3;
&$_($ek)for@$w;
&$_($hk)for@$y3;
&$_($kk)for@$w;
&$_($nk)for@$w;
&$_($qk)for@$y3;
&$_($sk)for@$tk;
&$_($yk)for@$G6;
&$_($Jk)for@$w;
&$_($Mk)for@$w;
&$_($Ok)for@$w;
&$_($Rk)for@$y3;
&$_($Vk)for@$w;
&$_($Yk)for@$w;
&$_($el)for@$w;
&$_($hl)for@$y3;
&$_($ll)for@$w;
&$_($ol)for@$w;
&$_($rl)for@$y3;
&$_($wl)for@$w;
&$_($zl)for@$y3;
&$_($Bl)for@$Cl;
&$_($Hl)for@$G6;
&$_($Rl)for@$w;
&$_($Ul)for@$y3;
&$_($dm)for@$w;
&$_($gm)for@$y3;
&$_($nm)for@$w;
&$_($qm)for@$y3;
&$_($vm)for@$w;
&$_($zm)for@$w;
&$_($Dm)for@$w;
&$_($Hm)for@$w;
&$_($Lm)for@$w;
&$_($Pm)for@$w;
&$_($Tm)for@$w;
&$_($Xm)for@$w;
&$_($cn)for@$w;
&$_($fn)for@$y3;
&$_($kn)for@$w;
&$_($nn)for@$y3;
&$_($sn)for@$w;
&$_($wn)for@$w;
&$_($An)for@$w;
&$_($En)for@$w;
&$_($In)for@$w;
&$_($Ln)for@$y3;
&$_($Qn)for@$w;
&$_($Un)for@$w;
&$_($Yn)for@$w;
&$_($do)for@$y3;
&$_($io)for@$w;
&$_($mo)for@$w;
&$_($qo)for@$w;
&$_($to)for@$y3;
&$_($vo)for@$wo;
&$_($Bo)for@$G6;
&$_($Lo)for@$w;
&$_($Po)for@$w;
&$_($To)for@$w;
&$_($Xo)for@$w;
&$_($dp)for@$w;
&$_($gp)for@$y3;
&$_($sp)for@$w;
&$_($vp)for@$w;
&$_($yp)for@$w;
&$_($Bp)for@$y3;
&$_($Fp)for@$w;
&$_($Ip)for@$w;
&$_($Lp)for@$y3;
&$_($Pp)for@$w;
&$_($Sp)for@$w;
&$_($Vp)for@$w;
&$_($Yp)for@$w;
&$_($dq)for@$w;
&$_($gq)for@$y3;
&$_($jq)for@$w;
&$_($mq)for@$w;
&$_($pq)for@$y3;
&$_($rq)for@$sq;
&$_($xq)for@$G6;
&$_($Hq)for@$w;
&$_($Lq)for@$w;
&$_($Pq)for@$w;
&$_($Tq)for@$w;
&$_($Xq)for@$w;
&$_($dr)for@$w;
&$_($hr)for@$w;
&$_($lr)for@$w;
&$_($pr)for@$w;
&$_($tr)for@$w;
&$_($xr)for@$w;
&$_($Br)for@$w;
&$_($Er)for@$y3;
&$_($Pr)for@$w;
&$_($Sr)for@$y3;
&$_($Vr)for@$w;
&$_($Yr)for@$w;
&$_($ds)for@$y3;
&$_($fs)for@$gs;
&$_($ls)for@$G6;
&$_($vs)for@$w;
&$_($xs)for@$w;
&$_($Es)for@$y3;
&$_($Hs)for@$w;
&$_($Ks)for@$y3;
&$_($Os)for@$w;
&$_($Rs)for@$y3;
&$_($Ts)for@$Us;
&$_($ct)for@$G6;
&$_($jt)for@$w;
&$_($nt)for@$w;
&$_($qt)for@$y3;
&$_($xt)for@$w;
&$_($At)for@$y3;
&$_($Dt)for@$w;
&$_($Gt)for@$y3;
&$_($It)for@$Jt;
&$_($Pt)for@$G6;
&$_($Xt)for@$w;
&$_($cu)for@$y3;
&$_($hu)for@$w;
&$_($lu)for@$w;
&$_($ou)for@$y3;
&$_($su)for@$w;
&$_($vu)for@$y3;
&$_($xu)for@$yu;
&$_($Du)for@$G6;
&$_($Lu)for@$Mu;
&$_($Ru)for@$G6;
&$_($Zu)for@$cv;
&$_($wv)for@$xv;
&$_($zv)for@$cv;
&$_($Ev)for@$w;
&$_($Iv)for@$w;
&$_($Mv)for@$w;
&$_($Qv)for@$w;
&$_($Uv)for@$w;
&$_($Wv)for@$Xv;
ni->run(@ARGV);
__DATA__
