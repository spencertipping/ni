#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib/doc#;
$L1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$M1=[$f,$L1];
$N1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$O1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$P1=[];
$Q1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$T1=[];
$U1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$V1=bless({$o,$T1,$q,$U1,$s,$t},$u);
$W1=[$i,$N1,$O1,$n,$R1,$S1,$n,$V1];
$X1=[$M1,$W1];
$Y1=q#/lib/doc#;
$Z1=bless({$e,$X1,$D,$Y1},$F);
$c2=q#ni:/class#;
$d2=q#applied_to#;
$e2=q#class#;
$f2=q#class.c#;
$g2=q#io/cat.c#;
$h2=q#io/exec.c#;
$i2=q#io/fd.c#;
$j2=q#io/file.c#;
$k2=q#io/null.c#;
$l2=q#io/object.c#;
$m2=q#io/pid.c#;
$n2=q#io/str.c#;
$o2=q#lib/behavior.c#;
$p2=q#lib/branch.c#;
$q2=q#lib/dataslice.c#;
$r2=q#lib/doc.c#;
$s2=q#lib/fn.c#;
$t2=q#lib/image.c#;
$u2=q#lib/ni.c#;
$v2=q#lib/quote_simple.c#;
$w2=q#lib/slice.c#;
$x2=q#lib/tag.c#;
$y2=q#lib/test_value.c#;
$z2=q#metaclass.c#;
$A2=q#module.c#;
$B2=q#object.c#;
$C2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1};
$D2=q#slices#;
$E2=q#metaclass#;
$F2=q#module#;
$G2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$E2,1,$z2,1,$F2,1,$A2,1,$B2,1};
$H2=q#/module#;
$I2=q#/lib/perlbranch.b#;
$J2={};
$K2=q#ctor#;
$L2=undef;
$M2=q#dtor#;
$N2=q#methods#;
$O2=q#add#;
$P2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$Q2=bless({$q,$P2,$s,$t},$u);
$R2=q#apply#;
$S2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$T2=bless({$q,$S2,$s,$t},$u);
$U2={$O2,$Q2,$R2,$T2};
$V2=q#/lib/branch.b#;
$W2=q#lib/slice#;
$X2=bless({$d2,$J2,$K2,$L2,$M2,$L2,$N2,$U2,$D,$V2},$W2);
$Y2=q#lib/branch#;
$Z2=q#lib/slice::ctors#;
$c3={};
$d3=q#my $s = shift; ni->def($s->name, $s)#;
$e3=bless({$q,$d3,$s,$t},$u);
$f3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$g3=bless({$q,$f3,$s,$t},$u);
$h3={$D,$g3};
$i3=q#/lib/named.b#;
$j3=bless({$d2,$c3,$K2,$e3,$M2,$L2,$N2,$h3,$D,$i3},$W2);
$k3=q#lib/tag#;
$l3={};
$m3=q#namespace#;
$n3=q#'ni'#;
$o3=bless({$q,$n3,$s,$t},$u);
$p3={$m3,$o3};
$q3=q#/lib/named_in_ni.b#;
$r3=bless({$d2,$l3,$K2,$L2,$M2,$L2,$N2,$p3,$D,$q3},$W2);
$s3={};
$t3=q#package#;
$u3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$v3=bless({$q,$u3,$s,$t},$u);
$w3={$t3,$v3};
$x3=q#/lib/namespaced.b#;
$y3=bless({$d2,$s3,$K2,$L2,$M2,$L2,$N2,$w3,$D,$x3},$W2);
$z3={};
$A3=q#resolve#;
$B3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$C3=bless({$q,$B3,$s,$t},$u);
$D3={$A3,$C3};
$E3=q#/lib/resolver.b#;
$F3=bless({$d2,$z3,$K2,$L2,$M2,$L2,$N2,$D3,$D,$E3},$W2);
$G3=[$X2,$j3,$r3,$y3,$F3];
$H3=bless({$D,$I2,$D2,$G3},$k3);
$I3=q#lib/tag::ctors#;
$J3={};
$K3=q#my $s = shift; $s->apply($s->package)#;
$L3=bless({$q,$K3,$s,$t},$u);
$M3=q#instantiate#;
$N3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$O3=bless({$q,$N3,$s,$t},$u);
$P3={$M3,$O3};
$Q3=q#/lib/class_init.b#;
$R3=bless({$d2,$J3,$K2,$L3,$M2,$L2,$N2,$P3,$D,$Q3},$W2);
$S3=q#io/cat#;
$T3=q#io/exec#;
$U3=q#io/fd#;
$V3=q#io/file#;
$W3=q#io/null#;
$X3=q#io/object#;
$Y3=q#io/pid#;
$Z3=q#io/str#;
$c4=q#lib/behavior#;
$d4=q#lib/dataslice#;
$e4=q#lib/image#;
$f4=q#lib/ni#;
$g4=q#lib/quote_simple#;
$h4=q#lib/test_value#;
$i4=q#object#;
$j4={$e2,1,$f2,1,$S3,1,$g2,1,$T3,1,$h2,1,$U3,1,$i2,1,$V3,1,$j2,1,$W3,1,$k2,1,$X3,1,$l2,1,$Y3,1,$m2,1,$Z3,1,$n2,1,$c4,1,$o2,1,$Y2,1,$p2,1,$d4,1,$q2,1,$F,1,$r2,1,$u,1,$s2,1,$e4,1,$t2,1,$f4,1,$u2,1,$g4,1,$v2,1,$W2,1,$w2,1,$k3,1,$x2,1,$h4,1,$y2,1,$E2,1,$z2,1,$F2,1,$A2,1,$i4,1,$B2,1};
$k4=q#/object#;
$l4={};
$m4=q#ni 'ni:/' . ref shift#;
$n4=bless({$q,$m4,$s,$t},$u);
$o4={$e2,$n4};
$p4=q#/lib/instance.b#;
$q4=bless({$d2,$l4,$K2,$L2,$M2,$L2,$N2,$o4,$D,$p4},$W2);
$r4=[$q4];
$s4=bless({$d2,$j4,$D,$k4,$D2,$r4},$B2);
$t4=q#object.c::ctors#;
$u4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$c4,1,$o2,1,$Y2,1,$p2,1,$d4,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$W2,1,$w2,1,$k3,1,$x2,1,$y2,1,$E2,1,$z2,1,$F2,1,$A2,1,$B2,1};
$v4=q#/lib/behavior#;
$w4={};
$x4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$y4=bless({$q,$x4,$s,$t},$u);
$z4={$e,$y4};
$A4=q#/lib/documentable.b#;
$B4=bless({$d2,$w4,$K2,$L2,$M2,$L2,$N2,$z4,$D,$A4},$W2);
$C4=[$s4,$B4];
$D4=bless({$d2,$u4,$D,$v4,$D2,$C4},$o2);
$E4=q#lib/behavior.c::ctors#;
$F4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$Y2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$E2,1,$z2,1,$F2,1,$A2,1,$B2,1};
$G4=q#/lib/definition.b#;
$H4={};
$I4=q#def#;
$J4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$K4=bless({$q,$J4,$s,$t},$u);
$L4={$I4,$K4};
$M4=q#/lib/definition_def.b#;
$N4=bless({$d2,$H4,$K2,$L2,$M2,$L2,$N2,$L4,$D,$M4},$W2);
$O4={};
$P4=q#ro#;
$Q4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$R4=bless({$q,$Q4,$s,$t},$u);
$S4=q#rw#;
$T4=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$U4=bless({$q,$T4,$s,$t},$u);
$V4={$P4,$R4,$S4,$U4};
$W4=q#/lib/accessor.b#;
$X4=bless({$d2,$O4,$K2,$L2,$M2,$L2,$N2,$V4,$D,$W4},$W2);
$Y4={};
$Z4=q#(""#;
$c5=q#shift->name#;
$d5=bless({$q,$c5,$s,$t},$u);
$e5={$Z4,$d5};
$f5=q#/lib/name_as_string.b#;
$g5=bless({$d2,$Y4,$K2,$L2,$M2,$L2,$N2,$e5,$D,$f5},$W2);
$h5={};
$i5=q#(eq#;
$j5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$k5=bless({$q,$j5,$s,$t},$u);
$l5={$i5,$k5};
$m5=q#/lib/ref_eq.b#;
$n5=bless({$d2,$h5,$K2,$L2,$M2,$L2,$N2,$l5,$D,$m5},$W2);
$o5={};
$p5=q#defdata#;
$q5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$r5=bless({$q,$q5,$s,$t},$u);
$s5={$p5,$r5};
$t5=q#/lib/definition_defdata.b#;
$u5=bless({$d2,$o5,$K2,$L2,$M2,$L2,$N2,$s5,$D,$t5},$W2);
$v5=[$N4,$X4,$g5,$n5,$u5];
$w5=bless({$d2,$F4,$D,$G4,$D2,$v5},$Y2);
$x5=q#lib/branch::ctors#;
$y5=[$H3,$R3,$s4,$D4,$w5];
$z5=bless({$d2,$G2,$D,$H2,$D2,$y5},$A2);
$A5=q#module.c::ctors#;
$B5={};
$C5=q#DESTROY#;
$D5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$E5=bless({$q,$D5,$s,$t},$u);
$F5=q#new#;
$G5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$H5=bless({$q,$G5,$s,$t},$u);
$I5={$C5,$E5,$F5,$H5};
$J5=q#/lib/instantiable.b#;
$K5=bless({$d2,$B5,$N2,$I5,$D,$J5},$W2);
$L5={};
$M5=q#child#;
$N5=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$O5=bless({$q,$N5,$s,$t},$u);
$P5={$M5,$O5};
$Q5=q#/lib/subclass.b#;
$R5=bless({$d2,$L5,$K2,$L2,$M2,$L2,$N2,$P5,$D,$Q5},$W2);
$S5=[$z5,$K5,$R3,$z5,$R5];
$T5=bless({$d2,$C2,$D,$E,$D2,$S5},$f2);
$U5=q#class.c::ctors#;
$V5=q#ni:/class.c#;
$W5={$f2,1};
$X5=q#/class.c#;
$Y5={$f2,1,$A2,1};
$Z5=q#/module.c#;
$c6={$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$A2,1,$B2,1};
$d6=q#/object.c#;
$e6=[$T5];
$f6=bless({$d2,$c6,$D,$d6,$D2,$e6},$E2);
$g6=q#metaclass::ctors#;
$h6={$f2,1,$o2,1,$p2,1,$q2,1,$w2,1,$x2,1,$A2,1};
$i6=q#/lib/behavior.c#;
$j6=[$f6];
$k6=bless({$d2,$h6,$D,$i6,$D2,$j6},$E2);
$l6=[$f6,$K5,$k6];
$m6=bless({$d2,$Y5,$D,$Z5,$D2,$l6},$E2);
$n6=[$m6];
$o6=bless({$d2,$W5,$D,$X5,$D2,$n6},$E2);
$p6=q#ni:/io/cat#;
$q6={$S3,1};
$r6={$S3,1,$T3,1,$U3,1,$V3,1,$W3,1,$X3,1,$Y3,1,$Z3,1};
$s6=q#/io/object#;
$t6={};
$u6=q#(bool#;
$v6=[];
$w6=bless({$o,$v6,$q,1,$s,$t},$u);
$x6={$u6,$w6};
$y6=q#/io/object_ops.b#;
$z6=bless({$d2,$t6,$K2,$L2,$M2,$L2,$N2,$x6,$D,$y6},$W2);
$A6={};
$B6=q#into#;
$C6=[];
$D6=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}
$self;#;
$E6=bless({$o,$C6,$q,$D6,$s,$t},$u);
$F6={$B6,$E6};
$G6=q#/io/object_stream.b#;
$H6=bless({$d2,$A6,$K2,$L2,$M2,$L2,$N2,$F6,$D,$G6},$W2);
$I6={};
$J6=q#die#;
$K6=[];
$L6=q#shift; die join " ", @_#;
$M6=bless({$o,$K6,$q,$L6,$s,$t},$u);
$N6=q#io_check#;
$O6=[];
$P6=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$Q6=bless({$o,$O6,$q,$P6,$s,$t},$u);
$R6=q#io_check_defined#;
$S6=[];
$T6=q#shift->io_check(sub {defined shift}, @_)#;
$U6=bless({$o,$S6,$q,$T6,$s,$t},$u);
$V6=q#io_check_true#;
$W6=[];
$X6=q#shift->io_check(sub {shift}, @_)#;
$Y6=bless({$o,$W6,$q,$X6,$s,$t},$u);
$Z6={$J6,$M6,$N6,$Q6,$R6,$U6,$V6,$Y6};
$c7=q#/io/object_checks.b#;
$d7=bless({$d2,$I6,$K2,$L2,$M2,$L2,$N2,$Z6,$D,$c7},$W2);
$e7={};
$f7=q#(+#;
$g7=[];
$h7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$i7=bless({$o,$g7,$q,$h7,$s,$t},$u);
$j7={$f7,$i7};
$k7=q#/io/object_constructors.b#;
$l7=bless({$d2,$e7,$K2,$L2,$M2,$L2,$N2,$j7,$D,$k7},$W2);
$m7={};
$n7=q#read_all#;
$o7=[];
$p7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$q7=bless({$o,$o7,$q,$p7,$s,$t},$u);
$r7={$n7,$q7};
$s7=q#/io/object_memory.b#;
$t7=bless({$d2,$m7,$K2,$L2,$M2,$L2,$N2,$r7,$D,$s7},$W2);
$u7=[$s4,$z6,$H6,$d7,$l7,$t7];
$v7=bless({$d2,$r6,$D,$s6,$D2,$u7},$l2);
$w7=q#io/object.c::ctors#;
$x7={};
$y7=[];
$z7=q#shift; +{fs => [@_]}#;
$A7=bless({$o,$y7,$q,$z7,$s,$t},$u);
$B7={$M3,$A7};
$C7=q#/io/cat_init.b#;
$D7=bless({$d2,$x7,$K2,$L2,$M2,$L2,$N2,$B7,$D,$C7},$W2);
$E7={};
$F7=q#read#;
$G7=[];
$H7=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$I7=bless({$o,$G7,$q,$H7,$s,$t},$u);
$J7={$F7,$I7};
$K7=q#/io/cat_read.b#;
$L7=bless({$d2,$E7,$K2,$L2,$M2,$L2,$N2,$J7,$D,$K7},$W2);
$M7=[$v7,$D7,$L7];
$N7=bless({$d2,$q6,$D,$g1,$D2,$M7},$g2);
$O7=q#io/cat.c::ctors#;
$P7=q#ni:/io/cat.c#;
$Q7={$g2,1};
$R7=q#/io/cat.c#;
$S7={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1};
$T7=q#/io/object.c#;
$U7=[$f6];
$V7=bless({$d2,$S7,$D,$T7,$D2,$U7},$E2);
$W7=[$V7];
$X7=bless({$d2,$Q7,$D,$R7,$D2,$W7},$E2);
$Y7=q#ni:/io/cat_init.b#;
$Z7=q#ni:/io/cat_read.b#;
$c8=q#ni:/io/exec#;
$d8={$T3,1};
$e8={};
$f8=q#argv#;
$g8=[];
$h8=q#shift->{'argv'}#;
$i8=bless({$o,$g8,$q,$h8,$s,$t},$u);
$j8={$f8,$i8};
$k8=q#/io/exec_ro.b#;
$l8=bless({$d2,$e8,$K2,$L2,$M2,$L2,$N2,$j8,$D,$k8},$W2);
$m8={};
$n8=[];
$o8=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$p8=bless({$o,$n8,$q,$o8,$s,$t},$u);
$q8={$M3,$p8};
$r8=q#/io/exec_init.b#;
$s8=bless({$d2,$m8,$K2,$L2,$M2,$L2,$N2,$q8,$D,$r8},$W2);
$t8={};
$u8=q#connect#;
$v8=[];
$w8=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$x8=bless({$o,$v8,$q,$w8,$s,$t},$u);
$y8=q#in_pipe#;
$z8=[];
$A8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$B8=bless({$o,$z8,$q,$A8,$s,$t},$u);
$C8=q#out_pipe#;
$D8=[];
$E8=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$F8=bless({$o,$D8,$q,$E8,$s,$t},$u);
$G8=q#setup_stdio#;
$H8=[];
$I8=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$J8=bless({$o,$H8,$q,$I8,$s,$t},$u);
$K8={$u8,$x8,$y8,$B8,$C8,$F8,$G8,$J8};
$L8=q#/io/exec_io_setup.b#;
$M8=bless({$d2,$t8,$K2,$L2,$M2,$L2,$N2,$K8,$D,$L8},$W2);
$N8={};
$O8=q#binds_fd#;
$P8=[];
$Q8=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$R8=bless({$o,$P8,$q,$Q8,$s,$t},$u);
$S8=q#fd#;
$T8=[];
$U8=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$V8=bless({$o,$T8,$q,$U8,$s,$t},$u);
$W8=q#stderr#;
$X8=[];
$Y8=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Z8=bless({$o,$X8,$q,$Y8,$s,$t},$u);
$c9=q#stdin#;
$d9=[];
$e9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$f9=bless({$o,$d9,$q,$e9,$s,$t},$u);
$g9=q#stdout#;
$h9=[];
$i9=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$j9=bless({$o,$h9,$q,$i9,$s,$t},$u);
$k9={$O8,$R8,$S8,$V8,$W8,$Z8,$c9,$f9,$g9,$j9};
$l9=q#/io/exec_io_accessors.b#;
$m9=bless({$d2,$N8,$K2,$L2,$M2,$L2,$N2,$k9,$D,$l9},$W2);
$n9={};
$o9=q#env#;
$p9=[];
$q9=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$r9=bless({$o,$p9,$q,$q9,$s,$t},$u);
$s9={$o9,$r9};
$t9=q#/io/exec_env.b#;
$u9=bless({$d2,$n9,$K2,$L2,$M2,$L2,$N2,$s9,$D,$t9},$W2);
$v9={};
$w9=q#exec#;
$x9=[];
$y9=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9=q#fork#;
$B9=[];
$C9=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$D9=bless({$o,$B9,$q,$C9,$s,$t},$u);
$E9=q#move_fds#;
$F9=[];
$G9=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$H9=bless({$o,$F9,$q,$G9,$s,$t},$u);
$I9={$w9,$z9,$A9,$D9,$E9,$H9};
$J9=q#/io/exec_fork.b#;
$K9=bless({$d2,$v9,$K2,$L2,$M2,$L2,$N2,$I9,$D,$J9},$W2);
$L9=[$v7,$l8,$s8,$M8,$m9,$u9,$K9];
$M9=bless({$d2,$d8,$D,$s1,$D2,$L9},$h2);
$N9=q#io/exec.c::ctors#;
$O9=q#ni:/io/exec.c#;
$P9={$h2,1};
$Q9=q#/io/exec.c#;
$R9=[$V7];
$S9=bless({$d2,$P9,$D,$Q9,$D2,$R9},$E2);
$T9=q#ni:/io/exec_env.b#;
$U9=q#ni:/io/exec_fork.b#;
$V9=q#ni:/io/exec_init.b#;
$W9=q#ni:/io/exec_io_accessors.b#;
$X9=q#ni:/io/exec_io_setup.b#;
$Y9=q#ni:/io/exec_ro.b#;
$Z9=q#ni:/io/fd#;
$ca={$U3,1};
$da=q#/io/fd#;
$ea={};
$fa=[];
$ga=q#shift->{'fd'}#;
$ha=bless({$o,$fa,$q,$ga,$s,$t},$u);
$ia={$S8,$ha};
$ja=q#/io/fd_readers.b#;
$ka=bless({$d2,$ea,$K2,$L2,$M2,$L2,$N2,$ia,$D,$ja},$W2);
$la={};
$ma=[];
$na=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$oa=bless({$o,$ma,$q,$na,$s,$t},$u);
$pa={$M3,$oa};
$qa=q#/io/fd_init.b#;
$ra=bless({$d2,$la,$K2,$L2,$M2,$L2,$N2,$pa,$D,$qa},$W2);
$sa={};
$ta=q#be#;
$ua=[];
$va=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa={$ta,$wa};
$ya=q#/io/fd_shell.b#;
$za=bless({$d2,$sa,$K2,$L2,$M2,$L2,$N2,$xa,$D,$ya},$W2);
$Aa={};
$Ba=q#cloexec#;
$Ca=[];
$Da=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa=q#fcntl_flag#;
$Ga=[];
$Ha=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja=q#nonblock#;
$Ka=[];
$La=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na={$Ba,$Ea,$Fa,$Ia,$Ja,$Ma};
$Oa=q#/io/fd_fcntl.b#;
$Pa=bless({$d2,$Aa,$K2,$L2,$M2,$L2,$N2,$Na,$D,$Oa},$W2);
$Qa={};
$Ra=[];
$Sa=q#shift->close#;
$Ta=bless({$o,$Ra,$q,$Sa,$s,$t},$u);
$Ua=q#close#;
$Va=[];
$Wa=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Xa=bless({$o,$Va,$q,$Wa,$s,$t},$u);
$Ya={$Ua,$Xa};
$Za=q#/io/fd_gc.b#;
$cb=bless({$d2,$Qa,$K2,$L2,$M2,$Ta,$N2,$Ya,$D,$Za},$W2);
$db={};
$eb=[];
$fb=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb=q#write#;
$ib=[];
$jb=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb={$F7,$gb,$hb,$kb};
$mb=q#/io/fd_perlio.b#;
$nb=bless({$d2,$db,$K2,$L2,$M2,$L2,$N2,$lb,$D,$mb},$W2);
$ob=[$v7,$ka,$ra,$za,$Pa,$cb,$nb];
$pb=bless({$d2,$ca,$D,$da,$D2,$ob},$i2);
$qb=q#io/fd.c::ctors#;
$rb=q#ni:/io/fd.c#;
$sb={$i2,1};
$tb=q#/io/fd.c#;
$ub=[$V7];
$vb=bless({$d2,$sb,$D,$tb,$D2,$ub},$E2);
$wb=q#ni:/io/fd_fcntl.b#;
$xb=q#ni:/io/fd_gc.b#;
$yb=q#ni:/io/fd_init.b#;
$zb=q#ni:/io/fd_perlio.b#;
$Ab=q#ni:/io/fd_readers.b#;
$Bb=q#ni:/io/fd_shell.b#;
$Cb=q#ni:/io/file#;
$Db={$V3,1};
$Eb=q#/io/file#;
$Fb={};
$Gb=[];
$Hb=q#shift->{'name'}#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb={$D,$Ib};
$Kb=q#/io/file_readers.b#;
$Lb=bless({$d2,$Fb,$K2,$L2,$M2,$L2,$N2,$Jb,$D,$Kb},$W2);
$Mb={};
$Nb=q#mode#;
$Ob=[];
$Pb=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb={$Nb,$Qb};
$Sb=q#/io/file_accessors.b#;
$Tb=bless({$d2,$Mb,$K2,$L2,$M2,$L2,$N2,$Rb,$D,$Sb},$W2);
$Ub={};
$Vb=[];
$Wb=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Xb=bless({$o,$Vb,$q,$Wb,$s,$t},$u);
$Yb={$M3,$Xb};
$Zb=q#/io/file_init.b#;
$cc=bless({$d2,$Ub,$K2,$L2,$M2,$L2,$N2,$Yb,$D,$Zb},$W2);
$dc={};
$ec=q#r#;
$fc=[];
$gc=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$hc=bless({$o,$fc,$q,$gc,$s,$t},$u);
$ic=[];
$jc=q#shift->r->read(@_)#;
$kc=bless({$o,$ic,$q,$jc,$s,$t},$u);
$lc=q#w#;
$mc=[];
$nc=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$oc=bless({$o,$mc,$q,$nc,$s,$t},$u);
$pc=[];
$qc=q#shift->w->write(@_)#;
$rc=bless({$o,$pc,$q,$qc,$s,$t},$u);
$sc={$ec,$hc,$F7,$kc,$lc,$oc,$hb,$rc};
$tc=q#/io/file_io.b#;
$uc=bless({$d2,$dc,$K2,$L2,$M2,$L2,$N2,$sc,$D,$tc},$W2);
$vc=[$v7,$Lb,$Tb,$cc,$uc];
$wc=bless({$d2,$Db,$D,$Eb,$D2,$vc},$j2);
$xc=q#io/file.c::ctors#;
$yc=q#ni:/io/file.c#;
$zc={$j2,1};
$Ac=q#/io/file.c#;
$Bc=[$V7];
$Cc=bless({$d2,$zc,$D,$Ac,$D2,$Bc},$E2);
$Dc=q#ni:/io/file_accessors.b#;
$Ec=q#ni:/io/file_init.b#;
$Fc=q#ni:/io/file_io.b#;
$Gc=q#ni:/io/file_readers.b#;
$Hc=q#ni:/io/named_io_fns.b#;
$Ic={};
$Jc=q#fcntl#;
$Kc=[];
$Lc=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Mc=bless({$o,$Kc,$q,$Lc,$s,$t},$u);
$Nc=[];
$Oc=q#CORE::fork#;
$Pc=bless({$o,$Nc,$q,$Oc,$s,$t},$u);
$Qc=q#open2#;
$Rc=[];
$Sc=q#CORE::open $_[0], $_[1]#;
$Tc=bless({$o,$Rc,$q,$Sc,$s,$t},$u);
$Uc=q#waitpid#;
$Vc=[];
$Wc=q#CORE::waitpid $_[0], $_[1]#;
$Xc=bless({$o,$Vc,$q,$Wc,$s,$t},$u);
$Yc={$Jc,$Mc,$A9,$Pc,$Qc,$Tc,$Uc,$Xc};
$Zc=q#/io/named_io_fns.b#;
$cd=bless({$d2,$Ic,$K2,$L2,$M2,$L2,$N2,$Yc,$D,$Zc},$W2);
$dd=q#main#;
$ed=q#ni:/io/null#;
$fd={$W3,1};
$gd=q#/io/null#;
$hd={};
$id=[];
$jd=q#+{fd => undef}#;
$kd=bless({$o,$id,$q,$jd,$s,$t},$u);
$ld={$M3,$kd};
$md=q#/io/null_init.b#;
$nd=bless({$d2,$hd,$K2,$L2,$M2,$L2,$N2,$ld,$D,$md},$W2);
$od={};
$pd=[];
$qd=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$rd=bless({$o,$pd,$q,$qd,$s,$t},$u);
$sd=[];
$td=q#shift->fd->read(@_)#;
$ud=bless({$o,$sd,$q,$td,$s,$t},$u);
$vd=[];
$wd=q#shift->fd->write(@_)#;
$xd=bless({$o,$vd,$q,$wd,$s,$t},$u);
$yd={$S8,$rd,$F7,$ud,$hb,$xd};
$zd=q#/io/null_io.b#;
$Ad=bless({$d2,$od,$K2,$L2,$M2,$L2,$N2,$yd,$D,$zd},$W2);
$Bd=[$v7,$nd,$Ad];
$Cd=bless({$d2,$fd,$D,$gd,$D2,$Bd},$k2);
$Dd=q#io/null.c::ctors#;
$Ed=q#ni:/io/null.c#;
$Fd={$k2,1};
$Gd=q#/io/null.c#;
$Hd=[$V7];
$Id=bless({$d2,$Fd,$D,$Gd,$D2,$Hd},$E2);
$Jd=q#ni:/io/null_init.b#;
$Kd=q#ni:/io/null_io.b#;
$Ld=q#ni:/io/object#;
$Md=q#ni:/io/object.c#;
$Nd=q#ni:/io/object_checks.b#;
$Od=q#ni:/io/object_constructors.b#;
$Pd=q#ni:/io/object_memory.b#;
$Qd=q#ni:/io/object_ops.b#;
$Rd=q#ni:/io/object_stream.b#;
$Sd=q#ni:/io/pid#;
$Td={$Y3,1};
$Ud={};
$Vd=q#pid#;
$Wd=[];
$Xd=q#shift->{'pid'}#;
$Yd=bless({$o,$Wd,$q,$Xd,$s,$t},$u);
$Zd=q#status#;
$ce=[];
$de=q#shift->{'status'}#;
$ee=bless({$o,$ce,$q,$de,$s,$t},$u);
$fe={$Vd,$Yd,$Zd,$ee};
$ge=q#/io/pid_readers.b#;
$he=bless({$d2,$Ud,$K2,$L2,$M2,$L2,$N2,$fe,$D,$ge},$W2);
$ie={};
$je=[];
$ke=q#shift->await#;
$le=bless({$o,$je,$q,$ke,$s,$t},$u);
$me=[];
$ne=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$oe=bless({$o,$me,$q,$ne,$s,$t},$u);
$pe={$M3,$oe};
$qe=q#/io/pid_init.b#;
$re=bless({$d2,$ie,$K2,$L2,$M2,$le,$N2,$pe,$D,$qe},$W2);
$se={};
$te=q#await#;
$ue=[];
$ve=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$we=bless({$o,$ue,$q,$ve,$s,$t},$u);
$xe=q#running#;
$ye=[];
$ze=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Ae=bless({$o,$ye,$q,$ze,$s,$t},$u);
$Be={$te,$we,$xe,$Ae};
$Ce=q#/io/pid_wait.b#;
$De=bless({$d2,$se,$K2,$L2,$M2,$L2,$N2,$Be,$D,$Ce},$W2);
$Ee={};
$Fe=[];
$Ge=q#shift->stdout->read(@_)#;
$He=bless({$o,$Fe,$q,$Ge,$s,$t},$u);
$Ie=[];
$Je=q#shift->stdin->write(@_)#;
$Ke=bless({$o,$Ie,$q,$Je,$s,$t},$u);
$Le={$F7,$He,$hb,$Ke};
$Me=q#/io/pid_io.b#;
$Ne=bless({$d2,$Ee,$K2,$L2,$M2,$L2,$N2,$Le,$D,$Me},$W2);
$Oe={};
$Pe=[];
$Qe=q#$_[0]->{external_fds}{$_[1]}#;
$Re=bless({$o,$Pe,$q,$Qe,$s,$t},$u);
$Se=[];
$Te=q#shift->fd(2)#;
$Ue=bless({$o,$Se,$q,$Te,$s,$t},$u);
$Ve=[];
$We=q#shift->fd(0)#;
$Xe=bless({$o,$Ve,$q,$We,$s,$t},$u);
$Ye=[];
$Ze=q#shift->fd(1)#;
$cf=bless({$o,$Ye,$q,$Ze,$s,$t},$u);
$df={$S8,$Re,$W8,$Ue,$c9,$Xe,$g9,$cf};
$ef=q#/io/pid_accessors.b#;
$ff=bless({$d2,$Oe,$K2,$L2,$M2,$L2,$N2,$df,$D,$ef},$W2);
$gf=[$v7,$he,$re,$De,$Ne,$ff];
$hf=bless({$d2,$Td,$D,$I1,$D2,$gf},$m2);
$if=q#io/pid.c::ctors#;
$jf=q#ni:/io/pid.c#;
$kf={$m2,1};
$lf=q#/io/pid.c#;
$mf=[$V7];
$nf=bless({$d2,$kf,$D,$lf,$D2,$mf},$E2);
$of=q#ni:/io/pid_accessors.b#;
$pf=q#ni:/io/pid_init.b#;
$qf=q#ni:/io/pid_io.b#;
$rf=q#ni:/io/pid_readers.b#;
$sf=q#ni:/io/pid_wait.b#;
$tf=q#ni:/io/str#;
$uf={$Z3,1};
$vf=q#/io/str#;
$wf={};
$xf=q#data#;
$yf=[];
$zf=q#shift->{'data'}#;
$Af=bless({$o,$yf,$q,$zf,$s,$t},$u);
$Bf=q#end#;
$Cf=[];
$Df=q#shift->{'end'}#;
$Ef=bless({$o,$Cf,$q,$Df,$s,$t},$u);
$Ff=q#start#;
$Gf=[];
$Hf=q#shift->{'start'}#;
$If=bless({$o,$Gf,$q,$Hf,$s,$t},$u);
$Jf={$xf,$Af,$Bf,$Ef,$Ff,$If};
$Kf=q#/io/str_ro.b#;
$Lf=bless({$d2,$wf,$K2,$L2,$M2,$L2,$N2,$Jf,$D,$Kf},$W2);
$Mf={};
$Nf=[];
$Of=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Pf=bless({$o,$Nf,$q,$Of,$s,$t},$u);
$Qf={$M3,$Pf};
$Rf=q#/io/str_init.b#;
$Sf=bless({$d2,$Mf,$K2,$L2,$M2,$L2,$N2,$Qf,$D,$Rf},$W2);
$Tf={};
$Uf=[];
$Vf=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Wf=bless({$o,$Uf,$q,$Vf,$s,$t},$u);
$Xf=q#remaining#;
$Yf=[];
$Zf=q#my $self = shift; $$self{end} - $$self{start}#;
$cg=bless({$o,$Yf,$q,$Zf,$s,$t},$u);
$dg=[];
$eg=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$fg=bless({$o,$dg,$q,$eg,$s,$t},$u);
$gg={$F7,$Wf,$Xf,$cg,$hb,$fg};
$hg=q#/io/str_io.b#;
$ig=bless({$d2,$Tf,$K2,$L2,$M2,$L2,$N2,$gg,$D,$hg},$W2);
$jg=[$v7,$Lf,$Sf,$ig];
$kg=bless({$d2,$uf,$D,$vf,$D2,$jg},$n2);
$lg=q#io/str.c::ctors#;
$mg=q#ni:/io/str.c#;
$ng={$n2,1};
$og=q#/io/str.c#;
$pg=[$V7];
$qg=bless({$d2,$ng,$D,$og,$D2,$pg},$E2);
$rg=q#ni:/io/str_init.b#;
$sg=q#ni:/io/str_io.b#;
$tg=q#ni:/io/str_ro.b#;
$ug=q#ni:/lib/accessor.b#;
$vg=q#ni:/lib/behavior#;
$wg=q#ni:/lib/behavior.c#;
$xg=q#ni:/lib/branch#;
$yg={$Y2,1};
$zg=q#/lib/branch#;
$Ag={};
$Bg=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Cg=bless({$q,$Bg,$s,$t},$u);
$Dg={$M3,$Cg};
$Eg=q#/lib/branch_init.b#;
$Fg=bless({$d2,$Ag,$K2,$L2,$M2,$L2,$N2,$Dg,$D,$Eg},$W2);
$Gg=[$D4,$j3,$X2,$Fg,$w5];
$Hg=bless({$d2,$yg,$D,$zg,$D2,$Gg},$p2);
$Ig=q#lib/branch.c::ctors#;
$Jg=q#ni:/lib/branch.b#;
$Kg=q#ni:/lib/branch.c#;
$Lg={$p2,1};
$Mg=q#/lib/branch.c#;
$Ng=[$k6];
$Og=bless({$d2,$Lg,$D,$Mg,$D2,$Ng},$E2);
$Pg=q#ni:/lib/branch_init.b#;
$Qg=q#ni:/lib/class_init.b#;
$Rg=q#ni:/lib/dataslice#;
$Sg={$d4,1};
$Tg=q#/lib/dataslice#;
$Ug={};
$Vg=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Wg=bless({$q,$Vg,$s,$t},$u);
$Xg={$M3,$Wg};
$Yg=q#/lib/dataslice_init.b#;
$Zg=bless({$d2,$Ug,$K2,$L2,$M2,$L2,$N2,$Xg,$D,$Yg},$W2);
$ch={};
$dh=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$eh=bless({$q,$dh,$s,$t},$u);
$fh={$R2,$eh};
$gh=q#/lib/dataslice_apply.b#;
$hh=bless({$d2,$ch,$K2,$L2,$M2,$L2,$N2,$fh,$D,$gh},$W2);
$ih=[$D4,$Zg,$hh];
$jh=bless({$d2,$Sg,$D,$Tg,$D2,$ih},$q2);
$kh=q#lib/dataslice.c::ctors#;
$lh=q#ni:/lib/dataslice.c#;
$mh={$q2,1};
$nh=q#/lib/dataslice.c#;
$oh=[$k6];
$ph=bless({$d2,$mh,$D,$nh,$D2,$oh},$E2);
$qh=q#ni:/lib/dataslice_apply.b#;
$rh=q#ni:/lib/dataslice_init.b#;
$sh=q#ni:/lib/definition.b#;
$th=q#ni:/lib/definition_def.b#;
$uh=q#ni:/lib/definition_defdata.b#;
$vh=q#ni:/lib/doc#;
$wh={$F,1};
$xh={};
$yh=q#shift; +{name => shift, doc => []}#;
$zh=bless({$q,$yh,$s,$t},$u);
$Ah={$M3,$zh};
$Bh=q#/lib/doc_init.b#;
$Ch=bless({$d2,$xh,$K2,$L2,$M2,$L2,$N2,$Ah,$D,$Bh},$W2);
$Dh={};
$Eh=q#'ni.doc'#;
$Fh=bless({$q,$Eh,$s,$t},$u);
$Gh={$m3,$Fh};
$Hh=q#/lib/doc_namespace.b#;
$Ih=bless({$d2,$Dh,$K2,$L2,$M2,$L2,$N2,$Gh,$D,$Hh},$W2);
$Jh={};
$Kh=q#AUTOLOAD#;
$Lh=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Mh=bless({$q,$Lh,$s,$t},$u);
$Nh={$Kh,$Mh};
$Oh=q#/lib/doc_define.b#;
$Ph=bless({$d2,$Jh,$K2,$L2,$M2,$L2,$N2,$Nh,$D,$Oh},$W2);
$Qh={};
$Rh=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Sh=bless({$q,$Rh,$s,$t},$u);
$Th=q#tests#;
$Uh=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Vh=bless({$q,$Uh,$s,$t},$u);
$Wh={$n,$Sh,$Th,$Vh};
$Xh=q#/lib/doc_test.b#;
$Yh=bless({$d2,$Qh,$K2,$L2,$M2,$L2,$N2,$Wh,$D,$Xh},$W2);
$Zh=[$s4,$j3,$Ch,$Ih,$Ph,$Yh];
$ci=bless({$d2,$wh,$D,$Y1,$D2,$Zh},$r2);
$di=q#lib/doc.c::ctors#;
$ei=q#ni:/lib/doc.c#;
$fi={$r2,1};
$gi=q#/lib/doc.c#;
$hi=[$f6];
$ii=bless({$d2,$fi,$D,$gi,$D2,$hi},$E2);
$ji=q#ni:/lib/doc_define.b#;
$ki=q#ni:/lib/doc_init.b#;
$li=q#ni:/lib/doc_namespace.b#;
$mi=q#ni:/lib/doc_test.b#;
$ni=q#ni:/lib/documentable.b#;
$oi=q#ni:/lib/fn#;
$pi={$u,1};
$qi=q#/lib/fn#;
$ri={};
$si=q#shift->compile#;
$ti=bless({$q,$si,$s,$t},$u);
$ui=q#compile#;
$vi=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$wi=bless({$q,$vi,$s,$t},$u);
$xi=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$yi=bless({$q,$xi,$s,$t},$u);
$zi={$ui,$wi,$M3,$yi};
$Ai=q#/lib/fn_init.b#;
$Bi=bless({$d2,$ri,$K2,$ti,$M2,$L2,$N2,$zi,$D,$Ai},$W2);
$Ci={};
$Di=[];
$Ei=q#shift->{'annotations'}#;
$Fi=bless({$o,$Di,$q,$Ei,$s,$t},$u);
$Gi=[];
$Hi=q#shift->{'code'}#;
$Ii=bless({$o,$Gi,$q,$Hi,$s,$t},$u);
$Ji=q#fn#;
$Ki=[];
$Li=q#shift->{'fn'}#;
$Mi=bless({$o,$Ki,$q,$Li,$s,$t},$u);
$Ni={$o,$Fi,$q,$Ii,$Ji,$Mi};
$Oi=q#/lib/fn_ro.b#;
$Pi=bless({$d2,$Ci,$K2,$L2,$M2,$L2,$N2,$Ni,$D,$Oi},$W2);
$Qi={};
$Ri=[];
$Si=q#shift->{code}#;
$Ti=bless({$o,$Ri,$q,$Si,$s,$t},$u);
$Ui=[];
$Vi=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Wi=bless({$o,$Ui,$q,$Vi,$s,$t},$u);
$Xi={$Z4,$Ti,$i5,$Wi};
$Yi=q#/lib/fn_ops.b#;
$Zi=bless({$d2,$Qi,$K2,$L2,$M2,$L2,$N2,$Xi,$D,$Yi},$W2);
$cj={};
$dj=q#serialize#;
$ej=[];
$fj=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$gj=bless({$o,$ej,$q,$fj,$s,$t},$u);
$hj={$dj,$gj};
$ij=q#/lib/fn_serialize.b#;
$jj=bless({$d2,$cj,$K2,$L2,$M2,$L2,$N2,$hj,$D,$ij},$W2);
$kj=[$s4,$K5,$Bi,$Pi,$Zi,$jj];
$lj=bless({$d2,$pi,$D,$qi,$D2,$kj},$s2);
$mj=q#lib/fn.c::ctors#;
$nj=q#ni:/lib/fn.c#;
$oj={$s2,1};
$pj=q#/lib/fn.c#;
$qj=[$f6];
$rj=bless({$d2,$oj,$D,$pj,$D2,$qj},$E2);
$sj=q#ni:/lib/fn_init.b#;
$tj=q#ni:/lib/fn_ops.b#;
$uj=q#ni:/lib/fn_ro.b#;
$vj=q#ni:/lib/fn_serialize.b#;
$wj=q#ni:/lib/global_static_test.b#;
$xj={};
$yj=q#now#;
$zj=[];
$Aj=q#ni('ni:/lib/test_value')->new(shift)#;
$Bj=q#($)#;
$Cj=bless({$o,$zj,$q,$Aj,$s,$Bj},$u);
$Dj={$yj,$Cj};
$Ej=q#/lib/global_static_test.b#;
$Fj=bless({$d2,$xj,$K2,$L2,$M2,$L2,$N2,$Dj,$D,$Ej},$W2);
$Gj=q#ni:/lib/image#;
$Hj={$e4,1};
$Ij=q#/lib/image#;
$Jj={};
$Kj=[];
$Lj=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Mj=bless({$o,$Kj,$q,$Lj,$s,$t},$u);
$Nj={$M3,$Mj};
$Oj=q#/lib/image_init.b#;
$Pj=bless({$d2,$Jj,$K2,$L2,$M2,$L2,$N2,$Nj,$D,$Oj},$W2);
$Qj={};
$Rj=q#address#;
$Sj=[];
$Tj=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Uj=bless({$o,$Sj,$q,$Tj,$s,$t},$u);
$Vj=q#allocate_gensym#;
$Wj=[];
$Xj=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Yj=bless({$o,$Wj,$q,$Xj,$s,$t},$u);
$Zj=q#boot_side_effect#;
$ck=[];
$dk=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$ek=bless({$o,$ck,$q,$dk,$s,$t},$u);
$fk=q#circular_arrayref#;
$gk=[];
$hk=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$ik=bless({$o,$gk,$q,$hk,$s,$t},$u);
$jk=q#circular_hashref#;
$kk=[];
$lk=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$mk=bless({$o,$kk,$q,$lk,$s,$t},$u);
$nk=q#circular_links#;
$ok=[];
$pk=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$qk=bless({$o,$ok,$q,$pk,$s,$t},$u);
$rk=q#finalizer#;
$sk=[];
$tk=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$uk=bless({$o,$sk,$q,$tk,$s,$t},$u);
$vk=q#gensym#;
$wk=[];
$xk=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$yk=bless({$o,$wk,$q,$xk,$s,$t},$u);
$zk=q#is_circular#;
$Ak=[];
$Bk=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$Ck=bless({$o,$Ak,$q,$Bk,$s,$t},$u);
$Dk=q#quote#;
$Ek=[];
$Fk=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Gk=bless({$o,$Ek,$q,$Fk,$s,$t},$u);
$Hk=q#reconstruction#;
$Ik=[];
$Jk=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Kk=bless({$o,$Ik,$q,$Jk,$s,$t},$u);
$Lk=q#side_effect#;
$Mk=[];
$Nk=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ok=bless({$o,$Mk,$q,$Nk,$s,$t},$u);
$Pk=[];
$Qk=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Rk=bless({$o,$Pk,$q,$Qk,$s,$t},$u);
$Sk={$Rj,$Uj,$Vj,$Yj,$Zj,$ek,$fk,$ik,$jk,$mk,$nk,$qk,$rk,$uk,$vk,$yk,$zk,$Ck,$Dk,$Gk,$Hk,$Kk,$Lk,$Ok,$hb,$Rk};
$Tk=q#/lib/image_quoting.b#;
$Uk=bless({$d2,$Qj,$K2,$L2,$M2,$L2,$N2,$Sk,$D,$Tk},$W2);
$Vk={};
$Wk=q#quote_code#;
$Xk=[];
$Yk=q#shift->die('cannot quote perl CODE refs', shift)#;
$Zk=bless({$o,$Xk,$q,$Yk,$s,$t},$u);
$cl={$Wk,$Zk};
$dl=q#/lib/no_code_quoting.b#;
$el=bless({$d2,$Vk,$K2,$L2,$M2,$L2,$N2,$cl,$D,$dl},$W2);
$fl={};
$gl=q#quote_array#;
$hl=[];
$il=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$jl=bless({$o,$hl,$q,$il,$s,$t},$u);
$kl=q#quote_hash#;
$ll=[];
$ml=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$nl=bless({$o,$ll,$q,$ml,$s,$t},$u);
$ol=q#quote_scalar#;
$pl=[];
$ql=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl=q#quote_scalar_ref#;
$tl=[];
$ul=q#'\\\\' . shift->quote(${$_[0]})#;
$vl=bless({$o,$tl,$q,$ul,$s,$t},$u);
$wl=q#quote_value#;
$xl=[];
$yl=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$zl=bless({$o,$xl,$q,$yl,$s,$t},$u);
$Al={$gl,$jl,$kl,$nl,$ol,$rl,$sl,$vl,$wl,$zl};
$Bl=q#/lib/quote_values.b#;
$Cl=bless({$d2,$fl,$K2,$L2,$M2,$L2,$N2,$Al,$D,$Bl},$W2);
$Dl={};
$El=q#quote_blessed#;
$Fl=[];
$Gl=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Hl=bless({$o,$Fl,$q,$Gl,$s,$t},$u);
$Il=q#quote_class#;
$Jl=[];
$Kl=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Ll=bless({$o,$Jl,$q,$Kl,$s,$t},$u);
$Ml=q#quote_object#;
$Nl=[];
$Ol=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Pl=bless({$o,$Nl,$q,$Ol,$s,$t},$u);
$Ql={$El,$Hl,$Il,$Ll,$Ml,$Pl};
$Rl=q#/lib/quote_objects.b#;
$Sl=bless({$d2,$Dl,$K2,$L2,$M2,$L2,$N2,$Ql,$D,$Rl},$W2);
$Tl=[$s4,$Pj,$Uk,$el,$Cl,$Sl];
$Ul=bless({$d2,$Hj,$D,$Ij,$D2,$Tl},$t2);
$Vl=q#lib/image.c::ctors#;
$Wl=q#ni:/lib/image.c#;
$Xl={$t2,1};
$Yl=q#/lib/image.c#;
$Zl=[$f6];
$cm=bless({$d2,$Xl,$D,$Yl,$D2,$Zl},$E2);
$dm=q#ni:/lib/image_init.b#;
$em=q#ni:/lib/image_quoting.b#;
$fm=q#ni:/lib/instance.b#;
$gm=q#ni:/lib/instantiable.b#;
$hm=q#ni:/lib/json.b#;
$im={};
$jm=q#json_decode#;
$km=[];
$lm=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$mm=bless({$o,$km,$q,$lm,$s,$Bj},$u);
$nm=q#json_encode#;
$om=[];
$pm=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$qm=bless({$o,$om,$q,$pm,$s,$Bj},$u);
$rm=q#json_escape#;
$sm=[];
$tm=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$um=bless({$o,$sm,$q,$tm,$s,$Bj},$u);
$vm=q#json_unescape#;
$wm=[];
$xm=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$ym=bless({$o,$wm,$q,$xm,$s,$Bj},$u);
$zm=q#json_unescape_one#;
$Am=[];
$Bm=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Cm=bless({$o,$Am,$q,$Bm,$s,$Bj},$u);
$Dm={$jm,$mm,$nm,$qm,$rm,$um,$vm,$ym,$zm,$Cm};
$Em=q#/lib/json.b#;
$Fm=bless({$d2,$im,$K2,$L2,$M2,$L2,$N2,$Dm,$D,$Em},$W2);
$Gm=q#ni#;
$Hm=q#ni:/lib/name_as_string.b#;
$Im=q#ni:/lib/named.b#;
$Jm=q#ni:/lib/named_in_ni.b#;
$Km=q#ni:/lib/namespaced.b#;
$Lm=q#ni:/lib/ni#;
$Mm={$f4,1};
$Nm=q#/lib/ni#;
$Om={};
$Pm=q#extend#;
$Qm=[];
$Rm=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Sm=bless({$o,$Qm,$q,$Rm,$s,$t},$u);
$Tm=q#is_mutable#;
$Um=[];
$Vm=q#$0 ne "-" && -w $0#;
$Wm=bless({$o,$Um,$q,$Vm,$s,$t},$u);
$Xm=q#modify#;
$Ym=[];
$Zm=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$cn=bless({$o,$Ym,$q,$Zm,$s,$t},$u);
$dn={$Pm,$Sm,$Tm,$Wm,$Xm,$cn};
$en=q#/lib/ni_self.b#;
$fn=bless({$d2,$Om,$K2,$L2,$M2,$L2,$N2,$dn,$D,$en},$W2);
$gn={};
$hn=q#exists#;
$in=[];
$jn=q#exists $_[0]->{named}{$_[1]}#;
$kn=bless({$o,$in,$q,$jn,$s,$t},$u);
$ln=q#quoted#;
$mn=[];
$nn=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$on=bless({$o,$mn,$q,$nn,$s,$t},$u);
$pn={$hn,$kn,$ln,$on};
$qn=q#/lib/ni_image.b#;
$rn=bless({$d2,$gn,$K2,$L2,$M2,$L2,$N2,$pn,$D,$qn},$W2);
$sn={};
$tn=q#--internal/+=#;
$un=[];
$vn=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$wn=bless({$o,$un,$q,$vn,$s,$t},$u);
$xn=q#--internal/eval#;
$yn=[];
$zn=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$An=bless({$o,$yn,$q,$zn,$s,$t},$u);
$Bn=q#--internal/image#;
$Cn=[];
$Dn=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$En=bless({$o,$Cn,$q,$Dn,$s,$t},$u);
$Fn=q#--internal/test#;
$Gn=[];
$Hn=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$In=bless({$o,$Gn,$q,$Hn,$s,$t},$u);
$Jn=q#run#;
$Kn=[];
$Ln=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Mn=bless({$o,$Kn,$q,$Ln,$s,$t},$u);
$Nn={$tn,$wn,$xn,$An,$Bn,$En,$Fn,$In,$Jn,$Mn};
$On=q#/lib/ni_main.b#;
$Pn=bless({$d2,$sn,$K2,$L2,$M2,$L2,$N2,$Nn,$D,$On},$W2);
$Qn={};
$Rn=[];
$Sn=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Tn=bless({$o,$Rn,$q,$Sn,$s,$t},$u);
$Un=q#resolver_for#;
$Vn=[];
$Wn=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Xn=bless({$o,$Vn,$q,$Wn,$s,$t},$u);
$Yn={$A3,$Tn,$Un,$Xn};
$Zn=q#/lib/ni_resolver.b#;
$co=bless({$d2,$Qn,$K2,$L2,$M2,$L2,$N2,$Yn,$D,$Zn},$W2);
$do=[$s4,$fn,$rn,$Pn,$co];
$eo=bless({$d2,$Mm,$D,$Nm,$D2,$do},$u2);
$fo=q#lib/ni.c::ctors#;
$go=q#ni:/lib/ni.c#;
$ho={$u2,1};
$io=q#/lib/ni.c#;
$jo=[$f6];
$ko=bless({$d2,$ho,$D,$io,$D2,$jo},$E2);
$lo=q#ni:/lib/ni_image.b#;
$mo=q#ni:/lib/ni_main.b#;
$no=q#ni:/lib/ni_resolver.b#;
$oo=q#ni:/lib/ni_self.b#;
$po=q#ni:/lib/ni_static_util.b#;
$qo={};
$ro=q#abbrev#;
$so=[];
$to=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$uo=bless({$o,$so,$q,$to,$s,$t},$u);
$vo=q#dor#;
$wo=[];
$xo=q#defined $_[0] ? $_[0] : $_[1]#;
$yo=bless({$o,$wo,$q,$xo,$s,$t},$u);
$zo=q#indent#;
$Ao=[];
$Bo=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Co=bless({$o,$Ao,$q,$Bo,$s,$t},$u);
$Do=q#max#;
$Eo=[];
$Fo=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Go=bless({$o,$Eo,$q,$Fo,$s,$t},$u);
$Ho=q#maxstr#;
$Io=[];
$Jo=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Ko=bless({$o,$Io,$q,$Jo,$s,$t},$u);
$Lo=q#mean#;
$Mo=[];
$No=q#sum(@_) / (@_ || 1)#;
$Oo=bless({$o,$Mo,$q,$No,$s,$t},$u);
$Po=q#min#;
$Qo=[];
$Ro=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$So=bless({$o,$Qo,$q,$Ro,$s,$t},$u);
$To=q#minstr#;
$Uo=[];
$Vo=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo=q#sgr#;
$Yo=[];
$Zo=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$cp=bless({$o,$Yo,$q,$Zo,$s,$t},$u);
$dp=q#sr#;
$ep=[];
$fp=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$gp=bless({$o,$ep,$q,$fp,$s,$t},$u);
$hp=q#sum#;
$ip=[];
$jp=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$kp=bless({$o,$ip,$q,$jp,$s,$t},$u);
$lp=q#swap#;
$mp=[];
$np=q#@_[0, 1] = @_[1, 0]#;
$op=bless({$o,$mp,$q,$np,$s,$t},$u);
$pp={$ro,$uo,$vo,$yo,$zo,$Co,$Do,$Go,$Ho,$Ko,$Lo,$Oo,$Po,$So,$To,$Wo,$Xo,$cp,$dp,$gp,$hp,$kp,$lp,$op};
$qp=q#/lib/ni_static_util.b#;
$rp=bless({$d2,$qo,$K2,$L2,$M2,$L2,$N2,$pp,$D,$qp},$W2);
$sp=q#ni:/lib/no_code_quoting.b#;
$tp=q#ni:/lib/perlbranch.b#;
$up=q#ni:/lib/quote_objects.b#;
$vp=q#ni:/lib/quote_simple#;
$wp={$g4,1};
$xp=q#/lib/quote_simple#;
$yp={};
$zp=[];
$Ap=q#+{}#;
$Bp=bless({$o,$zp,$q,$Ap,$s,$t},$u);
$Cp={$M3,$Bp};
$Dp=q#/lib/quote_simple_init.b#;
$Ep=bless({$d2,$yp,$K2,$L2,$M2,$L2,$N2,$Cp,$D,$Dp},$W2);
$Fp={};
$Gp=[];
$Hp=bless({$o,$Gp,$q,0,$s,$t},$u);
$Ip=[];
$Jp=q#shift->quote_value(shift)#;
$Kp=bless({$o,$Ip,$q,$Jp,$s,$t},$u);
$Lp={$zk,$Hp,$Dk,$Kp};
$Mp=q#/lib/quote_simple_quote.b#;
$Np=bless({$d2,$Fp,$K2,$L2,$M2,$L2,$N2,$Lp,$D,$Mp},$W2);
$Op=[$s4,$Ep,$Np,$el,$Cl,$Sl];
$Pp=bless({$d2,$wp,$D,$xp,$D2,$Op},$v2);
$Qp=q#lib/quote_simple.c::ctors#;
$Rp=q#ni:/lib/quote_simple.c#;
$Sp={$v2,1};
$Tp=q#/lib/quote_simple.c#;
$Up=[$f6];
$Vp=bless({$d2,$Sp,$D,$Tp,$D2,$Up},$E2);
$Wp=q#ni:/lib/quote_simple_init.b#;
$Xp=q#ni:/lib/quote_simple_quote.b#;
$Yp=q#ni:/lib/quote_values.b#;
$Zp=q#ni:/lib/ref_eq.b#;
$cq=q#ni:/lib/resolver.b#;
$dq=q#ni:/lib/slice#;
$eq={$W2,1};
$fq=q#/lib/slice#;
$gq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$hq=bless({$q,$gq,$s,$t},$u);
$iq=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$jq=bless({$q,$iq,$s,$t},$u);
$kq=q#lib/slice::apply#;
$lq=q#lib/slice::apply_unsafe#;
$mq={};
$nq=q#apply_unsafe#;
$oq={$R2,$hq,$nq,$jq};
$pq=q#/lib/slice.b#;
$qq=bless({$d2,$mq,$N2,$oq,$D,$pq},$W2);
$rq={};
$sq=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$tq=bless({$q,$sq,$s,$t},$u);
$uq={$M3,$tq};
$vq=q#/lib/slice_init.b#;
$wq=bless({$d2,$rq,$N2,$uq,$D,$vq},$W2);
$xq={};
$yq=[];
$zq=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Aq=bless({$o,$yq,$q,$zq,$s,$t},$u);
$Bq={$dj,$Aq};
$Cq=q#/lib/slice_serialize.b#;
$Dq=bless({$d2,$xq,$K2,$L2,$M2,$L2,$N2,$Bq,$D,$Cq},$W2);
$Eq=[$D4,$j3,$qq,$wq,$Dq];
$Fq=bless({$d2,$eq,$D,$fq,$D2,$Eq},$w2);
$Gq=q#lib/slice.c::ctors#;
$Hq=q#ni:/lib/slice.b#;
$Iq=q#ni:/lib/slice.c#;
$Jq={$w2,1};
$Kq=q#/lib/slice.c#;
$Lq=[$k6];
$Mq=bless({$d2,$Jq,$D,$Kq,$D2,$Lq},$E2);
$Nq=q#ni:/lib/slice_init.b#;
$Oq=q#ni:/lib/slice_serialize.b#;
$Pq=q#ni:/lib/static_fn.b#;
$Qq={};
$Rq=[];
$Sq=q#ni('ni:/lib/fn')->new(@_)#;
$Tq=bless({$o,$Rq,$q,$Sq,$s,$Bj},$u);
$Uq=q#fp#;
$Vq=[];
$Wq=q#($$)#;
$Xq=bless({$o,$Vq,$q,$Sq,$s,$Wq},$u);
$Yq={$Ji,$Tq,$Uq,$Xq};
$Zq=q#/lib/static_fn.b#;
$cr=bless({$d2,$Qq,$K2,$L2,$M2,$L2,$N2,$Yq,$D,$Zq},$W2);
$dr=q#ni:/lib/subclass.b#;
$er=q#ni:/lib/tag#;
$fr={$k3,1};
$gr=q#/lib/tag#;
$hr={};
$ir=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$jr=bless({$q,$ir,$s,$t},$u);
$kr={$R2,$jr};
$lr=q#/lib/tag.b#;
$mr=bless({$d2,$hr,$K2,$L2,$M2,$L2,$N2,$kr,$D,$lr},$W2);
$nr={};
$or=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$pr=bless({$q,$or,$s,$t},$u);
$qr={$M3,$pr};
$rr=q#/lib/tag_init.b#;
$sr=bless({$d2,$nr,$K2,$L2,$M2,$L2,$N2,$qr,$D,$rr},$W2);
$tr=[$D4,$j3,$mr,$sr];
$ur=bless({$d2,$fr,$D,$gr,$D2,$tr},$x2);
$vr=q#lib/tag.c::ctors#;
$wr=q#ni:/lib/tag.b#;
$xr=q#ni:/lib/tag.c#;
$yr={$x2,1};
$zr=q#/lib/tag.c#;
$Ar=[$k6];
$Br=bless({$d2,$yr,$D,$zr,$D2,$Ar},$E2);
$Cr=q#ni:/lib/tag_init.b#;
$Dr=q#ni:/lib/test_value#;
$Er={$h4,1};
$Fr=q#/lib/test_value#;
$Gr={};
$Hr=[];
$Ir=q#\\$_[1]#;
$Jr=bless({$o,$Hr,$q,$Ir,$s,$t},$u);
$Kr={$M3,$Jr};
$Lr=q#/lib/test_value_init.b#;
$Mr=bless({$d2,$Gr,$K2,$L2,$M2,$L2,$N2,$Kr,$D,$Lr},$W2);
$Nr={};
$Or=q#(==#;
$Pr=[];
$Qr=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Rr=bless({$o,$Pr,$q,$Qr,$s,$t},$u);
$Sr=q#diff#;
$Tr=[];
$Ur=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Vr=bless({$o,$Tr,$q,$Ur,$s,$t},$u);
$Wr={$Or,$Rr,$Sr,$Vr};
$Xr=q#/lib/test_value_eq.b#;
$Yr=bless({$d2,$Nr,$K2,$L2,$M2,$L2,$N2,$Wr,$D,$Xr},$W2);
$Zr={};
$cs=[];
$ds=q#ni::json_encode ${$_[0]}#;
$es=bless({$o,$cs,$q,$ds,$s,$t},$u);
$fs={$Z4,$es};
$gs=q#/lib/test_value_str.b#;
$hs=bless({$d2,$Zr,$K2,$L2,$M2,$L2,$N2,$fs,$D,$gs},$W2);
$is=[$s4,$Mr,$Yr,$hs];
$js=bless({$d2,$Er,$D,$Fr,$D2,$is},$y2);
$ks=q#lib/test_value.c::ctors#;
$ls=q#ni:/lib/test_value.c#;
$ms={$y2,1};
$ns=q#/lib/test_value.c#;
$os=[$f6];
$ps=bless({$d2,$ms,$D,$ns,$D2,$os},$E2);
$qs=q#ni:/lib/test_value_eq.b#;
$rs=q#ni:/lib/test_value_init.b#;
$ss=q#ni:/lib/test_value_str.b#;
$ts=q#ni:/metaclass#;
$us={$E2,1};
$vs=q#/metaclass#;
$ws=[$H3,$K5,$R3,$z5];
$xs=bless({$d2,$us,$D,$vs,$D2,$ws},$z2);
$ys=q#metaclass.c::ctors#;
$zs=q#ni:/metaclass.c#;
$As={$z2,1};
$Bs=q#/metaclass.c#;
$Cs=[$T5];
$Ds=bless({$d2,$As,$D,$Bs,$D2,$Cs},$E2);
$Es=q#ni:/module#;
$Fs=q#ni:/module.c#;
$Gs=q#ni:/object#;
$Hs=q#ni:/object.c#;
$Is=q#ni:main#;
$Js={$dd,1};
$Ks=[$cr,$Fj,$cd];
$Ls=bless({$d2,$Js,$D,$dd,$D2,$Ks},$F2);
$Ms=q#module::ctors#;
$Ns=q#ni:ni#;
$Os={$Gm,1};
$Ps={$Gm,1};
$Qs=q#json_escapes#;
$Rs=q##;
$Ss=q#b#;
$Ts=q#	#;
$Us=q#t#;
$Vs=q#
#;
$Ws=q#n#;
$Xs=q##;
$Ys=q#"#;
$Zs=q#/#;
$ct=q#\\#;
$dt={$Rs,$Ss,$Ts,$Us,$Vs,$Ws,$Xs,$ec,$Ys,$Ys,$Zs,$Zs,$ct,$ct};
$et=q#json_unescapes#;
$ft={$Ys,$Ys,$Zs,$Zs,$ct,$ct,$Ss,$Rs,$Ws,$Vs,$ec,$Xs,$Us,$Ts};
$gt={$Qs,$dt,$et,$ft};
$ht=q#/lib/json_data.b#;
$it=bless({$d2,$Ps,$xf,$gt,$D,$ht},$d4);
$jt=q#lib/dataslice::ctors#;
$kt=[$it,$Fm,$rp];
$lt=bless({$d2,$Os,$D,$Gm,$D2,$kt},$F2);
$mt={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$Z1,$c2,$T5,$V5,$o6,$p6,$N7,$P7,$X7,$Y7,$D7,$Z7,$L7,$c8,$M9,$O9,$S9,$T9,$u9,$U9,$K9,$V9,$s8,$W9,$m9,$X9,$M8,$Y9,$l8,$Z9,$pb,$rb,$vb,$wb,$Pa,$xb,$cb,$yb,$ra,$zb,$nb,$Ab,$ka,$Bb,$za,$Cb,$wc,$yc,$Cc,$Dc,$Tb,$Ec,$cc,$Fc,$uc,$Gc,$Lb,$Hc,$cd,$ed,$Cd,$Ed,$Id,$Jd,$nd,$Kd,$Ad,$Ld,$v7,$Md,$V7,$Nd,$d7,$Od,$l7,$Pd,$t7,$Qd,$z6,$Rd,$H6,$Sd,$hf,$jf,$nf,$of,$ff,$pf,$re,$qf,$Ne,$rf,$he,$sf,$De,$tf,$kg,$mg,$qg,$rg,$Sf,$sg,$ig,$tg,$Lf,$ug,$X4,$vg,$D4,$wg,$k6,$xg,$Hg,$Jg,$X2,$Kg,$Og,$Pg,$Fg,$Qg,$R3,$Rg,$jh,$lh,$ph,$qh,$hh,$rh,$Zg,$sh,$w5,$th,$N4,$uh,$u5,$vh,$ci,$ei,$ii,$ji,$Ph,$ki,$Ch,$li,$Ih,$mi,$Yh,$ni,$B4,$oi,$lj,$nj,$rj,$sj,$Bi,$tj,$Zi,$uj,$Pi,$vj,$jj,$wj,$Fj,$Gj,$Ul,$Wl,$cm,$dm,$Pj,$em,$Uk,$fm,$q4,$gm,$K5,$hm,$Fm,$Hm,$g5,$Im,$j3,$Jm,$r3,$Km,$y3,$Lm,$eo,$go,$ko,$lo,$rn,$mo,$Pn,$no,$co,$oo,$fn,$po,$rp,$sp,$el,$tp,$H3,$up,$Sl,$vp,$Pp,$Rp,$Vp,$Wp,$Ep,$Xp,$Np,$Yp,$Cl,$Zp,$n5,$cq,$F3,$dq,$Fq,$Hq,$qq,$Iq,$Mq,$Nq,$wq,$Oq,$Dq,$Pq,$cr,$dr,$R5,$er,$ur,$wr,$mr,$xr,$Br,$Cr,$sr,$Dr,$js,$ls,$ps,$qs,$Yr,$rs,$Mr,$ss,$hs,$ts,$xs,$zs,$Ds,$Es,$z5,$Fs,$m6,$Gs,$s4,$Hs,$f6,$Is,$Ls,$Ns,$lt};
$nt=q#resolvers#;
$ot=[];
$pt=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$qt=bless({$o,$ot,$q,$pt,$s,$t},$u);
$rt=q#file#;
$st=[];
$tt=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$ut=bless({$o,$st,$q,$tt,$s,$t},$u);
$vt=q#null#;
$wt=[];
$xt=q#ni('ni:/io/null')->new#;
$yt=bless({$o,$wt,$q,$xt,$s,$t},$u);
$zt=q#sh#;
$At=[];
$Bt=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Ct=bless({$o,$At,$q,$Bt,$s,$t},$u);
$Dt=q#str#;
$Et=[];
$Ft=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Gt=bless({$o,$Et,$q,$Ft,$s,$t},$u);
$Ht={$S8,$qt,$rt,$ut,$vt,$yt,$zt,$Ct,$Dt,$Gt};
$It=bless({$c,$mt,$nt,$Ht},$f4);
$Jt=q#lib/ni::ctors#;
*$lq=\&$jq;
*$kq=\&$hq;
$X2->apply_unsafe($e2);
$X2->apply_unsafe($f2);
$X2->apply_unsafe($g2);
$X2->apply_unsafe($h2);
$X2->apply_unsafe($i2);
$X2->apply_unsafe($j2);
$X2->apply_unsafe($k2);
$X2->apply_unsafe($l2);
$X2->apply_unsafe($m2);
$X2->apply_unsafe($n2);
$X2->apply_unsafe($o2);
$X2->apply_unsafe($Y2);
$X2->apply_unsafe($p2);
$X2->apply_unsafe($q2);
$X2->apply_unsafe($r2);
$X2->apply_unsafe($s2);
$X2->apply_unsafe($t2);
$X2->apply_unsafe($u2);
$X2->apply_unsafe($v2);
$X2->apply_unsafe($w2);
$X2->apply_unsafe($x2);
$X2->apply_unsafe($y2);
$X2->apply_unsafe($E2);
$X2->apply_unsafe($z2);
$X2->apply_unsafe($F2);
$X2->apply_unsafe($A2);
$X2->apply_unsafe($B2);
$j3->apply_unsafe($e2);
$j3->apply_unsafe($f2);
$j3->apply_unsafe($g2);
$j3->apply_unsafe($h2);
$j3->apply_unsafe($i2);
$j3->apply_unsafe($j2);
$j3->apply_unsafe($k2);
$j3->apply_unsafe($l2);
$j3->apply_unsafe($m2);
$j3->apply_unsafe($n2);
$j3->apply_unsafe($o2);
$j3->apply_unsafe($Y2);
$j3->apply_unsafe($p2);
$j3->apply_unsafe($q2);
$j3->apply_unsafe($F);
$j3->apply_unsafe($r2);
$j3->apply_unsafe($s2);
$j3->apply_unsafe($t2);
$j3->apply_unsafe($u2);
$j3->apply_unsafe($v2);
$j3->apply_unsafe($W2);
$j3->apply_unsafe($w2);
$j3->apply_unsafe($k3);
$j3->apply_unsafe($x2);
$j3->apply_unsafe($y2);
$j3->apply_unsafe($E2);
$j3->apply_unsafe($z2);
$j3->apply_unsafe($F2);
$j3->apply_unsafe($A2);
$j3->apply_unsafe($B2);
$r3->apply_unsafe($e2);
$r3->apply_unsafe($f2);
$r3->apply_unsafe($g2);
$r3->apply_unsafe($h2);
$r3->apply_unsafe($i2);
$r3->apply_unsafe($j2);
$r3->apply_unsafe($k2);
$r3->apply_unsafe($l2);
$r3->apply_unsafe($m2);
$r3->apply_unsafe($n2);
$r3->apply_unsafe($o2);
$r3->apply_unsafe($Y2);
$r3->apply_unsafe($p2);
$r3->apply_unsafe($q2);
$r3->apply_unsafe($r2);
$r3->apply_unsafe($s2);
$r3->apply_unsafe($t2);
$r3->apply_unsafe($u2);
$r3->apply_unsafe($v2);
$r3->apply_unsafe($W2);
$r3->apply_unsafe($w2);
$r3->apply_unsafe($k3);
$r3->apply_unsafe($x2);
$r3->apply_unsafe($y2);
$r3->apply_unsafe($E2);
$r3->apply_unsafe($z2);
$r3->apply_unsafe($F2);
$r3->apply_unsafe($A2);
$r3->apply_unsafe($B2);
$y3->apply_unsafe($e2);
$y3->apply_unsafe($f2);
$y3->apply_unsafe($g2);
$y3->apply_unsafe($h2);
$y3->apply_unsafe($i2);
$y3->apply_unsafe($j2);
$y3->apply_unsafe($k2);
$y3->apply_unsafe($l2);
$y3->apply_unsafe($m2);
$y3->apply_unsafe($n2);
$y3->apply_unsafe($o2);
$y3->apply_unsafe($Y2);
$y3->apply_unsafe($p2);
$y3->apply_unsafe($q2);
$y3->apply_unsafe($r2);
$y3->apply_unsafe($s2);
$y3->apply_unsafe($t2);
$y3->apply_unsafe($u2);
$y3->apply_unsafe($v2);
$y3->apply_unsafe($W2);
$y3->apply_unsafe($w2);
$y3->apply_unsafe($k3);
$y3->apply_unsafe($x2);
$y3->apply_unsafe($y2);
$y3->apply_unsafe($E2);
$y3->apply_unsafe($z2);
$y3->apply_unsafe($F2);
$y3->apply_unsafe($A2);
$y3->apply_unsafe($B2);
$F3->apply_unsafe($e2);
$F3->apply_unsafe($f2);
$F3->apply_unsafe($g2);
$F3->apply_unsafe($h2);
$F3->apply_unsafe($i2);
$F3->apply_unsafe($j2);
$F3->apply_unsafe($k2);
$F3->apply_unsafe($l2);
$F3->apply_unsafe($m2);
$F3->apply_unsafe($n2);
$F3->apply_unsafe($o2);
$F3->apply_unsafe($Y2);
$F3->apply_unsafe($p2);
$F3->apply_unsafe($q2);
$F3->apply_unsafe($r2);
$F3->apply_unsafe($s2);
$F3->apply_unsafe($t2);
$F3->apply_unsafe($u2);
$F3->apply_unsafe($v2);
$F3->apply_unsafe($w2);
$F3->apply_unsafe($k3);
$F3->apply_unsafe($x2);
$F3->apply_unsafe($y2);
$F3->apply_unsafe($E2);
$F3->apply_unsafe($z2);
$F3->apply_unsafe($F2);
$F3->apply_unsafe($A2);
$F3->apply_unsafe($B2);
$R3->apply_unsafe($e2);
$R3->apply_unsafe($f2);
$R3->apply_unsafe($g2);
$R3->apply_unsafe($h2);
$R3->apply_unsafe($i2);
$R3->apply_unsafe($j2);
$R3->apply_unsafe($k2);
$R3->apply_unsafe($l2);
$R3->apply_unsafe($m2);
$R3->apply_unsafe($n2);
$R3->apply_unsafe($o2);
$R3->apply_unsafe($p2);
$R3->apply_unsafe($q2);
$R3->apply_unsafe($r2);
$R3->apply_unsafe($s2);
$R3->apply_unsafe($t2);
$R3->apply_unsafe($u2);
$R3->apply_unsafe($v2);
$R3->apply_unsafe($w2);
$R3->apply_unsafe($x2);
$R3->apply_unsafe($y2);
$R3->apply_unsafe($E2);
$R3->apply_unsafe($z2);
$R3->apply_unsafe($F2);
$R3->apply_unsafe($A2);
$R3->apply_unsafe($B2);
$q4->apply_unsafe($e2);
$q4->apply_unsafe($f2);
$q4->apply_unsafe($S3);
$q4->apply_unsafe($g2);
$q4->apply_unsafe($T3);
$q4->apply_unsafe($h2);
$q4->apply_unsafe($U3);
$q4->apply_unsafe($i2);
$q4->apply_unsafe($V3);
$q4->apply_unsafe($j2);
$q4->apply_unsafe($W3);
$q4->apply_unsafe($k2);
$q4->apply_unsafe($X3);
$q4->apply_unsafe($l2);
$q4->apply_unsafe($Y3);
$q4->apply_unsafe($m2);
$q4->apply_unsafe($Z3);
$q4->apply_unsafe($n2);
$q4->apply_unsafe($c4);
$q4->apply_unsafe($o2);
$q4->apply_unsafe($Y2);
$q4->apply_unsafe($p2);
$q4->apply_unsafe($d4);
$q4->apply_unsafe($q2);
$q4->apply_unsafe($F);
$q4->apply_unsafe($r2);
$q4->apply_unsafe($u);
$q4->apply_unsafe($s2);
$q4->apply_unsafe($e4);
$q4->apply_unsafe($t2);
$q4->apply_unsafe($f4);
$q4->apply_unsafe($u2);
$q4->apply_unsafe($g4);
$q4->apply_unsafe($v2);
$q4->apply_unsafe($W2);
$q4->apply_unsafe($w2);
$q4->apply_unsafe($k3);
$q4->apply_unsafe($x2);
$q4->apply_unsafe($h4);
$q4->apply_unsafe($y2);
$q4->apply_unsafe($E2);
$q4->apply_unsafe($z2);
$q4->apply_unsafe($F2);
$q4->apply_unsafe($A2);
$q4->apply_unsafe($i4);
$q4->apply_unsafe($B2);
$B4->apply_unsafe($e2);
$B4->apply_unsafe($f2);
$B4->apply_unsafe($g2);
$B4->apply_unsafe($h2);
$B4->apply_unsafe($i2);
$B4->apply_unsafe($j2);
$B4->apply_unsafe($k2);
$B4->apply_unsafe($l2);
$B4->apply_unsafe($m2);
$B4->apply_unsafe($n2);
$B4->apply_unsafe($c4);
$B4->apply_unsafe($o2);
$B4->apply_unsafe($Y2);
$B4->apply_unsafe($p2);
$B4->apply_unsafe($d4);
$B4->apply_unsafe($q2);
$B4->apply_unsafe($r2);
$B4->apply_unsafe($s2);
$B4->apply_unsafe($t2);
$B4->apply_unsafe($u2);
$B4->apply_unsafe($v2);
$B4->apply_unsafe($W2);
$B4->apply_unsafe($w2);
$B4->apply_unsafe($k3);
$B4->apply_unsafe($x2);
$B4->apply_unsafe($y2);
$B4->apply_unsafe($E2);
$B4->apply_unsafe($z2);
$B4->apply_unsafe($F2);
$B4->apply_unsafe($A2);
$B4->apply_unsafe($B2);
$N4->apply_unsafe($e2);
$N4->apply_unsafe($f2);
$N4->apply_unsafe($g2);
$N4->apply_unsafe($h2);
$N4->apply_unsafe($i2);
$N4->apply_unsafe($j2);
$N4->apply_unsafe($k2);
$N4->apply_unsafe($l2);
$N4->apply_unsafe($m2);
$N4->apply_unsafe($n2);
$N4->apply_unsafe($o2);
$N4->apply_unsafe($Y2);
$N4->apply_unsafe($p2);
$N4->apply_unsafe($q2);
$N4->apply_unsafe($r2);
$N4->apply_unsafe($s2);
$N4->apply_unsafe($t2);
$N4->apply_unsafe($u2);
$N4->apply_unsafe($v2);
$N4->apply_unsafe($w2);
$N4->apply_unsafe($x2);
$N4->apply_unsafe($y2);
$N4->apply_unsafe($E2);
$N4->apply_unsafe($z2);
$N4->apply_unsafe($F2);
$N4->apply_unsafe($A2);
$N4->apply_unsafe($B2);
$X4->apply_unsafe($e2);
$X4->apply_unsafe($f2);
$X4->apply_unsafe($g2);
$X4->apply_unsafe($h2);
$X4->apply_unsafe($i2);
$X4->apply_unsafe($j2);
$X4->apply_unsafe($k2);
$X4->apply_unsafe($l2);
$X4->apply_unsafe($m2);
$X4->apply_unsafe($n2);
$X4->apply_unsafe($o2);
$X4->apply_unsafe($Y2);
$X4->apply_unsafe($p2);
$X4->apply_unsafe($q2);
$X4->apply_unsafe($r2);
$X4->apply_unsafe($s2);
$X4->apply_unsafe($t2);
$X4->apply_unsafe($u2);
$X4->apply_unsafe($v2);
$X4->apply_unsafe($w2);
$X4->apply_unsafe($x2);
$X4->apply_unsafe($y2);
$X4->apply_unsafe($E2);
$X4->apply_unsafe($z2);
$X4->apply_unsafe($F2);
$X4->apply_unsafe($A2);
$X4->apply_unsafe($B2);
$g5->apply_unsafe($e2);
$g5->apply_unsafe($f2);
$g5->apply_unsafe($g2);
$g5->apply_unsafe($h2);
$g5->apply_unsafe($i2);
$g5->apply_unsafe($j2);
$g5->apply_unsafe($k2);
$g5->apply_unsafe($l2);
$g5->apply_unsafe($m2);
$g5->apply_unsafe($n2);
$g5->apply_unsafe($o2);
$g5->apply_unsafe($Y2);
$g5->apply_unsafe($p2);
$g5->apply_unsafe($q2);
$g5->apply_unsafe($r2);
$g5->apply_unsafe($s2);
$g5->apply_unsafe($t2);
$g5->apply_unsafe($u2);
$g5->apply_unsafe($v2);
$g5->apply_unsafe($w2);
$g5->apply_unsafe($x2);
$g5->apply_unsafe($y2);
$g5->apply_unsafe($E2);
$g5->apply_unsafe($z2);
$g5->apply_unsafe($F2);
$g5->apply_unsafe($A2);
$g5->apply_unsafe($B2);
$n5->apply_unsafe($e2);
$n5->apply_unsafe($f2);
$n5->apply_unsafe($g2);
$n5->apply_unsafe($h2);
$n5->apply_unsafe($i2);
$n5->apply_unsafe($j2);
$n5->apply_unsafe($k2);
$n5->apply_unsafe($l2);
$n5->apply_unsafe($m2);
$n5->apply_unsafe($n2);
$n5->apply_unsafe($o2);
$n5->apply_unsafe($Y2);
$n5->apply_unsafe($p2);
$n5->apply_unsafe($q2);
$n5->apply_unsafe($r2);
$n5->apply_unsafe($s2);
$n5->apply_unsafe($t2);
$n5->apply_unsafe($u2);
$n5->apply_unsafe($v2);
$n5->apply_unsafe($w2);
$n5->apply_unsafe($x2);
$n5->apply_unsafe($y2);
$n5->apply_unsafe($E2);
$n5->apply_unsafe($z2);
$n5->apply_unsafe($F2);
$n5->apply_unsafe($A2);
$n5->apply_unsafe($B2);
$u5->apply_unsafe($e2);
$u5->apply_unsafe($f2);
$u5->apply_unsafe($g2);
$u5->apply_unsafe($h2);
$u5->apply_unsafe($i2);
$u5->apply_unsafe($j2);
$u5->apply_unsafe($k2);
$u5->apply_unsafe($l2);
$u5->apply_unsafe($m2);
$u5->apply_unsafe($n2);
$u5->apply_unsafe($o2);
$u5->apply_unsafe($Y2);
$u5->apply_unsafe($p2);
$u5->apply_unsafe($q2);
$u5->apply_unsafe($r2);
$u5->apply_unsafe($s2);
$u5->apply_unsafe($t2);
$u5->apply_unsafe($u2);
$u5->apply_unsafe($v2);
$u5->apply_unsafe($w2);
$u5->apply_unsafe($x2);
$u5->apply_unsafe($y2);
$u5->apply_unsafe($E2);
$u5->apply_unsafe($z2);
$u5->apply_unsafe($F2);
$u5->apply_unsafe($A2);
$u5->apply_unsafe($B2);
$K5->apply_unsafe($e2);
$K5->apply_unsafe($f2);
$K5->apply_unsafe($g2);
$K5->apply_unsafe($h2);
$K5->apply_unsafe($i2);
$K5->apply_unsafe($j2);
$K5->apply_unsafe($k2);
$K5->apply_unsafe($l2);
$K5->apply_unsafe($m2);
$K5->apply_unsafe($n2);
$K5->apply_unsafe($o2);
$K5->apply_unsafe($p2);
$K5->apply_unsafe($q2);
$K5->apply_unsafe($r2);
$K5->apply_unsafe($u);
$K5->apply_unsafe($s2);
$K5->apply_unsafe($t2);
$K5->apply_unsafe($u2);
$K5->apply_unsafe($v2);
$K5->apply_unsafe($W2);
$K5->apply_unsafe($w2);
$K5->apply_unsafe($k3);
$K5->apply_unsafe($x2);
$K5->apply_unsafe($y2);
$K5->apply_unsafe($E2);
$K5->apply_unsafe($z2);
$K5->apply_unsafe($A2);
$K5->apply_unsafe($B2);
$R5->apply_unsafe($e2);
$R5->apply_unsafe($f2);
$R5->apply_unsafe($g2);
$R5->apply_unsafe($h2);
$R5->apply_unsafe($i2);
$R5->apply_unsafe($j2);
$R5->apply_unsafe($k2);
$R5->apply_unsafe($l2);
$R5->apply_unsafe($m2);
$R5->apply_unsafe($n2);
$R5->apply_unsafe($o2);
$R5->apply_unsafe($p2);
$R5->apply_unsafe($q2);
$R5->apply_unsafe($r2);
$R5->apply_unsafe($s2);
$R5->apply_unsafe($t2);
$R5->apply_unsafe($u2);
$R5->apply_unsafe($v2);
$R5->apply_unsafe($w2);
$R5->apply_unsafe($x2);
$R5->apply_unsafe($y2);
$R5->apply_unsafe($z2);
$R5->apply_unsafe($A2);
$R5->apply_unsafe($B2);
$z6->apply_unsafe($S3);
$z6->apply_unsafe($T3);
$z6->apply_unsafe($U3);
$z6->apply_unsafe($V3);
$z6->apply_unsafe($W3);
$z6->apply_unsafe($X3);
$z6->apply_unsafe($Y3);
$z6->apply_unsafe($Z3);
$H6->apply_unsafe($S3);
$H6->apply_unsafe($T3);
$H6->apply_unsafe($U3);
$H6->apply_unsafe($V3);
$H6->apply_unsafe($W3);
$H6->apply_unsafe($X3);
$H6->apply_unsafe($Y3);
$H6->apply_unsafe($Z3);
$d7->apply_unsafe($S3);
$d7->apply_unsafe($T3);
$d7->apply_unsafe($U3);
$d7->apply_unsafe($V3);
$d7->apply_unsafe($W3);
$d7->apply_unsafe($X3);
$d7->apply_unsafe($Y3);
$d7->apply_unsafe($Z3);
$l7->apply_unsafe($S3);
$l7->apply_unsafe($T3);
$l7->apply_unsafe($U3);
$l7->apply_unsafe($V3);
$l7->apply_unsafe($W3);
$l7->apply_unsafe($X3);
$l7->apply_unsafe($Y3);
$l7->apply_unsafe($Z3);
$t7->apply_unsafe($S3);
$t7->apply_unsafe($T3);
$t7->apply_unsafe($U3);
$t7->apply_unsafe($V3);
$t7->apply_unsafe($W3);
$t7->apply_unsafe($X3);
$t7->apply_unsafe($Y3);
$t7->apply_unsafe($Z3);
$D7->apply_unsafe($S3);
$L7->apply_unsafe($S3);
$l8->apply_unsafe($T3);
$s8->apply_unsafe($T3);
$M8->apply_unsafe($T3);
$m9->apply_unsafe($T3);
$u9->apply_unsafe($T3);
$K9->apply_unsafe($T3);
$ka->apply_unsafe($U3);
$ra->apply_unsafe($U3);
$za->apply_unsafe($U3);
$Pa->apply_unsafe($U3);
$cb->apply_unsafe($U3);
$nb->apply_unsafe($U3);
$Lb->apply_unsafe($V3);
$Tb->apply_unsafe($V3);
$cc->apply_unsafe($V3);
$uc->apply_unsafe($V3);
$cd->apply_unsafe($dd);
$nd->apply_unsafe($W3);
$Ad->apply_unsafe($W3);
$he->apply_unsafe($Y3);
$re->apply_unsafe($Y3);
$De->apply_unsafe($Y3);
$Ne->apply_unsafe($Y3);
$ff->apply_unsafe($Y3);
$Lf->apply_unsafe($Z3);
$Sf->apply_unsafe($Z3);
$ig->apply_unsafe($Z3);
$Fg->apply_unsafe($Y2);
$Zg->apply_unsafe($d4);
$hh->apply_unsafe($d4);
$Ch->apply_unsafe($F);
$Ih->apply_unsafe($F);
$Ph->apply_unsafe($F);
$Yh->apply_unsafe($F);
$Bi->apply_unsafe($u);
$Pi->apply_unsafe($u);
$Zi->apply_unsafe($u);
$jj->apply_unsafe($u);
$Fj->apply_unsafe($dd);
$Pj->apply_unsafe($e4);
$Uk->apply_unsafe($e4);
$el->apply_unsafe($e4);
$el->apply_unsafe($g4);
$Cl->apply_unsafe($e4);
$Cl->apply_unsafe($g4);
$Sl->apply_unsafe($e4);
$Sl->apply_unsafe($g4);
$Fm->apply_unsafe($Gm);
$fn->apply_unsafe($f4);
$rn->apply_unsafe($f4);
$Pn->apply_unsafe($f4);
$co->apply_unsafe($f4);
$rp->apply_unsafe($Gm);
$Ep->apply_unsafe($g4);
$Np->apply_unsafe($g4);
$qq->apply_unsafe($W2);
$wq->apply_unsafe($W2);
$Dq->apply_unsafe($W2);
$cr->apply_unsafe($dd);
$mr->apply_unsafe($k3);
$sr->apply_unsafe($k3);
$Mr->apply_unsafe($h4);
$Yr->apply_unsafe($h4);
$hs->apply_unsafe($h4);
$ni::self=$It;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$w;
&$_($Z1)for@$H;
&$_($Q2)for@$w;
&$_($T2)for@$w;
&$_($X2)for@$Z2;
&$_($e3)for@$w;
&$_($g3)for@$w;
&$_($j3)for@$Z2;
&$_($o3)for@$w;
&$_($r3)for@$Z2;
&$_($v3)for@$w;
&$_($y3)for@$Z2;
&$_($C3)for@$w;
&$_($F3)for@$Z2;
&$_($H3)for@$I3;
&$_($L3)for@$w;
&$_($O3)for@$w;
&$_($R3)for@$Z2;
&$_($n4)for@$w;
&$_($q4)for@$Z2;
&$_($s4)for@$t4;
&$_($y4)for@$w;
&$_($B4)for@$Z2;
&$_($D4)for@$E4;
&$_($K4)for@$w;
&$_($N4)for@$Z2;
&$_($R4)for@$w;
&$_($U4)for@$w;
&$_($X4)for@$Z2;
&$_($d5)for@$w;
&$_($g5)for@$Z2;
&$_($k5)for@$w;
&$_($n5)for@$Z2;
&$_($r5)for@$w;
&$_($u5)for@$Z2;
&$_($w5)for@$x5;
&$_($z5)for@$A5;
&$_($E5)for@$w;
&$_($H5)for@$w;
&$_($K5)for@$Z2;
&$_($O5)for@$w;
&$_($R5)for@$Z2;
&$_($T5)for@$U5;
&$_($f6)for@$g6;
&$_($k6)for@$g6;
&$_($m6)for@$g6;
&$_($o6)for@$g6;
&$_($w6)for@$w;
&$_($z6)for@$Z2;
&$_($E6)for@$w;
&$_($H6)for@$Z2;
&$_($M6)for@$w;
&$_($Q6)for@$w;
&$_($U6)for@$w;
&$_($Y6)for@$w;
&$_($d7)for@$Z2;
&$_($i7)for@$w;
&$_($l7)for@$Z2;
&$_($q7)for@$w;
&$_($t7)for@$Z2;
&$_($v7)for@$w7;
&$_($A7)for@$w;
&$_($D7)for@$Z2;
&$_($I7)for@$w;
&$_($L7)for@$Z2;
&$_($N7)for@$O7;
&$_($V7)for@$g6;
&$_($X7)for@$g6;
&$_($i8)for@$w;
&$_($l8)for@$Z2;
&$_($p8)for@$w;
&$_($s8)for@$Z2;
&$_($x8)for@$w;
&$_($B8)for@$w;
&$_($F8)for@$w;
&$_($J8)for@$w;
&$_($M8)for@$Z2;
&$_($R8)for@$w;
&$_($V8)for@$w;
&$_($Z8)for@$w;
&$_($f9)for@$w;
&$_($j9)for@$w;
&$_($m9)for@$Z2;
&$_($r9)for@$w;
&$_($u9)for@$Z2;
&$_($z9)for@$w;
&$_($D9)for@$w;
&$_($H9)for@$w;
&$_($K9)for@$Z2;
&$_($M9)for@$N9;
&$_($S9)for@$g6;
&$_($ha)for@$w;
&$_($ka)for@$Z2;
&$_($oa)for@$w;
&$_($ra)for@$Z2;
&$_($wa)for@$w;
&$_($za)for@$Z2;
&$_($Ea)for@$w;
&$_($Ia)for@$w;
&$_($Ma)for@$w;
&$_($Pa)for@$Z2;
&$_($Ta)for@$w;
&$_($Xa)for@$w;
&$_($cb)for@$Z2;
&$_($gb)for@$w;
&$_($kb)for@$w;
&$_($nb)for@$Z2;
&$_($pb)for@$qb;
&$_($vb)for@$g6;
&$_($Ib)for@$w;
&$_($Lb)for@$Z2;
&$_($Qb)for@$w;
&$_($Tb)for@$Z2;
&$_($Xb)for@$w;
&$_($cc)for@$Z2;
&$_($hc)for@$w;
&$_($kc)for@$w;
&$_($oc)for@$w;
&$_($rc)for@$w;
&$_($uc)for@$Z2;
&$_($wc)for@$xc;
&$_($Cc)for@$g6;
&$_($Mc)for@$w;
&$_($Pc)for@$w;
&$_($Tc)for@$w;
&$_($Xc)for@$w;
&$_($cd)for@$Z2;
&$_($kd)for@$w;
&$_($nd)for@$Z2;
&$_($rd)for@$w;
&$_($ud)for@$w;
&$_($xd)for@$w;
&$_($Ad)for@$Z2;
&$_($Cd)for@$Dd;
&$_($Id)for@$g6;
&$_($Yd)for@$w;
&$_($ee)for@$w;
&$_($he)for@$Z2;
&$_($le)for@$w;
&$_($oe)for@$w;
&$_($re)for@$Z2;
&$_($we)for@$w;
&$_($Ae)for@$w;
&$_($De)for@$Z2;
&$_($He)for@$w;
&$_($Ke)for@$w;
&$_($Ne)for@$Z2;
&$_($Re)for@$w;
&$_($Ue)for@$w;
&$_($Xe)for@$w;
&$_($cf)for@$w;
&$_($ff)for@$Z2;
&$_($hf)for@$if;
&$_($nf)for@$g6;
&$_($Af)for@$w;
&$_($Ef)for@$w;
&$_($If)for@$w;
&$_($Lf)for@$Z2;
&$_($Pf)for@$w;
&$_($Sf)for@$Z2;
&$_($Wf)for@$w;
&$_($cg)for@$w;
&$_($fg)for@$w;
&$_($ig)for@$Z2;
&$_($kg)for@$lg;
&$_($qg)for@$g6;
&$_($Cg)for@$w;
&$_($Fg)for@$Z2;
&$_($Hg)for@$Ig;
&$_($Og)for@$g6;
&$_($Wg)for@$w;
&$_($Zg)for@$Z2;
&$_($eh)for@$w;
&$_($hh)for@$Z2;
&$_($jh)for@$kh;
&$_($ph)for@$g6;
&$_($zh)for@$w;
&$_($Ch)for@$Z2;
&$_($Fh)for@$w;
&$_($Ih)for@$Z2;
&$_($Mh)for@$w;
&$_($Ph)for@$Z2;
&$_($Sh)for@$w;
&$_($Vh)for@$w;
&$_($Yh)for@$Z2;
&$_($ci)for@$di;
&$_($ii)for@$g6;
&$_($ti)for@$w;
&$_($wi)for@$w;
&$_($yi)for@$w;
&$_($Bi)for@$Z2;
&$_($Fi)for@$w;
&$_($Ii)for@$w;
&$_($Mi)for@$w;
&$_($Pi)for@$Z2;
&$_($Ti)for@$w;
&$_($Wi)for@$w;
&$_($Zi)for@$Z2;
&$_($gj)for@$w;
&$_($jj)for@$Z2;
&$_($lj)for@$mj;
&$_($rj)for@$g6;
&$_($Cj)for@$w;
&$_($Fj)for@$Z2;
&$_($Mj)for@$w;
&$_($Pj)for@$Z2;
&$_($Uj)for@$w;
&$_($Yj)for@$w;
&$_($ek)for@$w;
&$_($ik)for@$w;
&$_($mk)for@$w;
&$_($qk)for@$w;
&$_($uk)for@$w;
&$_($yk)for@$w;
&$_($Ck)for@$w;
&$_($Gk)for@$w;
&$_($Kk)for@$w;
&$_($Ok)for@$w;
&$_($Rk)for@$w;
&$_($Uk)for@$Z2;
&$_($Zk)for@$w;
&$_($el)for@$Z2;
&$_($jl)for@$w;
&$_($nl)for@$w;
&$_($rl)for@$w;
&$_($vl)for@$w;
&$_($zl)for@$w;
&$_($Cl)for@$Z2;
&$_($Hl)for@$w;
&$_($Ll)for@$w;
&$_($Pl)for@$w;
&$_($Sl)for@$Z2;
&$_($Ul)for@$Vl;
&$_($cm)for@$g6;
&$_($mm)for@$w;
&$_($qm)for@$w;
&$_($um)for@$w;
&$_($ym)for@$w;
&$_($Cm)for@$w;
&$_($Fm)for@$Z2;
&$_($Sm)for@$w;
&$_($Wm)for@$w;
&$_($cn)for@$w;
&$_($fn)for@$Z2;
&$_($kn)for@$w;
&$_($on)for@$w;
&$_($rn)for@$Z2;
&$_($wn)for@$w;
&$_($An)for@$w;
&$_($En)for@$w;
&$_($In)for@$w;
&$_($Mn)for@$w;
&$_($Pn)for@$Z2;
&$_($Tn)for@$w;
&$_($Xn)for@$w;
&$_($co)for@$Z2;
&$_($eo)for@$fo;
&$_($ko)for@$g6;
&$_($uo)for@$w;
&$_($yo)for@$w;
&$_($Co)for@$w;
&$_($Go)for@$w;
&$_($Ko)for@$w;
&$_($Oo)for@$w;
&$_($So)for@$w;
&$_($Wo)for@$w;
&$_($cp)for@$w;
&$_($gp)for@$w;
&$_($kp)for@$w;
&$_($op)for@$w;
&$_($rp)for@$Z2;
&$_($Bp)for@$w;
&$_($Ep)for@$Z2;
&$_($Hp)for@$w;
&$_($Kp)for@$w;
&$_($Np)for@$Z2;
&$_($Pp)for@$Qp;
&$_($Vp)for@$g6;
&$_($hq)for@$w;
&$_($jq)for@$w;
&$_($qq)for@$Z2;
&$_($tq)for@$w;
&$_($wq)for@$Z2;
&$_($Aq)for@$w;
&$_($Dq)for@$Z2;
&$_($Fq)for@$Gq;
&$_($Mq)for@$g6;
&$_($Tq)for@$w;
&$_($Xq)for@$w;
&$_($cr)for@$Z2;
&$_($jr)for@$w;
&$_($mr)for@$Z2;
&$_($pr)for@$w;
&$_($sr)for@$Z2;
&$_($ur)for@$vr;
&$_($Br)for@$g6;
&$_($Jr)for@$w;
&$_($Mr)for@$Z2;
&$_($Rr)for@$w;
&$_($Vr)for@$w;
&$_($Yr)for@$Z2;
&$_($es)for@$w;
&$_($hs)for@$Z2;
&$_($js)for@$ks;
&$_($ps)for@$g6;
&$_($xs)for@$ys;
&$_($Ds)for@$g6;
&$_($Ls)for@$Ms;
&$_($it)for@$jt;
&$_($lt)for@$Ms;
&$_($qt)for@$w;
&$_($ut)for@$w;
&$_($yt)for@$w;
&$_($Ct)for@$w;
&$_($Gt)for@$w;
&$_($It)for@$Jt;
ni->run(@ARGV);
__DATA__
