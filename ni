#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/fabric/rmi#;
$P=[];
$Q=q#/fabric/rmi#;
$R=bless({$e,$P,$D,$Q},$F);
$S=q#ni.doc:/io#;
$T=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$U=[$i,$T];
$V=[$U];
$W=q#/io#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/io/buffer#;
$Z=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$c1=[$f,$Z];
$d1=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$e1=[$i,$d1];
$f1=[];
$g1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q#/io/buffer#;
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q#ni.doc:/io/cat#;
$n1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$o1=[$f,$n1];
$p1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$q1=[$i,$p1];
$r1=[];
$s1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$o1,$q1,$u1];
$w1=q#/io/cat#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/io/exec#;
$z1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$A1=[$f,$z1];
$B1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$C1=[$i,$B1];
$D1=[];
$E1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now [$out->read_all, $pid->await] == ["hi\\n", 0];#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$A1,$C1,$G1];
$I1=q#/io/exec#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/io/fd#;
$L1=q#
    open my $fh, ...;
    my $fd = ni('ni:/io/fd')->new($fh); \# from perl FH
    my $fd = ni('ni:/io/fd')->new(0);   \# from number
    my $fd = ni('fd:0');                \# same thing
    $fd->nonblock(1)->read($_, 100);
    $fd->be(10);                        \# move FD number
  #;
$M1=[$f,$L1];
$N1=q#Represents a file descriptor as a child of /io/object (so the usual IO
      methods like into_async are available), and provides some convenience
      functions for things like setting up FDs for child processes. FDs are
      closed when destroyed.#;
$O1=[$i,$N1];
$P1=[];
$Q1=q#my ($r, $w) = POSIX::pipe;
{
  my $fd = ni('ni:/io/fd')->new($r);
}
ni('ni:/io/fd')->new($w)->be($r);   \# fails unless $r was GC-closed#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=[$n,$R1];
$T1=[$M1,$O1,$S1];
$U1=q#/io/fd#;
$V1=bless({$e,$T1,$D,$U1},$F);
$W1=q#ni.doc:/io/file#;
$X1=q#
    my $f = ni('ni:/io/file')->new('/etc/passwd');
    my $f = ni('file:/etc/passwd');     \# same as above
    $f->into_sync(ni('fd:1'));          \# cat to stdout
  #;
$Y1=[$f,$X1];
$Z1=q#warning#;
$c2=q#Files overload the -X file test operators, but this feature wasn't
      introduced until Perl 5.12 -- prior versions won't recognize this
      overload. That means that using this overload in ni's base code will
      reduce its portability and cause tests to fail.#;
$d2=[$Z1,$c2];
$e2=q#Represents a file that may or may not exist, and stores/constructs file
      descriptors for reading/writing. /io/files are one-shot objects: once
      you've consumed them for reading or written to them, you should destroy
      the object and start over (or close the file) if you want to operate on
      the file further -- put differently, /io/file objects own the FDs they
      create.#;
$f2=[];
$g2=q#my $ni = ni('file:ni');
now [$ni->read($_, 19), $_] == [19, "\#!/usr/bin/env perl"];#;
$h2=bless({$o,$f2,$q,$g2,$s,$t},$u);
$i2=q#File objects also provide some useful functions like atomic-updating.
      This lets you write a stream slowly into a tempfile, then rename over the
      original once the tempfile is closed. ni uses this to update itself to
      avoid race conditions.#;
$j2=[];
$k2=q#ni('file:tmp1')->write_all("original contents");
{
  my $updater = ni('file:tmp1')->atomic_update;
  $updater->write_all('foo bar');
  now ni('file:tmp1')->read_all == "original contents";
}
now ni('file:tmp1')->read_all == "foo bar";
ni('file:tmp1')->rm;#;
$l2=bless({$o,$j2,$q,$k2,$s,$t},$u);
$m2=[$i,$e2,$n,$h2,$i2,$n,$l2];
$n2=[$Y1,$d2,$m2];
$o2=q#/io/file#;
$p2=bless({$e,$n2,$D,$o2},$F);
$q2=q#ni.doc:/io/file_update_fd#;
$r2=q#A write fd that performs a file rename upon closing.#;
$s2=[$i,$r2];
$t2=[$s2];
$u2=q#/io/file_update_fd#;
$v2=bless({$e,$t2,$D,$u2},$F);
$w2=q#ni.doc:/io/mio#;
$x2=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$y2=[$f,$x2];
$z2=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$A2=q#

      #;
$B2=[$i,$z2,$A2];
$C2=[$y2,$B2];
$D2=q#/io/mio#;
$E2=bless({$e,$C2,$D,$D2},$F);
$F2=q#ni.doc:/io/mio_channel#;
$G2=q#
    #;
$H2=[$i,$G2];
$I2=[$H2];
$J2=q#/io/mio_channel#;
$K2=bless({$e,$I2,$D,$J2},$F);
$L2=q#ni.doc:/io/pid#;
$M2=[];
$N2=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$O2=bless({$o,$M2,$q,$N2,$s,$t},$u);
$P2=[$n,$O2];
$Q2=[];
$R2=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$S2=bless({$o,$Q2,$q,$R2,$s,$t},$u);
$T2=[$n,$S2];
$U2=[];
$V2=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$W2=bless({$o,$U2,$q,$V2,$s,$t},$u);
$X2=[$n,$W2];
$Y2=[$P2,$T2,$X2];
$Z2=q#/io/pid#;
$c3=bless({$e,$Y2,$D,$Z2},$F);
$d3=q#ni.doc:/lib#;
$e3=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$f3=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$g3=[$i,$e3,$f3];
$h3=[$g3];
$i3=q#/lib#;
$j3=bless({$e,$h3,$D,$i3},$F);
$k3=q#ni.doc:/lib/doc#;
$l3=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$m3=[$f,$l3];
$n3=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$o3=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$p3=[];
$q3=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$r3=bless({$o,$p3,$q,$q3,$s,$t},$u);
$s3=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$t3=[];
$u3=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$v3=bless({$o,$t3,$q,$u3,$s,$t},$u);
$w3=[$i,$n3,$o3,$n,$r3,$s3,$n,$v3];
$x3=[$m3,$w3];
$y3=q#/lib/doc#;
$z3=bless({$e,$x3,$D,$y3},$F);
$A3=q#ni.doc:/lib/image#;
$B3=q#
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         \# TODO#;
$C3=[$f,$B3];
$D3=q#Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.#;
$E3=[$i,$D3];
$F3=[$C3,$E3];
$G3=q#/lib/image#;
$H3=bless({$e,$F3,$D,$G3},$F);
$I3=q#ni.doc:/lib/ni#;
$J3=q#my $value = ni->resolve($name);
               my $value = ni($name);   \# alias for ni->resolve($name)
               my $self  = ni;#;
$K3=[$f,$J3];
$L3=q#The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.#;
$M3=[$i,$L3];
$N3=[$K3,$M3];
$O3=q#/lib/ni#;
$P3=bless({$e,$N3,$D,$O3},$F);
$Q3=q#ni.doc:/lib/quote_simple#;
$R3=q#A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.#;
$S3=[$i,$R3];
$T3=[];
$U3=q#my $q = ni('ni:/lib/quote_simple')->new;
now $q->quote([1,2,3]) == "[1,2,3]";
now $q->quote({foo => 1, bar => [1, 2]}) == "{q\#bar\#,[1,2],q\#foo\#,1}";#;
$V3=bless({$o,$T3,$q,$U3,$s,$t},$u);
$W3=[$n,$V3];
$X3=[$S3,$W3];
$Y3=q#/lib/quote_simple#;
$Z3=bless({$e,$X3,$D,$Y3},$F);
$c4=q#ni.doc:/semantic#;
$d4=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$e4=[$i,$d4];
$f4=[$e4];
$g4=q#/semantic#;
$h4=bless({$e,$f4,$D,$g4},$F);
$i4=q#ni:/class#;
$j4=q#applied_to#;
$k4=q#class#;
$l4=q#class.c#;
$m4=q#fabric/rmi.c#;
$n4=q#io/buffer.c#;
$o4=q#io/cat.c#;
$p4=q#io/exec.c#;
$q4=q#io/fd.c#;
$r4=q#io/file.c#;
$s4=q#io/file_update_fd.c#;
$t4=q#io/mio.c#;
$u4=q#io/mio_channel.c#;
$v4=q#io/null.c#;
$w4=q#io/object.c#;
$x4=q#io/pid.c#;
$y4=q#io/str.c#;
$z4=q#io/transfer.c#;
$A4=q#io/transfer_async.c#;
$B4=q#io/transfer_sync.c#;
$C4=q#lib/behavior.c#;
$D4=q#lib/branch.c#;
$E4=q#lib/dataslice.c#;
$F4=q#lib/doc.c#;
$G4=q#lib/fn.c#;
$H4=q#lib/image.c#;
$I4=q#lib/ni.c#;
$J4=q#lib/quote_simple.c#;
$K4=q#lib/slice.c#;
$L4=q#lib/tag.c#;
$M4=q#lib/test_value.c#;
$N4=q#metaclass.c#;
$O4=q#module.c#;
$P4=q#object.c#;
$Q4=q#semantic/dimension#;
$R4=q#semantic/dimension.c#;
$S4=q#semantic/task.c#;
$T4={$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$N4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1};
$U4=q#slices#;
$V4=q#metaclass#;
$W4=q#module#;
$X4={$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$V4,1,$N4,1,$W4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1};
$Y4=q#/module#;
$Z4=q#/lib/perlbranch.b#;
$c5={};
$d5=q#ctor#;
$e5=undef;
$f5=q#dtor#;
$g5=q#methods#;
$h5=q#add#;
$i5=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$j5=bless({$q,$i5,$s,$t},$u);
$k5=q#apply#;
$l5=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$m5=bless({$q,$l5,$s,$t},$u);
$n5={$h5,$j5,$k5,$m5};
$o5=q#/lib/branch.b#;
$p5=q#lib/slice#;
$q5=bless({$j4,$c5,$d5,$e5,$f5,$e5,$g5,$n5,$D,$o5},$p5);
$r5=q#lib/branch#;
$s5=q#lib/slice::ctors#;
$t5={};
$u5=q#my $s = shift; ni->def($s->name, $s)#;
$v5=bless({$q,$u5,$s,$t},$u);
$w5=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$x5=bless({$q,$w5,$s,$t},$u);
$y5={$D,$x5};
$z5=q#/lib/named.b#;
$A5=bless({$j4,$t5,$d5,$v5,$f5,$e5,$g5,$y5,$D,$z5},$p5);
$B5=q#lib/tag#;
$C5={};
$D5=q#namespace#;
$E5=q#'ni'#;
$F5=bless({$q,$E5,$s,$t},$u);
$G5={$D5,$F5};
$H5=q#/lib/named_in_ni.b#;
$I5=bless({$j4,$C5,$d5,$e5,$f5,$e5,$g5,$G5,$D,$H5},$p5);
$J5={};
$K5=q#package#;
$L5=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/namespaced.b#;
$P5=bless({$j4,$J5,$d5,$e5,$f5,$e5,$g5,$N5,$D,$O5},$p5);
$Q5={};
$R5=q#resolve#;
$S5=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$T5=bless({$q,$S5,$s,$t},$u);
$U5={$R5,$T5};
$V5=q#/lib/resolver.b#;
$W5=bless({$j4,$Q5,$d5,$e5,$f5,$e5,$g5,$U5,$D,$V5},$p5);
$X5=[$q5,$A5,$I5,$P5,$W5];
$Y5=bless({$D,$Z4,$U4,$X5},$B5);
$Z5=q#lib/tag::ctors#;
$c6={};
$d6=q#my $s = shift; $s->apply($s->package)#;
$e6=bless({$q,$d6,$s,$t},$u);
$f6=q#instantiate#;
$g6=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$h6=bless({$q,$g6,$s,$t},$u);
$i6={$f6,$h6};
$j6=q#/lib/class_init.b#;
$k6=bless({$j4,$c6,$d5,$e6,$f5,$e5,$g5,$i6,$D,$j6},$p5);
$l6=q#fabric/rmi#;
$m6=q#io/buffer#;
$n6=q#io/cat#;
$o6=q#io/exec#;
$p6=q#io/fd#;
$q6=q#io/file#;
$r6=q#io/file_update_fd#;
$s6=q#io/mio#;
$t6=q#io/mio_channel#;
$u6=q#io/null#;
$v6=q#io/object#;
$w6=q#io/pid#;
$x6=q#io/str#;
$y6=q#io/transfer#;
$z6=q#io/transfer_async#;
$A6=q#io/transfer_sync#;
$B6=q#lib/behavior#;
$C6=q#lib/dataslice#;
$D6=q#lib/image#;
$E6=q#lib/ni#;
$F6=q#lib/quote_simple#;
$G6=q#lib/test_value#;
$H6=q#object#;
$I6=q#semantic/task#;
$J6={$k4,1,$l4,1,$l6,1,$m4,1,$m6,1,$n4,1,$n6,1,$o4,1,$o6,1,$p4,1,$p6,1,$q4,1,$q6,1,$r4,1,$r6,1,$s4,1,$s6,1,$t4,1,$t6,1,$u4,1,$u6,1,$v4,1,$v6,1,$w4,1,$w6,1,$x4,1,$x6,1,$y4,1,$y6,1,$z4,1,$z6,1,$A4,1,$A6,1,$B4,1,$B6,1,$C4,1,$r5,1,$D4,1,$C6,1,$E4,1,$F,1,$F4,1,$u,1,$G4,1,$D6,1,$H4,1,$E6,1,$I4,1,$F6,1,$J4,1,$p5,1,$K4,1,$B5,1,$L4,1,$G6,1,$M4,1,$V4,1,$N4,1,$W4,1,$O4,1,$H6,1,$P4,1,$Q4,1,$R4,1,$I6,1,$S4,1};
$K6=q#/object#;
$L6={};
$M6=q#ni 'ni:/' . ref shift#;
$N6=bless({$q,$M6,$s,$t},$u);
$O6={$k4,$N6};
$P6=q#/lib/instance.b#;
$Q6=bless({$j4,$L6,$d5,$e5,$f5,$e5,$g5,$O6,$D,$P6},$p5);
$R6=[$Q6];
$S6=bless({$j4,$J6,$D,$K6,$U4,$R6},$P4);
$T6=q#object.c::ctors#;
$U6={$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$B6,1,$C4,1,$r5,1,$D4,1,$C6,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$p5,1,$K4,1,$B5,1,$L4,1,$M4,1,$V4,1,$N4,1,$W4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1};
$V6=q#/lib/behavior#;
$W6={};
$X6=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$Y6=bless({$q,$X6,$s,$t},$u);
$Z6={$e,$Y6};
$c7=q#/lib/documentable.b#;
$d7=bless({$j4,$W6,$d5,$e5,$f5,$e5,$g5,$Z6,$D,$c7},$p5);
$e7=[$S6,$d7];
$f7=bless({$j4,$U6,$D,$V6,$U4,$e7},$C4);
$g7=q#lib/behavior.c::ctors#;
$h7={$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$r5,1,$D4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$V4,1,$N4,1,$W4,1,$O4,1,$P4,1,$Q4,1,$R4,1,$S4,1};
$i7=q#/lib/definition.b#;
$j7={};
$k7=q#def#;
$l7=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$m7=bless({$q,$l7,$s,$t},$u);
$n7={$k7,$m7};
$o7=q#/lib/definition_def.b#;
$p7=bless({$j4,$j7,$d5,$e5,$f5,$e5,$g5,$n7,$D,$o7},$p5);
$q7={};
$r7=q#ro#;
$s7=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$t7=bless({$q,$s7,$s,$t},$u);
$u7=q#rw#;
$v7=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$w7=bless({$q,$v7,$s,$t},$u);
$x7={$r7,$t7,$u7,$w7};
$y7=q#/lib/accessor.b#;
$z7=bless({$j4,$q7,$d5,$e5,$f5,$e5,$g5,$x7,$D,$y7},$p5);
$A7={};
$B7=q#(""#;
$C7=q#shift->name#;
$D7=bless({$q,$C7,$s,$t},$u);
$E7={$B7,$D7};
$F7=q#/lib/name_as_string.b#;
$G7=bless({$j4,$A7,$d5,$e5,$f5,$e5,$g5,$E7,$D,$F7},$p5);
$H7={};
$I7=q#(eq#;
$J7=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$K7=bless({$q,$J7,$s,$t},$u);
$L7={$I7,$K7};
$M7=q#/lib/ref_eq.b#;
$N7=bless({$j4,$H7,$d5,$e5,$f5,$e5,$g5,$L7,$D,$M7},$p5);
$O7={};
$P7=q#defdata#;
$Q7=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$R7=bless({$q,$Q7,$s,$t},$u);
$S7={$P7,$R7};
$T7=q#/lib/definition_defdata.b#;
$U7=bless({$j4,$O7,$d5,$e5,$f5,$e5,$g5,$S7,$D,$T7},$p5);
$V7=[$p7,$z7,$G7,$N7,$U7];
$W7=bless({$j4,$h7,$D,$i7,$U4,$V7},$r5);
$X7=q#lib/branch::ctors#;
$Y7=[$Y5,$k6,$S6,$f7,$W7];
$Z7=bless({$j4,$X4,$D,$Y4,$U4,$Y7},$O4);
$c8=q#module.c::ctors#;
$d8={};
$e8=q#DESTROY#;
$f8=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$g8=bless({$q,$f8,$s,$t},$u);
$h8=q#new#;
$i8=q#local $_;
my $class   = shift;
my $package = ref $class ? $class->package : $class;
my $self = bless &{"$package\\::instantiate"}($class, @_), $package;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$j8=bless({$q,$i8,$s,$t},$u);
$k8={$e8,$g8,$h8,$j8};
$l8=q#/lib/instantiable.b#;
$m8=bless({$j4,$d8,$g5,$k8,$D,$l8},$p5);
$n8={};
$o8=q#child#;
$p8=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$q8=bless({$q,$p8,$s,$t},$u);
$r8={$o8,$q8};
$s8=q#/lib/subclass.b#;
$t8=bless({$j4,$n8,$d5,$e5,$f5,$e5,$g5,$r8,$D,$s8},$p5);
$u8=[$Z7,$m8,$k6,$Z7,$t8];
$v8=bless({$j4,$T4,$D,$E,$U4,$u8},$l4);
$w8=q#class.c::ctors#;
$x8=q#ni:/class.c#;
$y8={$l4,1,$R4,1};
$z8=q#/class.c#;
$A8={$l4,1,$O4,1,$R4,1};
$B8=q#/module.c#;
$C8={$l4,1,$m4,1,$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1,$z4,1,$A4,1,$B4,1,$C4,1,$D4,1,$E4,1,$F4,1,$G4,1,$H4,1,$I4,1,$J4,1,$K4,1,$L4,1,$M4,1,$O4,1,$P4,1,$R4,1,$S4,1};
$D8=q#/object.c#;
$E8=[$v8];
$F8=bless({$j4,$C8,$D,$D8,$U4,$E8},$V4);
$G8=q#metaclass::ctors#;
$H8={$l4,1,$C4,1,$D4,1,$E4,1,$K4,1,$L4,1,$O4,1,$R4,1};
$I8=q#/lib/behavior.c#;
$J8=[$F8];
$K8=bless({$j4,$H8,$D,$I8,$U4,$J8},$V4);
$L8=[$F8,$m8,$K8];
$M8=bless({$j4,$A8,$D,$B8,$U4,$L8},$V4);
$N8=[$M8];
$O8=bless({$j4,$y8,$D,$z8,$U4,$N8},$V4);
$P8=q#ni:/fabric/rmi#;
$Q8={$l6,1};
$R8={};
$S8=[];
$T8=q#my ($class, $io, $quote) = @_;#;
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8={$f6,$U8};
$W8=q#/fabric/rmi_init.b#;
$X8=bless({$j4,$R8,$d5,$e5,$f5,$e5,$g5,$V8,$D,$W8},$p5);
$Y8=[$S6,$X8];
$Z8=bless({$j4,$Q8,$D,$Q,$U4,$Y8},$m4);
$c9=q#fabric/rmi.c::ctors#;
$d9=q#ni:/fabric/rmi.c#;
$e9={$m4,1};
$f9=q#/fabric/rmi.c#;
$g9=[$F8];
$h9=bless({$j4,$e9,$D,$f9,$U4,$g9},$V4);
$i9=q#ni:/fabric/rmi_init.b#;
$j9=q#ni:/io/buffer#;
$k9={$m6,1};
$l9={$m6,1,$n6,1,$o6,1,$p6,1,$q6,1,$r6,1,$s6,1,$t6,1,$u6,1,$v6,1,$w6,1,$x6,1};
$m9=q#/io/object#;
$n9={};
$o9=q#(bool#;
$p9=[];
$q9=bless({$o,$p9,$q,1,$s,$t},$u);
$r9={$o9,$q9};
$s9=q#/io/object_ops.b#;
$t9=bless({$j4,$n9,$d5,$e5,$f5,$e5,$g5,$r9,$D,$s9},$p5);
$u9={};
$v9=q#die#;
$w9=[];
$x9=q#shift; die join " ", @_#;
$y9=bless({$o,$w9,$q,$x9,$s,$t},$u);
$z9=q#io_check#;
$A9=[];
$B9=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$C9=bless({$o,$A9,$q,$B9,$s,$t},$u);
$D9=q#io_check_defined#;
$E9=[];
$F9=q#shift->io_check(sub {defined shift}, @_)#;
$G9=bless({$o,$E9,$q,$F9,$s,$t},$u);
$H9=q#io_check_true#;
$I9=[];
$J9=q#shift->io_check(sub {shift}, @_)#;
$K9=bless({$o,$I9,$q,$J9,$s,$t},$u);
$L9={$v9,$y9,$z9,$C9,$D9,$G9,$H9,$K9};
$M9=q#/io/object_checks.b#;
$N9=bless({$j4,$u9,$d5,$e5,$f5,$e5,$g5,$L9,$D,$M9},$p5);
$O9={};
$P9=q#(+#;
$Q9=[];
$R9=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$S9=bless({$o,$Q9,$q,$R9,$s,$t},$u);
$T9={$P9,$S9};
$U9=q#/io/object_constructors.b#;
$V9=bless({$j4,$O9,$d5,$e5,$f5,$e5,$g5,$T9,$D,$U9},$p5);
$W9={};
$X9=q#read_all#;
$Y9=[];
$Z9=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da=q#write_all#;
$ea=[];
$fa=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_sync($self);#;
$ga=bless({$o,$ea,$q,$fa,$s,$t},$u);
$ha={$X9,$ca,$da,$ga};
$ia=q#/io/object_memory.b#;
$ja=bless({$j4,$W9,$d5,$e5,$f5,$e5,$g5,$ha,$D,$ia},$p5);
$ka={};
$la=q#connect_sync#;
$ma=[];
$na=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$oa=bless({$o,$ma,$q,$na,$s,$t},$u);
$pa=q#into_sync#;
$qa=[];
$ra=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta={$la,$oa,$pa,$sa};
$ua=q#/io/object_transfer_sync.b#;
$va=bless({$j4,$ka,$d5,$e5,$f5,$e5,$g5,$ta,$D,$ua},$p5);
$wa={};
$xa=q#connect_async#;
$ya=[];
$za=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$Aa=bless({$o,$ya,$q,$za,$s,$t},$u);
$Ba=q#into_async#;
$Ca=[];
$Da=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa={$xa,$Aa,$Ba,$Ea};
$Ga=q#/io/object_transfer_async.b#;
$Ha=bless({$j4,$wa,$d5,$e5,$f5,$e5,$g5,$Fa,$D,$Ga},$p5);
$Ia=[$S6,$t9,$N9,$V9,$ja,$va,$Ha,$Ha,$va];
$Ja=bless({$j4,$l9,$D,$m9,$U4,$Ia},$w4);
$Ka=q#io/object.c::ctors#;
$La={};
$Ma=[];
$Na=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$Oa=bless({$o,$Ma,$q,$Na,$s,$t},$u);
$Pa={$f6,$Oa};
$Qa=q#/io/buffer_init.b#;
$Ra=bless({$j4,$La,$d5,$e5,$f5,$e5,$g5,$Pa,$D,$Qa},$p5);
$Sa={};
$Ta=q#read#;
$Ua=[];
$Va=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#read_capacity#;
$Ya=[];
$Za=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db=q#write#;
$eb=[];
$fb=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb=q#write_capacity#;
$ib=[];
$jb=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb={$Ta,$Wa,$Xa,$cb,$db,$gb,$hb,$kb};
$mb=q#/io/buffer_io.b#;
$nb=bless({$j4,$Sa,$d5,$e5,$f5,$e5,$g5,$lb,$D,$mb},$p5);
$ob=[$Ja,$Ra,$nb];
$pb=bless({$j4,$k9,$D,$k1,$U4,$ob},$n4);
$qb=q#io/buffer.c::ctors#;
$rb=q#ni:/io/buffer.c#;
$sb={$n4,1};
$tb=q#/io/buffer.c#;
$ub={$n4,1,$o4,1,$p4,1,$q4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1,$y4,1};
$vb=q#/io/object.c#;
$wb={};
$xb=q#def_transfer_method#;
$yb=[];
$zb=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb={$xb,$Ab};
$Cb=q#/io/object.c_transfer_def.b#;
$Db=bless({$j4,$wb,$d5,$e5,$f5,$e5,$g5,$Bb,$D,$Cb},$p5);
$Eb=[$F8,$Db];
$Fb=bless({$j4,$ub,$D,$vb,$U4,$Eb},$V4);
$Gb=[$Fb];
$Hb=bless({$j4,$sb,$D,$tb,$U4,$Gb},$V4);
$Ib=q#ni:/io/buffer_init.b#;
$Jb=q#ni:/io/buffer_io.b#;
$Kb=q#ni:/io/cat#;
$Lb={$n6,1};
$Mb={};
$Nb=[];
$Ob=q#shift; +{fs => [@_]}#;
$Pb=bless({$o,$Nb,$q,$Ob,$s,$t},$u);
$Qb={$f6,$Pb};
$Rb=q#/io/cat_init.b#;
$Sb=bless({$j4,$Mb,$d5,$e5,$f5,$e5,$g5,$Qb,$D,$Rb},$p5);
$Tb={};
$Ub=[];
$Vb=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb={$Ta,$Wb};
$Yb=q#/io/cat_read.b#;
$Zb=bless({$j4,$Tb,$d5,$e5,$f5,$e5,$g5,$Xb,$D,$Yb},$p5);
$cc=[$Ja,$Sb,$Zb];
$dc=bless({$j4,$Lb,$D,$w1,$U4,$cc},$o4);
$ec=q#io/cat.c::ctors#;
$fc=q#ni:/io/cat.c#;
$gc={$o4,1};
$hc=q#/io/cat.c#;
$ic=[$Fb];
$jc=bless({$j4,$gc,$D,$hc,$U4,$ic},$V4);
$kc=q#ni:/io/cat_init.b#;
$lc=q#ni:/io/cat_read.b#;
$mc=q#ni:/io/exec#;
$nc={$o6,1};
$oc={};
$pc=q#argv#;
$qc=[];
$rc=q#shift->{'argv'}#;
$sc=bless({$o,$qc,$q,$rc,$s,$t},$u);
$tc={$pc,$sc};
$uc=q#/io/exec_ro.b#;
$vc=bless({$j4,$oc,$d5,$e5,$f5,$e5,$g5,$tc,$D,$uc},$p5);
$wc={};
$xc=[];
$yc=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$zc=bless({$o,$xc,$q,$yc,$s,$t},$u);
$Ac={$f6,$zc};
$Bc=q#/io/exec_init.b#;
$Cc=bless({$j4,$wc,$d5,$e5,$f5,$e5,$g5,$Ac,$D,$Bc},$p5);
$Dc={};
$Ec=q#connect#;
$Fc=[];
$Gc=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Hc=bless({$o,$Fc,$q,$Gc,$s,$t},$u);
$Ic=q#in_pipe#;
$Jc=[];
$Kc=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Lc=bless({$o,$Jc,$q,$Kc,$s,$t},$u);
$Mc=q#out_pipe#;
$Nc=[];
$Oc=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Pc=bless({$o,$Nc,$q,$Oc,$s,$t},$u);
$Qc=q#setup_stdio#;
$Rc=[];
$Sc=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Tc=bless({$o,$Rc,$q,$Sc,$s,$t},$u);
$Uc={$Ec,$Hc,$Ic,$Lc,$Mc,$Pc,$Qc,$Tc};
$Vc=q#/io/exec_io_setup.b#;
$Wc=bless({$j4,$Dc,$d5,$e5,$f5,$e5,$g5,$Uc,$D,$Vc},$p5);
$Xc={};
$Yc=q#binds_fd#;
$Zc=[];
$cd=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$dd=bless({$o,$Zc,$q,$cd,$s,$t},$u);
$ed=q#fd#;
$fd=[];
$gd=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$hd=bless({$o,$fd,$q,$gd,$s,$t},$u);
$id=q#stderr#;
$jd=[];
$kd=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$ld=bless({$o,$jd,$q,$kd,$s,$t},$u);
$md=q#stdin#;
$nd=[];
$od=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$pd=bless({$o,$nd,$q,$od,$s,$t},$u);
$qd=q#stdout#;
$rd=[];
$sd=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$td=bless({$o,$rd,$q,$sd,$s,$t},$u);
$ud={$Yc,$dd,$ed,$hd,$id,$ld,$md,$pd,$qd,$td};
$vd=q#/io/exec_io_accessors.b#;
$wd=bless({$j4,$Xc,$d5,$e5,$f5,$e5,$g5,$ud,$D,$vd},$p5);
$xd={};
$yd=q#env#;
$zd=[];
$Ad=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Bd=bless({$o,$zd,$q,$Ad,$s,$t},$u);
$Cd={$yd,$Bd};
$Dd=q#/io/exec_env.b#;
$Ed=bless({$j4,$xd,$d5,$e5,$f5,$e5,$g5,$Cd,$D,$Dd},$p5);
$Fd={};
$Gd=q#exec#;
$Hd=[];
$Id=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Jd=bless({$o,$Hd,$q,$Id,$s,$t},$u);
$Kd=q#fork#;
$Ld=[];
$Md=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Nd=bless({$o,$Ld,$q,$Md,$s,$t},$u);
$Od=q#move_fds#;
$Pd=[];
$Qd=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Rd=bless({$o,$Pd,$q,$Qd,$s,$t},$u);
$Sd={$Gd,$Jd,$Kd,$Nd,$Od,$Rd};
$Td=q#/io/exec_fork.b#;
$Ud=bless({$j4,$Fd,$d5,$e5,$f5,$e5,$g5,$Sd,$D,$Td},$p5);
$Vd=[$Ja,$vc,$Cc,$Wc,$wd,$Ed,$Ud];
$Wd=bless({$j4,$nc,$D,$I1,$U4,$Vd},$p4);
$Xd=q#io/exec.c::ctors#;
$Yd=q#ni:/io/exec.c#;
$Zd={$p4,1};
$ce=q#/io/exec.c#;
$de=[$Fb];
$ee=bless({$j4,$Zd,$D,$ce,$U4,$de},$V4);
$fe=q#ni:/io/exec_env.b#;
$ge=q#ni:/io/exec_fork.b#;
$he=q#ni:/io/exec_init.b#;
$ie=q#ni:/io/exec_io_accessors.b#;
$je=q#ni:/io/exec_io_setup.b#;
$ke=q#ni:/io/exec_ro.b#;
$le=q#ni:/io/fd#;
$me={$p6,1};
$ne={};
$oe=[];
$pe=q#shift->{'fd'}#;
$qe=bless({$o,$oe,$q,$pe,$s,$t},$u);
$re={$ed,$qe};
$se=q#/io/fd_readers.b#;
$te=bless({$j4,$ne,$d5,$e5,$f5,$e5,$g5,$re,$D,$se},$p5);
$ue={};
$ve=[];
$we=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$xe=bless({$o,$ve,$q,$we,$s,$t},$u);
$ye={$f6,$xe};
$ze=q#/io/fd_init.b#;
$Ae=bless({$j4,$ue,$d5,$e5,$f5,$e5,$g5,$ye,$D,$ze},$p5);
$Be={};
$Ce=q#be#;
$De=[];
$Ee=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge={$Ce,$Fe};
$He=q#/io/fd_shell.b#;
$Ie=bless({$j4,$Be,$d5,$e5,$f5,$e5,$g5,$Ge,$D,$He},$p5);
$Je={};
$Ke=q#cloexec#;
$Le=[];
$Me=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe=q#fcntl_flag#;
$Pe=[];
$Qe=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Re=bless({$o,$Pe,$q,$Qe,$s,$t},$u);
$Se=q#nonblock#;
$Te=[];
$Ue=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We={$Ke,$Ne,$Oe,$Re,$Se,$Ve};
$Xe=q#/io/fd_fcntl.b#;
$Ye=bless({$j4,$Je,$d5,$e5,$f5,$e5,$g5,$We,$D,$Xe},$p5);
$Ze={};
$cf=[];
$df=q#shift->close#;
$ef=bless({$o,$cf,$q,$df,$s,$t},$u);
$ff=q#close#;
$gf=[];
$hf=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$if=bless({$o,$gf,$q,$hf,$s,$t},$u);
$jf={$ff,$if};
$kf=q#/io/fd_gc.b#;
$lf=bless({$j4,$Ze,$d5,$e5,$f5,$ef,$g5,$jf,$D,$kf},$p5);
$mf={};
$nf=[];
$of=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$pf=bless({$o,$nf,$q,$of,$s,$t},$u);
$qf=[];
$rf=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$sf=bless({$o,$qf,$q,$rf,$s,$t},$u);
$tf={$Ta,$pf,$db,$sf};
$uf=q#/io/fd_perlio.b#;
$vf=bless({$j4,$mf,$d5,$e5,$f5,$e5,$g5,$tf,$D,$uf},$p5);
$wf=[$Ja,$te,$Ae,$Ie,$Ye,$lf,$vf];
$xf=bless({$j4,$me,$D,$U1,$U4,$wf},$q4);
$yf=q#io/fd.c::ctors#;
$zf=q#ni:/io/fd.c#;
$Af={$q4,1};
$Bf=q#/io/fd.c#;
$Cf=[$Fb];
$Df=bless({$j4,$Af,$D,$Bf,$U4,$Cf},$V4);
$Ef=q#ni:/io/fd_fcntl.b#;
$Ff=q#ni:/io/fd_gc.b#;
$Gf=q#ni:/io/fd_init.b#;
$Hf=q#ni:/io/fd_perlio.b#;
$If=q#ni:/io/fd_readers.b#;
$Jf=q#ni:/io/fd_shell.b#;
$Kf=q#ni:/io/file#;
$Lf={$q6,1};
$Mf={};
$Nf=[];
$Of=q#shift->{'name'}#;
$Pf=bless({$o,$Nf,$q,$Of,$s,$t},$u);
$Qf={$D,$Pf};
$Rf=q#/io/file_readers.b#;
$Sf=bless({$j4,$Mf,$d5,$e5,$f5,$e5,$g5,$Qf,$D,$Rf},$p5);
$Tf={};
$Uf=q#mode#;
$Vf=[];
$Wf=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Xf=bless({$o,$Vf,$q,$Wf,$s,$t},$u);
$Yf={$Uf,$Xf};
$Zf=q#/io/file_accessors.b#;
$cg=bless({$j4,$Tf,$d5,$e5,$f5,$e5,$g5,$Yf,$D,$Zf},$p5);
$dg={};
$eg=[];
$fg=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$gg=bless({$o,$eg,$q,$fg,$s,$t},$u);
$hg={$f6,$gg};
$ig=q#/io/file_init.b#;
$jg=bless({$j4,$dg,$d5,$e5,$f5,$e5,$g5,$hg,$D,$ig},$p5);
$kg={};
$lg=q#(-X#;
$mg=[];
$ng=q#my ($self, $test) = @_;
&{"-$test"}($$self{name});#;
$og=bless({$o,$mg,$q,$ng,$s,$t},$u);
$pg=q#mv#;
$qg=[];
$rg=q#my ($self, $dest) = @_;
$dest = $dest->name if ref $dest;
$self->io_check_true(*POSIX::rename, $self->name, $dest);
$$self{name} = $dest;
$self;#;
$sg=bless({$o,$qg,$q,$rg,$s,$t},$u);
$tg=q#rm#;
$ug=[];
$vg=q#my $self = shift;
$self->io_check_true(*POSIX::unlink, $self->name);
$self;#;
$wg=bless({$o,$ug,$q,$vg,$s,$t},$u);
$xg={$lg,$og,$pg,$sg,$tg,$wg};
$yg=q#/io/file_fns.b#;
$zg=bless({$j4,$kg,$d5,$e5,$f5,$e5,$g5,$xg,$D,$yg},$p5);
$Ag={};
$Bg=q#atomic_update#;
$Cg=[];
$Dg=q#my $self = shift;
my $suffix = 0;
++$suffix while -e $self->name . ".$suffix";
ni('ni:/io/file_update_fd')->new(
  $self,
  $self->class->new($self->name . ".$suffix"));#;
$Eg=bless({$o,$Cg,$q,$Dg,$s,$t},$u);
$Fg={$Bg,$Eg};
$Gg=q#/io/file_update.b#;
$Hg=bless({$j4,$Ag,$d5,$e5,$f5,$e5,$g5,$Fg,$D,$Gg},$p5);
$Ig={};
$Jg=[];
$Kg=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Lg=bless({$o,$Jg,$q,$Kg,$s,$t},$u);
$Mg=q#r#;
$Ng=[];
$Og=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Pg=bless({$o,$Ng,$q,$Og,$s,$t},$u);
$Qg=[];
$Rg=q#shift->r->read(@_)#;
$Sg=bless({$o,$Qg,$q,$Rg,$s,$t},$u);
$Tg=q#w#;
$Ug=[];
$Vg=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Wg=bless({$o,$Ug,$q,$Vg,$s,$t},$u);
$Xg=[];
$Yg=q#shift->w->write(@_)#;
$Zg=bless({$o,$Xg,$q,$Yg,$s,$t},$u);
$ch={$ff,$Lg,$Mg,$Pg,$Ta,$Sg,$Tg,$Wg,$db,$Zg};
$dh=q#/io/file_io.b#;
$eh=bless({$j4,$Ig,$d5,$e5,$f5,$e5,$g5,$ch,$D,$dh},$p5);
$fh=[$Ja,$Sf,$cg,$jg,$zg,$Hg,$eh];
$gh=bless({$j4,$Lf,$D,$o2,$U4,$fh},$r4);
$hh=q#io/file.c::ctors#;
$ih=q#ni:/io/file.c#;
$jh={$r4,1};
$kh=q#/io/file.c#;
$lh=[$Fb];
$mh=bless({$j4,$jh,$D,$kh,$U4,$lh},$V4);
$nh=q#ni:/io/file_accessors.b#;
$oh=q#ni:/io/file_fns.b#;
$ph=q#ni:/io/file_init.b#;
$qh=q#ni:/io/file_io.b#;
$rh=q#ni:/io/file_readers.b#;
$sh=q#ni:/io/file_update.b#;
$th=q#ni:/io/file_update_fd#;
$uh={$r6,1};
$vh={};
$wh=[];
$xh=q#my ($class, $file, $tempfile) = @_;
my $fd = $tempfile->w;
+{writer   => $fd,
  fd       => $fd->fd,
  wfh      => undef,
  tempfile => $tempfile,
  file     => $file};#;
$yh=bless({$o,$wh,$q,$xh,$s,$t},$u);
$zh={$f6,$yh};
$Ah=q#/io/file_update_fd_init.b#;
$Bh=bless({$j4,$vh,$d5,$e5,$f5,$e5,$g5,$zh,$D,$Ah},$p5);
$Ch={};
$Dh=[];
$Eh=q#print STDERR "destroying file_update_fd\\n";
shift->close;#;
$Fh=bless({$o,$Dh,$q,$Eh,$s,$t},$u);
$Gh=[];
$Hh=q#my $self = shift;
close $$self{wfh} if $$self{wfh};
$$self{writer}->close;
$$self{tempfile}->rename($$self{file}->name);
$self;#;
$Ih=bless({$o,$Gh,$q,$Hh,$s,$t},$u);
$Jh={$ff,$Ih};
$Kh=q#/io/file_update_fd_gc.b#;
$Lh=bless({$j4,$Ch,$d5,$e5,$f5,$Fh,$g5,$Jh,$D,$Kh},$p5);
$Mh=[$Ja,$te,$Ye,$vf,$Bh,$Lh];
$Nh=bless({$j4,$uh,$D,$u2,$U4,$Mh},$s4);
$Oh=q#io/file_update_fd.c::ctors#;
$Ph=q#ni:/io/file_update_fd.c#;
$Qh={$s4,1};
$Rh=q#/io/file_update_fd.c#;
$Sh=[$Fb];
$Th=bless({$j4,$Qh,$D,$Rh,$U4,$Sh},$V4);
$Uh=q#ni:/io/file_update_fd_gc.b#;
$Vh=q#ni:/io/file_update_fd_init.b#;
$Wh=q#ni:/io/mio#;
$Xh={$s6,1};
$Yh={};
$Zh=q#io#;
$ci=[];
$di=q#shift->{'io'}#;
$ei=bless({$o,$ci,$q,$di,$s,$t},$u);
$fi=q#packet_size#;
$gi=[];
$hi=q#shift->{'packet_size'}#;
$ii=bless({$o,$gi,$q,$hi,$s,$t},$u);
$ji={$Zh,$ei,$fi,$ii};
$ki=q#/io/mio_ro.b#;
$li=bless({$j4,$Yh,$d5,$e5,$f5,$e5,$g5,$ji,$D,$ki},$p5);
$mi={};
$ni=[];
$oi=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$pi=bless({$o,$ni,$q,$oi,$s,$t},$u);
$qi={$f6,$pi};
$ri=q#/io/mio_init.b#;
$si=bless({$j4,$mi,$d5,$e5,$f5,$e5,$g5,$qi,$D,$ri},$p5);
$ti={};
$ui=q#next_sender#;
$vi=[];
$wi=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$xi=bless({$o,$vi,$q,$wi,$s,$t},$u);
$yi={$ui,$xi};
$zi=q#/io/mio_rr_scheduler.b#;
$Ai=bless({$j4,$ti,$d5,$e5,$f5,$e5,$g5,$yi,$D,$zi},$p5);
$Bi={};
$Ci=[];
$Di=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$Ei=bless({$o,$Ci,$q,$Di,$s,$t},$u);
$Fi=[];
$Gi=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$Hi=bless({$o,$Fi,$q,$Gi,$s,$t},$u);
$Ii=[];
$Ji=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
\# TODO#;
$Ki=bless({$o,$Ii,$q,$Ji,$s,$t},$u);
$Li={$ff,$Ei,$Ta,$Hi,$db,$Ki};
$Mi=q#/io/mio_io.b#;
$Ni=bless({$j4,$Bi,$d5,$e5,$f5,$e5,$g5,$Li,$D,$Mi},$p5);
$Oi={};
$Pi=q#channel#;
$Qi=[];
$Ri=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$Si=bless({$o,$Qi,$q,$Ri,$s,$t},$u);
$Ti=q#channels#;
$Ui=[];
$Vi=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$Wi=bless({$o,$Ui,$q,$Vi,$s,$t},$u);
$Xi=q#unchannel#;
$Yi=[];
$Zi=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$cj=bless({$o,$Yi,$q,$Zi,$s,$t},$u);
$dj={$Pi,$Si,$Ti,$Wi,$Xi,$cj};
$ej=q#/io/mio_channel.b#;
$fj=bless({$j4,$Oi,$d5,$e5,$f5,$e5,$g5,$dj,$D,$ej},$p5);
$gj=[$Ja,$li,$si,$Ai,$Ni,$fj];
$hj=bless({$j4,$Xh,$D,$D2,$U4,$gj},$t4);
$ij=q#io/mio.c::ctors#;
$jj=q#ni:/io/mio.c#;
$kj={$t4,1};
$lj=q#/io/mio.c#;
$mj=[$Fb];
$nj=bless({$j4,$kj,$D,$lj,$U4,$mj},$V4);
$oj=q#ni:/io/mio_channel#;
$pj={$t6,1};
$qj={};
$rj=q#capacity#;
$sj=[];
$tj=q#shift->{'capacity'}#;
$uj=bless({$o,$sj,$q,$tj,$s,$t},$u);
$vj=q#id#;
$wj=[];
$xj=q#shift->{'id'}#;
$yj=bless({$o,$wj,$q,$xj,$s,$t},$u);
$zj=q#mio#;
$Aj=[];
$Bj=q#shift->{'mio'}#;
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj={$rj,$uj,$vj,$yj,$zj,$Cj};
$Ej=q#/io/mio_channel_ro.b#;
$Fj=bless({$j4,$qj,$d5,$e5,$f5,$e5,$g5,$Dj,$D,$Ej},$p5);
$Gj={};
$Hj=[];
$Ij=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Jj=bless({$o,$Hj,$q,$Ij,$s,$t},$u);
$Kj={$f6,$Jj};
$Lj=q#/io/mio_channel_init.b#;
$Mj=bless({$j4,$Gj,$d5,$e5,$f5,$e5,$g5,$Kj,$D,$Lj},$p5);
$Nj={};
$Oj=[];
$Pj=bless({$o,$Oj,$q,$df,$s,$t},$u);
$Qj={};
$Rj=q#/io/mio_channel_lifecycle.b#;
$Sj=bless({$j4,$Nj,$d5,$e5,$f5,$Pj,$g5,$Qj,$D,$Rj},$p5);
$Tj={};
$Uj=[];
$Vj=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$Wj=bless({$o,$Uj,$q,$Vj,$s,$t},$u);
$Xj=[];
$Yj=q#shift->{read_buffer} ->read(@_)#;
$Zj=bless({$o,$Xj,$q,$Yj,$s,$t},$u);
$ck=[];
$dk=q#shift->{write_buffer}->write(@_)#;
$ek=bless({$o,$ck,$q,$dk,$s,$t},$u);
$fk={$ff,$Wj,$Ta,$Zj,$db,$ek};
$gk=q#/io/mio_channel_io.b#;
$hk=bless({$j4,$Tj,$d5,$e5,$f5,$e5,$g5,$fk,$D,$gk},$p5);
$ik=[$Ja,$Fj,$Mj,$Sj,$hk];
$jk=bless({$j4,$pj,$D,$J2,$U4,$ik},$u4);
$kk=q#io/mio_channel.c::ctors#;
$lk=q#ni:/io/mio_channel.b#;
$mk=q#ni:/io/mio_channel.c#;
$nk={$u4,1};
$ok=q#/io/mio_channel.c#;
$pk=[$Fb];
$qk=bless({$j4,$nk,$D,$ok,$U4,$pk},$V4);
$rk=q#ni:/io/mio_channel_init.b#;
$sk=q#ni:/io/mio_channel_io.b#;
$tk=q#ni:/io/mio_channel_lifecycle.b#;
$uk=q#ni:/io/mio_channel_ro.b#;
$vk=q#ni:/io/mio_init.b#;
$wk=q#ni:/io/mio_io.b#;
$xk=q#ni:/io/mio_ro.b#;
$yk=q#ni:/io/mio_rr_scheduler.b#;
$zk=q#ni:/io/named_io_fns.b#;
$Ak={};
$Bk=q#fcntl#;
$Ck=[];
$Dk=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Ek=bless({$o,$Ck,$q,$Dk,$s,$t},$u);
$Fk=[];
$Gk=q#CORE::fork#;
$Hk=bless({$o,$Fk,$q,$Gk,$s,$t},$u);
$Ik=q#open2#;
$Jk=[];
$Kk=q#CORE::open $_[0], $_[1]#;
$Lk=bless({$o,$Jk,$q,$Kk,$s,$t},$u);
$Mk=q#waitpid#;
$Nk=[];
$Ok=q#CORE::waitpid $_[0], $_[1]#;
$Pk=bless({$o,$Nk,$q,$Ok,$s,$t},$u);
$Qk={$Bk,$Ek,$Kd,$Hk,$Ik,$Lk,$Mk,$Pk};
$Rk=q#/io/named_io_fns.b#;
$Sk=bless({$j4,$Ak,$d5,$e5,$f5,$e5,$g5,$Qk,$D,$Rk},$p5);
$Tk=q#main#;
$Uk=q#ni:/io/null#;
$Vk={$u6,1};
$Wk=q#/io/null#;
$Xk={};
$Yk=[];
$Zk=q#+{fd => undef}#;
$cl=bless({$o,$Yk,$q,$Zk,$s,$t},$u);
$dl={$f6,$cl};
$el=q#/io/null_init.b#;
$fl=bless({$j4,$Xk,$d5,$e5,$f5,$e5,$g5,$dl,$D,$el},$p5);
$gl={};
$hl=[];
$il=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$jl=bless({$o,$hl,$q,$il,$s,$t},$u);
$kl=[];
$ll=q#shift->fd->read(@_)#;
$ml=bless({$o,$kl,$q,$ll,$s,$t},$u);
$nl=[];
$ol=q#shift->fd->write(@_)#;
$pl=bless({$o,$nl,$q,$ol,$s,$t},$u);
$ql={$ed,$jl,$Ta,$ml,$db,$pl};
$rl=q#/io/null_io.b#;
$sl=bless({$j4,$gl,$d5,$e5,$f5,$e5,$g5,$ql,$D,$rl},$p5);
$tl=[$Ja,$fl,$sl];
$ul=bless({$j4,$Vk,$D,$Wk,$U4,$tl},$v4);
$vl=q#io/null.c::ctors#;
$wl=q#ni:/io/null.c#;
$xl={$v4,1};
$yl=q#/io/null.c#;
$zl=[$Fb];
$Al=bless({$j4,$xl,$D,$yl,$U4,$zl},$V4);
$Bl=q#ni:/io/null_init.b#;
$Cl=q#ni:/io/null_io.b#;
$Dl=q#ni:/io/object#;
$El=q#ni:/io/object.c#;
$Fl=q#ni:/io/object.c_transfer_def.b#;
$Gl=q#ni:/io/object_checks.b#;
$Hl=q#ni:/io/object_constructors.b#;
$Il=q#ni:/io/object_memory.b#;
$Jl=q#ni:/io/object_ops.b#;
$Kl=q#ni:/io/object_transfer_async.b#;
$Ll=q#ni:/io/object_transfer_sync.b#;
$Ml=q#ni:/io/pid#;
$Nl={$w6,1};
$Ol={};
$Pl=q#pid#;
$Ql=[];
$Rl=q#shift->{'pid'}#;
$Sl=bless({$o,$Ql,$q,$Rl,$s,$t},$u);
$Tl=q#status#;
$Ul=[];
$Vl=q#shift->{'status'}#;
$Wl=bless({$o,$Ul,$q,$Vl,$s,$t},$u);
$Xl={$Pl,$Sl,$Tl,$Wl};
$Yl=q#/io/pid_readers.b#;
$Zl=bless({$j4,$Ol,$d5,$e5,$f5,$e5,$g5,$Xl,$D,$Yl},$p5);
$cm={};
$dm=[];
$em=q#shift->await#;
$fm=bless({$o,$dm,$q,$em,$s,$t},$u);
$gm=[];
$hm=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$im=bless({$o,$gm,$q,$hm,$s,$t},$u);
$jm={$f6,$im};
$km=q#/io/pid_init.b#;
$lm=bless({$j4,$cm,$d5,$e5,$f5,$fm,$g5,$jm,$D,$km},$p5);
$mm={};
$nm=q#await#;
$om=[];
$pm=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$qm=bless({$o,$om,$q,$pm,$s,$t},$u);
$rm=q#running#;
$sm=[];
$tm=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$um=bless({$o,$sm,$q,$tm,$s,$t},$u);
$vm={$nm,$qm,$rm,$um};
$wm=q#/io/pid_wait.b#;
$xm=bless({$j4,$mm,$d5,$e5,$f5,$e5,$g5,$vm,$D,$wm},$p5);
$ym={};
$zm=[];
$Am=q#shift->stdout->read(@_)#;
$Bm=bless({$o,$zm,$q,$Am,$s,$t},$u);
$Cm=[];
$Dm=q#shift->stdin->write(@_)#;
$Em=bless({$o,$Cm,$q,$Dm,$s,$t},$u);
$Fm={$Ta,$Bm,$db,$Em};
$Gm=q#/io/pid_io.b#;
$Hm=bless({$j4,$ym,$d5,$e5,$f5,$e5,$g5,$Fm,$D,$Gm},$p5);
$Im={};
$Jm=[];
$Km=q#$_[0]->{external_fds}{$_[1]}#;
$Lm=bless({$o,$Jm,$q,$Km,$s,$t},$u);
$Mm=[];
$Nm=q#shift->fd(2)#;
$Om=bless({$o,$Mm,$q,$Nm,$s,$t},$u);
$Pm=[];
$Qm=q#shift->fd(0)#;
$Rm=bless({$o,$Pm,$q,$Qm,$s,$t},$u);
$Sm=[];
$Tm=q#shift->fd(1)#;
$Um=bless({$o,$Sm,$q,$Tm,$s,$t},$u);
$Vm={$ed,$Lm,$id,$Om,$md,$Rm,$qd,$Um};
$Wm=q#/io/pid_accessors.b#;
$Xm=bless({$j4,$Im,$d5,$e5,$f5,$e5,$g5,$Vm,$D,$Wm},$p5);
$Ym=[$Ja,$Zl,$lm,$xm,$Hm,$Xm];
$Zm=bless({$j4,$Nl,$D,$Z2,$U4,$Ym},$x4);
$cn=q#io/pid.c::ctors#;
$dn=q#ni:/io/pid.c#;
$en={$x4,1};
$fn=q#/io/pid.c#;
$gn=[$Fb];
$hn=bless({$j4,$en,$D,$fn,$U4,$gn},$V4);
$in=q#ni:/io/pid_accessors.b#;
$jn=q#ni:/io/pid_init.b#;
$kn=q#ni:/io/pid_io.b#;
$ln=q#ni:/io/pid_readers.b#;
$mn=q#ni:/io/pid_wait.b#;
$nn=q#ni:/io/str#;
$on={$x6,1};
$pn=q#/io/str#;
$qn={};
$rn=q#data#;
$sn=[];
$tn=q#shift->{'data'}#;
$un=bless({$o,$sn,$q,$tn,$s,$t},$u);
$vn=q#end#;
$wn=[];
$xn=q#shift->{'end'}#;
$yn=bless({$o,$wn,$q,$xn,$s,$t},$u);
$zn=q#start#;
$An=[];
$Bn=q#shift->{'start'}#;
$Cn=bless({$o,$An,$q,$Bn,$s,$t},$u);
$Dn={$rn,$un,$vn,$yn,$zn,$Cn};
$En=q#/io/str_ro.b#;
$Fn=bless({$j4,$qn,$d5,$e5,$f5,$e5,$g5,$Dn,$D,$En},$p5);
$Gn={};
$Hn=[];
$In=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Jn=bless({$o,$Hn,$q,$In,$s,$t},$u);
$Kn={$f6,$Jn};
$Ln=q#/io/str_init.b#;
$Mn=bless({$j4,$Gn,$d5,$e5,$f5,$e5,$g5,$Kn,$D,$Ln},$p5);
$Nn={};
$On=[];
$Pn=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Qn=bless({$o,$On,$q,$Pn,$s,$t},$u);
$Rn=q#remaining#;
$Sn=[];
$Tn=q#my $self = shift; $$self{end} - $$self{start}#;
$Un=bless({$o,$Sn,$q,$Tn,$s,$t},$u);
$Vn=[];
$Wn=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Xn=bless({$o,$Vn,$q,$Wn,$s,$t},$u);
$Yn={$Ta,$Qn,$Rn,$Un,$db,$Xn};
$Zn=q#/io/str_io.b#;
$co=bless({$j4,$Nn,$d5,$e5,$f5,$e5,$g5,$Yn,$D,$Zn},$p5);
$do=[$Ja,$Fn,$Mn,$co];
$eo=bless({$j4,$on,$D,$pn,$U4,$do},$y4);
$fo=q#io/str.c::ctors#;
$go=q#ni:/io/str.c#;
$ho={$y4,1};
$io=q#/io/str.c#;
$jo=[$Fb];
$ko=bless({$j4,$ho,$D,$io,$U4,$jo},$V4);
$lo=q#ni:/io/str_init.b#;
$mo=q#ni:/io/str_io.b#;
$no=q#ni:/io/str_ro.b#;
$oo=q#ni:/io/transfer#;
$po={$y6,1,$z6,1,$A6,1};
$qo=q#/io/transfer#;
$ro={$y6,1,$z6,1,$A6,1,$I6,1};
$so=q#/semantic/task#;
$to={};
$uo=q#outcome#;
$vo=[];
$wo=q#shift->{'outcome'}#;
$xo=bless({$o,$vo,$q,$wo,$s,$t},$u);
$yo={$uo,$xo};
$zo=q#/semantic/task_ro.b#;
$Ao=bless({$j4,$to,$d5,$e5,$f5,$e5,$g5,$yo,$D,$zo},$p5);
$Bo={};
$Co=q#failure#;
$Do=[];
$Eo=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go=q#success#;
$Ho=[];
$Io=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Jo=bless({$o,$Ho,$q,$Io,$s,$t},$u);
$Ko={$Co,$Fo,$Go,$Jo};
$Lo=q#/semantic/task_outcome.b#;
$Mo=bless({$j4,$Bo,$d5,$e5,$f5,$e5,$g5,$Ko,$D,$Lo},$p5);
$No=[$S6,$Ao,$Mo];
$Oo=bless({$j4,$ro,$D,$so,$U4,$No},$S4);
$Po=q#semantic/task.c::ctors#;
$Qo={};
$Ro=[];
$So=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$To=bless({$o,$Ro,$q,$So,$s,$t},$u);
$Uo=[];
$Vo=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo=[];
$Yo=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp={$Ta,$Wo,$db,$Zo};
$dp=q#/io/transfer_io_interop.b#;
$ep=bless({$j4,$Qo,$d5,$To,$f5,$e5,$g5,$cp,$D,$dp},$p5);
$fp={};
$gp=q#pressure#;
$hp=[];
$ip=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$jp=bless({$o,$hp,$q,$ip,$s,$t},$u);
$kp=q#read_limit_throughput#;
$lp=[];
$mp=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$np=bless({$o,$lp,$q,$mp,$s,$t},$u);
$op=q#throughput#;
$pp=[];
$qp=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$rp=bless({$o,$pp,$q,$qp,$s,$t},$u);
$sp=q#write_limit_throughput#;
$tp=[];
$up=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={$gp,$jp,$kp,$np,$op,$rp,$sp,$vp};
$xp=q#/io/transfer_io_measurement.b#;
$yp=bless({$j4,$fp,$d5,$e5,$f5,$e5,$g5,$wp,$D,$xp},$p5);
$zp=[$Oo,$ep,$yp];
$Ap=bless({$j4,$po,$D,$qo,$U4,$zp},$z4);
$Bp=q#io/transfer.c::ctors#;
$Cp=q#ni:/io/transfer.c#;
$Dp={$z4,1,$A4,1,$B4,1};
$Ep=q#/io/transfer.c#;
$Fp={$z4,1,$A4,1,$B4,1,$S4,1};
$Gp=q#/semantic/task.c#;
$Hp=[$F8];
$Ip=bless({$j4,$Fp,$D,$Gp,$U4,$Hp},$V4);
$Jp={};
$Kp=[];
$Lp=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$Mp=bless({$o,$Kp,$q,$Lp,$s,$t},$u);
$Np={};
$Op=q#/io/transfer.c_into.b#;
$Pp=bless({$j4,$Jp,$d5,$Mp,$f5,$e5,$g5,$Np,$D,$Op},$p5);
$Qp=[$Ip,$Pp];
$Rp=bless({$j4,$Dp,$D,$Ep,$U4,$Qp},$V4);
$Sp=q#ni:/io/transfer.c_into.b#;
$Tp=q#ni:/io/transfer_async#;
$Up={$z6,1};
$Vp=q#/io/transfer_async#;
$Wp={};
$Xp=q#dest_io#;
$Yp=[];
$Zp=q#shift->{'dest_io'}#;
$cq=bless({$o,$Yp,$q,$Zp,$s,$t},$u);
$dq=[];
$eq=bless({$o,$dq,$q,$xj,$s,$t},$u);
$fq=q#source_io#;
$gq=[];
$hq=q#shift->{'source_io'}#;
$iq=bless({$o,$gq,$q,$hq,$s,$t},$u);
$jq={$Xp,$cq,$vj,$eq,$fq,$iq};
$kq=q#/io/transfer_async_ro.b#;
$lq=bless({$j4,$Wp,$d5,$e5,$f5,$e5,$g5,$jq,$D,$kq},$p5);
$mq={};
$nq=[];
$oq=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$pq=bless({$o,$nq,$q,$oq,$s,$t},$u);
$qq={$f6,$pq};
$rq=q#/io/transfer_async_init.b#;
$sq=bless({$j4,$mq,$d5,$e5,$f5,$e5,$g5,$qq,$D,$rq},$p5);
$tq={};
$uq=[];
$vq=q#ni('ni:/io/transfer_async')->track(shift)#;
$wq=bless({$o,$uq,$q,$vq,$s,$t},$u);
$xq=[];
$yq=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$zq=bless({$o,$xq,$q,$yq,$s,$t},$u);
$Aq={};
$Bq=q#/io/transfer_async_lifecycle.b#;
$Cq=bless({$j4,$tq,$d5,$wq,$f5,$zq,$g5,$Aq,$D,$Bq},$p5);
$Dq={};
$Eq=q#run#;
$Fq=[];
$Gq=q#shift#;
$Hq=bless({$o,$Fq,$q,$Gq,$s,$t},$u);
$Iq=q#run_async#;
$Jq=[];
$Kq=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Lq=bless({$o,$Jq,$q,$Kq,$s,$t},$u);
$Mq={$Eq,$Hq,$Iq,$Lq};
$Nq=q#/io/transfer_async_run.b#;
$Oq=bless({$j4,$Dq,$d5,$e5,$f5,$e5,$g5,$Mq,$D,$Nq},$p5);
$Pq=[$Ap,$lq,$sq,$Cq,$Oq];
$Qq=q#tracked_transfers#;
$Rq={};
$Sq=q#transfer_id#;
$Tq=bless({$j4,$Up,$D,$Vp,$U4,$Pq,$Qq,$Rq,$Sq,0},$A4);
$Uq=q#io/transfer_async.c::ctors#;
$Vq=q#ni:/io/transfer_async.c#;
$Wq={$A4,1};
$Xq=q#/io/transfer_async.c#;
$Yq={};
$Zq=[];
$cr=q#my $self = shift;
$$self{tracked_transfers} = {};
$$self{transfer_id}       = 0;#;
$dr=bless({$o,$Zq,$q,$cr,$s,$t},$u);
$er=q#new_id#;
$fr=[];
$gr=q#++shift->{transfer_id}#;
$hr=bless({$o,$fr,$q,$gr,$s,$t},$u);
$ir=q#track#;
$jr=[];
$kr=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$lr=bless({$o,$jr,$q,$kr,$s,$t},$u);
$mr=q#untrack#;
$nr=[];
$or=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$pr=bless({$o,$nr,$q,$or,$s,$t},$u);
$qr={$er,$hr,$ir,$lr,$mr,$pr};
$rr=q#/io/transfer_async.c_tracker.b#;
$sr=bless({$j4,$Yq,$d5,$dr,$f5,$e5,$g5,$qr,$D,$rr},$p5);
$tr=[$Rp,$sr];
$ur=bless({$j4,$Wq,$D,$Xq,$U4,$tr},$V4);
$vr=q#ni:/io/transfer_async.c_tracker.b#;
$wr=q#ni:/io/transfer_async_init.b#;
$xr=q#ni:/io/transfer_async_lifecycle.b#;
$yr=q#ni:/io/transfer_async_ro.b#;
$zr=q#ni:/io/transfer_async_run.b#;
$Ar=q#ni:/io/transfer_io_interop.b#;
$Br=q#ni:/io/transfer_io_measurement.b#;
$Cr=q#ni:/io/transfer_sync#;
$Dr={$A6,1};
$Er=q#/io/transfer_sync#;
$Fr={};
$Gr=[];
$Hr=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Ir=bless({$o,$Gr,$q,$Hr,$s,$t},$u);
$Jr={$f6,$Ir};
$Kr=q#/io/transfer_sync_init.b#;
$Lr=bless({$j4,$Fr,$d5,$e5,$f5,$e5,$g5,$Jr,$D,$Kr},$p5);
$Mr={};
$Nr=[];
$Or=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Pr=bless({$o,$Nr,$q,$Or,$s,$t},$u);
$Qr={$Eq,$Pr};
$Rr=q#/io/transfer_sync_run.b#;
$Sr=bless({$j4,$Mr,$d5,$e5,$f5,$e5,$g5,$Qr,$D,$Rr},$p5);
$Tr=[$Ap,$Lr,$Sr];
$Ur=bless({$j4,$Dr,$D,$Er,$U4,$Tr},$B4);
$Vr=q#io/transfer_sync.c::ctors#;
$Wr=q#ni:/io/transfer_sync.c#;
$Xr={$B4,1};
$Yr=q#/io/transfer_sync.c#;
$Zr=[$Rp];
$cs=bless({$j4,$Xr,$D,$Yr,$U4,$Zr},$V4);
$ds=q#ni:/io/transfer_sync_init.b#;
$es=q#ni:/io/transfer_sync_run.b#;
$fs=q#ni:/lib/accessor.b#;
$gs=q#ni:/lib/behavior#;
$hs=q#ni:/lib/behavior.c#;
$is=q#ni:/lib/branch#;
$js={$r5,1};
$ks=q#/lib/branch#;
$ls={};
$ms=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$ns=bless({$q,$ms,$s,$t},$u);
$os={$f6,$ns};
$ps=q#/lib/branch_init.b#;
$qs=bless({$j4,$ls,$d5,$e5,$f5,$e5,$g5,$os,$D,$ps},$p5);
$rs=[$f7,$A5,$q5,$qs,$W7];
$ss=bless({$j4,$js,$D,$ks,$U4,$rs},$D4);
$ts=q#lib/branch.c::ctors#;
$us=q#ni:/lib/branch.b#;
$vs=q#ni:/lib/branch.c#;
$ws={$D4,1};
$xs=q#/lib/branch.c#;
$ys=[$K8];
$zs=bless({$j4,$ws,$D,$xs,$U4,$ys},$V4);
$As=q#ni:/lib/branch_init.b#;
$Bs=q#ni:/lib/class_init.b#;
$Cs=q#ni:/lib/dataslice#;
$Ds={$C6,1};
$Es=q#/lib/dataslice#;
$Fs={};
$Gs=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Hs=bless({$q,$Gs,$s,$t},$u);
$Is={$f6,$Hs};
$Js=q#/lib/dataslice_init.b#;
$Ks=bless({$j4,$Fs,$d5,$e5,$f5,$e5,$g5,$Is,$D,$Js},$p5);
$Ls={};
$Ms=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Ns=bless({$q,$Ms,$s,$t},$u);
$Os={$k5,$Ns};
$Ps=q#/lib/dataslice_apply.b#;
$Qs=bless({$j4,$Ls,$d5,$e5,$f5,$e5,$g5,$Os,$D,$Ps},$p5);
$Rs=[$f7,$Ks,$Qs];
$Ss=bless({$j4,$Ds,$D,$Es,$U4,$Rs},$E4);
$Ts=q#lib/dataslice.c::ctors#;
$Us=q#ni:/lib/dataslice.c#;
$Vs={$E4,1};
$Ws=q#/lib/dataslice.c#;
$Xs=[$K8];
$Ys=bless({$j4,$Vs,$D,$Ws,$U4,$Xs},$V4);
$Zs=q#ni:/lib/dataslice_apply.b#;
$ct=q#ni:/lib/dataslice_init.b#;
$dt=q#ni:/lib/definition.b#;
$et=q#ni:/lib/definition_def.b#;
$ft=q#ni:/lib/definition_defdata.b#;
$gt=q#ni:/lib/doc#;
$ht={$F,1};
$it={};
$jt=q#shift; +{name => shift, doc => []}#;
$kt=bless({$q,$jt,$s,$t},$u);
$lt={$f6,$kt};
$mt=q#/lib/doc_init.b#;
$nt=bless({$j4,$it,$d5,$e5,$f5,$e5,$g5,$lt,$D,$mt},$p5);
$ot={};
$pt=q#'ni.doc'#;
$qt=bless({$q,$pt,$s,$t},$u);
$rt={$D5,$qt};
$st=q#/lib/doc_namespace.b#;
$tt=bless({$j4,$ot,$d5,$e5,$f5,$e5,$g5,$rt,$D,$st},$p5);
$ut={};
$vt=q#AUTOLOAD#;
$wt=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$xt=bless({$q,$wt,$s,$t},$u);
$yt={$vt,$xt};
$zt=q#/lib/doc_define.b#;
$At=bless({$j4,$ut,$d5,$e5,$f5,$e5,$g5,$yt,$D,$zt},$p5);
$Bt={};
$Ct=q#shift->referent#;
$Dt=bless({$q,$Ct,$s,$t},$u);
$Et=q#referent#;
$Ft=q#ni 'ni:' . shift->{name}#;
$Gt=bless({$q,$Ft,$s,$t},$u);
$Ht={$vn,$Dt,$Et,$Gt};
$It=q#/lib/doc_end.b#;
$Jt=bless({$j4,$Bt,$d5,$e5,$f5,$e5,$g5,$Ht,$D,$It},$p5);
$Kt={};
$Lt=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Mt=bless({$q,$Lt,$s,$t},$u);
$Nt=q#linearized#;
$Ot=q#map @$_, @{shift->{doc}}#;
$Pt=bless({$q,$Ot,$s,$t},$u);
$Qt=q#tests#;
$Rt=q#my $self = shift;
my @flattened = $self->linearized;
return () unless @flattened;
my @eg_indexes = grep $flattened[$_] eq 'eg', 0..$\#flattened;
for (@eg_indexes) {
  ++$_ until $_ > @flattened or ref $flattened[$_] eq 'lib/fn';
}
@flattened[@eg_indexes];#;
$St=bless({$q,$Rt,$s,$t},$u);
$Tt={$n,$Mt,$Nt,$Pt,$Qt,$St};
$Ut=q#/lib/doc_test.b#;
$Vt=bless({$j4,$Kt,$d5,$e5,$f5,$e5,$g5,$Tt,$D,$Ut},$p5);
$Wt=[$S6,$A5,$nt,$tt,$At,$Jt,$Vt];
$Xt=bless({$j4,$ht,$D,$y3,$U4,$Wt},$F4);
$Yt=q#lib/doc.c::ctors#;
$Zt=q#ni:/lib/doc.c#;
$cu={$F4,1};
$du=q#/lib/doc.c#;
$eu=[$F8];
$fu=bless({$j4,$cu,$D,$du,$U4,$eu},$V4);
$gu=q#ni:/lib/doc_define.b#;
$hu=q#ni:/lib/doc_end.b#;
$iu=q#ni:/lib/doc_init.b#;
$ju=q#ni:/lib/doc_namespace.b#;
$ku=q#ni:/lib/doc_test.b#;
$lu=q#ni:/lib/documentable.b#;
$mu=q#ni:/lib/fn#;
$nu={$u,1};
$ou=q#/lib/fn#;
$pu={};
$qu=q#shift->compile#;
$ru=bless({$q,$qu,$s,$t},$u);
$su=q#compile#;
$tu=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$uu=bless({$q,$tu,$s,$t},$u);
$vu=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$wu=bless({$q,$vu,$s,$t},$u);
$xu={$su,$uu,$f6,$wu};
$yu=q#/lib/fn_init.b#;
$zu=bless({$j4,$pu,$d5,$ru,$f5,$e5,$g5,$xu,$D,$yu},$p5);
$Au={};
$Bu=[];
$Cu=q#shift->{'annotations'}#;
$Du=bless({$o,$Bu,$q,$Cu,$s,$t},$u);
$Eu=[];
$Fu=q#shift->{'code'}#;
$Gu=bless({$o,$Eu,$q,$Fu,$s,$t},$u);
$Hu=q#fn#;
$Iu=[];
$Ju=q#shift->{'fn'}#;
$Ku=bless({$o,$Iu,$q,$Ju,$s,$t},$u);
$Lu={$o,$Du,$q,$Gu,$Hu,$Ku};
$Mu=q#/lib/fn_ro.b#;
$Nu=bless({$j4,$Au,$d5,$e5,$f5,$e5,$g5,$Lu,$D,$Mu},$p5);
$Ou={};
$Pu=[];
$Qu=q#shift->{code}#;
$Ru=bless({$o,$Pu,$q,$Qu,$s,$t},$u);
$Su=[];
$Tu=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Uu=bless({$o,$Su,$q,$Tu,$s,$t},$u);
$Vu={$B7,$Ru,$I7,$Uu};
$Wu=q#/lib/fn_ops.b#;
$Xu=bless({$j4,$Ou,$d5,$e5,$f5,$e5,$g5,$Vu,$D,$Wu},$p5);
$Yu={};
$Zu=q#serialize#;
$cv=[];
$dv=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$ev=bless({$o,$cv,$q,$dv,$s,$t},$u);
$fv={$Zu,$ev};
$gv=q#/lib/fn_serialize.b#;
$hv=bless({$j4,$Yu,$d5,$e5,$f5,$e5,$g5,$fv,$D,$gv},$p5);
$iv=[$S6,$m8,$zu,$Nu,$Xu,$hv];
$jv=bless({$j4,$nu,$D,$ou,$U4,$iv},$G4);
$kv=q#lib/fn.c::ctors#;
$lv=q#ni:/lib/fn.c#;
$mv={$G4,1};
$nv=q#/lib/fn.c#;
$ov=[$F8];
$pv=bless({$j4,$mv,$D,$nv,$U4,$ov},$V4);
$qv=q#ni:/lib/fn_init.b#;
$rv=q#ni:/lib/fn_ops.b#;
$sv=q#ni:/lib/fn_ro.b#;
$tv=q#ni:/lib/fn_serialize.b#;
$uv=q#ni:/lib/gensym_generator_compact.b#;
$vv={};
$wv=q#gensym#;
$xv=[];
$yv=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$zv=bless({$o,$xv,$q,$yv,$s,$t},$u);
$Av={$wv,$zv};
$Bv=q#/lib/gensym_generator_compact.b#;
$Cv=bless({$j4,$vv,$d5,$e5,$f5,$e5,$g5,$Av,$D,$Bv},$p5);
$Dv=q#ni:/lib/global_static_test.b#;
$Ev={};
$Fv=q#now#;
$Gv=[];
$Hv=q#ni('ni:/lib/test_value')->new(shift)#;
$Iv=q#($)#;
$Jv=bless({$o,$Gv,$q,$Hv,$s,$Iv},$u);
$Kv={$Fv,$Jv};
$Lv=q#/lib/global_static_test.b#;
$Mv=bless({$j4,$Ev,$d5,$e5,$f5,$e5,$g5,$Kv,$D,$Lv},$p5);
$Nv=q#ni:/lib/image#;
$Ov={$D6,1};
$Pv={};
$Qv=[];
$Rv=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Sv=bless({$o,$Qv,$q,$Rv,$s,$t},$u);
$Tv={$f6,$Sv};
$Uv=q#/lib/image_init.b#;
$Vv=bless({$j4,$Pv,$d5,$e5,$f5,$e5,$g5,$Tv,$D,$Uv},$p5);
$Wv={};
$Xv=q#address#;
$Yv=[];
$Zv=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$cw=bless({$o,$Yv,$q,$Zv,$s,$t},$u);
$dw=q#allocate_gensym#;
$ew=[];
$fw=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$gw=bless({$o,$ew,$q,$fw,$s,$t},$u);
$hw=q#boot_side_effect#;
$iw=[];
$jw=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$kw=bless({$o,$iw,$q,$jw,$s,$t},$u);
$lw=q#circular_links#;
$mw=[];
$nw=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$ow=bless({$o,$mw,$q,$nw,$s,$t},$u);
$pw=q#finalizer#;
$qw=[];
$rw=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$sw=bless({$o,$qw,$q,$rw,$s,$t},$u);
$tw=q#quote#;
$uw=[];
$vw=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$ww=bless({$o,$uw,$q,$vw,$s,$t},$u);
$xw=q#reconstruction#;
$yw=[];
$zw=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Aw=bless({$o,$yw,$q,$zw,$s,$t},$u);
$Bw=q#side_effect#;
$Cw=[];
$Dw=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ew=bless({$o,$Cw,$q,$Dw,$s,$t},$u);
$Fw=[];
$Gw=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$Hw=bless({$o,$Fw,$q,$Gw,$s,$t},$u);
$Iw={$Xv,$cw,$dw,$gw,$hw,$kw,$lw,$ow,$pw,$sw,$tw,$ww,$xw,$Aw,$Bw,$Ew,$db,$Hw};
$Jw=q#/lib/image_quoting.b#;
$Kw=bless({$j4,$Wv,$d5,$e5,$f5,$e5,$g5,$Iw,$D,$Jw},$p5);
$Lw={};
$Mw=q#quote_code#;
$Nw=[];
$Ow=q#shift->die('cannot quote perl CODE refs', shift)#;
$Pw=bless({$o,$Nw,$q,$Ow,$s,$t},$u);
$Qw={$Mw,$Pw};
$Rw=q#/lib/quote_code_fail.b#;
$Sw=bless({$j4,$Lw,$d5,$e5,$f5,$e5,$g5,$Qw,$D,$Rw},$p5);
$Tw={};
$Uw=q#quote_array#;
$Vw=[];
$Ww=q#local $_;
my ($self, $v) = @_;
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Xw=bless({$o,$Vw,$q,$Ww,$s,$t},$u);
$Yw=q#quote_hash#;
$Zw=[];
$cx=q#local $_;
my ($self, $v) = @_;
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$dx=bless({$o,$Zw,$q,$cx,$s,$t},$u);
$ex=q#quote_scalar#;
$fx=[];
$gx=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$hx=bless({$o,$fx,$q,$gx,$s,$t},$u);
$ix=q#quote_scalar_ref#;
$jx=[];
$kx=q#'\\\\' . shift->quote(${$_[0]})#;
$lx=bless({$o,$jx,$q,$kx,$s,$t},$u);
$mx=q#quote_value#;
$nx=[];
$ox=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$px=bless({$o,$nx,$q,$ox,$s,$t},$u);
$qx={$Uw,$Xw,$Yw,$dx,$ex,$hx,$ix,$lx,$mx,$px};
$rx=q#/lib/quote_values.b#;
$sx=bless({$j4,$Tw,$d5,$e5,$f5,$e5,$g5,$qx,$D,$rx},$p5);
$tx={};
$ux=q#quote_blessed#;
$vx=[];
$wx=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$xx=bless({$o,$vx,$q,$wx,$s,$t},$u);
$yx=q#quote_class#;
$zx=[];
$Ax=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Bx=bless({$o,$zx,$q,$Ax,$s,$t},$u);
$Cx=q#quote_object#;
$Dx=[];
$Ex=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . '::ctors') . ';')
  if @{ref($_[0]) . '::ctors'};
$q;#;
$Fx=bless({$o,$Dx,$q,$Ex,$s,$t},$u);
$Gx={$ux,$xx,$yx,$Bx,$Cx,$Fx};
$Hx=q#/lib/quote_objects.b#;
$Ix=bless({$j4,$tx,$d5,$e5,$f5,$e5,$g5,$Gx,$D,$Hx},$p5);
$Jx={};
$Kx=q#circular_arrayref#;
$Lx=[];
$Mx=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$Nx=bless({$o,$Lx,$q,$Mx,$s,$t},$u);
$Ox=q#circular_hashref#;
$Px=[];
$Qx=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$Rx=bless({$o,$Px,$q,$Qx,$s,$t},$u);
$Sx=q#is_circular#;
$Tx=[];
$Ux=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$Vx=bless({$o,$Tx,$q,$Ux,$s,$t},$u);
$Wx={$Kx,$Nx,$Ox,$Rx,$Sx,$Vx};
$Xx=q#/lib/quote_circular_addressed.b#;
$Yx=bless({$j4,$Jx,$d5,$e5,$f5,$e5,$g5,$Wx,$D,$Xx},$p5);
$Zx=[$S6,$Vv,$Kw,$Sw,$sx,$Ix,$Yx,$Cv];
$cy=bless({$j4,$Ov,$D,$G3,$U4,$Zx},$H4);
$dy=q#lib/image.c::ctors#;
$ey=q#ni:/lib/image.c#;
$fy={$H4,1};
$gy=q#/lib/image.c#;
$hy=[$F8];
$iy=bless({$j4,$fy,$D,$gy,$U4,$hy},$V4);
$jy=q#ni:/lib/image_init.b#;
$ky=q#ni:/lib/image_quoting.b#;
$ly=q#ni:/lib/instance.b#;
$my=q#ni:/lib/instantiable.b#;
$ny=q#ni:/lib/json.b#;
$oy={};
$py=q#json_decode#;
$qy=[];
$ry=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$sy=bless({$o,$qy,$q,$ry,$s,$Iv},$u);
$ty=q#json_encode#;
$uy=[];
$vy=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$wy=bless({$o,$uy,$q,$vy,$s,$Iv},$u);
$xy=q#json_escape#;
$yy=[];
$zy=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Ay=bless({$o,$yy,$q,$zy,$s,$Iv},$u);
$By=q#json_unescape#;
$Cy=[];
$Dy=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Ey=bless({$o,$Cy,$q,$Dy,$s,$Iv},$u);
$Fy=q#json_unescape_one#;
$Gy=[];
$Hy=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Iy=bless({$o,$Gy,$q,$Hy,$s,$Iv},$u);
$Jy={$py,$sy,$ty,$wy,$xy,$Ay,$By,$Ey,$Fy,$Iy};
$Ky=q#/lib/json.b#;
$Ly=bless({$j4,$oy,$d5,$e5,$f5,$e5,$g5,$Jy,$D,$Ky},$p5);
$My=q#ni#;
$Ny=q#ni:/lib/name_as_string.b#;
$Oy=q#ni:/lib/named.b#;
$Py=q#ni:/lib/named_in_ni.b#;
$Qy=q#ni:/lib/namespaced.b#;
$Ry=q#ni:/lib/ni#;
$Sy={$E6,1};
$Ty={};
$Uy=q#extend#;
$Vy=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Wy=bless({$q,$Vy,$s,$t},$u);
$Xy=q#is_mutable#;
$Yy=q#$0 ne '-' && -w $0#;
$Zy=bless({$q,$Yy,$s,$t},$u);
$cz=q#modify#;
$dz=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$ez=bless({$q,$dz,$s,$t},$u);
$fz={$Uy,$Wy,$Xy,$Zy,$cz,$ez};
$gz=q#/lib/ni_self.b#;
$hz=bless({$j4,$Ty,$d5,$e5,$f5,$e5,$g5,$fz,$D,$gz},$p5);
$iz={};
$jz=q#--internal/+=#;
$kz=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$lz=bless({$q,$kz,$s,$t},$u);
$mz=q#--internal/eval#;
$nz=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$oz=bless({$q,$nz,$s,$t},$u);
$pz=q#--internal/image#;
$qz=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$rz=bless({$q,$qz,$s,$t},$u);
$sz=q#--internal/test#;
$tz=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$uz=bless({$q,$tz,$s,$t},$u);
$vz=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$wz=bless({$q,$vz,$s,$t},$u);
$xz={$jz,$lz,$mz,$oz,$pz,$rz,$sz,$uz,$Eq,$wz};
$yz=q#/lib/ni_main.b#;
$zz=bless({$j4,$iz,$d5,$e5,$f5,$e5,$g5,$xz,$D,$yz},$p5);
$Az={};
$Bz=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Cz=bless({$q,$Bz,$s,$t},$u);
$Dz=q#resolver_for#;
$Ez=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Fz=bless({$q,$Ez,$s,$t},$u);
$Gz={$R5,$Cz,$Dz,$Fz};
$Hz=q#/lib/ni_resolver.b#;
$Iz=bless({$j4,$Az,$d5,$e5,$f5,$e5,$g5,$Gz,$D,$Hz},$p5);
$Jz={};
$Kz=q#exists#;
$Lz=q#exists $_[0]->{named}{$_[1]}#;
$Mz=bless({$q,$Lz,$s,$t},$u);
$Nz=q#quoted#;
$Oz=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Pz=bless({$q,$Oz,$s,$t},$u);
$Qz={$Kz,$Mz,$Nz,$Pz};
$Rz=q#/lib/ni_image.b#;
$Sz=bless({$j4,$Jz,$d5,$e5,$f5,$e5,$g5,$Qz,$D,$Rz},$p5);
$Tz=[$S6,$hz,$zz,$Iz,$Sz];
$Uz=bless({$j4,$Sy,$D,$O3,$U4,$Tz},$I4);
$Vz=q#lib/ni.c::ctors#;
$Wz=q#ni:/lib/ni.c#;
$Xz={$I4,1};
$Yz=q#/lib/ni.c#;
$Zz=[$F8];
$cA=bless({$j4,$Xz,$D,$Yz,$U4,$Zz},$V4);
$dA=q#ni:/lib/ni_image.b#;
$eA=q#ni:/lib/ni_main.b#;
$fA=q#ni:/lib/ni_resolver.b#;
$gA=q#ni:/lib/ni_self.b#;
$hA=q#ni:/lib/ni_static_util.b#;
$iA={};
$jA=q#abbrev#;
$kA=[];
$lA=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$mA=bless({$o,$kA,$q,$lA,$s,$t},$u);
$nA=q#dor#;
$oA=[];
$pA=q#defined $_[0] ? $_[0] : $_[1]#;
$qA=bless({$o,$oA,$q,$pA,$s,$t},$u);
$rA=q#indent#;
$sA=[];
$tA=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$uA=bless({$o,$sA,$q,$tA,$s,$t},$u);
$vA=q#max#;
$wA=[];
$xA=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$yA=bless({$o,$wA,$q,$xA,$s,$t},$u);
$zA=q#maxstr#;
$AA=[];
$BA=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$CA=bless({$o,$AA,$q,$BA,$s,$t},$u);
$DA=q#mean#;
$EA=[];
$FA=q#sum(@_) / (@_ || 1)#;
$GA=bless({$o,$EA,$q,$FA,$s,$t},$u);
$HA=q#min#;
$IA=[];
$JA=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$KA=bless({$o,$IA,$q,$JA,$s,$t},$u);
$LA=q#minstr#;
$MA=[];
$NA=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$OA=bless({$o,$MA,$q,$NA,$s,$t},$u);
$PA=q#sgr#;
$QA=[];
$RA=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$SA=bless({$o,$QA,$q,$RA,$s,$t},$u);
$TA=q#sr#;
$UA=[];
$VA=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$WA=bless({$o,$UA,$q,$VA,$s,$t},$u);
$XA=q#sum#;
$YA=[];
$ZA=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$cB=bless({$o,$YA,$q,$ZA,$s,$t},$u);
$dB=q#swap#;
$eB=[];
$fB=q#@_[0, 1] = @_[1, 0]#;
$gB=bless({$o,$eB,$q,$fB,$s,$t},$u);
$hB={$jA,$mA,$nA,$qA,$rA,$uA,$vA,$yA,$zA,$CA,$DA,$GA,$HA,$KA,$LA,$OA,$PA,$SA,$TA,$WA,$XA,$cB,$dB,$gB};
$iB=q#/lib/ni_static_util.b#;
$jB=bless({$j4,$iA,$d5,$e5,$f5,$e5,$g5,$hB,$D,$iB},$p5);
$kB=q#ni:/lib/perlbranch.b#;
$lB=q#ni:/lib/quote_circular_addressed.b#;
$mB=q#ni:/lib/quote_code_fail.b#;
$nB=q#ni:/lib/quote_objects.b#;
$oB=q#ni:/lib/quote_simple#;
$pB={$F6,1};
$qB={};
$rB=[];
$sB=q#+{}#;
$tB=bless({$o,$rB,$q,$sB,$s,$t},$u);
$uB={$f6,$tB};
$vB=q#/lib/quote_simple_init.b#;
$wB=bless({$j4,$qB,$d5,$e5,$f5,$e5,$g5,$uB,$D,$vB},$p5);
$xB={};
$yB=[];
$zB=bless({$o,$yB,$q,0,$s,$t},$u);
$AB=[];
$BB=q#shift->quote_value(shift)#;
$CB=bless({$o,$AB,$q,$BB,$s,$t},$u);
$DB={$Sx,$zB,$tw,$CB};
$EB=q#/lib/quote_simple_quote.b#;
$FB=bless({$j4,$xB,$d5,$e5,$f5,$e5,$g5,$DB,$D,$EB},$p5);
$GB=[$S6,$wB,$FB,$Sw,$sx,$Ix];
$HB=bless({$j4,$pB,$D,$Y3,$U4,$GB},$J4);
$IB=q#lib/quote_simple.c::ctors#;
$JB=q#ni:/lib/quote_simple.c#;
$KB={$J4,1};
$LB=q#/lib/quote_simple.c#;
$MB=[$F8];
$NB=bless({$j4,$KB,$D,$LB,$U4,$MB},$V4);
$OB=q#ni:/lib/quote_simple_init.b#;
$PB=q#ni:/lib/quote_simple_quote.b#;
$QB=q#ni:/lib/quote_values.b#;
$RB=q#ni:/lib/ref_eq.b#;
$SB=q#ni:/lib/resolver.b#;
$TB=q#ni:/lib/slice#;
$UB={$p5,1};
$VB=q#/lib/slice#;
$WB=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$XB=bless({$q,$WB,$s,$t},$u);
$YB=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$ZB=bless({$q,$YB,$s,$t},$u);
$cC=q#lib/slice::apply#;
$dC=q#lib/slice::apply_unsafe#;
$eC={};
$fC=q#apply_unsafe#;
$gC={$k5,$XB,$fC,$ZB};
$hC=q#/lib/slice.b#;
$iC=bless({$j4,$eC,$g5,$gC,$D,$hC},$p5);
$jC={};
$kC=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$lC=bless({$q,$kC,$s,$t},$u);
$mC={$f6,$lC};
$nC=q#/lib/slice_init.b#;
$oC=bless({$j4,$jC,$g5,$mC,$D,$nC},$p5);
$pC={};
$qC=[];
$rC=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$sC=bless({$o,$qC,$q,$rC,$s,$t},$u);
$tC={$Zu,$sC};
$uC=q#/lib/slice_serialize.b#;
$vC=bless({$j4,$pC,$d5,$e5,$f5,$e5,$g5,$tC,$D,$uC},$p5);
$wC=[$f7,$A5,$iC,$oC,$vC];
$xC=bless({$j4,$UB,$D,$VB,$U4,$wC},$K4);
$yC=q#lib/slice.c::ctors#;
$zC=q#ni:/lib/slice.b#;
$AC=q#ni:/lib/slice.c#;
$BC={$K4,1};
$CC=q#/lib/slice.c#;
$DC=[$K8];
$EC=bless({$j4,$BC,$D,$CC,$U4,$DC},$V4);
$FC=q#ni:/lib/slice_init.b#;
$GC=q#ni:/lib/slice_serialize.b#;
$HC=q#ni:/lib/static_fn.b#;
$IC={};
$JC=[];
$KC=q#ni('ni:/lib/fn')->new(@_)#;
$LC=bless({$o,$JC,$q,$KC,$s,$Iv},$u);
$MC=q#fp#;
$NC=[];
$OC=q#($$)#;
$PC=bless({$o,$NC,$q,$KC,$s,$OC},$u);
$QC={$Hu,$LC,$MC,$PC};
$RC=q#/lib/static_fn.b#;
$SC=bless({$j4,$IC,$d5,$e5,$f5,$e5,$g5,$QC,$D,$RC},$p5);
$TC=q#ni:/lib/subclass.b#;
$UC=q#ni:/lib/tag#;
$VC={$B5,1};
$WC=q#/lib/tag#;
$XC={};
$YC=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$ZC=bless({$q,$YC,$s,$t},$u);
$cD={$k5,$ZC};
$dD=q#/lib/tag.b#;
$eD=bless({$j4,$XC,$d5,$e5,$f5,$e5,$g5,$cD,$D,$dD},$p5);
$fD={};
$gD=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$hD=bless({$q,$gD,$s,$t},$u);
$iD={$f6,$hD};
$jD=q#/lib/tag_init.b#;
$kD=bless({$j4,$fD,$d5,$e5,$f5,$e5,$g5,$iD,$D,$jD},$p5);
$lD=[$f7,$A5,$eD,$kD];
$mD=bless({$j4,$VC,$D,$WC,$U4,$lD},$L4);
$nD=q#lib/tag.c::ctors#;
$oD=q#ni:/lib/tag.b#;
$pD=q#ni:/lib/tag.c#;
$qD={$L4,1};
$rD=q#/lib/tag.c#;
$sD=[$K8];
$tD=bless({$j4,$qD,$D,$rD,$U4,$sD},$V4);
$uD=q#ni:/lib/tag_init.b#;
$vD=q#ni:/lib/test_value#;
$wD={$G6,1};
$xD=q#/lib/test_value#;
$yD={};
$zD=[];
$AD=q#\\$_[1]#;
$BD=bless({$o,$zD,$q,$AD,$s,$t},$u);
$CD={$f6,$BD};
$DD=q#/lib/test_value_init.b#;
$ED=bless({$j4,$yD,$d5,$e5,$f5,$e5,$g5,$CD,$D,$DD},$p5);
$FD={};
$GD=q#(==#;
$HD=[];
$ID=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$JD=bless({$o,$HD,$q,$ID,$s,$t},$u);
$KD=q#diff#;
$LD=[];
$MD=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]}
    unless !defined($lhs) && !defined($rhs) || $lhs eq $rhs;
}
return undef;#;
$ND=bless({$o,$LD,$q,$MD,$s,$t},$u);
$OD={$GD,$JD,$KD,$ND};
$PD=q#/lib/test_value_eq.b#;
$QD=bless({$j4,$FD,$d5,$e5,$f5,$e5,$g5,$OD,$D,$PD},$p5);
$RD={};
$SD=[];
$TD=q#ni::json_encode ${$_[0]}#;
$UD=bless({$o,$SD,$q,$TD,$s,$t},$u);
$VD={$B7,$UD};
$WD=q#/lib/test_value_str.b#;
$XD=bless({$j4,$RD,$d5,$e5,$f5,$e5,$g5,$VD,$D,$WD},$p5);
$YD=[$S6,$ED,$QD,$XD];
$ZD=bless({$j4,$wD,$D,$xD,$U4,$YD},$M4);
$cE=q#lib/test_value.c::ctors#;
$dE=q#ni:/lib/test_value.c#;
$eE={$M4,1};
$fE=q#/lib/test_value.c#;
$gE=[$F8];
$hE=bless({$j4,$eE,$D,$fE,$U4,$gE},$V4);
$iE=q#ni:/lib/test_value_eq.b#;
$jE=q#ni:/lib/test_value_init.b#;
$kE=q#ni:/lib/test_value_str.b#;
$lE=q#ni:/metaclass#;
$mE={$V4,1};
$nE=q#/metaclass#;
$oE=[$Y5,$m8,$k6,$Z7];
$pE=bless({$j4,$mE,$D,$nE,$U4,$oE},$N4);
$qE=q#metaclass.c::ctors#;
$rE=q#ni:/metaclass.c#;
$sE={$N4,1};
$tE=q#/metaclass.c#;
$uE=[$v8];
$vE=bless({$j4,$sE,$D,$tE,$U4,$uE},$V4);
$wE=q#ni:/module#;
$xE=q#ni:/module.c#;
$yE=q#ni:/object#;
$zE=q#ni:/object.c#;
$AE=q#ni:/semantic/dimension#;
$BE={$Q4,1};
$CE=q#/semantic/dimension#;
$DE=[$v8];
$EE=bless({$j4,$BE,$D,$CE,$U4,$DE},$R4);
$FE=q#semantic/dimension.c::ctors#;
$GE=q#ni:/semantic/dimension.c#;
$HE={$R4,1};
$IE=q#/semantic/dimension.c#;
$JE=[$O8];
$KE=bless({$j4,$HE,$D,$IE,$U4,$JE},$V4);
$LE=q#ni:/semantic/task#;
$ME=q#ni:/semantic/task.c#;
$NE=q#ni:/semantic/task_outcome.b#;
$OE=q#ni:/semantic/task_ro.b#;
$PE=q#ni:main#;
$QE={$Tk,1};
$RE=[$SC,$Mv,$Sk];
$SE=bless({$j4,$QE,$D,$Tk,$U4,$RE},$W4);
$TE=q#module::ctors#;
$UE=q#ni:ni#;
$VE={$My,1};
$WE={$My,1};
$XE=q#json_escapes#;
$YE=q##;
$ZE=q#b#;
$cF=q#	#;
$dF=q#t#;
$eF=q#
#;
$fF=q#n#;
$gF=q##;
$hF=q#"#;
$iF=q#/#;
$jF=q#\\#;
$kF={$YE,$ZE,$cF,$dF,$eF,$fF,$gF,$Mg,$hF,$hF,$iF,$iF,$jF,$jF};
$lF=q#json_unescapes#;
$mF={$hF,$hF,$iF,$iF,$jF,$jF,$ZE,$YE,$fF,$eF,$Mg,$gF,$dF,$cF};
$nF={$XE,$kF,$lF,$mF};
$oF=q#/lib/json_data.b#;
$pF=bless({$j4,$WE,$rn,$nF,$D,$oF},$C6);
$qF=[$pF,$Ly,$jB];
$rF=bless({$j4,$VE,$D,$My,$U4,$qF},$W4);
$sF={$d,$G,$I,$N,$O,$R,$S,$X,$Y,$l1,$m1,$x1,$y1,$J1,$K1,$V1,$W1,$p2,$q2,$v2,$w2,$E2,$F2,$K2,$L2,$c3,$d3,$j3,$k3,$z3,$A3,$H3,$I3,$P3,$Q3,$Z3,$c4,$h4,$i4,$v8,$x8,$O8,$P8,$Z8,$d9,$h9,$i9,$X8,$j9,$pb,$rb,$Hb,$Ib,$Ra,$Jb,$nb,$Kb,$dc,$fc,$jc,$kc,$Sb,$lc,$Zb,$mc,$Wd,$Yd,$ee,$fe,$Ed,$ge,$Ud,$he,$Cc,$ie,$wd,$je,$Wc,$ke,$vc,$le,$xf,$zf,$Df,$Ef,$Ye,$Ff,$lf,$Gf,$Ae,$Hf,$vf,$If,$te,$Jf,$Ie,$Kf,$gh,$ih,$mh,$nh,$cg,$oh,$zg,$ph,$jg,$qh,$eh,$rh,$Sf,$sh,$Hg,$th,$Nh,$Ph,$Th,$Uh,$Lh,$Vh,$Bh,$Wh,$hj,$jj,$nj,$oj,$jk,$lk,$fj,$mk,$qk,$rk,$Mj,$sk,$hk,$tk,$Sj,$uk,$Fj,$vk,$si,$wk,$Ni,$xk,$li,$yk,$Ai,$zk,$Sk,$Uk,$ul,$wl,$Al,$Bl,$fl,$Cl,$sl,$Dl,$Ja,$El,$Fb,$Fl,$Db,$Gl,$N9,$Hl,$V9,$Il,$ja,$Jl,$t9,$Kl,$Ha,$Ll,$va,$Ml,$Zm,$dn,$hn,$in,$Xm,$jn,$lm,$kn,$Hm,$ln,$Zl,$mn,$xm,$nn,$eo,$go,$ko,$lo,$Mn,$mo,$co,$no,$Fn,$oo,$Ap,$Cp,$Rp,$Sp,$Pp,$Tp,$Tq,$Vq,$ur,$vr,$sr,$wr,$sq,$xr,$Cq,$yr,$lq,$zr,$Oq,$Ar,$ep,$Br,$yp,$Cr,$Ur,$Wr,$cs,$ds,$Lr,$es,$Sr,$fs,$z7,$gs,$f7,$hs,$K8,$is,$ss,$us,$q5,$vs,$zs,$As,$qs,$Bs,$k6,$Cs,$Ss,$Us,$Ys,$Zs,$Qs,$ct,$Ks,$dt,$W7,$et,$p7,$ft,$U7,$gt,$Xt,$Zt,$fu,$gu,$At,$hu,$Jt,$iu,$nt,$ju,$tt,$ku,$Vt,$lu,$d7,$mu,$jv,$lv,$pv,$qv,$zu,$rv,$Xu,$sv,$Nu,$tv,$hv,$uv,$Cv,$Dv,$Mv,$Nv,$cy,$ey,$iy,$jy,$Vv,$ky,$Kw,$ly,$Q6,$my,$m8,$ny,$Ly,$Ny,$G7,$Oy,$A5,$Py,$I5,$Qy,$P5,$Ry,$Uz,$Wz,$cA,$dA,$Sz,$eA,$zz,$fA,$Iz,$gA,$hz,$hA,$jB,$kB,$Y5,$lB,$Yx,$mB,$Sw,$nB,$Ix,$oB,$HB,$JB,$NB,$OB,$wB,$PB,$FB,$QB,$sx,$RB,$N7,$SB,$W5,$TB,$xC,$zC,$iC,$AC,$EC,$FC,$oC,$GC,$vC,$HC,$SC,$TC,$t8,$UC,$mD,$oD,$eD,$pD,$tD,$uD,$kD,$vD,$ZD,$dE,$hE,$iE,$QD,$jE,$ED,$kE,$XD,$lE,$pE,$rE,$vE,$wE,$Z7,$xE,$M8,$yE,$S6,$zE,$F8,$AE,$EE,$GE,$KE,$LE,$Oo,$ME,$Ip,$NE,$Mo,$OE,$Ao,$PE,$SE,$UE,$rF};
$tF=q#resolvers#;
$uF=[];
$vF=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$wF=bless({$o,$uF,$q,$vF,$s,$t},$u);
$xF=q#file#;
$yF=[];
$zF=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$AF=bless({$o,$yF,$q,$zF,$s,$t},$u);
$BF=q#null#;
$CF=[];
$DF=q#ni('ni:/io/null')->new#;
$EF=bless({$o,$CF,$q,$DF,$s,$t},$u);
$FF=q#sh#;
$GF=[];
$HF=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$IF=bless({$o,$GF,$q,$HF,$s,$t},$u);
$JF=q#str#;
$KF=[];
$LF=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$MF=bless({$o,$KF,$q,$LF,$s,$t},$u);
$NF={$ed,$wF,$xF,$AF,$BF,$EF,$FF,$IF,$JF,$MF};
$OF=bless({$c,$sF,$tF,$NF},$E6);
*$dC=\&$ZB;
*$cC=\&$XB;
$q5->apply_unsafe($k4);
$q5->apply_unsafe($l4);
$q5->apply_unsafe($m4);
$q5->apply_unsafe($n4);
$q5->apply_unsafe($o4);
$q5->apply_unsafe($p4);
$q5->apply_unsafe($q4);
$q5->apply_unsafe($r4);
$q5->apply_unsafe($s4);
$q5->apply_unsafe($t4);
$q5->apply_unsafe($u4);
$q5->apply_unsafe($v4);
$q5->apply_unsafe($w4);
$q5->apply_unsafe($x4);
$q5->apply_unsafe($y4);
$q5->apply_unsafe($z4);
$q5->apply_unsafe($A4);
$q5->apply_unsafe($B4);
$q5->apply_unsafe($C4);
$q5->apply_unsafe($r5);
$q5->apply_unsafe($D4);
$q5->apply_unsafe($E4);
$q5->apply_unsafe($F4);
$q5->apply_unsafe($G4);
$q5->apply_unsafe($H4);
$q5->apply_unsafe($I4);
$q5->apply_unsafe($J4);
$q5->apply_unsafe($K4);
$q5->apply_unsafe($L4);
$q5->apply_unsafe($M4);
$q5->apply_unsafe($V4);
$q5->apply_unsafe($N4);
$q5->apply_unsafe($W4);
$q5->apply_unsafe($O4);
$q5->apply_unsafe($P4);
$q5->apply_unsafe($Q4);
$q5->apply_unsafe($R4);
$q5->apply_unsafe($S4);
$A5->apply_unsafe($k4);
$A5->apply_unsafe($l4);
$A5->apply_unsafe($m4);
$A5->apply_unsafe($n4);
$A5->apply_unsafe($o4);
$A5->apply_unsafe($p4);
$A5->apply_unsafe($q4);
$A5->apply_unsafe($r4);
$A5->apply_unsafe($s4);
$A5->apply_unsafe($t4);
$A5->apply_unsafe($u4);
$A5->apply_unsafe($v4);
$A5->apply_unsafe($w4);
$A5->apply_unsafe($x4);
$A5->apply_unsafe($y4);
$A5->apply_unsafe($z4);
$A5->apply_unsafe($A4);
$A5->apply_unsafe($B4);
$A5->apply_unsafe($C4);
$A5->apply_unsafe($r5);
$A5->apply_unsafe($D4);
$A5->apply_unsafe($E4);
$A5->apply_unsafe($F);
$A5->apply_unsafe($F4);
$A5->apply_unsafe($G4);
$A5->apply_unsafe($H4);
$A5->apply_unsafe($I4);
$A5->apply_unsafe($J4);
$A5->apply_unsafe($p5);
$A5->apply_unsafe($K4);
$A5->apply_unsafe($B5);
$A5->apply_unsafe($L4);
$A5->apply_unsafe($M4);
$A5->apply_unsafe($V4);
$A5->apply_unsafe($N4);
$A5->apply_unsafe($W4);
$A5->apply_unsafe($O4);
$A5->apply_unsafe($P4);
$A5->apply_unsafe($Q4);
$A5->apply_unsafe($R4);
$A5->apply_unsafe($S4);
$I5->apply_unsafe($k4);
$I5->apply_unsafe($l4);
$I5->apply_unsafe($m4);
$I5->apply_unsafe($n4);
$I5->apply_unsafe($o4);
$I5->apply_unsafe($p4);
$I5->apply_unsafe($q4);
$I5->apply_unsafe($r4);
$I5->apply_unsafe($s4);
$I5->apply_unsafe($t4);
$I5->apply_unsafe($u4);
$I5->apply_unsafe($v4);
$I5->apply_unsafe($w4);
$I5->apply_unsafe($x4);
$I5->apply_unsafe($y4);
$I5->apply_unsafe($z4);
$I5->apply_unsafe($A4);
$I5->apply_unsafe($B4);
$I5->apply_unsafe($C4);
$I5->apply_unsafe($r5);
$I5->apply_unsafe($D4);
$I5->apply_unsafe($E4);
$I5->apply_unsafe($F4);
$I5->apply_unsafe($G4);
$I5->apply_unsafe($H4);
$I5->apply_unsafe($I4);
$I5->apply_unsafe($J4);
$I5->apply_unsafe($p5);
$I5->apply_unsafe($K4);
$I5->apply_unsafe($B5);
$I5->apply_unsafe($L4);
$I5->apply_unsafe($M4);
$I5->apply_unsafe($V4);
$I5->apply_unsafe($N4);
$I5->apply_unsafe($W4);
$I5->apply_unsafe($O4);
$I5->apply_unsafe($P4);
$I5->apply_unsafe($Q4);
$I5->apply_unsafe($R4);
$I5->apply_unsafe($S4);
$P5->apply_unsafe($k4);
$P5->apply_unsafe($l4);
$P5->apply_unsafe($m4);
$P5->apply_unsafe($n4);
$P5->apply_unsafe($o4);
$P5->apply_unsafe($p4);
$P5->apply_unsafe($q4);
$P5->apply_unsafe($r4);
$P5->apply_unsafe($s4);
$P5->apply_unsafe($t4);
$P5->apply_unsafe($u4);
$P5->apply_unsafe($v4);
$P5->apply_unsafe($w4);
$P5->apply_unsafe($x4);
$P5->apply_unsafe($y4);
$P5->apply_unsafe($z4);
$P5->apply_unsafe($A4);
$P5->apply_unsafe($B4);
$P5->apply_unsafe($C4);
$P5->apply_unsafe($r5);
$P5->apply_unsafe($D4);
$P5->apply_unsafe($E4);
$P5->apply_unsafe($F4);
$P5->apply_unsafe($G4);
$P5->apply_unsafe($H4);
$P5->apply_unsafe($I4);
$P5->apply_unsafe($J4);
$P5->apply_unsafe($p5);
$P5->apply_unsafe($K4);
$P5->apply_unsafe($B5);
$P5->apply_unsafe($L4);
$P5->apply_unsafe($M4);
$P5->apply_unsafe($V4);
$P5->apply_unsafe($N4);
$P5->apply_unsafe($W4);
$P5->apply_unsafe($O4);
$P5->apply_unsafe($P4);
$P5->apply_unsafe($Q4);
$P5->apply_unsafe($R4);
$P5->apply_unsafe($S4);
$W5->apply_unsafe($k4);
$W5->apply_unsafe($l4);
$W5->apply_unsafe($m4);
$W5->apply_unsafe($n4);
$W5->apply_unsafe($o4);
$W5->apply_unsafe($p4);
$W5->apply_unsafe($q4);
$W5->apply_unsafe($r4);
$W5->apply_unsafe($s4);
$W5->apply_unsafe($t4);
$W5->apply_unsafe($u4);
$W5->apply_unsafe($v4);
$W5->apply_unsafe($w4);
$W5->apply_unsafe($x4);
$W5->apply_unsafe($y4);
$W5->apply_unsafe($z4);
$W5->apply_unsafe($A4);
$W5->apply_unsafe($B4);
$W5->apply_unsafe($C4);
$W5->apply_unsafe($r5);
$W5->apply_unsafe($D4);
$W5->apply_unsafe($E4);
$W5->apply_unsafe($F4);
$W5->apply_unsafe($G4);
$W5->apply_unsafe($H4);
$W5->apply_unsafe($I4);
$W5->apply_unsafe($J4);
$W5->apply_unsafe($K4);
$W5->apply_unsafe($B5);
$W5->apply_unsafe($L4);
$W5->apply_unsafe($M4);
$W5->apply_unsafe($V4);
$W5->apply_unsafe($N4);
$W5->apply_unsafe($W4);
$W5->apply_unsafe($O4);
$W5->apply_unsafe($P4);
$W5->apply_unsafe($Q4);
$W5->apply_unsafe($R4);
$W5->apply_unsafe($S4);
$k6->apply_unsafe($k4);
$k6->apply_unsafe($l4);
$k6->apply_unsafe($m4);
$k6->apply_unsafe($n4);
$k6->apply_unsafe($o4);
$k6->apply_unsafe($p4);
$k6->apply_unsafe($q4);
$k6->apply_unsafe($r4);
$k6->apply_unsafe($s4);
$k6->apply_unsafe($t4);
$k6->apply_unsafe($u4);
$k6->apply_unsafe($v4);
$k6->apply_unsafe($w4);
$k6->apply_unsafe($x4);
$k6->apply_unsafe($y4);
$k6->apply_unsafe($z4);
$k6->apply_unsafe($A4);
$k6->apply_unsafe($B4);
$k6->apply_unsafe($C4);
$k6->apply_unsafe($D4);
$k6->apply_unsafe($E4);
$k6->apply_unsafe($F4);
$k6->apply_unsafe($G4);
$k6->apply_unsafe($H4);
$k6->apply_unsafe($I4);
$k6->apply_unsafe($J4);
$k6->apply_unsafe($K4);
$k6->apply_unsafe($L4);
$k6->apply_unsafe($M4);
$k6->apply_unsafe($V4);
$k6->apply_unsafe($N4);
$k6->apply_unsafe($W4);
$k6->apply_unsafe($O4);
$k6->apply_unsafe($P4);
$k6->apply_unsafe($Q4);
$k6->apply_unsafe($R4);
$k6->apply_unsafe($S4);
$Q6->apply_unsafe($k4);
$Q6->apply_unsafe($l4);
$Q6->apply_unsafe($l6);
$Q6->apply_unsafe($m4);
$Q6->apply_unsafe($m6);
$Q6->apply_unsafe($n4);
$Q6->apply_unsafe($n6);
$Q6->apply_unsafe($o4);
$Q6->apply_unsafe($o6);
$Q6->apply_unsafe($p4);
$Q6->apply_unsafe($p6);
$Q6->apply_unsafe($q4);
$Q6->apply_unsafe($q6);
$Q6->apply_unsafe($r4);
$Q6->apply_unsafe($r6);
$Q6->apply_unsafe($s4);
$Q6->apply_unsafe($s6);
$Q6->apply_unsafe($t4);
$Q6->apply_unsafe($t6);
$Q6->apply_unsafe($u4);
$Q6->apply_unsafe($u6);
$Q6->apply_unsafe($v4);
$Q6->apply_unsafe($v6);
$Q6->apply_unsafe($w4);
$Q6->apply_unsafe($w6);
$Q6->apply_unsafe($x4);
$Q6->apply_unsafe($x6);
$Q6->apply_unsafe($y4);
$Q6->apply_unsafe($y6);
$Q6->apply_unsafe($z4);
$Q6->apply_unsafe($z6);
$Q6->apply_unsafe($A4);
$Q6->apply_unsafe($A6);
$Q6->apply_unsafe($B4);
$Q6->apply_unsafe($B6);
$Q6->apply_unsafe($C4);
$Q6->apply_unsafe($r5);
$Q6->apply_unsafe($D4);
$Q6->apply_unsafe($C6);
$Q6->apply_unsafe($E4);
$Q6->apply_unsafe($F);
$Q6->apply_unsafe($F4);
$Q6->apply_unsafe($u);
$Q6->apply_unsafe($G4);
$Q6->apply_unsafe($D6);
$Q6->apply_unsafe($H4);
$Q6->apply_unsafe($E6);
$Q6->apply_unsafe($I4);
$Q6->apply_unsafe($F6);
$Q6->apply_unsafe($J4);
$Q6->apply_unsafe($p5);
$Q6->apply_unsafe($K4);
$Q6->apply_unsafe($B5);
$Q6->apply_unsafe($L4);
$Q6->apply_unsafe($G6);
$Q6->apply_unsafe($M4);
$Q6->apply_unsafe($V4);
$Q6->apply_unsafe($N4);
$Q6->apply_unsafe($W4);
$Q6->apply_unsafe($O4);
$Q6->apply_unsafe($H6);
$Q6->apply_unsafe($P4);
$Q6->apply_unsafe($Q4);
$Q6->apply_unsafe($R4);
$Q6->apply_unsafe($I6);
$Q6->apply_unsafe($S4);
$d7->apply_unsafe($k4);
$d7->apply_unsafe($l4);
$d7->apply_unsafe($m4);
$d7->apply_unsafe($n4);
$d7->apply_unsafe($o4);
$d7->apply_unsafe($p4);
$d7->apply_unsafe($q4);
$d7->apply_unsafe($r4);
$d7->apply_unsafe($s4);
$d7->apply_unsafe($t4);
$d7->apply_unsafe($u4);
$d7->apply_unsafe($v4);
$d7->apply_unsafe($w4);
$d7->apply_unsafe($x4);
$d7->apply_unsafe($y4);
$d7->apply_unsafe($z4);
$d7->apply_unsafe($A4);
$d7->apply_unsafe($B4);
$d7->apply_unsafe($B6);
$d7->apply_unsafe($C4);
$d7->apply_unsafe($r5);
$d7->apply_unsafe($D4);
$d7->apply_unsafe($C6);
$d7->apply_unsafe($E4);
$d7->apply_unsafe($F4);
$d7->apply_unsafe($G4);
$d7->apply_unsafe($H4);
$d7->apply_unsafe($I4);
$d7->apply_unsafe($J4);
$d7->apply_unsafe($p5);
$d7->apply_unsafe($K4);
$d7->apply_unsafe($B5);
$d7->apply_unsafe($L4);
$d7->apply_unsafe($M4);
$d7->apply_unsafe($V4);
$d7->apply_unsafe($N4);
$d7->apply_unsafe($W4);
$d7->apply_unsafe($O4);
$d7->apply_unsafe($P4);
$d7->apply_unsafe($Q4);
$d7->apply_unsafe($R4);
$d7->apply_unsafe($S4);
$p7->apply_unsafe($k4);
$p7->apply_unsafe($l4);
$p7->apply_unsafe($m4);
$p7->apply_unsafe($n4);
$p7->apply_unsafe($o4);
$p7->apply_unsafe($p4);
$p7->apply_unsafe($q4);
$p7->apply_unsafe($r4);
$p7->apply_unsafe($s4);
$p7->apply_unsafe($t4);
$p7->apply_unsafe($u4);
$p7->apply_unsafe($v4);
$p7->apply_unsafe($w4);
$p7->apply_unsafe($x4);
$p7->apply_unsafe($y4);
$p7->apply_unsafe($z4);
$p7->apply_unsafe($A4);
$p7->apply_unsafe($B4);
$p7->apply_unsafe($C4);
$p7->apply_unsafe($r5);
$p7->apply_unsafe($D4);
$p7->apply_unsafe($E4);
$p7->apply_unsafe($F4);
$p7->apply_unsafe($G4);
$p7->apply_unsafe($H4);
$p7->apply_unsafe($I4);
$p7->apply_unsafe($J4);
$p7->apply_unsafe($K4);
$p7->apply_unsafe($L4);
$p7->apply_unsafe($M4);
$p7->apply_unsafe($V4);
$p7->apply_unsafe($N4);
$p7->apply_unsafe($W4);
$p7->apply_unsafe($O4);
$p7->apply_unsafe($P4);
$p7->apply_unsafe($Q4);
$p7->apply_unsafe($R4);
$p7->apply_unsafe($S4);
$z7->apply_unsafe($k4);
$z7->apply_unsafe($l4);
$z7->apply_unsafe($m4);
$z7->apply_unsafe($n4);
$z7->apply_unsafe($o4);
$z7->apply_unsafe($p4);
$z7->apply_unsafe($q4);
$z7->apply_unsafe($r4);
$z7->apply_unsafe($s4);
$z7->apply_unsafe($t4);
$z7->apply_unsafe($u4);
$z7->apply_unsafe($v4);
$z7->apply_unsafe($w4);
$z7->apply_unsafe($x4);
$z7->apply_unsafe($y4);
$z7->apply_unsafe($z4);
$z7->apply_unsafe($A4);
$z7->apply_unsafe($B4);
$z7->apply_unsafe($C4);
$z7->apply_unsafe($r5);
$z7->apply_unsafe($D4);
$z7->apply_unsafe($E4);
$z7->apply_unsafe($F4);
$z7->apply_unsafe($G4);
$z7->apply_unsafe($H4);
$z7->apply_unsafe($I4);
$z7->apply_unsafe($J4);
$z7->apply_unsafe($K4);
$z7->apply_unsafe($L4);
$z7->apply_unsafe($M4);
$z7->apply_unsafe($V4);
$z7->apply_unsafe($N4);
$z7->apply_unsafe($W4);
$z7->apply_unsafe($O4);
$z7->apply_unsafe($P4);
$z7->apply_unsafe($Q4);
$z7->apply_unsafe($R4);
$z7->apply_unsafe($S4);
$G7->apply_unsafe($k4);
$G7->apply_unsafe($l4);
$G7->apply_unsafe($m4);
$G7->apply_unsafe($n4);
$G7->apply_unsafe($o4);
$G7->apply_unsafe($p4);
$G7->apply_unsafe($q4);
$G7->apply_unsafe($r4);
$G7->apply_unsafe($s4);
$G7->apply_unsafe($t4);
$G7->apply_unsafe($u4);
$G7->apply_unsafe($v4);
$G7->apply_unsafe($w4);
$G7->apply_unsafe($x4);
$G7->apply_unsafe($y4);
$G7->apply_unsafe($z4);
$G7->apply_unsafe($A4);
$G7->apply_unsafe($B4);
$G7->apply_unsafe($C4);
$G7->apply_unsafe($r5);
$G7->apply_unsafe($D4);
$G7->apply_unsafe($E4);
$G7->apply_unsafe($F4);
$G7->apply_unsafe($G4);
$G7->apply_unsafe($H4);
$G7->apply_unsafe($I4);
$G7->apply_unsafe($J4);
$G7->apply_unsafe($K4);
$G7->apply_unsafe($L4);
$G7->apply_unsafe($M4);
$G7->apply_unsafe($V4);
$G7->apply_unsafe($N4);
$G7->apply_unsafe($W4);
$G7->apply_unsafe($O4);
$G7->apply_unsafe($P4);
$G7->apply_unsafe($Q4);
$G7->apply_unsafe($R4);
$G7->apply_unsafe($S4);
$N7->apply_unsafe($k4);
$N7->apply_unsafe($l4);
$N7->apply_unsafe($m4);
$N7->apply_unsafe($n4);
$N7->apply_unsafe($o4);
$N7->apply_unsafe($p4);
$N7->apply_unsafe($q4);
$N7->apply_unsafe($r4);
$N7->apply_unsafe($s4);
$N7->apply_unsafe($t4);
$N7->apply_unsafe($u4);
$N7->apply_unsafe($v4);
$N7->apply_unsafe($w4);
$N7->apply_unsafe($x4);
$N7->apply_unsafe($y4);
$N7->apply_unsafe($z4);
$N7->apply_unsafe($A4);
$N7->apply_unsafe($B4);
$N7->apply_unsafe($C4);
$N7->apply_unsafe($r5);
$N7->apply_unsafe($D4);
$N7->apply_unsafe($E4);
$N7->apply_unsafe($F4);
$N7->apply_unsafe($G4);
$N7->apply_unsafe($H4);
$N7->apply_unsafe($I4);
$N7->apply_unsafe($J4);
$N7->apply_unsafe($K4);
$N7->apply_unsafe($L4);
$N7->apply_unsafe($M4);
$N7->apply_unsafe($V4);
$N7->apply_unsafe($N4);
$N7->apply_unsafe($W4);
$N7->apply_unsafe($O4);
$N7->apply_unsafe($P4);
$N7->apply_unsafe($Q4);
$N7->apply_unsafe($R4);
$N7->apply_unsafe($S4);
$U7->apply_unsafe($k4);
$U7->apply_unsafe($l4);
$U7->apply_unsafe($m4);
$U7->apply_unsafe($n4);
$U7->apply_unsafe($o4);
$U7->apply_unsafe($p4);
$U7->apply_unsafe($q4);
$U7->apply_unsafe($r4);
$U7->apply_unsafe($s4);
$U7->apply_unsafe($t4);
$U7->apply_unsafe($u4);
$U7->apply_unsafe($v4);
$U7->apply_unsafe($w4);
$U7->apply_unsafe($x4);
$U7->apply_unsafe($y4);
$U7->apply_unsafe($z4);
$U7->apply_unsafe($A4);
$U7->apply_unsafe($B4);
$U7->apply_unsafe($C4);
$U7->apply_unsafe($r5);
$U7->apply_unsafe($D4);
$U7->apply_unsafe($E4);
$U7->apply_unsafe($F4);
$U7->apply_unsafe($G4);
$U7->apply_unsafe($H4);
$U7->apply_unsafe($I4);
$U7->apply_unsafe($J4);
$U7->apply_unsafe($K4);
$U7->apply_unsafe($L4);
$U7->apply_unsafe($M4);
$U7->apply_unsafe($V4);
$U7->apply_unsafe($N4);
$U7->apply_unsafe($W4);
$U7->apply_unsafe($O4);
$U7->apply_unsafe($P4);
$U7->apply_unsafe($Q4);
$U7->apply_unsafe($R4);
$U7->apply_unsafe($S4);
$m8->apply_unsafe($k4);
$m8->apply_unsafe($l4);
$m8->apply_unsafe($m4);
$m8->apply_unsafe($n4);
$m8->apply_unsafe($o4);
$m8->apply_unsafe($p4);
$m8->apply_unsafe($q4);
$m8->apply_unsafe($r4);
$m8->apply_unsafe($s4);
$m8->apply_unsafe($t4);
$m8->apply_unsafe($u4);
$m8->apply_unsafe($v4);
$m8->apply_unsafe($w4);
$m8->apply_unsafe($x4);
$m8->apply_unsafe($y4);
$m8->apply_unsafe($z4);
$m8->apply_unsafe($A4);
$m8->apply_unsafe($B4);
$m8->apply_unsafe($C4);
$m8->apply_unsafe($D4);
$m8->apply_unsafe($E4);
$m8->apply_unsafe($F4);
$m8->apply_unsafe($u);
$m8->apply_unsafe($G4);
$m8->apply_unsafe($H4);
$m8->apply_unsafe($I4);
$m8->apply_unsafe($J4);
$m8->apply_unsafe($p5);
$m8->apply_unsafe($K4);
$m8->apply_unsafe($B5);
$m8->apply_unsafe($L4);
$m8->apply_unsafe($M4);
$m8->apply_unsafe($V4);
$m8->apply_unsafe($N4);
$m8->apply_unsafe($O4);
$m8->apply_unsafe($P4);
$m8->apply_unsafe($Q4);
$m8->apply_unsafe($R4);
$m8->apply_unsafe($S4);
$t8->apply_unsafe($k4);
$t8->apply_unsafe($l4);
$t8->apply_unsafe($m4);
$t8->apply_unsafe($n4);
$t8->apply_unsafe($o4);
$t8->apply_unsafe($p4);
$t8->apply_unsafe($q4);
$t8->apply_unsafe($r4);
$t8->apply_unsafe($s4);
$t8->apply_unsafe($t4);
$t8->apply_unsafe($u4);
$t8->apply_unsafe($v4);
$t8->apply_unsafe($w4);
$t8->apply_unsafe($x4);
$t8->apply_unsafe($y4);
$t8->apply_unsafe($z4);
$t8->apply_unsafe($A4);
$t8->apply_unsafe($B4);
$t8->apply_unsafe($C4);
$t8->apply_unsafe($D4);
$t8->apply_unsafe($E4);
$t8->apply_unsafe($F4);
$t8->apply_unsafe($G4);
$t8->apply_unsafe($H4);
$t8->apply_unsafe($I4);
$t8->apply_unsafe($J4);
$t8->apply_unsafe($K4);
$t8->apply_unsafe($L4);
$t8->apply_unsafe($M4);
$t8->apply_unsafe($N4);
$t8->apply_unsafe($O4);
$t8->apply_unsafe($P4);
$t8->apply_unsafe($Q4);
$t8->apply_unsafe($R4);
$t8->apply_unsafe($S4);
$X8->apply_unsafe($l6);
$t9->apply_unsafe($m6);
$t9->apply_unsafe($n6);
$t9->apply_unsafe($o6);
$t9->apply_unsafe($p6);
$t9->apply_unsafe($q6);
$t9->apply_unsafe($r6);
$t9->apply_unsafe($s6);
$t9->apply_unsafe($t6);
$t9->apply_unsafe($u6);
$t9->apply_unsafe($v6);
$t9->apply_unsafe($w6);
$t9->apply_unsafe($x6);
$N9->apply_unsafe($m6);
$N9->apply_unsafe($n6);
$N9->apply_unsafe($o6);
$N9->apply_unsafe($p6);
$N9->apply_unsafe($q6);
$N9->apply_unsafe($r6);
$N9->apply_unsafe($s6);
$N9->apply_unsafe($t6);
$N9->apply_unsafe($u6);
$N9->apply_unsafe($v6);
$N9->apply_unsafe($w6);
$N9->apply_unsafe($x6);
$V9->apply_unsafe($m6);
$V9->apply_unsafe($n6);
$V9->apply_unsafe($o6);
$V9->apply_unsafe($p6);
$V9->apply_unsafe($q6);
$V9->apply_unsafe($r6);
$V9->apply_unsafe($s6);
$V9->apply_unsafe($t6);
$V9->apply_unsafe($u6);
$V9->apply_unsafe($v6);
$V9->apply_unsafe($w6);
$V9->apply_unsafe($x6);
$ja->apply_unsafe($m6);
$ja->apply_unsafe($n6);
$ja->apply_unsafe($o6);
$ja->apply_unsafe($p6);
$ja->apply_unsafe($q6);
$ja->apply_unsafe($r6);
$ja->apply_unsafe($s6);
$ja->apply_unsafe($t6);
$ja->apply_unsafe($u6);
$ja->apply_unsafe($v6);
$ja->apply_unsafe($w6);
$ja->apply_unsafe($x6);
$va->apply_unsafe($m6);
$va->apply_unsafe($n6);
$va->apply_unsafe($o6);
$va->apply_unsafe($p6);
$va->apply_unsafe($q6);
$va->apply_unsafe($r6);
$va->apply_unsafe($s6);
$va->apply_unsafe($t6);
$va->apply_unsafe($u6);
$va->apply_unsafe($v6);
$va->apply_unsafe($w6);
$va->apply_unsafe($x6);
$Ha->apply_unsafe($m6);
$Ha->apply_unsafe($n6);
$Ha->apply_unsafe($o6);
$Ha->apply_unsafe($p6);
$Ha->apply_unsafe($q6);
$Ha->apply_unsafe($r6);
$Ha->apply_unsafe($s6);
$Ha->apply_unsafe($t6);
$Ha->apply_unsafe($u6);
$Ha->apply_unsafe($v6);
$Ha->apply_unsafe($w6);
$Ha->apply_unsafe($x6);
$Ra->apply_unsafe($m6);
$nb->apply_unsafe($m6);
$Db->apply_unsafe($n4);
$Db->apply_unsafe($o4);
$Db->apply_unsafe($p4);
$Db->apply_unsafe($q4);
$Db->apply_unsafe($r4);
$Db->apply_unsafe($s4);
$Db->apply_unsafe($t4);
$Db->apply_unsafe($u4);
$Db->apply_unsafe($v4);
$Db->apply_unsafe($w4);
$Db->apply_unsafe($x4);
$Db->apply_unsafe($y4);
$Sb->apply_unsafe($n6);
$Zb->apply_unsafe($n6);
$vc->apply_unsafe($o6);
$Cc->apply_unsafe($o6);
$Wc->apply_unsafe($o6);
$wd->apply_unsafe($o6);
$Ed->apply_unsafe($o6);
$Ud->apply_unsafe($o6);
$te->apply_unsafe($p6);
$te->apply_unsafe($r6);
$Ae->apply_unsafe($p6);
$Ie->apply_unsafe($p6);
$Ye->apply_unsafe($p6);
$Ye->apply_unsafe($r6);
$lf->apply_unsafe($p6);
$vf->apply_unsafe($p6);
$vf->apply_unsafe($r6);
$Sf->apply_unsafe($q6);
$cg->apply_unsafe($q6);
$jg->apply_unsafe($q6);
$zg->apply_unsafe($q6);
$Hg->apply_unsafe($q6);
$eh->apply_unsafe($q6);
$Bh->apply_unsafe($r6);
$Lh->apply_unsafe($r6);
$li->apply_unsafe($s6);
$si->apply_unsafe($s6);
$Ai->apply_unsafe($s6);
$Ni->apply_unsafe($s6);
$fj->apply_unsafe($s6);
$Fj->apply_unsafe($t6);
$Mj->apply_unsafe($t6);
$Sj->apply_unsafe($t6);
$hk->apply_unsafe($t6);
$Sk->apply_unsafe($Tk);
$fl->apply_unsafe($u6);
$sl->apply_unsafe($u6);
$Zl->apply_unsafe($w6);
$lm->apply_unsafe($w6);
$xm->apply_unsafe($w6);
$Hm->apply_unsafe($w6);
$Xm->apply_unsafe($w6);
$Fn->apply_unsafe($x6);
$Mn->apply_unsafe($x6);
$co->apply_unsafe($x6);
$Ao->apply_unsafe($y6);
$Ao->apply_unsafe($z6);
$Ao->apply_unsafe($A6);
$Ao->apply_unsafe($I6);
$Mo->apply_unsafe($y6);
$Mo->apply_unsafe($z6);
$Mo->apply_unsafe($A6);
$Mo->apply_unsafe($I6);
$ep->apply_unsafe($y6);
$ep->apply_unsafe($z6);
$ep->apply_unsafe($A6);
$yp->apply_unsafe($y6);
$yp->apply_unsafe($z6);
$yp->apply_unsafe($A6);
$Pp->apply_unsafe($z4);
$Pp->apply_unsafe($A4);
$Pp->apply_unsafe($B4);
$lq->apply_unsafe($z6);
$sq->apply_unsafe($z6);
$Cq->apply_unsafe($z6);
$Oq->apply_unsafe($z6);
$sr->apply_unsafe($A4);
$Lr->apply_unsafe($A6);
$Sr->apply_unsafe($A6);
$qs->apply_unsafe($r5);
$Ks->apply_unsafe($C6);
$Qs->apply_unsafe($C6);
$nt->apply_unsafe($F);
$tt->apply_unsafe($F);
$At->apply_unsafe($F);
$Jt->apply_unsafe($F);
$Vt->apply_unsafe($F);
$zu->apply_unsafe($u);
$Nu->apply_unsafe($u);
$Xu->apply_unsafe($u);
$hv->apply_unsafe($u);
$Cv->apply_unsafe($D6);
$Mv->apply_unsafe($Tk);
$Vv->apply_unsafe($D6);
$Kw->apply_unsafe($D6);
$Sw->apply_unsafe($D6);
$Sw->apply_unsafe($F6);
$sx->apply_unsafe($D6);
$sx->apply_unsafe($F6);
$Ix->apply_unsafe($D6);
$Ix->apply_unsafe($F6);
$Yx->apply_unsafe($D6);
$Ly->apply_unsafe($My);
$hz->apply_unsafe($E6);
$zz->apply_unsafe($E6);
$Iz->apply_unsafe($E6);
$Sz->apply_unsafe($E6);
$jB->apply_unsafe($My);
$wB->apply_unsafe($F6);
$FB->apply_unsafe($F6);
$iC->apply_unsafe($p5);
$oC->apply_unsafe($p5);
$vC->apply_unsafe($p5);
$SC->apply_unsafe($Tk);
$eD->apply_unsafe($B5);
$kD->apply_unsafe($B5);
$ED->apply_unsafe($G6);
$QD->apply_unsafe($G6);
$XD->apply_unsafe($G6);
$ni::self=$OF;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($R)for@$H;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$H;
&$_($h2)for@$w;
&$_($l2)for@$w;
&$_($p2)for@$H;
&$_($v2)for@$H;
&$_($E2)for@$H;
&$_($K2)for@$H;
&$_($O2)for@$w;
&$_($S2)for@$w;
&$_($W2)for@$w;
&$_($c3)for@$H;
&$_($j3)for@$H;
&$_($r3)for@$w;
&$_($v3)for@$w;
&$_($z3)for@$H;
&$_($H3)for@$H;
&$_($P3)for@$H;
&$_($V3)for@$w;
&$_($Z3)for@$H;
&$_($h4)for@$H;
&$_($j5)for@$w;
&$_($m5)for@$w;
&$_($q5)for@$s5;
&$_($v5)for@$w;
&$_($x5)for@$w;
&$_($A5)for@$s5;
&$_($F5)for@$w;
&$_($I5)for@$s5;
&$_($M5)for@$w;
&$_($P5)for@$s5;
&$_($T5)for@$w;
&$_($W5)for@$s5;
&$_($Y5)for@$Z5;
&$_($e6)for@$w;
&$_($h6)for@$w;
&$_($k6)for@$s5;
&$_($N6)for@$w;
&$_($Q6)for@$s5;
&$_($S6)for@$T6;
&$_($Y6)for@$w;
&$_($d7)for@$s5;
&$_($f7)for@$g7;
&$_($m7)for@$w;
&$_($p7)for@$s5;
&$_($t7)for@$w;
&$_($w7)for@$w;
&$_($z7)for@$s5;
&$_($D7)for@$w;
&$_($G7)for@$s5;
&$_($K7)for@$w;
&$_($N7)for@$s5;
&$_($R7)for@$w;
&$_($U7)for@$s5;
&$_($W7)for@$X7;
&$_($Z7)for@$c8;
&$_($g8)for@$w;
&$_($j8)for@$w;
&$_($m8)for@$s5;
&$_($q8)for@$w;
&$_($t8)for@$s5;
&$_($v8)for@$w8;
&$_($F8)for@$G8;
&$_($K8)for@$G8;
&$_($M8)for@$G8;
&$_($O8)for@$G8;
&$_($U8)for@$w;
&$_($X8)for@$s5;
&$_($Z8)for@$c9;
&$_($h9)for@$G8;
&$_($q9)for@$w;
&$_($t9)for@$s5;
&$_($y9)for@$w;
&$_($C9)for@$w;
&$_($G9)for@$w;
&$_($K9)for@$w;
&$_($N9)for@$s5;
&$_($S9)for@$w;
&$_($V9)for@$s5;
&$_($ca)for@$w;
&$_($ga)for@$w;
&$_($ja)for@$s5;
&$_($oa)for@$w;
&$_($sa)for@$w;
&$_($va)for@$s5;
&$_($Aa)for@$w;
&$_($Ea)for@$w;
&$_($Ha)for@$s5;
&$_($Ja)for@$Ka;
&$_($Oa)for@$w;
&$_($Ra)for@$s5;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($gb)for@$w;
&$_($kb)for@$w;
&$_($nb)for@$s5;
&$_($pb)for@$qb;
&$_($Ab)for@$w;
&$_($Db)for@$s5;
&$_($Fb)for@$G8;
&$_($Hb)for@$G8;
&$_($Pb)for@$w;
&$_($Sb)for@$s5;
&$_($Wb)for@$w;
&$_($Zb)for@$s5;
&$_($dc)for@$ec;
&$_($jc)for@$G8;
&$_($sc)for@$w;
&$_($vc)for@$s5;
&$_($zc)for@$w;
&$_($Cc)for@$s5;
&$_($Hc)for@$w;
&$_($Lc)for@$w;
&$_($Pc)for@$w;
&$_($Tc)for@$w;
&$_($Wc)for@$s5;
&$_($dd)for@$w;
&$_($hd)for@$w;
&$_($ld)for@$w;
&$_($pd)for@$w;
&$_($td)for@$w;
&$_($wd)for@$s5;
&$_($Bd)for@$w;
&$_($Ed)for@$s5;
&$_($Jd)for@$w;
&$_($Nd)for@$w;
&$_($Rd)for@$w;
&$_($Ud)for@$s5;
&$_($Wd)for@$Xd;
&$_($ee)for@$G8;
&$_($qe)for@$w;
&$_($te)for@$s5;
&$_($xe)for@$w;
&$_($Ae)for@$s5;
&$_($Fe)for@$w;
&$_($Ie)for@$s5;
&$_($Ne)for@$w;
&$_($Re)for@$w;
&$_($Ve)for@$w;
&$_($Ye)for@$s5;
&$_($ef)for@$w;
&$_($if)for@$w;
&$_($lf)for@$s5;
&$_($pf)for@$w;
&$_($sf)for@$w;
&$_($vf)for@$s5;
&$_($xf)for@$yf;
&$_($Df)for@$G8;
&$_($Pf)for@$w;
&$_($Sf)for@$s5;
&$_($Xf)for@$w;
&$_($cg)for@$s5;
&$_($gg)for@$w;
&$_($jg)for@$s5;
&$_($og)for@$w;
&$_($sg)for@$w;
&$_($wg)for@$w;
&$_($zg)for@$s5;
&$_($Eg)for@$w;
&$_($Hg)for@$s5;
&$_($Lg)for@$w;
&$_($Pg)for@$w;
&$_($Sg)for@$w;
&$_($Wg)for@$w;
&$_($Zg)for@$w;
&$_($eh)for@$s5;
&$_($gh)for@$hh;
&$_($mh)for@$G8;
&$_($yh)for@$w;
&$_($Bh)for@$s5;
&$_($Fh)for@$w;
&$_($Ih)for@$w;
&$_($Lh)for@$s5;
&$_($Nh)for@$Oh;
&$_($Th)for@$G8;
&$_($ei)for@$w;
&$_($ii)for@$w;
&$_($li)for@$s5;
&$_($pi)for@$w;
&$_($si)for@$s5;
&$_($xi)for@$w;
&$_($Ai)for@$s5;
&$_($Ei)for@$w;
&$_($Hi)for@$w;
&$_($Ki)for@$w;
&$_($Ni)for@$s5;
&$_($Si)for@$w;
&$_($Wi)for@$w;
&$_($cj)for@$w;
&$_($fj)for@$s5;
&$_($hj)for@$ij;
&$_($nj)for@$G8;
&$_($uj)for@$w;
&$_($yj)for@$w;
&$_($Cj)for@$w;
&$_($Fj)for@$s5;
&$_($Jj)for@$w;
&$_($Mj)for@$s5;
&$_($Pj)for@$w;
&$_($Sj)for@$s5;
&$_($Wj)for@$w;
&$_($Zj)for@$w;
&$_($ek)for@$w;
&$_($hk)for@$s5;
&$_($jk)for@$kk;
&$_($qk)for@$G8;
&$_($Ek)for@$w;
&$_($Hk)for@$w;
&$_($Lk)for@$w;
&$_($Pk)for@$w;
&$_($Sk)for@$s5;
&$_($cl)for@$w;
&$_($fl)for@$s5;
&$_($jl)for@$w;
&$_($ml)for@$w;
&$_($pl)for@$w;
&$_($sl)for@$s5;
&$_($ul)for@$vl;
&$_($Al)for@$G8;
&$_($Sl)for@$w;
&$_($Wl)for@$w;
&$_($Zl)for@$s5;
&$_($fm)for@$w;
&$_($im)for@$w;
&$_($lm)for@$s5;
&$_($qm)for@$w;
&$_($um)for@$w;
&$_($xm)for@$s5;
&$_($Bm)for@$w;
&$_($Em)for@$w;
&$_($Hm)for@$s5;
&$_($Lm)for@$w;
&$_($Om)for@$w;
&$_($Rm)for@$w;
&$_($Um)for@$w;
&$_($Xm)for@$s5;
&$_($Zm)for@$cn;
&$_($hn)for@$G8;
&$_($un)for@$w;
&$_($yn)for@$w;
&$_($Cn)for@$w;
&$_($Fn)for@$s5;
&$_($Jn)for@$w;
&$_($Mn)for@$s5;
&$_($Qn)for@$w;
&$_($Un)for@$w;
&$_($Xn)for@$w;
&$_($co)for@$s5;
&$_($eo)for@$fo;
&$_($ko)for@$G8;
&$_($xo)for@$w;
&$_($Ao)for@$s5;
&$_($Fo)for@$w;
&$_($Jo)for@$w;
&$_($Mo)for@$s5;
&$_($Oo)for@$Po;
&$_($To)for@$w;
&$_($Wo)for@$w;
&$_($Zo)for@$w;
&$_($ep)for@$s5;
&$_($jp)for@$w;
&$_($np)for@$w;
&$_($rp)for@$w;
&$_($vp)for@$w;
&$_($yp)for@$s5;
&$_($Ap)for@$Bp;
&$_($Ip)for@$G8;
&$_($Mp)for@$w;
&$_($Pp)for@$s5;
&$_($Rp)for@$G8;
&$_($cq)for@$w;
&$_($eq)for@$w;
&$_($iq)for@$w;
&$_($lq)for@$s5;
&$_($pq)for@$w;
&$_($sq)for@$s5;
&$_($wq)for@$w;
&$_($zq)for@$w;
&$_($Cq)for@$s5;
&$_($Hq)for@$w;
&$_($Lq)for@$w;
&$_($Oq)for@$s5;
&$_($Tq)for@$Uq;
&$_($dr)for@$w;
&$_($hr)for@$w;
&$_($lr)for@$w;
&$_($pr)for@$w;
&$_($sr)for@$s5;
&$_($ur)for@$G8;
&$_($Ir)for@$w;
&$_($Lr)for@$s5;
&$_($Pr)for@$w;
&$_($Sr)for@$s5;
&$_($Ur)for@$Vr;
&$_($cs)for@$G8;
&$_($ns)for@$w;
&$_($qs)for@$s5;
&$_($ss)for@$ts;
&$_($zs)for@$G8;
&$_($Hs)for@$w;
&$_($Ks)for@$s5;
&$_($Ns)for@$w;
&$_($Qs)for@$s5;
&$_($Ss)for@$Ts;
&$_($Ys)for@$G8;
&$_($kt)for@$w;
&$_($nt)for@$s5;
&$_($qt)for@$w;
&$_($tt)for@$s5;
&$_($xt)for@$w;
&$_($At)for@$s5;
&$_($Dt)for@$w;
&$_($Gt)for@$w;
&$_($Jt)for@$s5;
&$_($Mt)for@$w;
&$_($Pt)for@$w;
&$_($St)for@$w;
&$_($Vt)for@$s5;
&$_($Xt)for@$Yt;
&$_($fu)for@$G8;
&$_($ru)for@$w;
&$_($uu)for@$w;
&$_($wu)for@$w;
&$_($zu)for@$s5;
&$_($Du)for@$w;
&$_($Gu)for@$w;
&$_($Ku)for@$w;
&$_($Nu)for@$s5;
&$_($Ru)for@$w;
&$_($Uu)for@$w;
&$_($Xu)for@$s5;
&$_($ev)for@$w;
&$_($hv)for@$s5;
&$_($jv)for@$kv;
&$_($pv)for@$G8;
&$_($zv)for@$w;
&$_($Cv)for@$s5;
&$_($Jv)for@$w;
&$_($Mv)for@$s5;
&$_($Sv)for@$w;
&$_($Vv)for@$s5;
&$_($cw)for@$w;
&$_($gw)for@$w;
&$_($kw)for@$w;
&$_($ow)for@$w;
&$_($sw)for@$w;
&$_($ww)for@$w;
&$_($Aw)for@$w;
&$_($Ew)for@$w;
&$_($Hw)for@$w;
&$_($Kw)for@$s5;
&$_($Pw)for@$w;
&$_($Sw)for@$s5;
&$_($Xw)for@$w;
&$_($dx)for@$w;
&$_($hx)for@$w;
&$_($lx)for@$w;
&$_($px)for@$w;
&$_($sx)for@$s5;
&$_($xx)for@$w;
&$_($Bx)for@$w;
&$_($Fx)for@$w;
&$_($Ix)for@$s5;
&$_($Nx)for@$w;
&$_($Rx)for@$w;
&$_($Vx)for@$w;
&$_($Yx)for@$s5;
&$_($cy)for@$dy;
&$_($iy)for@$G8;
&$_($sy)for@$w;
&$_($wy)for@$w;
&$_($Ay)for@$w;
&$_($Ey)for@$w;
&$_($Iy)for@$w;
&$_($Ly)for@$s5;
&$_($Wy)for@$w;
&$_($Zy)for@$w;
&$_($ez)for@$w;
&$_($hz)for@$s5;
&$_($lz)for@$w;
&$_($oz)for@$w;
&$_($rz)for@$w;
&$_($uz)for@$w;
&$_($wz)for@$w;
&$_($zz)for@$s5;
&$_($Cz)for@$w;
&$_($Fz)for@$w;
&$_($Iz)for@$s5;
&$_($Mz)for@$w;
&$_($Pz)for@$w;
&$_($Sz)for@$s5;
&$_($Uz)for@$Vz;
&$_($cA)for@$G8;
&$_($mA)for@$w;
&$_($qA)for@$w;
&$_($uA)for@$w;
&$_($yA)for@$w;
&$_($CA)for@$w;
&$_($GA)for@$w;
&$_($KA)for@$w;
&$_($OA)for@$w;
&$_($SA)for@$w;
&$_($WA)for@$w;
&$_($cB)for@$w;
&$_($gB)for@$w;
&$_($jB)for@$s5;
&$_($tB)for@$w;
&$_($wB)for@$s5;
&$_($zB)for@$w;
&$_($CB)for@$w;
&$_($FB)for@$s5;
&$_($HB)for@$IB;
&$_($NB)for@$G8;
&$_($XB)for@$w;
&$_($ZB)for@$w;
&$_($iC)for@$s5;
&$_($lC)for@$w;
&$_($oC)for@$s5;
&$_($sC)for@$w;
&$_($vC)for@$s5;
&$_($xC)for@$yC;
&$_($EC)for@$G8;
&$_($LC)for@$w;
&$_($PC)for@$w;
&$_($SC)for@$s5;
&$_($ZC)for@$w;
&$_($eD)for@$s5;
&$_($hD)for@$w;
&$_($kD)for@$s5;
&$_($mD)for@$nD;
&$_($tD)for@$G8;
&$_($BD)for@$w;
&$_($ED)for@$s5;
&$_($JD)for@$w;
&$_($ND)for@$w;
&$_($QD)for@$s5;
&$_($UD)for@$w;
&$_($XD)for@$s5;
&$_($ZD)for@$cE;
&$_($hE)for@$G8;
&$_($pE)for@$qE;
&$_($vE)for@$G8;
&$_($EE)for@$FE;
&$_($KE)for@$G8;
&$_($SE)for@$TE;
&$_($rF)for@$TE;
&$_($wF)for@$w;
&$_($AF)for@$w;
&$_($EF)for@$w;
&$_($IF)for@$w;
&$_($MF)for@$w;
ni->run(@ARGV);
__DATA__
