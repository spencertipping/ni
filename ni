#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Fcntl;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib/doc#;
$L1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$M1=[$f,$L1];
$N1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$O1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$P1=[];
$Q1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$T1=[];
$U1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$V1=bless({$o,$T1,$q,$U1,$s,$t},$u);
$W1=[$i,$N1,$O1,$n,$R1,$S1,$n,$V1];
$X1=[$M1,$W1];
$Y1=q#/lib/doc#;
$Z1=bless({$e,$X1,$D,$Y1},$F);
$c2=q#ni:/class#;
$d2=q#applied_to#;
$e2=q#class#;
$f2=q#class.c#;
$g2=q#io/cat.c#;
$h2=q#io/exec.c#;
$i2=q#io/fd.c#;
$j2=q#io/file.c#;
$k2=q#io/null.c#;
$l2=q#io/object.c#;
$m2=q#io/pid.c#;
$n2=q#io/str.c#;
$o2=q#lib/behavior.c#;
$p2=q#lib/branch.c#;
$q2=q#lib/dataslice.c#;
$r2=q#lib/doc.c#;
$s2=q#lib/fn.c#;
$t2=q#lib/image.c#;
$u2=q#lib/ni.c#;
$v2=q#lib/slice.c#;
$w2=q#lib/tag.c#;
$x2=q#lib/test_value.c#;
$y2=q#metaclass.c#;
$z2=q#module.c#;
$A2=q#object.c#;
$B2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1};
$C2=q#slices#;
$D2=q#lib/test_value.c#;
$E2=q#metaclass#;
$F2=q#module#;
$G2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$D2,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$H2=q#/module#;
$I2=q#/lib/perlbranch.b#;
$J2={};
$K2=q#ctor#;
$L2=undef;
$M2=q#dtor#;
$N2=q#methods#;
$O2=q#add#;
$P2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$Q2=bless({$q,$P2,$s,$t},$u);
$R2=q#apply#;
$S2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$T2=bless({$q,$S2,$s,$t},$u);
$U2={$O2,$Q2,$R2,$T2};
$V2=q#/lib/branch.b#;
$W2=q#lib/slice#;
$X2=bless({$d2,$J2,$K2,$L2,$M2,$L2,$N2,$U2,$D,$V2},$W2);
$Y2=q#lib/branch#;
$Z2=q#lib/test_value.c#;
$c3=q#lib/slice::ctors#;
$d3={};
$e3=q#my $s = shift; ni->def($s->name, $s)#;
$f3=bless({$q,$e3,$s,$t},$u);
$g3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$h3=bless({$q,$g3,$s,$t},$u);
$i3={$D,$h3};
$j3=q#/lib/named.b#;
$k3=bless({$d2,$d3,$K2,$f3,$M2,$L2,$N2,$i3,$D,$j3},$W2);
$l3=q#lib/tag#;
$m3=q#lib/test_value.c#;
$n3=q#lib/slice::ctors#;
$o3={};
$p3=q#namespace#;
$q3=q#'ni'#;
$r3=bless({$q,$q3,$s,$t},$u);
$s3={$p3,$r3};
$t3=q#/lib/named_in_ni.b#;
$u3=bless({$d2,$o3,$K2,$L2,$M2,$L2,$N2,$s3,$D,$t3},$W2);
$v3=q#lib/test_value.c#;
$w3=q#lib/slice::ctors#;
$x3={};
$y3=q#package#;
$z3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$A3=bless({$q,$z3,$s,$t},$u);
$B3={$y3,$A3};
$C3=q#/lib/namespaced.b#;
$D3=bless({$d2,$x3,$K2,$L2,$M2,$L2,$N2,$B3,$D,$C3},$W2);
$E3=q#lib/test_value.c#;
$F3=q#lib/slice::ctors#;
$G3={};
$H3=q#resolve#;
$I3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$J3=bless({$q,$I3,$s,$t},$u);
$K3={$H3,$J3};
$L3=q#/lib/resolver.b#;
$M3=bless({$d2,$G3,$K2,$L2,$M2,$L2,$N2,$K3,$D,$L3},$W2);
$N3=q#lib/test_value.c#;
$O3=q#lib/slice::ctors#;
$P3=[$X2,$k3,$u3,$D3,$M3];
$Q3=bless({$D,$I2,$C2,$P3},$l3);
$R3=q#lib/tag::ctors#;
$S3={};
$T3=q#my $s = shift; $s->apply($s->package)#;
$U3=bless({$q,$T3,$s,$t},$u);
$V3=q#instantiate#;
$W3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$X3=bless({$q,$W3,$s,$t},$u);
$Y3={$V3,$X3};
$Z3=q#/lib/class_init.b#;
$c4=bless({$d2,$S3,$K2,$U3,$M2,$L2,$N2,$Y3,$D,$Z3},$W2);
$d4=q#lib/test_value.c#;
$e4=q#lib/slice::ctors#;
$f4=q#io/cat#;
$g4=q#io/exec#;
$h4=q#io/fd#;
$i4=q#io/file#;
$j4=q#io/null#;
$k4=q#io/object#;
$l4=q#io/pid#;
$m4=q#io/str#;
$n4=q#lib/behavior#;
$o4=q#lib/dataslice#;
$p4=q#lib/image#;
$q4=q#lib/ni#;
$r4=q#lib/test_value#;
$s4=q#lib/test_value.c#;
$t4=q#object#;
$u4={$e2,1,$f2,1,$f4,1,$g2,1,$g4,1,$h2,1,$h4,1,$i2,1,$i4,1,$j2,1,$j4,1,$k2,1,$k4,1,$l2,1,$l4,1,$m2,1,$m4,1,$n2,1,$n4,1,$o2,1,$Y2,1,$p2,1,$o4,1,$q2,1,$F,1,$r2,1,$u,1,$s2,1,$p4,1,$t2,1,$q4,1,$u2,1,$W2,1,$v2,1,$l3,1,$w2,1,$r4,1,$s4,1,$E2,1,$y2,1,$F2,1,$z2,1,$t4,1,$A2,1};
$v4=q#/object#;
$w4={};
$x4=q#ni 'ni:/' . ref shift#;
$y4=bless({$q,$x4,$s,$t},$u);
$z4={$e2,$y4};
$A4=q#/lib/instance.b#;
$B4=bless({$d2,$w4,$K2,$L2,$M2,$L2,$N2,$z4,$D,$A4},$W2);
$C4=q#lib/test_value.c#;
$D4=q#lib/slice::ctors#;
$E4=[$B4];
$F4=bless({$d2,$u4,$D,$v4,$C2,$E4},$A2);
$G4=q#object.c::ctors#;
$H4=q#lib/test_value.c#;
$I4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$n4,1,$o2,1,$Y2,1,$p2,1,$o4,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$W2,1,$v2,1,$l3,1,$w2,1,$H4,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$J4=q#/lib/behavior#;
$K4={};
$L4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$M4=bless({$q,$L4,$s,$t},$u);
$N4={$e,$M4};
$O4=q#/lib/documentable.b#;
$P4=bless({$d2,$K4,$K2,$L2,$M2,$L2,$N2,$N4,$D,$O4},$W2);
$Q4=q#lib/test_value.c#;
$R4=q#lib/slice::ctors#;
$S4=[$F4,$P4];
$T4=bless({$d2,$I4,$D,$J4,$C2,$S4},$o2);
$U4=q#lib/behavior.c::ctors#;
$V4=q#lib/test_value.c#;
$W4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$Y2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$V4,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$X4=q#/lib/definition.b#;
$Y4={};
$Z4=q#def#;
$c5=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$d5=bless({$q,$c5,$s,$t},$u);
$e5={$Z4,$d5};
$f5=q#/lib/definition_def.b#;
$g5=bless({$d2,$Y4,$K2,$L2,$M2,$L2,$N2,$e5,$D,$f5},$W2);
$h5=q#lib/test_value.c#;
$i5=q#lib/slice::ctors#;
$j5={};
$k5=q#ro#;
$l5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$m5=bless({$q,$l5,$s,$t},$u);
$n5=q#rw#;
$o5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$p5=bless({$q,$o5,$s,$t},$u);
$q5={$k5,$m5,$n5,$p5};
$r5=q#/lib/accessor.b#;
$s5=bless({$d2,$j5,$K2,$L2,$M2,$L2,$N2,$q5,$D,$r5},$W2);
$t5=q#lib/test_value.c#;
$u5=q#lib/slice::ctors#;
$v5={};
$w5=q#(""#;
$x5=q#shift->name#;
$y5=bless({$q,$x5,$s,$t},$u);
$z5={$w5,$y5};
$A5=q#/lib/name_as_string.b#;
$B5=bless({$d2,$v5,$K2,$L2,$M2,$L2,$N2,$z5,$D,$A5},$W2);
$C5=q#lib/test_value.c#;
$D5=q#lib/slice::ctors#;
$E5={};
$F5=q#(eq#;
$G5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$H5=bless({$q,$G5,$s,$t},$u);
$I5={$F5,$H5};
$J5=q#/lib/ref_eq.b#;
$K5=bless({$d2,$E5,$K2,$L2,$M2,$L2,$N2,$I5,$D,$J5},$W2);
$L5=q#lib/test_value.c#;
$M5=q#lib/slice::ctors#;
$N5={};
$O5=q#defdata#;
$P5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$Q5=bless({$q,$P5,$s,$t},$u);
$R5={$O5,$Q5};
$S5=q#/lib/definition_defdata.b#;
$T5=bless({$d2,$N5,$K2,$L2,$M2,$L2,$N2,$R5,$D,$S5},$W2);
$U5=q#lib/test_value.c#;
$V5=q#lib/slice::ctors#;
$W5=[$g5,$s5,$B5,$K5,$T5];
$X5=bless({$d2,$W4,$D,$X4,$C2,$W5},$Y2);
$Y5=q#lib/branch::ctors#;
$Z5=[$Q3,$c4,$F4,$T4,$X5];
$c6=bless({$d2,$G2,$D,$H2,$C2,$Z5},$z2);
$d6=q#module.c::ctors#;
$e6={};
$f6=q#DESTROY#;
$g6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$h6=bless({$q,$g6,$s,$t},$u);
$i6=q#new#;
$j6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$k6=bless({$q,$j6,$s,$t},$u);
$l6={$f6,$h6,$i6,$k6};
$m6=q#/lib/instantiable.b#;
$n6=bless({$d2,$e6,$N2,$l6,$D,$m6},$W2);
$o6=q#lib/test_value.c#;
$p6=q#lib/slice::ctors#;
$q6={};
$r6=q#child#;
$s6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$t6=bless({$q,$s6,$s,$t},$u);
$u6={$r6,$t6};
$v6=q#/lib/subclass.b#;
$w6=bless({$d2,$q6,$K2,$L2,$M2,$L2,$N2,$u6,$D,$v6},$W2);
$x6=q#lib/test_value.c#;
$y6=q#lib/slice::ctors#;
$z6=[$c6,$n6,$c4,$c6,$w6];
$A6=bless({$d2,$B2,$D,$E,$C2,$z6},$f2);
$B6=q#class.c::ctors#;
$C6=q#ni:/class.c#;
$D6={$f2,1};
$E6=q#/class.c#;
$F6={$f2,1,$z2,1};
$G6=q#/module.c#;
$H6=q#lib/test_value.c#;
$I6={$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$H6,1,$z2,1,$A2,1};
$J6=q#/object.c#;
$K6=[$A6];
$L6=bless({$d2,$I6,$D,$J6,$C2,$K6},$E2);
$M6=q#metaclass::ctors#;
$N6={$f2,1,$o2,1,$p2,1,$q2,1,$v2,1,$w2,1,$z2,1};
$O6=q#/lib/behavior.c#;
$P6=[$L6];
$Q6=bless({$d2,$N6,$D,$O6,$C2,$P6},$E2);
$R6=q#metaclass::ctors#;
$S6=[$L6,$n6,$Q6];
$T6=bless({$d2,$F6,$D,$G6,$C2,$S6},$E2);
$U6=q#metaclass::ctors#;
$V6=[$T6];
$W6=bless({$d2,$D6,$D,$E6,$C2,$V6},$E2);
$X6=q#metaclass::ctors#;
$Y6=q#ni:/io/cat#;
$Z6={$f4,1};
$c7={$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1};
$d7=q#/io/object#;
$e7={};
$f7=q#(bool#;
$g7=[];
$h7=bless({$o,$g7,$q,1,$s,$t},$u);
$i7={$f7,$h7};
$j7=q#/io/object_ops.b#;
$k7=bless({$d2,$e7,$K2,$L2,$M2,$L2,$N2,$i7,$D,$j7},$W2);
$l7=q#lib/slice::ctors#;
$m7={};
$n7=q#into#;
$o7=[];
$p7=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}
$self;#;
$q7=bless({$o,$o7,$q,$p7,$s,$t},$u);
$r7={$n7,$q7};
$s7=q#/io/object_stream.b#;
$t7=bless({$d2,$m7,$K2,$L2,$M2,$L2,$N2,$r7,$D,$s7},$W2);
$u7=q#lib/slice::ctors#;
$v7={};
$w7=q#die#;
$x7=[];
$y7=q#shift; die join " ", @_#;
$z7=bless({$o,$x7,$q,$y7,$s,$t},$u);
$A7=q#io_check#;
$B7=[];
$C7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$D7=bless({$o,$B7,$q,$C7,$s,$t},$u);
$E7=q#io_check_defined#;
$F7=[];
$G7=q#shift->io_check(sub {defined shift}, @_)#;
$H7=bless({$o,$F7,$q,$G7,$s,$t},$u);
$I7=q#io_check_true#;
$J7=[];
$K7=q#shift->io_check(sub {shift}, @_)#;
$L7=bless({$o,$J7,$q,$K7,$s,$t},$u);
$M7={$w7,$z7,$A7,$D7,$E7,$H7,$I7,$L7};
$N7=q#/io/object_checks.b#;
$O7=bless({$d2,$v7,$K2,$L2,$M2,$L2,$N2,$M7,$D,$N7},$W2);
$P7=q#lib/slice::ctors#;
$Q7={};
$R7=q#(+#;
$S7=[];
$T7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$U7=bless({$o,$S7,$q,$T7,$s,$t},$u);
$V7={$R7,$U7};
$W7=q#/io/object_constructors.b#;
$X7=bless({$d2,$Q7,$K2,$L2,$M2,$L2,$N2,$V7,$D,$W7},$W2);
$Y7=q#lib/slice::ctors#;
$Z7={};
$c8=q#read_all#;
$d8=[];
$e8=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$f8=bless({$o,$d8,$q,$e8,$s,$t},$u);
$g8={$c8,$f8};
$h8=q#/io/object_memory.b#;
$i8=bless({$d2,$Z7,$K2,$L2,$M2,$L2,$N2,$g8,$D,$h8},$W2);
$j8=q#lib/slice::ctors#;
$k8=[$F4,$k7,$t7,$O7,$X7,$i8];
$l8=bless({$d2,$c7,$D,$d7,$C2,$k8},$l2);
$m8=q#io/object.c::ctors#;
$n8={};
$o8=[];
$p8=q#shift; +{fs => [@_]}#;
$q8=bless({$o,$o8,$q,$p8,$s,$t},$u);
$r8={$V3,$q8};
$s8=q#/io/cat_init.b#;
$t8=bless({$d2,$n8,$K2,$L2,$M2,$L2,$N2,$r8,$D,$s8},$W2);
$u8=q#lib/slice::ctors#;
$v8={};
$w8=q#read#;
$x8=[];
$y8=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$z8=bless({$o,$x8,$q,$y8,$s,$t},$u);
$A8={$w8,$z8};
$B8=q#/io/cat_read.b#;
$C8=bless({$d2,$v8,$K2,$L2,$M2,$L2,$N2,$A8,$D,$B8},$W2);
$D8=q#lib/slice::ctors#;
$E8=[$l8,$t8,$C8];
$F8=bless({$d2,$Z6,$D,$g1,$C2,$E8},$g2);
$G8=q#io/cat.c::ctors#;
$H8=q#ni:/io/cat.c#;
$I8={$g2,1};
$J8=q#/io/cat.c#;
$K8={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1};
$L8=q#/io/object.c#;
$M8=[$L6];
$N8=bless({$d2,$K8,$D,$L8,$C2,$M8},$E2);
$O8=q#metaclass::ctors#;
$P8=[$N8];
$Q8=bless({$d2,$I8,$D,$J8,$C2,$P8},$E2);
$R8=q#metaclass::ctors#;
$S8=q#ni:/io/cat_init.b#;
$T8=q#ni:/io/cat_read.b#;
$U8=q#ni:/io/exec#;
$V8={$g4,1};
$W8={};
$X8=q#argv#;
$Y8=[];
$Z8=q#shift->{'argv'}#;
$c9=bless({$o,$Y8,$q,$Z8,$s,$t},$u);
$d9={$X8,$c9};
$e9=q#/io/exec_ro.b#;
$f9=bless({$d2,$W8,$K2,$L2,$M2,$L2,$N2,$d9,$D,$e9},$W2);
$g9=q#lib/slice::ctors#;
$h9={};
$i9=[];
$j9=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$k9=bless({$o,$i9,$q,$j9,$s,$t},$u);
$l9={$V3,$k9};
$m9=q#/io/exec_init.b#;
$n9=bless({$d2,$h9,$K2,$L2,$M2,$L2,$N2,$l9,$D,$m9},$W2);
$o9=q#lib/slice::ctors#;
$p9={};
$q9=q#connect#;
$r9=[];
$s9=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$t9=bless({$o,$r9,$q,$s9,$s,$t},$u);
$u9=q#in_pipe#;
$v9=[];
$w9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9=q#out_pipe#;
$z9=[];
$A9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$B9=bless({$o,$z9,$q,$A9,$s,$t},$u);
$C9=q#setup_stdio#;
$D9=[];
$E9=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$F9=bless({$o,$D9,$q,$E9,$s,$t},$u);
$G9={$q9,$t9,$u9,$x9,$y9,$B9,$C9,$F9};
$H9=q#/io/exec_io_setup.b#;
$I9=bless({$d2,$p9,$K2,$L2,$M2,$L2,$N2,$G9,$D,$H9},$W2);
$J9=q#lib/slice::ctors#;
$K9={};
$L9=q#binds_fd#;
$M9=[];
$N9=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$O9=bless({$o,$M9,$q,$N9,$s,$t},$u);
$P9=q#fd#;
$Q9=[];
$R9=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$S9=bless({$o,$Q9,$q,$R9,$s,$t},$u);
$T9=q#stderr#;
$U9=[];
$V9=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$W9=bless({$o,$U9,$q,$V9,$s,$t},$u);
$X9=q#stdin#;
$Y9=[];
$Z9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da=q#stdout#;
$ea=[];
$fa=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$ga=bless({$o,$ea,$q,$fa,$s,$t},$u);
$ha={$L9,$O9,$P9,$S9,$T9,$W9,$X9,$ca,$da,$ga};
$ia=q#/io/exec_io_accessors.b#;
$ja=bless({$d2,$K9,$K2,$L2,$M2,$L2,$N2,$ha,$D,$ia},$W2);
$ka=q#lib/slice::ctors#;
$la={};
$ma=q#env#;
$na=[];
$oa=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$pa=bless({$o,$na,$q,$oa,$s,$t},$u);
$qa={$ma,$pa};
$ra=q#/io/exec_env.b#;
$sa=bless({$d2,$la,$K2,$L2,$M2,$L2,$N2,$qa,$D,$ra},$W2);
$ta=q#lib/slice::ctors#;
$ua={};
$va=q#exec#;
$wa=[];
$xa=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$ya=bless({$o,$wa,$q,$xa,$s,$t},$u);
$za=q#fork#;
$Aa=[];
$Ba=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Ca=bless({$o,$Aa,$q,$Ba,$s,$t},$u);
$Da=q#move_fds#;
$Ea=[];
$Fa=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Ga=bless({$o,$Ea,$q,$Fa,$s,$t},$u);
$Ha={$va,$ya,$za,$Ca,$Da,$Ga};
$Ia=q#/io/exec_fork.b#;
$Ja=bless({$d2,$ua,$K2,$L2,$M2,$L2,$N2,$Ha,$D,$Ia},$W2);
$Ka=q#lib/slice::ctors#;
$La=[$l8,$f9,$n9,$I9,$ja,$sa,$Ja];
$Ma=bless({$d2,$V8,$D,$s1,$C2,$La},$h2);
$Na=q#io/exec.c::ctors#;
$Oa=q#ni:/io/exec.c#;
$Pa={$h2,1};
$Qa=q#/io/exec.c#;
$Ra=[$N8];
$Sa=bless({$d2,$Pa,$D,$Qa,$C2,$Ra},$E2);
$Ta=q#metaclass::ctors#;
$Ua=q#ni:/io/exec_env.b#;
$Va=q#ni:/io/exec_fork.b#;
$Wa=q#ni:/io/exec_init.b#;
$Xa=q#ni:/io/exec_io_accessors.b#;
$Ya=q#ni:/io/exec_io_setup.b#;
$Za=q#ni:/io/exec_ro.b#;
$cb=q#ni:/io/fd#;
$db={$h4,1};
$eb=q#/io/fd#;
$fb={};
$gb=[];
$hb=q#shift->{'fd'}#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb={$P9,$ib};
$kb=q#/io/fd_readers.b#;
$lb=bless({$d2,$fb,$K2,$L2,$M2,$L2,$N2,$jb,$D,$kb},$W2);
$mb=q#lib/slice::ctors#;
$nb={};
$ob=[];
$pb=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb={$V3,$qb};
$sb=q#/io/fd_init.b#;
$tb=bless({$d2,$nb,$K2,$L2,$M2,$L2,$N2,$rb,$D,$sb},$W2);
$ub=q#lib/slice::ctors#;
$vb={};
$wb=q#be#;
$xb=[];
$yb=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$zb=bless({$o,$xb,$q,$yb,$s,$t},$u);
$Ab={$wb,$zb};
$Bb=q#/io/fd_shell.b#;
$Cb=bless({$d2,$vb,$K2,$L2,$M2,$L2,$N2,$Ab,$D,$Bb},$W2);
$Db=q#lib/slice::ctors#;
$Eb={};
$Fb=q#cloexec#;
$Gb=[];
$Hb=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#fcntl_flag#;
$Kb=[];
$Lb=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#nonblock#;
$Ob=[];
$Pb=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb={$Fb,$Ib,$Jb,$Mb,$Nb,$Qb};
$Sb=q#/io/fd_fcntl.b#;
$Tb=bless({$d2,$Eb,$K2,$L2,$M2,$L2,$N2,$Rb,$D,$Sb},$W2);
$Ub=q#lib/slice::ctors#;
$Vb={};
$Wb=[];
$Xb=q#shift->close#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#close#;
$cc=[];
$dc=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc={$Zb,$ec};
$gc=q#/io/fd_gc.b#;
$hc=bless({$d2,$Vb,$K2,$L2,$M2,$Yb,$N2,$fc,$D,$gc},$W2);
$ic=q#lib/slice::ctors#;
$jc={};
$kc=[];
$lc=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc=q#write#;
$oc=[];
$pc=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc={$w8,$mc,$nc,$qc};
$sc=q#/io/fd_perlio.b#;
$tc=bless({$d2,$jc,$K2,$L2,$M2,$L2,$N2,$rc,$D,$sc},$W2);
$uc=q#lib/slice::ctors#;
$vc=[$l8,$lb,$tb,$Cb,$Tb,$hc,$tc];
$wc=bless({$d2,$db,$D,$eb,$C2,$vc},$i2);
$xc=q#io/fd.c::ctors#;
$yc=q#ni:/io/fd.c#;
$zc={$i2,1};
$Ac=q#/io/fd.c#;
$Bc=[$N8];
$Cc=bless({$d2,$zc,$D,$Ac,$C2,$Bc},$E2);
$Dc=q#metaclass::ctors#;
$Ec=q#ni:/io/fd_fcntl.b#;
$Fc=q#ni:/io/fd_gc.b#;
$Gc=q#ni:/io/fd_init.b#;
$Hc=q#ni:/io/fd_perlio.b#;
$Ic=q#ni:/io/fd_readers.b#;
$Jc=q#ni:/io/fd_shell.b#;
$Kc=q#ni:/io/file#;
$Lc={$i4,1};
$Mc=q#/io/file#;
$Nc={};
$Oc=[];
$Pc=q#shift->{'name'}#;
$Qc=bless({$o,$Oc,$q,$Pc,$s,$t},$u);
$Rc={$D,$Qc};
$Sc=q#/io/file_readers.b#;
$Tc=bless({$d2,$Nc,$K2,$L2,$M2,$L2,$N2,$Rc,$D,$Sc},$W2);
$Uc=q#lib/slice::ctors#;
$Vc={};
$Wc=q#mode#;
$Xc=[];
$Yc=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd={$Wc,$Zc};
$dd=q#/io/file_accessors.b#;
$ed=bless({$d2,$Vc,$K2,$L2,$M2,$L2,$N2,$cd,$D,$dd},$W2);
$fd=q#lib/slice::ctors#;
$gd={};
$hd=[];
$id=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$V3,$jd};
$ld=q#/io/file_init.b#;
$md=bless({$d2,$gd,$K2,$L2,$M2,$L2,$N2,$kd,$D,$ld},$W2);
$nd=q#lib/slice::ctors#;
$od={};
$pd=q#r#;
$qd=[];
$rd=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=[];
$ud=q#shift->r->read(@_)#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd=q#w#;
$xd=[];
$yd=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$zd=bless({$o,$xd,$q,$yd,$s,$t},$u);
$Ad=[];
$Bd=q#shift->w->write(@_)#;
$Cd=bless({$o,$Ad,$q,$Bd,$s,$t},$u);
$Dd={$pd,$sd,$w8,$vd,$wd,$zd,$nc,$Cd};
$Ed=q#/io/file_io.b#;
$Fd=bless({$d2,$od,$K2,$L2,$M2,$L2,$N2,$Dd,$D,$Ed},$W2);
$Gd=q#lib/slice::ctors#;
$Hd=[$l8,$Tc,$ed,$md,$Fd];
$Id=bless({$d2,$Lc,$D,$Mc,$C2,$Hd},$j2);
$Jd=q#io/file.c::ctors#;
$Kd=q#ni:/io/file.c#;
$Ld={$j2,1};
$Md=q#/io/file.c#;
$Nd=[$N8];
$Od=bless({$d2,$Ld,$D,$Md,$C2,$Nd},$E2);
$Pd=q#metaclass::ctors#;
$Qd=q#ni:/io/file_accessors.b#;
$Rd=q#ni:/io/file_init.b#;
$Sd=q#ni:/io/file_io.b#;
$Td=q#ni:/io/file_readers.b#;
$Ud=q#ni:/io/named_io_fns.b#;
$Vd={};
$Wd=q#fcntl#;
$Xd=[];
$Yd=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Zd=bless({$o,$Xd,$q,$Yd,$s,$t},$u);
$ce=[];
$de=q#CORE::fork#;
$ee=bless({$o,$ce,$q,$de,$s,$t},$u);
$fe=q#open2#;
$ge=[];
$he=q#CORE::open $_[0], $_[1]#;
$ie=bless({$o,$ge,$q,$he,$s,$t},$u);
$je=q#waitpid#;
$ke=[];
$le=q#CORE::waitpid $_[0], $_[1]#;
$me=bless({$o,$ke,$q,$le,$s,$t},$u);
$ne={$Wd,$Zd,$za,$ee,$fe,$ie,$je,$me};
$oe=q#/io/named_io_fns.b#;
$pe=bless({$d2,$Vd,$K2,$L2,$M2,$L2,$N2,$ne,$D,$oe},$W2);
$qe=q#main#;
$re=q#lib/slice::ctors#;
$se=q#ni:/io/null#;
$te={$j4,1};
$ue=q#/io/null#;
$ve={};
$we=[];
$xe=q#+{fd => undef}#;
$ye=bless({$o,$we,$q,$xe,$s,$t},$u);
$ze={$V3,$ye};
$Ae=q#/io/null_init.b#;
$Be=bless({$d2,$ve,$K2,$L2,$M2,$L2,$N2,$ze,$D,$Ae},$W2);
$Ce=q#lib/slice::ctors#;
$De={};
$Ee=[];
$Fe=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Ge=bless({$o,$Ee,$q,$Fe,$s,$t},$u);
$He=[];
$Ie=q#shift->fd->read(@_)#;
$Je=bless({$o,$He,$q,$Ie,$s,$t},$u);
$Ke=[];
$Le=q#shift->fd->write(@_)#;
$Me=bless({$o,$Ke,$q,$Le,$s,$t},$u);
$Ne={$P9,$Ge,$w8,$Je,$nc,$Me};
$Oe=q#/io/null_io.b#;
$Pe=bless({$d2,$De,$K2,$L2,$M2,$L2,$N2,$Ne,$D,$Oe},$W2);
$Qe=q#lib/slice::ctors#;
$Re=[$l8,$Be,$Pe];
$Se=bless({$d2,$te,$D,$ue,$C2,$Re},$k2);
$Te=q#io/null.c::ctors#;
$Ue=q#ni:/io/null.c#;
$Ve={$k2,1};
$We=q#/io/null.c#;
$Xe=[$N8];
$Ye=bless({$d2,$Ve,$D,$We,$C2,$Xe},$E2);
$Ze=q#metaclass::ctors#;
$cf=q#ni:/io/null_init.b#;
$df=q#ni:/io/null_io.b#;
$ef=q#ni:/io/object#;
$ff=q#ni:/io/object.c#;
$gf=q#ni:/io/object_checks.b#;
$hf=q#ni:/io/object_constructors.b#;
$if=q#ni:/io/object_memory.b#;
$jf=q#ni:/io/object_ops.b#;
$kf=q#ni:/io/object_stream.b#;
$lf=q#ni:/io/pid#;
$mf={$l4,1};
$nf={};
$of=q#pid#;
$pf=[];
$qf=q#shift->{'pid'}#;
$rf=bless({$o,$pf,$q,$qf,$s,$t},$u);
$sf=q#status#;
$tf=[];
$uf=q#shift->{'status'}#;
$vf=bless({$o,$tf,$q,$uf,$s,$t},$u);
$wf={$of,$rf,$sf,$vf};
$xf=q#/io/pid_readers.b#;
$yf=bless({$d2,$nf,$K2,$L2,$M2,$L2,$N2,$wf,$D,$xf},$W2);
$zf=q#lib/slice::ctors#;
$Af={};
$Bf=[];
$Cf=q#shift->await#;
$Df=bless({$o,$Bf,$q,$Cf,$s,$t},$u);
$Ef=[];
$Ff=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Gf=bless({$o,$Ef,$q,$Ff,$s,$t},$u);
$Hf={$V3,$Gf};
$If=q#/io/pid_init.b#;
$Jf=bless({$d2,$Af,$K2,$L2,$M2,$Df,$N2,$Hf,$D,$If},$W2);
$Kf=q#lib/slice::ctors#;
$Lf={};
$Mf=q#await#;
$Nf=[];
$Of=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Pf=bless({$o,$Nf,$q,$Of,$s,$t},$u);
$Qf=q#running#;
$Rf=[];
$Sf=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Tf=bless({$o,$Rf,$q,$Sf,$s,$t},$u);
$Uf={$Mf,$Pf,$Qf,$Tf};
$Vf=q#/io/pid_wait.b#;
$Wf=bless({$d2,$Lf,$K2,$L2,$M2,$L2,$N2,$Uf,$D,$Vf},$W2);
$Xf=q#lib/slice::ctors#;
$Yf={};
$Zf=[];
$cg=q#shift->stdout->read(@_)#;
$dg=bless({$o,$Zf,$q,$cg,$s,$t},$u);
$eg=[];
$fg=q#shift->stdin->write(@_)#;
$gg=bless({$o,$eg,$q,$fg,$s,$t},$u);
$hg={$w8,$dg,$nc,$gg};
$ig=q#/io/pid_io.b#;
$jg=bless({$d2,$Yf,$K2,$L2,$M2,$L2,$N2,$hg,$D,$ig},$W2);
$kg=q#lib/slice::ctors#;
$lg={};
$mg=[];
$ng=q#$_[0]->{external_fds}{$_[1]}#;
$og=bless({$o,$mg,$q,$ng,$s,$t},$u);
$pg=[];
$qg=q#shift->fd(2)#;
$rg=bless({$o,$pg,$q,$qg,$s,$t},$u);
$sg=[];
$tg=q#shift->fd(0)#;
$ug=bless({$o,$sg,$q,$tg,$s,$t},$u);
$vg=[];
$wg=q#shift->fd(1)#;
$xg=bless({$o,$vg,$q,$wg,$s,$t},$u);
$yg={$P9,$og,$T9,$rg,$X9,$ug,$da,$xg};
$zg=q#/io/pid_accessors.b#;
$Ag=bless({$d2,$lg,$K2,$L2,$M2,$L2,$N2,$yg,$D,$zg},$W2);
$Bg=q#lib/slice::ctors#;
$Cg=[$l8,$yf,$Jf,$Wf,$jg,$Ag];
$Dg=bless({$d2,$mf,$D,$I1,$C2,$Cg},$m2);
$Eg=q#io/pid.c::ctors#;
$Fg=q#ni:/io/pid.c#;
$Gg={$m2,1};
$Hg=q#/io/pid.c#;
$Ig=[$N8];
$Jg=bless({$d2,$Gg,$D,$Hg,$C2,$Ig},$E2);
$Kg=q#metaclass::ctors#;
$Lg=q#ni:/io/pid_accessors.b#;
$Mg=q#ni:/io/pid_init.b#;
$Ng=q#ni:/io/pid_io.b#;
$Og=q#ni:/io/pid_readers.b#;
$Pg=q#ni:/io/pid_wait.b#;
$Qg=q#ni:/io/str#;
$Rg={$m4,1};
$Sg=q#/io/str#;
$Tg={};
$Ug=q#data#;
$Vg=[];
$Wg=q#shift->{'data'}#;
$Xg=bless({$o,$Vg,$q,$Wg,$s,$t},$u);
$Yg=q#end#;
$Zg=[];
$ch=q#shift->{'end'}#;
$dh=bless({$o,$Zg,$q,$ch,$s,$t},$u);
$eh=q#start#;
$fh=[];
$gh=q#shift->{'start'}#;
$hh=bless({$o,$fh,$q,$gh,$s,$t},$u);
$ih={$Ug,$Xg,$Yg,$dh,$eh,$hh};
$jh=q#/io/str_ro.b#;
$kh=bless({$d2,$Tg,$K2,$L2,$M2,$L2,$N2,$ih,$D,$jh},$W2);
$lh=q#lib/slice::ctors#;
$mh={};
$nh=[];
$oh=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$ph=bless({$o,$nh,$q,$oh,$s,$t},$u);
$qh={$V3,$ph};
$rh=q#/io/str_init.b#;
$sh=bless({$d2,$mh,$K2,$L2,$M2,$L2,$N2,$qh,$D,$rh},$W2);
$th=q#lib/slice::ctors#;
$uh={};
$vh=[];
$wh=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$xh=bless({$o,$vh,$q,$wh,$s,$t},$u);
$yh=q#remaining#;
$zh=[];
$Ah=q#my $self = shift; $$self{end} - $$self{start}#;
$Bh=bless({$o,$zh,$q,$Ah,$s,$t},$u);
$Ch=[];
$Dh=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Eh=bless({$o,$Ch,$q,$Dh,$s,$t},$u);
$Fh={$w8,$xh,$yh,$Bh,$nc,$Eh};
$Gh=q#/io/str_io.b#;
$Hh=bless({$d2,$uh,$K2,$L2,$M2,$L2,$N2,$Fh,$D,$Gh},$W2);
$Ih=q#lib/slice::ctors#;
$Jh=[$l8,$kh,$sh,$Hh];
$Kh=bless({$d2,$Rg,$D,$Sg,$C2,$Jh},$n2);
$Lh=q#io/str.c::ctors#;
$Mh=q#ni:/io/str.c#;
$Nh={$n2,1};
$Oh=q#/io/str.c#;
$Ph=[$N8];
$Qh=bless({$d2,$Nh,$D,$Oh,$C2,$Ph},$E2);
$Rh=q#metaclass::ctors#;
$Sh=q#ni:/io/str_init.b#;
$Th=q#ni:/io/str_io.b#;
$Uh=q#ni:/io/str_ro.b#;
$Vh=q#ni:/lib/accessor.b#;
$Wh=q#ni:/lib/behavior#;
$Xh=q#ni:/lib/behavior.c#;
$Yh=q#ni:/lib/branch#;
$Zh={$Y2,1};
$ci=q#/lib/branch#;
$di={};
$ei=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$fi=bless({$q,$ei,$s,$t},$u);
$gi={$V3,$fi};
$hi=q#/lib/branch_init.b#;
$ii=bless({$d2,$di,$K2,$L2,$M2,$L2,$N2,$gi,$D,$hi},$W2);
$ji=q#lib/slice::ctors#;
$ki=[$T4,$k3,$X2,$ii,$X5];
$li=bless({$d2,$Zh,$D,$ci,$C2,$ki},$p2);
$mi=q#lib/branch.c::ctors#;
$ni=q#ni:/lib/branch.b#;
$oi=q#ni:/lib/branch.c#;
$pi={$p2,1};
$qi=q#/lib/branch.c#;
$ri=[$Q6];
$si=bless({$d2,$pi,$D,$qi,$C2,$ri},$E2);
$ti=q#metaclass::ctors#;
$ui=q#ni:/lib/branch_init.b#;
$vi=q#ni:/lib/class_init.b#;
$wi=q#ni:/lib/dataslice#;
$xi={$o4,1};
$yi=q#/lib/dataslice#;
$zi={};
$Ai=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Bi=bless({$q,$Ai,$s,$t},$u);
$Ci={$V3,$Bi};
$Di=q#/lib/dataslice_init.b#;
$Ei=bless({$d2,$zi,$K2,$L2,$M2,$L2,$N2,$Ci,$D,$Di},$W2);
$Fi=q#lib/slice::ctors#;
$Gi={};
$Hi=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Ii=bless({$q,$Hi,$s,$t},$u);
$Ji={$R2,$Ii};
$Ki=q#/lib/dataslice_apply.b#;
$Li=bless({$d2,$Gi,$K2,$L2,$M2,$L2,$N2,$Ji,$D,$Ki},$W2);
$Mi=q#lib/slice::ctors#;
$Ni=[$T4,$Ei,$Li];
$Oi=bless({$d2,$xi,$D,$yi,$C2,$Ni},$q2);
$Pi=q#lib/dataslice.c::ctors#;
$Qi=q#ni:/lib/dataslice.c#;
$Ri={$q2,1};
$Si=q#/lib/dataslice.c#;
$Ti=[$Q6];
$Ui=bless({$d2,$Ri,$D,$Si,$C2,$Ti},$E2);
$Vi=q#metaclass::ctors#;
$Wi=q#ni:/lib/dataslice_apply.b#;
$Xi=q#ni:/lib/dataslice_init.b#;
$Yi=q#ni:/lib/definition.b#;
$Zi=q#ni:/lib/definition_def.b#;
$cj=q#ni:/lib/definition_defdata.b#;
$dj=q#ni:/lib/doc#;
$ej={$F,1};
$fj={};
$gj=q#shift; +{name => shift, doc => []}#;
$hj=bless({$q,$gj,$s,$t},$u);
$ij={$V3,$hj};
$jj=q#/lib/doc_init.b#;
$kj=bless({$d2,$fj,$K2,$L2,$M2,$L2,$N2,$ij,$D,$jj},$W2);
$lj=q#lib/slice::ctors#;
$mj={};
$nj=q#'ni.doc'#;
$oj=bless({$q,$nj,$s,$t},$u);
$pj={$p3,$oj};
$qj=q#/lib/doc_namespace.b#;
$rj=bless({$d2,$mj,$K2,$L2,$M2,$L2,$N2,$pj,$D,$qj},$W2);
$sj=q#lib/slice::ctors#;
$tj={};
$uj=q#AUTOLOAD#;
$vj=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$wj=bless({$q,$vj,$s,$t},$u);
$xj={$uj,$wj};
$yj=q#/lib/doc_define.b#;
$zj=bless({$d2,$tj,$K2,$L2,$M2,$L2,$N2,$xj,$D,$yj},$W2);
$Aj=q#lib/slice::ctors#;
$Bj={};
$Cj=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Dj=bless({$q,$Cj,$s,$t},$u);
$Ej=q#tests#;
$Fj=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$Gj=bless({$q,$Fj,$s,$t},$u);
$Hj={$n,$Dj,$Ej,$Gj};
$Ij=q#/lib/doc_test.b#;
$Jj=bless({$d2,$Bj,$K2,$L2,$M2,$L2,$N2,$Hj,$D,$Ij},$W2);
$Kj=q#lib/slice::ctors#;
$Lj=[$F4,$k3,$kj,$rj,$zj,$Jj];
$Mj=bless({$d2,$ej,$D,$Y1,$C2,$Lj},$r2);
$Nj=q#lib/doc.c::ctors#;
$Oj=q#ni:/lib/doc.c#;
$Pj={$r2,1};
$Qj=q#/lib/doc.c#;
$Rj=[$L6];
$Sj=bless({$d2,$Pj,$D,$Qj,$C2,$Rj},$E2);
$Tj=q#metaclass::ctors#;
$Uj=q#ni:/lib/doc_define.b#;
$Vj=q#ni:/lib/doc_init.b#;
$Wj=q#ni:/lib/doc_namespace.b#;
$Xj=q#ni:/lib/doc_test.b#;
$Yj=q#ni:/lib/documentable.b#;
$Zj=q#ni:/lib/fn#;
$ck={$u,1};
$dk=q#/lib/fn#;
$ek={};
$fk=q#shift->compile#;
$gk=bless({$q,$fk,$s,$t},$u);
$hk=q#compile#;
$ik=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$jk=bless({$q,$ik,$s,$t},$u);
$kk=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$lk=bless({$q,$kk,$s,$t},$u);
$mk={$hk,$jk,$V3,$lk};
$nk=q#/lib/fn_init.b#;
$ok=bless({$d2,$ek,$K2,$gk,$M2,$L2,$N2,$mk,$D,$nk},$W2);
$pk=q#lib/slice::ctors#;
$qk={};
$rk=[];
$sk=q#shift->{'annotations'}#;
$tk=bless({$o,$rk,$q,$sk,$s,$t},$u);
$uk=[];
$vk=q#shift->{'code'}#;
$wk=bless({$o,$uk,$q,$vk,$s,$t},$u);
$xk=q#fn#;
$yk=[];
$zk=q#shift->{'fn'}#;
$Ak=bless({$o,$yk,$q,$zk,$s,$t},$u);
$Bk={$o,$tk,$q,$wk,$xk,$Ak};
$Ck=q#/lib/fn_ro.b#;
$Dk=bless({$d2,$qk,$K2,$L2,$M2,$L2,$N2,$Bk,$D,$Ck},$W2);
$Ek=q#lib/slice::ctors#;
$Fk={};
$Gk=[];
$Hk=q#shift->{code}#;
$Ik=bless({$o,$Gk,$q,$Hk,$s,$t},$u);
$Jk=[];
$Kk=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$Lk=bless({$o,$Jk,$q,$Kk,$s,$t},$u);
$Mk={$w5,$Ik,$F5,$Lk};
$Nk=q#/lib/fn_ops.b#;
$Ok=bless({$d2,$Fk,$K2,$L2,$M2,$L2,$N2,$Mk,$D,$Nk},$W2);
$Pk=q#lib/slice::ctors#;
$Qk={};
$Rk=q#serialize#;
$Sk=[];
$Tk=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Uk=bless({$o,$Sk,$q,$Tk,$s,$t},$u);
$Vk={$Rk,$Uk};
$Wk=q#/lib/fn_serialize.b#;
$Xk=bless({$d2,$Qk,$K2,$L2,$M2,$L2,$N2,$Vk,$D,$Wk},$W2);
$Yk=q#lib/slice::ctors#;
$Zk=[$F4,$n6,$ok,$Dk,$Ok,$Xk];
$cl=bless({$d2,$ck,$D,$dk,$C2,$Zk},$s2);
$dl=q#lib/fn.c::ctors#;
$el=q#ni:/lib/fn.c#;
$fl={$s2,1};
$gl=q#/lib/fn.c#;
$hl=[$L6];
$il=bless({$d2,$fl,$D,$gl,$C2,$hl},$E2);
$jl=q#metaclass::ctors#;
$kl=q#ni:/lib/fn_init.b#;
$ll=q#ni:/lib/fn_ops.b#;
$ml=q#ni:/lib/fn_ro.b#;
$nl=q#ni:/lib/fn_serialize.b#;
$ol=q#ni:/lib/global_static_test.b#;
$pl={};
$ql=q#now#;
$rl=[];
$sl=q#ni('ni:/lib/test_value')->new(shift)#;
$tl=q#($)#;
$ul=bless({$o,$rl,$q,$sl,$s,$tl},$u);
$vl={$ql,$ul};
$wl=q#/lib/global_static_test.b#;
$xl=bless({$d2,$pl,$K2,$L2,$M2,$L2,$N2,$vl,$D,$wl},$W2);
$yl=q#lib/slice::ctors#;
$zl=q#ni:/lib/image#;
$Al={$p4,1};
$Bl=q#/lib/image#;
$Cl={};
$Dl=[];
$El=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Fl=bless({$o,$Dl,$q,$El,$s,$t},$u);
$Gl={$V3,$Fl};
$Hl=q#/lib/image_init.b#;
$Il=bless({$d2,$Cl,$K2,$L2,$M2,$L2,$N2,$Gl,$D,$Hl},$W2);
$Jl=q#lib/slice::ctors#;
$Kl={};
$Ll=q#address#;
$Ml=[];
$Nl=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Ol=bless({$o,$Ml,$q,$Nl,$s,$t},$u);
$Pl=q#allocate_gensym#;
$Ql=[];
$Rl=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Sl=bless({$o,$Ql,$q,$Rl,$s,$t},$u);
$Tl=q#boot_side_effect#;
$Ul=[];
$Vl=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Wl=bless({$o,$Ul,$q,$Vl,$s,$t},$u);
$Xl=q#circular_links#;
$Yl=[];
$Zl=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$cm=bless({$o,$Yl,$q,$Zl,$s,$t},$u);
$dm=q#finalizer#;
$em=[];
$fm=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$gm=bless({$o,$em,$q,$fm,$s,$t},$u);
$hm=q#gensym#;
$im=[];
$jm=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$km=bless({$o,$im,$q,$jm,$s,$t},$u);
$lm=q#is_circular#;
$mm=[];
$nm=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$om=bless({$o,$mm,$q,$nm,$s,$t},$u);
$pm=q#quote#;
$qm=[];
$rm=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$sm=bless({$o,$qm,$q,$rm,$s,$t},$u);
$tm=q#quote_array#;
$um=[];
$vm=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$wm=bless({$o,$um,$q,$vm,$s,$t},$u);
$xm=q#quote_blessed#;
$ym=[];
$zm=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Am=bless({$o,$ym,$q,$zm,$s,$t},$u);
$Bm=q#quote_class#;
$Cm=[];
$Dm=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Em=bless({$o,$Cm,$q,$Dm,$s,$t},$u);
$Fm=q#quote_hash#;
$Gm=[];
$Hm=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Im=bless({$o,$Gm,$q,$Hm,$s,$t},$u);
$Jm=q#quote_object#;
$Km=[];
$Lm=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Mm=bless({$o,$Km,$q,$Lm,$s,$t},$u);
$Nm=q#quote_scalar#;
$Om=[];
$Pm=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Qm=bless({$o,$Om,$q,$Pm,$s,$t},$u);
$Rm=q#quote_value#;
$Sm=[];
$Tm=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$Um=bless({$o,$Sm,$q,$Tm,$s,$t},$u);
$Vm=q#reconstruction#;
$Wm=[];
$Xm=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ym=bless({$o,$Wm,$q,$Xm,$s,$t},$u);
$Zm=q#side_effect#;
$cn=[];
$dn=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$en=bless({$o,$cn,$q,$dn,$s,$t},$u);
$fn=[];
$gn=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$hn=bless({$o,$fn,$q,$gn,$s,$t},$u);
$in={$Ll,$Ol,$Pl,$Sl,$Tl,$Wl,$Xl,$cm,$dm,$gm,$hm,$km,$lm,$om,$pm,$sm,$tm,$wm,$xm,$Am,$Bm,$Em,$Fm,$Im,$Jm,$Mm,$Nm,$Qm,$Rm,$Um,$Vm,$Ym,$Zm,$en,$nc,$hn};
$jn=q#/lib/image_quoting.b#;
$kn=bless({$d2,$Kl,$K2,$L2,$M2,$L2,$N2,$in,$D,$jn},$W2);
$ln=q#lib/slice::ctors#;
$mn=[$F4,$Il,$kn];
$nn=bless({$d2,$Al,$D,$Bl,$C2,$mn},$t2);
$on=q#lib/image.c::ctors#;
$pn=q#ni:/lib/image.c#;
$qn={$t2,1};
$rn=q#/lib/image.c#;
$sn=[$L6];
$tn=bless({$d2,$qn,$D,$rn,$C2,$sn},$E2);
$un=q#metaclass::ctors#;
$vn=q#ni:/lib/image_init.b#;
$wn=q#ni:/lib/image_quoting.b#;
$xn=q#ni:/lib/instance.b#;
$yn=q#ni:/lib/instantiable.b#;
$zn=q#ni:/lib/json.b#;
$An={};
$Bn=q#json_decode#;
$Cn=[];
$Dn=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$En=bless({$o,$Cn,$q,$Dn,$s,$tl},$u);
$Fn=q#json_encode#;
$Gn=[];
$Hn=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$In=bless({$o,$Gn,$q,$Hn,$s,$tl},$u);
$Jn=q#json_escape#;
$Kn=[];
$Ln=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Mn=bless({$o,$Kn,$q,$Ln,$s,$tl},$u);
$Nn=q#json_unescape#;
$On=[];
$Pn=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Qn=bless({$o,$On,$q,$Pn,$s,$tl},$u);
$Rn=q#json_unescape_one#;
$Sn=[];
$Tn=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Un=bless({$o,$Sn,$q,$Tn,$s,$tl},$u);
$Vn={$Bn,$En,$Fn,$In,$Jn,$Mn,$Nn,$Qn,$Rn,$Un};
$Wn=q#/lib/json.b#;
$Xn=bless({$d2,$An,$K2,$L2,$M2,$L2,$N2,$Vn,$D,$Wn},$W2);
$Yn=q#ni#;
$Zn=q#lib/slice::ctors#;
$co=q#ni:/lib/name_as_string.b#;
$do=q#ni:/lib/named.b#;
$eo=q#ni:/lib/named_in_ni.b#;
$fo=q#ni:/lib/namespaced.b#;
$go=q#ni:/lib/ni#;
$ho={$q4,1};
$io=q#/lib/ni#;
$jo={};
$ko=q#extend#;
$lo=[];
$mo=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$no=bless({$o,$lo,$q,$mo,$s,$t},$u);
$oo=q#is_mutable#;
$po=[];
$qo=q#$0 ne "-" && -w $0#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so=q#modify#;
$to=[];
$uo=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$vo=bless({$o,$to,$q,$uo,$s,$t},$u);
$wo={$ko,$no,$oo,$ro,$so,$vo};
$xo=q#/lib/ni_self.b#;
$yo=bless({$d2,$jo,$K2,$L2,$M2,$L2,$N2,$wo,$D,$xo},$W2);
$zo=q#lib/slice::ctors#;
$Ao={};
$Bo=q#exists#;
$Co=[];
$Do=q#exists $_[0]->{named}{$_[1]}#;
$Eo=bless({$o,$Co,$q,$Do,$s,$t},$u);
$Fo=q#quoted#;
$Go=[];
$Ho=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo={$Bo,$Eo,$Fo,$Io};
$Ko=q#/lib/ni_image.b#;
$Lo=bless({$d2,$Ao,$K2,$L2,$M2,$L2,$N2,$Jo,$D,$Ko},$W2);
$Mo=q#lib/slice::ctors#;
$No={};
$Oo=q#--internal/+=#;
$Po=[];
$Qo=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Ro=bless({$o,$Po,$q,$Qo,$s,$t},$u);
$So=q#--internal/eval#;
$To=[];
$Uo=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Vo=bless({$o,$To,$q,$Uo,$s,$t},$u);
$Wo=q#--internal/image#;
$Xo=[];
$Yo=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp=q#--internal/test#;
$dp=[];
$ep=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$fp=bless({$o,$dp,$q,$ep,$s,$t},$u);
$gp=q#run#;
$hp=[];
$ip=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$jp=bless({$o,$hp,$q,$ip,$s,$t},$u);
$kp={$Oo,$Ro,$So,$Vo,$Wo,$Zo,$cp,$fp,$gp,$jp};
$lp=q#/lib/ni_main.b#;
$mp=bless({$d2,$No,$K2,$L2,$M2,$L2,$N2,$kp,$D,$lp},$W2);
$np=q#lib/slice::ctors#;
$op={};
$pp=[];
$qp=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$rp=bless({$o,$pp,$q,$qp,$s,$t},$u);
$sp=q#resolver_for#;
$tp=[];
$up=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={$H3,$rp,$sp,$vp};
$xp=q#/lib/ni_resolver.b#;
$yp=bless({$d2,$op,$K2,$L2,$M2,$L2,$N2,$wp,$D,$xp},$W2);
$zp=q#lib/slice::ctors#;
$Ap=[$F4,$yo,$Lo,$mp,$yp];
$Bp=bless({$d2,$ho,$D,$io,$C2,$Ap},$u2);
$Cp=q#lib/ni.c::ctors#;
$Dp=q#ni:/lib/ni.c#;
$Ep={$u2,1};
$Fp=q#/lib/ni.c#;
$Gp=[$L6];
$Hp=bless({$d2,$Ep,$D,$Fp,$C2,$Gp},$E2);
$Ip=q#metaclass::ctors#;
$Jp=q#ni:/lib/ni_image.b#;
$Kp=q#ni:/lib/ni_main.b#;
$Lp=q#ni:/lib/ni_resolver.b#;
$Mp=q#ni:/lib/ni_self.b#;
$Np=q#ni:/lib/ni_static_util.b#;
$Op={};
$Pp=q#abbrev#;
$Qp=[];
$Rp=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Sp=bless({$o,$Qp,$q,$Rp,$s,$t},$u);
$Tp=q#dor#;
$Up=[];
$Vp=q#defined $_[0] ? $_[0] : $_[1]#;
$Wp=bless({$o,$Up,$q,$Vp,$s,$t},$u);
$Xp=q#indent#;
$Yp=[];
$Zp=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$cq=bless({$o,$Yp,$q,$Zp,$s,$t},$u);
$dq=q#max#;
$eq=[];
$fq=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$gq=bless({$o,$eq,$q,$fq,$s,$t},$u);
$hq=q#maxstr#;
$iq=[];
$jq=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$kq=bless({$o,$iq,$q,$jq,$s,$t},$u);
$lq=q#mean#;
$mq=[];
$nq=q#sum(@_) / (@_ || 1)#;
$oq=bless({$o,$mq,$q,$nq,$s,$t},$u);
$pq=q#min#;
$qq=[];
$rq=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$sq=bless({$o,$qq,$q,$rq,$s,$t},$u);
$tq=q#minstr#;
$uq=[];
$vq=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$wq=bless({$o,$uq,$q,$vq,$s,$t},$u);
$xq=q#sgr#;
$yq=[];
$zq=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Aq=bless({$o,$yq,$q,$zq,$s,$t},$u);
$Bq=q#sr#;
$Cq=[];
$Dq=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Eq=bless({$o,$Cq,$q,$Dq,$s,$t},$u);
$Fq=q#sum#;
$Gq=[];
$Hq=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Iq=bless({$o,$Gq,$q,$Hq,$s,$t},$u);
$Jq=q#swap#;
$Kq=[];
$Lq=q#@_[0, 1] = @_[1, 0]#;
$Mq=bless({$o,$Kq,$q,$Lq,$s,$t},$u);
$Nq={$Pp,$Sp,$Tp,$Wp,$Xp,$cq,$dq,$gq,$hq,$kq,$lq,$oq,$pq,$sq,$tq,$wq,$xq,$Aq,$Bq,$Eq,$Fq,$Iq,$Jq,$Mq};
$Oq=q#/lib/ni_static_util.b#;
$Pq=bless({$d2,$Op,$K2,$L2,$M2,$L2,$N2,$Nq,$D,$Oq},$W2);
$Qq=q#lib/slice::ctors#;
$Rq=q#ni:/lib/perlbranch.b#;
$Sq=q#ni:/lib/ref_eq.b#;
$Tq=q#ni:/lib/resolver.b#;
$Uq=q#ni:/lib/slice#;
$Vq={$W2,1};
$Wq=q#/lib/slice#;
$Xq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Yq=bless({$q,$Xq,$s,$t},$u);
$Zq=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$cr=bless({$q,$Zq,$s,$t},$u);
$dr=q#lib/slice::apply#;
$er=q#lib/slice::apply_unsafe#;
$fr={};
$gr=q#apply_unsafe#;
$hr={$R2,$Yq,$gr,$cr};
$ir=q#/lib/slice.b#;
$jr=bless({$d2,$fr,$N2,$hr,$D,$ir},$W2);
$kr=q#lib/slice::ctors#;
$lr={};
$mr=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$nr=bless({$q,$mr,$s,$t},$u);
$or={$V3,$nr};
$pr=q#/lib/slice_init.b#;
$qr=bless({$d2,$lr,$N2,$or,$D,$pr},$W2);
$rr=q#lib/slice::ctors#;
$sr={};
$tr=[];
$ur=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$vr=bless({$o,$tr,$q,$ur,$s,$t},$u);
$wr={$Rk,$vr};
$xr=q#/lib/slice_serialize.b#;
$yr=bless({$d2,$sr,$K2,$L2,$M2,$L2,$N2,$wr,$D,$xr},$W2);
$zr=q#lib/slice::ctors#;
$Ar=[$T4,$k3,$jr,$qr,$yr];
$Br=bless({$d2,$Vq,$D,$Wq,$C2,$Ar},$v2);
$Cr=q#lib/slice.c::ctors#;
$Dr=q#ni:/lib/slice.b#;
$Er=q#ni:/lib/slice.c#;
$Fr={$v2,1};
$Gr=q#/lib/slice.c#;
$Hr=[$Q6];
$Ir=bless({$d2,$Fr,$D,$Gr,$C2,$Hr},$E2);
$Jr=q#metaclass::ctors#;
$Kr=q#ni:/lib/slice_init.b#;
$Lr=q#ni:/lib/slice_serialize.b#;
$Mr=q#ni:/lib/static_fn.b#;
$Nr={};
$Or=[];
$Pr=q#ni('ni:/lib/fn')->new(@_)#;
$Qr=bless({$o,$Or,$q,$Pr,$s,$tl},$u);
$Rr=q#fp#;
$Sr=[];
$Tr=q#ni('ni:/lib/fn')->new(@_)#;
$Ur=q#($$)#;
$Vr=bless({$o,$Sr,$q,$Tr,$s,$Ur},$u);
$Wr={$xk,$Qr,$Rr,$Vr};
$Xr=q#/lib/static_fn.b#;
$Yr=bless({$d2,$Nr,$K2,$L2,$M2,$L2,$N2,$Wr,$D,$Xr},$W2);
$Zr=q#lib/slice::ctors#;
$cs=q#ni:/lib/subclass.b#;
$ds=q#ni:/lib/tag#;
$es={$l3,1};
$fs=q#/lib/tag#;
$gs={};
$hs=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$is=bless({$q,$hs,$s,$t},$u);
$js={$R2,$is};
$ks=q#/lib/tag.b#;
$ls=bless({$d2,$gs,$K2,$L2,$M2,$L2,$N2,$js,$D,$ks},$W2);
$ms=q#lib/slice::ctors#;
$ns={};
$os=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$ps=bless({$q,$os,$s,$t},$u);
$qs={$V3,$ps};
$rs=q#/lib/tag_init.b#;
$ss=bless({$d2,$ns,$K2,$L2,$M2,$L2,$N2,$qs,$D,$rs},$W2);
$ts=q#lib/slice::ctors#;
$us=[$T4,$k3,$ls,$ss];
$vs=bless({$d2,$es,$D,$fs,$C2,$us},$w2);
$ws=q#lib/tag.c::ctors#;
$xs=q#ni:/lib/tag.b#;
$ys=q#ni:/lib/tag.c#;
$zs={$w2,1};
$As=q#/lib/tag.c#;
$Bs=[$Q6];
$Cs=bless({$d2,$zs,$D,$As,$C2,$Bs},$E2);
$Ds=q#metaclass::ctors#;
$Es=q#ni:/lib/tag_init.b#;
$Fs=q#ni:/lib/test_value#;
$Gs={$r4,1};
$Hs=q#/lib/test_value#;
$Is={};
$Js=[];
$Ks=q#\\$_[1]#;
$Ls=bless({$o,$Js,$q,$Ks,$s,$t},$u);
$Ms={$V3,$Ls};
$Ns=q#/lib/test_value_init.b#;
$Os=bless({$d2,$Is,$K2,$L2,$M2,$L2,$N2,$Ms,$D,$Ns},$W2);
$Ps=q#lib/slice::ctors#;
$Qs={};
$Rs=q#(==#;
$Ss=[];
$Ts=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Us=bless({$o,$Ss,$q,$Ts,$s,$t},$u);
$Vs=q#diff#;
$Ws=[];
$Xs=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Ys=bless({$o,$Ws,$q,$Xs,$s,$t},$u);
$Zs={$Rs,$Us,$Vs,$Ys};
$ct=q#/lib/test_value_eq.b#;
$dt=bless({$d2,$Qs,$K2,$L2,$M2,$L2,$N2,$Zs,$D,$ct},$W2);
$et=q#lib/slice::ctors#;
$ft={};
$gt=[];
$ht=q#ni::json_encode ${$_[0]}#;
$it=bless({$o,$gt,$q,$ht,$s,$t},$u);
$jt={$w5,$it};
$kt=q#/lib/test_value_str.b#;
$lt=bless({$d2,$ft,$K2,$L2,$M2,$L2,$N2,$jt,$D,$kt},$W2);
$mt=q#lib/slice::ctors#;
$nt=[$F4,$Os,$dt,$lt];
$ot=q#lib/test_value.c#;
$pt=bless({$d2,$Gs,$D,$Hs,$C2,$nt},$ot);
$qt=q#lib/test_value.c::ctors#;
$rt=q#ni:/lib/test_value.c#;
$st=q#lib/test_value.c#;
$tt={$st,1};
$ut=q#/lib/test_value.c#;
$vt=[$L6];
$wt=bless({$d2,$tt,$D,$ut,$C2,$vt},$E2);
$xt=q#metaclass::ctors#;
$yt=q#ni:/lib/test_value_eq.b#;
$zt=q#ni:/lib/test_value_init.b#;
$At=q#ni:/lib/test_value_str.b#;
$Bt=q#ni:/metaclass#;
$Ct={$E2,1};
$Dt=q#/metaclass#;
$Et=[$Q3,$n6,$c4,$c6];
$Ft=bless({$d2,$Ct,$D,$Dt,$C2,$Et},$y2);
$Gt=q#metaclass.c::ctors#;
$Ht=q#ni:/metaclass.c#;
$It={$y2,1};
$Jt=q#/metaclass.c#;
$Kt=[$A6];
$Lt=bless({$d2,$It,$D,$Jt,$C2,$Kt},$E2);
$Mt=q#metaclass::ctors#;
$Nt=q#ni:/module#;
$Ot=q#ni:/module.c#;
$Pt=q#ni:/object#;
$Qt=q#ni:/object.c#;
$Rt=q#ni:main#;
$St={$qe,1};
$Tt=[$Yr,$xl,$pe];
$Ut=bless({$d2,$St,$D,$qe,$C2,$Tt},$F2);
$Vt=q#module::ctors#;
$Wt=q#ni:ni#;
$Xt={$Yn,1};
$Yt={$Yn,1};
$Zt=q#json_escapes#;
$cu=q##;
$du=q#b#;
$eu=q#	#;
$fu=q#t#;
$gu=q#
#;
$hu=q#n#;
$iu=q##;
$ju=q#"#;
$ku=q#/#;
$lu=q#\\#;
$mu={$cu,$du,$eu,$fu,$gu,$hu,$iu,$pd,$ju,$ju,$ku,$ku,$lu,$lu};
$nu=q#json_unescapes#;
$ou={$ju,$ju,$ku,$ku,$lu,$lu,$du,$cu,$hu,$gu,$pd,$iu,$fu,$eu};
$pu={$Zt,$mu,$nu,$ou};
$qu=q#/lib/json_data.b#;
$ru=bless({$d2,$Yt,$Ug,$pu,$D,$qu},$o4);
$su=q#lib/dataslice::ctors#;
$tu=[$ru,$Xn,$Pq];
$uu=bless({$d2,$Xt,$D,$Yn,$C2,$tu},$F2);
$vu={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$Z1,$c2,$A6,$C6,$W6,$Y6,$F8,$H8,$Q8,$S8,$t8,$T8,$C8,$U8,$Ma,$Oa,$Sa,$Ua,$sa,$Va,$Ja,$Wa,$n9,$Xa,$ja,$Ya,$I9,$Za,$f9,$cb,$wc,$yc,$Cc,$Ec,$Tb,$Fc,$hc,$Gc,$tb,$Hc,$tc,$Ic,$lb,$Jc,$Cb,$Kc,$Id,$Kd,$Od,$Qd,$ed,$Rd,$md,$Sd,$Fd,$Td,$Tc,$Ud,$pe,$se,$Se,$Ue,$Ye,$cf,$Be,$df,$Pe,$ef,$l8,$ff,$N8,$gf,$O7,$hf,$X7,$if,$i8,$jf,$k7,$kf,$t7,$lf,$Dg,$Fg,$Jg,$Lg,$Ag,$Mg,$Jf,$Ng,$jg,$Og,$yf,$Pg,$Wf,$Qg,$Kh,$Mh,$Qh,$Sh,$sh,$Th,$Hh,$Uh,$kh,$Vh,$s5,$Wh,$T4,$Xh,$Q6,$Yh,$li,$ni,$X2,$oi,$si,$ui,$ii,$vi,$c4,$wi,$Oi,$Qi,$Ui,$Wi,$Li,$Xi,$Ei,$Yi,$X5,$Zi,$g5,$cj,$T5,$dj,$Mj,$Oj,$Sj,$Uj,$zj,$Vj,$kj,$Wj,$rj,$Xj,$Jj,$Yj,$P4,$Zj,$cl,$el,$il,$kl,$ok,$ll,$Ok,$ml,$Dk,$nl,$Xk,$ol,$xl,$zl,$nn,$pn,$tn,$vn,$Il,$wn,$kn,$xn,$B4,$yn,$n6,$zn,$Xn,$co,$B5,$do,$k3,$eo,$u3,$fo,$D3,$go,$Bp,$Dp,$Hp,$Jp,$Lo,$Kp,$mp,$Lp,$yp,$Mp,$yo,$Np,$Pq,$Rq,$Q3,$Sq,$K5,$Tq,$M3,$Uq,$Br,$Dr,$jr,$Er,$Ir,$Kr,$qr,$Lr,$yr,$Mr,$Yr,$cs,$w6,$ds,$vs,$xs,$ls,$ys,$Cs,$Es,$ss,$Fs,$pt,$rt,$wt,$yt,$dt,$zt,$Os,$At,$lt,$Bt,$Ft,$Ht,$Lt,$Nt,$c6,$Ot,$T6,$Pt,$F4,$Qt,$L6,$Rt,$Ut,$Wt,$uu};
$wu=q#resolvers#;
$xu=[];
$yu=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$zu=bless({$o,$xu,$q,$yu,$s,$t},$u);
$Au=q#file#;
$Bu=[];
$Cu=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Du=bless({$o,$Bu,$q,$Cu,$s,$t},$u);
$Eu=q#null#;
$Fu=[];
$Gu=q#ni('ni:/io/null')->new#;
$Hu=bless({$o,$Fu,$q,$Gu,$s,$t},$u);
$Iu=q#sh#;
$Ju=[];
$Ku=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$Lu=bless({$o,$Ju,$q,$Ku,$s,$t},$u);
$Mu=q#str#;
$Nu=[];
$Ou=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$Pu=bless({$o,$Nu,$q,$Ou,$s,$t},$u);
$Qu={$P9,$zu,$Au,$Du,$Eu,$Hu,$Iu,$Lu,$Mu,$Pu};
$Ru=bless({$c,$vu,$wu,$Qu},$q4);
$Su=q#lib/ni::ctors#;
*$er=\&$cr;
*$dr=\&$Yq;
$X2->apply_unsafe($e2);
$X2->apply_unsafe($f2);
$X2->apply_unsafe($g2);
$X2->apply_unsafe($h2);
$X2->apply_unsafe($i2);
$X2->apply_unsafe($j2);
$X2->apply_unsafe($k2);
$X2->apply_unsafe($l2);
$X2->apply_unsafe($m2);
$X2->apply_unsafe($n2);
$X2->apply_unsafe($o2);
$X2->apply_unsafe($Y2);
$X2->apply_unsafe($p2);
$X2->apply_unsafe($q2);
$X2->apply_unsafe($r2);
$X2->apply_unsafe($s2);
$X2->apply_unsafe($t2);
$X2->apply_unsafe($u2);
$X2->apply_unsafe($v2);
$X2->apply_unsafe($w2);
$X2->apply_unsafe($Z2);
$X2->apply_unsafe($E2);
$X2->apply_unsafe($y2);
$X2->apply_unsafe($F2);
$X2->apply_unsafe($z2);
$X2->apply_unsafe($A2);
$k3->apply_unsafe($e2);
$k3->apply_unsafe($f2);
$k3->apply_unsafe($g2);
$k3->apply_unsafe($h2);
$k3->apply_unsafe($i2);
$k3->apply_unsafe($j2);
$k3->apply_unsafe($k2);
$k3->apply_unsafe($l2);
$k3->apply_unsafe($m2);
$k3->apply_unsafe($n2);
$k3->apply_unsafe($o2);
$k3->apply_unsafe($Y2);
$k3->apply_unsafe($p2);
$k3->apply_unsafe($q2);
$k3->apply_unsafe($F);
$k3->apply_unsafe($r2);
$k3->apply_unsafe($s2);
$k3->apply_unsafe($t2);
$k3->apply_unsafe($u2);
$k3->apply_unsafe($W2);
$k3->apply_unsafe($v2);
$k3->apply_unsafe($l3);
$k3->apply_unsafe($w2);
$k3->apply_unsafe($m3);
$k3->apply_unsafe($E2);
$k3->apply_unsafe($y2);
$k3->apply_unsafe($F2);
$k3->apply_unsafe($z2);
$k3->apply_unsafe($A2);
$u3->apply_unsafe($e2);
$u3->apply_unsafe($f2);
$u3->apply_unsafe($g2);
$u3->apply_unsafe($h2);
$u3->apply_unsafe($i2);
$u3->apply_unsafe($j2);
$u3->apply_unsafe($k2);
$u3->apply_unsafe($l2);
$u3->apply_unsafe($m2);
$u3->apply_unsafe($n2);
$u3->apply_unsafe($o2);
$u3->apply_unsafe($Y2);
$u3->apply_unsafe($p2);
$u3->apply_unsafe($q2);
$u3->apply_unsafe($r2);
$u3->apply_unsafe($s2);
$u3->apply_unsafe($t2);
$u3->apply_unsafe($u2);
$u3->apply_unsafe($W2);
$u3->apply_unsafe($v2);
$u3->apply_unsafe($l3);
$u3->apply_unsafe($w2);
$u3->apply_unsafe($v3);
$u3->apply_unsafe($E2);
$u3->apply_unsafe($y2);
$u3->apply_unsafe($F2);
$u3->apply_unsafe($z2);
$u3->apply_unsafe($A2);
$D3->apply_unsafe($e2);
$D3->apply_unsafe($f2);
$D3->apply_unsafe($g2);
$D3->apply_unsafe($h2);
$D3->apply_unsafe($i2);
$D3->apply_unsafe($j2);
$D3->apply_unsafe($k2);
$D3->apply_unsafe($l2);
$D3->apply_unsafe($m2);
$D3->apply_unsafe($n2);
$D3->apply_unsafe($o2);
$D3->apply_unsafe($Y2);
$D3->apply_unsafe($p2);
$D3->apply_unsafe($q2);
$D3->apply_unsafe($r2);
$D3->apply_unsafe($s2);
$D3->apply_unsafe($t2);
$D3->apply_unsafe($u2);
$D3->apply_unsafe($W2);
$D3->apply_unsafe($v2);
$D3->apply_unsafe($l3);
$D3->apply_unsafe($w2);
$D3->apply_unsafe($E3);
$D3->apply_unsafe($E2);
$D3->apply_unsafe($y2);
$D3->apply_unsafe($F2);
$D3->apply_unsafe($z2);
$D3->apply_unsafe($A2);
$M3->apply_unsafe($e2);
$M3->apply_unsafe($f2);
$M3->apply_unsafe($g2);
$M3->apply_unsafe($h2);
$M3->apply_unsafe($i2);
$M3->apply_unsafe($j2);
$M3->apply_unsafe($k2);
$M3->apply_unsafe($l2);
$M3->apply_unsafe($m2);
$M3->apply_unsafe($n2);
$M3->apply_unsafe($o2);
$M3->apply_unsafe($Y2);
$M3->apply_unsafe($p2);
$M3->apply_unsafe($q2);
$M3->apply_unsafe($r2);
$M3->apply_unsafe($s2);
$M3->apply_unsafe($t2);
$M3->apply_unsafe($u2);
$M3->apply_unsafe($v2);
$M3->apply_unsafe($l3);
$M3->apply_unsafe($w2);
$M3->apply_unsafe($N3);
$M3->apply_unsafe($E2);
$M3->apply_unsafe($y2);
$M3->apply_unsafe($F2);
$M3->apply_unsafe($z2);
$M3->apply_unsafe($A2);
$c4->apply_unsafe($e2);
$c4->apply_unsafe($f2);
$c4->apply_unsafe($g2);
$c4->apply_unsafe($h2);
$c4->apply_unsafe($i2);
$c4->apply_unsafe($j2);
$c4->apply_unsafe($k2);
$c4->apply_unsafe($l2);
$c4->apply_unsafe($m2);
$c4->apply_unsafe($n2);
$c4->apply_unsafe($o2);
$c4->apply_unsafe($p2);
$c4->apply_unsafe($q2);
$c4->apply_unsafe($r2);
$c4->apply_unsafe($s2);
$c4->apply_unsafe($t2);
$c4->apply_unsafe($u2);
$c4->apply_unsafe($v2);
$c4->apply_unsafe($w2);
$c4->apply_unsafe($d4);
$c4->apply_unsafe($E2);
$c4->apply_unsafe($y2);
$c4->apply_unsafe($F2);
$c4->apply_unsafe($z2);
$c4->apply_unsafe($A2);
$B4->apply_unsafe($e2);
$B4->apply_unsafe($f2);
$B4->apply_unsafe($f4);
$B4->apply_unsafe($g2);
$B4->apply_unsafe($g4);
$B4->apply_unsafe($h2);
$B4->apply_unsafe($h4);
$B4->apply_unsafe($i2);
$B4->apply_unsafe($i4);
$B4->apply_unsafe($j2);
$B4->apply_unsafe($j4);
$B4->apply_unsafe($k2);
$B4->apply_unsafe($k4);
$B4->apply_unsafe($l2);
$B4->apply_unsafe($l4);
$B4->apply_unsafe($m2);
$B4->apply_unsafe($m4);
$B4->apply_unsafe($n2);
$B4->apply_unsafe($n4);
$B4->apply_unsafe($o2);
$B4->apply_unsafe($Y2);
$B4->apply_unsafe($p2);
$B4->apply_unsafe($o4);
$B4->apply_unsafe($q2);
$B4->apply_unsafe($F);
$B4->apply_unsafe($r2);
$B4->apply_unsafe($u);
$B4->apply_unsafe($s2);
$B4->apply_unsafe($p4);
$B4->apply_unsafe($t2);
$B4->apply_unsafe($q4);
$B4->apply_unsafe($u2);
$B4->apply_unsafe($W2);
$B4->apply_unsafe($v2);
$B4->apply_unsafe($l3);
$B4->apply_unsafe($w2);
$B4->apply_unsafe($r4);
$B4->apply_unsafe($C4);
$B4->apply_unsafe($E2);
$B4->apply_unsafe($y2);
$B4->apply_unsafe($F2);
$B4->apply_unsafe($z2);
$B4->apply_unsafe($t4);
$B4->apply_unsafe($A2);
$P4->apply_unsafe($e2);
$P4->apply_unsafe($f2);
$P4->apply_unsafe($g2);
$P4->apply_unsafe($h2);
$P4->apply_unsafe($i2);
$P4->apply_unsafe($j2);
$P4->apply_unsafe($k2);
$P4->apply_unsafe($l2);
$P4->apply_unsafe($m2);
$P4->apply_unsafe($n2);
$P4->apply_unsafe($n4);
$P4->apply_unsafe($o2);
$P4->apply_unsafe($Y2);
$P4->apply_unsafe($p2);
$P4->apply_unsafe($o4);
$P4->apply_unsafe($q2);
$P4->apply_unsafe($r2);
$P4->apply_unsafe($s2);
$P4->apply_unsafe($t2);
$P4->apply_unsafe($u2);
$P4->apply_unsafe($W2);
$P4->apply_unsafe($v2);
$P4->apply_unsafe($l3);
$P4->apply_unsafe($w2);
$P4->apply_unsafe($Q4);
$P4->apply_unsafe($E2);
$P4->apply_unsafe($y2);
$P4->apply_unsafe($F2);
$P4->apply_unsafe($z2);
$P4->apply_unsafe($A2);
$g5->apply_unsafe($e2);
$g5->apply_unsafe($f2);
$g5->apply_unsafe($g2);
$g5->apply_unsafe($h2);
$g5->apply_unsafe($i2);
$g5->apply_unsafe($j2);
$g5->apply_unsafe($k2);
$g5->apply_unsafe($l2);
$g5->apply_unsafe($m2);
$g5->apply_unsafe($n2);
$g5->apply_unsafe($o2);
$g5->apply_unsafe($Y2);
$g5->apply_unsafe($p2);
$g5->apply_unsafe($q2);
$g5->apply_unsafe($r2);
$g5->apply_unsafe($s2);
$g5->apply_unsafe($t2);
$g5->apply_unsafe($u2);
$g5->apply_unsafe($v2);
$g5->apply_unsafe($w2);
$g5->apply_unsafe($h5);
$g5->apply_unsafe($E2);
$g5->apply_unsafe($y2);
$g5->apply_unsafe($F2);
$g5->apply_unsafe($z2);
$g5->apply_unsafe($A2);
$s5->apply_unsafe($e2);
$s5->apply_unsafe($f2);
$s5->apply_unsafe($g2);
$s5->apply_unsafe($h2);
$s5->apply_unsafe($i2);
$s5->apply_unsafe($j2);
$s5->apply_unsafe($k2);
$s5->apply_unsafe($l2);
$s5->apply_unsafe($m2);
$s5->apply_unsafe($n2);
$s5->apply_unsafe($o2);
$s5->apply_unsafe($Y2);
$s5->apply_unsafe($p2);
$s5->apply_unsafe($q2);
$s5->apply_unsafe($r2);
$s5->apply_unsafe($s2);
$s5->apply_unsafe($t2);
$s5->apply_unsafe($u2);
$s5->apply_unsafe($v2);
$s5->apply_unsafe($w2);
$s5->apply_unsafe($t5);
$s5->apply_unsafe($E2);
$s5->apply_unsafe($y2);
$s5->apply_unsafe($F2);
$s5->apply_unsafe($z2);
$s5->apply_unsafe($A2);
$B5->apply_unsafe($e2);
$B5->apply_unsafe($f2);
$B5->apply_unsafe($g2);
$B5->apply_unsafe($h2);
$B5->apply_unsafe($i2);
$B5->apply_unsafe($j2);
$B5->apply_unsafe($k2);
$B5->apply_unsafe($l2);
$B5->apply_unsafe($m2);
$B5->apply_unsafe($n2);
$B5->apply_unsafe($o2);
$B5->apply_unsafe($Y2);
$B5->apply_unsafe($p2);
$B5->apply_unsafe($q2);
$B5->apply_unsafe($r2);
$B5->apply_unsafe($s2);
$B5->apply_unsafe($t2);
$B5->apply_unsafe($u2);
$B5->apply_unsafe($v2);
$B5->apply_unsafe($w2);
$B5->apply_unsafe($C5);
$B5->apply_unsafe($E2);
$B5->apply_unsafe($y2);
$B5->apply_unsafe($F2);
$B5->apply_unsafe($z2);
$B5->apply_unsafe($A2);
$K5->apply_unsafe($e2);
$K5->apply_unsafe($f2);
$K5->apply_unsafe($g2);
$K5->apply_unsafe($h2);
$K5->apply_unsafe($i2);
$K5->apply_unsafe($j2);
$K5->apply_unsafe($k2);
$K5->apply_unsafe($l2);
$K5->apply_unsafe($m2);
$K5->apply_unsafe($n2);
$K5->apply_unsafe($o2);
$K5->apply_unsafe($Y2);
$K5->apply_unsafe($p2);
$K5->apply_unsafe($q2);
$K5->apply_unsafe($r2);
$K5->apply_unsafe($s2);
$K5->apply_unsafe($t2);
$K5->apply_unsafe($u2);
$K5->apply_unsafe($v2);
$K5->apply_unsafe($w2);
$K5->apply_unsafe($L5);
$K5->apply_unsafe($E2);
$K5->apply_unsafe($y2);
$K5->apply_unsafe($F2);
$K5->apply_unsafe($z2);
$K5->apply_unsafe($A2);
$T5->apply_unsafe($e2);
$T5->apply_unsafe($f2);
$T5->apply_unsafe($g2);
$T5->apply_unsafe($h2);
$T5->apply_unsafe($i2);
$T5->apply_unsafe($j2);
$T5->apply_unsafe($k2);
$T5->apply_unsafe($l2);
$T5->apply_unsafe($m2);
$T5->apply_unsafe($n2);
$T5->apply_unsafe($o2);
$T5->apply_unsafe($Y2);
$T5->apply_unsafe($p2);
$T5->apply_unsafe($q2);
$T5->apply_unsafe($r2);
$T5->apply_unsafe($s2);
$T5->apply_unsafe($t2);
$T5->apply_unsafe($u2);
$T5->apply_unsafe($v2);
$T5->apply_unsafe($w2);
$T5->apply_unsafe($U5);
$T5->apply_unsafe($E2);
$T5->apply_unsafe($y2);
$T5->apply_unsafe($F2);
$T5->apply_unsafe($z2);
$T5->apply_unsafe($A2);
$n6->apply_unsafe($e2);
$n6->apply_unsafe($f2);
$n6->apply_unsafe($g2);
$n6->apply_unsafe($h2);
$n6->apply_unsafe($i2);
$n6->apply_unsafe($j2);
$n6->apply_unsafe($k2);
$n6->apply_unsafe($l2);
$n6->apply_unsafe($m2);
$n6->apply_unsafe($n2);
$n6->apply_unsafe($o2);
$n6->apply_unsafe($p2);
$n6->apply_unsafe($q2);
$n6->apply_unsafe($r2);
$n6->apply_unsafe($u);
$n6->apply_unsafe($s2);
$n6->apply_unsafe($t2);
$n6->apply_unsafe($u2);
$n6->apply_unsafe($W2);
$n6->apply_unsafe($v2);
$n6->apply_unsafe($l3);
$n6->apply_unsafe($w2);
$n6->apply_unsafe($o6);
$n6->apply_unsafe($E2);
$n6->apply_unsafe($y2);
$n6->apply_unsafe($z2);
$n6->apply_unsafe($A2);
$w6->apply_unsafe($e2);
$w6->apply_unsafe($f2);
$w6->apply_unsafe($g2);
$w6->apply_unsafe($h2);
$w6->apply_unsafe($i2);
$w6->apply_unsafe($j2);
$w6->apply_unsafe($k2);
$w6->apply_unsafe($l2);
$w6->apply_unsafe($m2);
$w6->apply_unsafe($n2);
$w6->apply_unsafe($o2);
$w6->apply_unsafe($p2);
$w6->apply_unsafe($q2);
$w6->apply_unsafe($r2);
$w6->apply_unsafe($s2);
$w6->apply_unsafe($t2);
$w6->apply_unsafe($u2);
$w6->apply_unsafe($v2);
$w6->apply_unsafe($w2);
$w6->apply_unsafe($x6);
$w6->apply_unsafe($y2);
$w6->apply_unsafe($z2);
$w6->apply_unsafe($A2);
$k7->apply_unsafe($f4);
$k7->apply_unsafe($g4);
$k7->apply_unsafe($h4);
$k7->apply_unsafe($i4);
$k7->apply_unsafe($j4);
$k7->apply_unsafe($k4);
$k7->apply_unsafe($l4);
$k7->apply_unsafe($m4);
$t7->apply_unsafe($f4);
$t7->apply_unsafe($g4);
$t7->apply_unsafe($h4);
$t7->apply_unsafe($i4);
$t7->apply_unsafe($j4);
$t7->apply_unsafe($k4);
$t7->apply_unsafe($l4);
$t7->apply_unsafe($m4);
$O7->apply_unsafe($f4);
$O7->apply_unsafe($g4);
$O7->apply_unsafe($h4);
$O7->apply_unsafe($i4);
$O7->apply_unsafe($j4);
$O7->apply_unsafe($k4);
$O7->apply_unsafe($l4);
$O7->apply_unsafe($m4);
$X7->apply_unsafe($f4);
$X7->apply_unsafe($g4);
$X7->apply_unsafe($h4);
$X7->apply_unsafe($i4);
$X7->apply_unsafe($j4);
$X7->apply_unsafe($k4);
$X7->apply_unsafe($l4);
$X7->apply_unsafe($m4);
$i8->apply_unsafe($f4);
$i8->apply_unsafe($g4);
$i8->apply_unsafe($h4);
$i8->apply_unsafe($i4);
$i8->apply_unsafe($j4);
$i8->apply_unsafe($k4);
$i8->apply_unsafe($l4);
$i8->apply_unsafe($m4);
$t8->apply_unsafe($f4);
$C8->apply_unsafe($f4);
$f9->apply_unsafe($g4);
$n9->apply_unsafe($g4);
$I9->apply_unsafe($g4);
$ja->apply_unsafe($g4);
$sa->apply_unsafe($g4);
$Ja->apply_unsafe($g4);
$lb->apply_unsafe($h4);
$tb->apply_unsafe($h4);
$Cb->apply_unsafe($h4);
$Tb->apply_unsafe($h4);
$hc->apply_unsafe($h4);
$tc->apply_unsafe($h4);
$Tc->apply_unsafe($i4);
$ed->apply_unsafe($i4);
$md->apply_unsafe($i4);
$Fd->apply_unsafe($i4);
$pe->apply_unsafe($qe);
$Be->apply_unsafe($j4);
$Pe->apply_unsafe($j4);
$yf->apply_unsafe($l4);
$Jf->apply_unsafe($l4);
$Wf->apply_unsafe($l4);
$jg->apply_unsafe($l4);
$Ag->apply_unsafe($l4);
$kh->apply_unsafe($m4);
$sh->apply_unsafe($m4);
$Hh->apply_unsafe($m4);
$ii->apply_unsafe($Y2);
$Ei->apply_unsafe($o4);
$Li->apply_unsafe($o4);
$kj->apply_unsafe($F);
$rj->apply_unsafe($F);
$zj->apply_unsafe($F);
$Jj->apply_unsafe($F);
$ok->apply_unsafe($u);
$Dk->apply_unsafe($u);
$Ok->apply_unsafe($u);
$Xk->apply_unsafe($u);
$xl->apply_unsafe($qe);
$Il->apply_unsafe($p4);
$kn->apply_unsafe($p4);
$Xn->apply_unsafe($Yn);
$yo->apply_unsafe($q4);
$Lo->apply_unsafe($q4);
$mp->apply_unsafe($q4);
$yp->apply_unsafe($q4);
$Pq->apply_unsafe($Yn);
$jr->apply_unsafe($W2);
$qr->apply_unsafe($W2);
$yr->apply_unsafe($W2);
$Yr->apply_unsafe($qe);
$ls->apply_unsafe($l3);
$ss->apply_unsafe($l3);
$Os->apply_unsafe($r4);
$dt->apply_unsafe($r4);
$lt->apply_unsafe($r4);
$ni::self=$Ru;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$w;
&$_($Z1)for@$H;
&$_($Q2)for@$w;
&$_($T2)for@$w;
&$_($X2)for@$c3;
&$_($f3)for@$w;
&$_($h3)for@$w;
&$_($k3)for@$n3;
&$_($r3)for@$w;
&$_($u3)for@$w3;
&$_($A3)for@$w;
&$_($D3)for@$F3;
&$_($J3)for@$w;
&$_($M3)for@$O3;
&$_($Q3)for@$R3;
&$_($U3)for@$w;
&$_($X3)for@$w;
&$_($c4)for@$e4;
&$_($y4)for@$w;
&$_($B4)for@$D4;
&$_($F4)for@$G4;
&$_($M4)for@$w;
&$_($P4)for@$R4;
&$_($T4)for@$U4;
&$_($d5)for@$w;
&$_($g5)for@$i5;
&$_($m5)for@$w;
&$_($p5)for@$w;
&$_($s5)for@$u5;
&$_($y5)for@$w;
&$_($B5)for@$D5;
&$_($H5)for@$w;
&$_($K5)for@$M5;
&$_($Q5)for@$w;
&$_($T5)for@$V5;
&$_($X5)for@$Y5;
&$_($c6)for@$d6;
&$_($h6)for@$w;
&$_($k6)for@$w;
&$_($n6)for@$p6;
&$_($t6)for@$w;
&$_($w6)for@$y6;
&$_($A6)for@$B6;
&$_($L6)for@$M6;
&$_($Q6)for@$R6;
&$_($T6)for@$U6;
&$_($W6)for@$X6;
&$_($h7)for@$w;
&$_($k7)for@$l7;
&$_($q7)for@$w;
&$_($t7)for@$u7;
&$_($z7)for@$w;
&$_($D7)for@$w;
&$_($H7)for@$w;
&$_($L7)for@$w;
&$_($O7)for@$P7;
&$_($U7)for@$w;
&$_($X7)for@$Y7;
&$_($f8)for@$w;
&$_($i8)for@$j8;
&$_($l8)for@$m8;
&$_($q8)for@$w;
&$_($t8)for@$u8;
&$_($z8)for@$w;
&$_($C8)for@$D8;
&$_($F8)for@$G8;
&$_($N8)for@$O8;
&$_($Q8)for@$R8;
&$_($c9)for@$w;
&$_($f9)for@$g9;
&$_($k9)for@$w;
&$_($n9)for@$o9;
&$_($t9)for@$w;
&$_($x9)for@$w;
&$_($B9)for@$w;
&$_($F9)for@$w;
&$_($I9)for@$J9;
&$_($O9)for@$w;
&$_($S9)for@$w;
&$_($W9)for@$w;
&$_($ca)for@$w;
&$_($ga)for@$w;
&$_($ja)for@$ka;
&$_($pa)for@$w;
&$_($sa)for@$ta;
&$_($ya)for@$w;
&$_($Ca)for@$w;
&$_($Ga)for@$w;
&$_($Ja)for@$Ka;
&$_($Ma)for@$Na;
&$_($Sa)for@$Ta;
&$_($ib)for@$w;
&$_($lb)for@$mb;
&$_($qb)for@$w;
&$_($tb)for@$ub;
&$_($zb)for@$w;
&$_($Cb)for@$Db;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Tb)for@$Ub;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($hc)for@$ic;
&$_($mc)for@$w;
&$_($qc)for@$w;
&$_($tc)for@$uc;
&$_($wc)for@$xc;
&$_($Cc)for@$Dc;
&$_($Qc)for@$w;
&$_($Tc)for@$Uc;
&$_($Zc)for@$w;
&$_($ed)for@$fd;
&$_($jd)for@$w;
&$_($md)for@$nd;
&$_($sd)for@$w;
&$_($vd)for@$w;
&$_($zd)for@$w;
&$_($Cd)for@$w;
&$_($Fd)for@$Gd;
&$_($Id)for@$Jd;
&$_($Od)for@$Pd;
&$_($Zd)for@$w;
&$_($ee)for@$w;
&$_($ie)for@$w;
&$_($me)for@$w;
&$_($pe)for@$re;
&$_($ye)for@$w;
&$_($Be)for@$Ce;
&$_($Ge)for@$w;
&$_($Je)for@$w;
&$_($Me)for@$w;
&$_($Pe)for@$Qe;
&$_($Se)for@$Te;
&$_($Ye)for@$Ze;
&$_($rf)for@$w;
&$_($vf)for@$w;
&$_($yf)for@$zf;
&$_($Df)for@$w;
&$_($Gf)for@$w;
&$_($Jf)for@$Kf;
&$_($Pf)for@$w;
&$_($Tf)for@$w;
&$_($Wf)for@$Xf;
&$_($dg)for@$w;
&$_($gg)for@$w;
&$_($jg)for@$kg;
&$_($og)for@$w;
&$_($rg)for@$w;
&$_($ug)for@$w;
&$_($xg)for@$w;
&$_($Ag)for@$Bg;
&$_($Dg)for@$Eg;
&$_($Jg)for@$Kg;
&$_($Xg)for@$w;
&$_($dh)for@$w;
&$_($hh)for@$w;
&$_($kh)for@$lh;
&$_($ph)for@$w;
&$_($sh)for@$th;
&$_($xh)for@$w;
&$_($Bh)for@$w;
&$_($Eh)for@$w;
&$_($Hh)for@$Ih;
&$_($Kh)for@$Lh;
&$_($Qh)for@$Rh;
&$_($fi)for@$w;
&$_($ii)for@$ji;
&$_($li)for@$mi;
&$_($si)for@$ti;
&$_($Bi)for@$w;
&$_($Ei)for@$Fi;
&$_($Ii)for@$w;
&$_($Li)for@$Mi;
&$_($Oi)for@$Pi;
&$_($Ui)for@$Vi;
&$_($hj)for@$w;
&$_($kj)for@$lj;
&$_($oj)for@$w;
&$_($rj)for@$sj;
&$_($wj)for@$w;
&$_($zj)for@$Aj;
&$_($Dj)for@$w;
&$_($Gj)for@$w;
&$_($Jj)for@$Kj;
&$_($Mj)for@$Nj;
&$_($Sj)for@$Tj;
&$_($gk)for@$w;
&$_($jk)for@$w;
&$_($lk)for@$w;
&$_($ok)for@$pk;
&$_($tk)for@$w;
&$_($wk)for@$w;
&$_($Ak)for@$w;
&$_($Dk)for@$Ek;
&$_($Ik)for@$w;
&$_($Lk)for@$w;
&$_($Ok)for@$Pk;
&$_($Uk)for@$w;
&$_($Xk)for@$Yk;
&$_($cl)for@$dl;
&$_($il)for@$jl;
&$_($ul)for@$w;
&$_($xl)for@$yl;
&$_($Fl)for@$w;
&$_($Il)for@$Jl;
&$_($Ol)for@$w;
&$_($Sl)for@$w;
&$_($Wl)for@$w;
&$_($cm)for@$w;
&$_($gm)for@$w;
&$_($km)for@$w;
&$_($om)for@$w;
&$_($sm)for@$w;
&$_($wm)for@$w;
&$_($Am)for@$w;
&$_($Em)for@$w;
&$_($Im)for@$w;
&$_($Mm)for@$w;
&$_($Qm)for@$w;
&$_($Um)for@$w;
&$_($Ym)for@$w;
&$_($en)for@$w;
&$_($hn)for@$w;
&$_($kn)for@$ln;
&$_($nn)for@$on;
&$_($tn)for@$un;
&$_($En)for@$w;
&$_($In)for@$w;
&$_($Mn)for@$w;
&$_($Qn)for@$w;
&$_($Un)for@$w;
&$_($Xn)for@$Zn;
&$_($no)for@$w;
&$_($ro)for@$w;
&$_($vo)for@$w;
&$_($yo)for@$zo;
&$_($Eo)for@$w;
&$_($Io)for@$w;
&$_($Lo)for@$Mo;
&$_($Ro)for@$w;
&$_($Vo)for@$w;
&$_($Zo)for@$w;
&$_($fp)for@$w;
&$_($jp)for@$w;
&$_($mp)for@$np;
&$_($rp)for@$w;
&$_($vp)for@$w;
&$_($yp)for@$zp;
&$_($Bp)for@$Cp;
&$_($Hp)for@$Ip;
&$_($Sp)for@$w;
&$_($Wp)for@$w;
&$_($cq)for@$w;
&$_($gq)for@$w;
&$_($kq)for@$w;
&$_($oq)for@$w;
&$_($sq)for@$w;
&$_($wq)for@$w;
&$_($Aq)for@$w;
&$_($Eq)for@$w;
&$_($Iq)for@$w;
&$_($Mq)for@$w;
&$_($Pq)for@$Qq;
&$_($Yq)for@$w;
&$_($cr)for@$w;
&$_($jr)for@$kr;
&$_($nr)for@$w;
&$_($qr)for@$rr;
&$_($vr)for@$w;
&$_($yr)for@$zr;
&$_($Br)for@$Cr;
&$_($Ir)for@$Jr;
&$_($Qr)for@$w;
&$_($Vr)for@$w;
&$_($Yr)for@$Zr;
&$_($is)for@$w;
&$_($ls)for@$ms;
&$_($ps)for@$w;
&$_($ss)for@$ts;
&$_($vs)for@$ws;
&$_($Cs)for@$Ds;
&$_($Ls)for@$w;
&$_($Os)for@$Ps;
&$_($Us)for@$w;
&$_($Ys)for@$w;
&$_($dt)for@$et;
&$_($it)for@$w;
&$_($lt)for@$mt;
&$_($pt)for@$qt;
&$_($wt)for@$xt;
&$_($Ft)for@$Gt;
&$_($Lt)for@$Mt;
&$_($Ut)for@$Vt;
&$_($ru)for@$su;
&$_($uu)for@$Vt;
&$_($zu)for@$w;
&$_($Du)for@$w;
&$_($Hu)for@$w;
&$_($Lu)for@$w;
&$_($Pu)for@$w;
&$_($Ru)for@$Su;
ni->run(@ARGV);
__DATA__
