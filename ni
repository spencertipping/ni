#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  my ($en) = ni::eval('__FILE__') =~ /eval (\d+)/;
  $$self{eval_number} = ++$en;
  Scalar::Util::weaken(${'lib/fn::evals'}{$en} = $self);
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#assertions#;
$o=[];
$p=q#error#;
$q=undef;
$r=q#outcome#;
$s=q#test#;
$t=q#annotations#;
$u=[];
$v=q#code#;
$w=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$x=q#eval_number#;
$y=q#proto#;
$z=q##;
$A=q#lib/fn#;
$B=bless({$t,$u,$v,$w,$x,504,$y,$z},$A);
$C=q#lib/fn::ctors#;
$D=q#lib/test_case#;
$E=bless({$n,$o,$p,$q,$r,$q,$s,$B},$D);
$F=q#TODO...#;
$G=[$l,$m,$E,$F];
$H=q#classes#;
$I=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$J=[$H,$I,$F];
$K=[$h,$k,$G,$J];
$L=q#name#;
$M=q#/class#;
$N=q#lib/doc#;
$O=bless({$e,$K,$L,$M},$N);
$P=q#lib/doc::ctors#;
$Q=q#ni.doc:/fabric#;
$R=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$S=[$i,$R];
$T=[$S];
$U=q#/fabric#;
$V=bless({$e,$T,$L,$U},$N);
$W=q#ni.doc:/fabric/rmi#;
$X=[];
$Y=q#/fabric/rmi#;
$Z=bless({$e,$X,$L,$Y},$N);
$c1=q#ni.doc:/io#;
$d1=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$e1=[$i,$d1];
$f1=[$e1];
$g1=q#/io#;
$h1=bless({$e,$f1,$L,$g1},$N);
$i1=q#ni.doc:/io/buffer#;
$j1=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$k1=[$f,$j1];
$l1=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$m1=[];
$n1=[];
$o1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$p1=bless({$t,$n1,$v,$o1,$x,508,$y,$z},$A);
$q1=bless({$n,$m1,$p,$q,$r,$q,$s,$p1},$D);
$r1=[$i,$l1,$q1];
$s1=[$k1,$r1];
$t1=q#/io/buffer#;
$u1=bless({$e,$s1,$L,$t1},$N);
$v1=q#ni.doc:/io/cat#;
$w1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$x1=[$f,$w1];
$y1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$z1=[];
$A1=[];
$B1=q#my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$C1=bless({$t,$A1,$v,$B1,$x,510,$y,$z},$A);
$D1=bless({$n,$z1,$p,$q,$r,$q,$s,$C1},$D);
$E1=[$i,$y1,$D1];
$F1=[$x1,$E1];
$G1=q#/io/cat#;
$H1=bless({$e,$F1,$L,$G1},$N);
$I1=q#ni.doc:/io/exec#;
$J1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$K1=[$f,$J1];
$L1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$M1=[];
$N1=[];
$O1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now [$out->read_all, $pid->await] == ["hi\\n", 0];#;
$P1=bless({$t,$N1,$v,$O1,$x,512,$y,$z},$A);
$Q1=bless({$n,$M1,$p,$q,$r,$q,$s,$P1},$D);
$R1=[$i,$L1,$Q1];
$S1=[$K1,$R1];
$T1=q#/io/exec#;
$U1=bless({$e,$S1,$L,$T1},$N);
$V1=q#ni.doc:/io/fd#;
$W1=q#
    open my $fh, ...;
    my $fd = ni('ni:/io/fd')->new($fh); \# from perl FH
    my $fd = ni('ni:/io/fd')->new(0);   \# from number
    my $fd = ni('fd:0');                \# same thing
    $fd->nonblock(1)->read($_, 100);
    $fd->be(10);                        \# move FD number
  #;
$X1=[$f,$W1];
$Y1=q#Represents a file descriptor as a child of /io/object (so the usual IO
      methods like into_async are available), and provides some convenience
      functions for things like setting up FDs for child processes. FDs are
      closed when destroyed.#;
$Z1=[];
$c2=[];
$d2=q#my ($r, $w) = POSIX::pipe;
{
  my $fd = ni('ni:/io/fd')->new($r);
}
ni('ni:/io/fd')->new($w)->be($r);   \# fails unless $r was GC-closed#;
$e2=bless({$t,$c2,$v,$d2,$x,514,$y,$z},$A);
$f2=bless({$n,$Z1,$p,$q,$r,$q,$s,$e2},$D);
$g2=[$i,$Y1,$f2];
$h2=[$X1,$g2];
$i2=q#/io/fd#;
$j2=bless({$e,$h2,$L,$i2},$N);
$k2=q#ni.doc:/io/file#;
$l2=q#
    my $f = ni('ni:/io/file')->new('/etc/passwd');
    my $f = ni('file:/etc/passwd');     \# same as above
    $f->into_sync(ni('fd:1'));          \# cat to stdout
  #;
$m2=[$f,$l2];
$n2=q#warning#;
$o2=q#Files overload the -X file test operators, but this feature wasn't
      introduced until Perl 5.12 -- prior versions won't recognize this
      overload. That means that using this overload in ni's base code will
      reduce its portability and cause tests to fail.#;
$p2=[$n2,$o2];
$q2=q#Represents a file that may or may not exist, and stores/constructs file
      descriptors for reading/writing. /io/files are one-shot objects: once
      you've consumed them for reading or written to them, you should destroy
      the object and start over (or close the file) if you want to operate on
      the file further -- put differently, /io/file objects own the FDs they
      create.#;
$r2=[];
$s2=[];
$t2=q#my $ni = ni('file:/dev/zero');
now [$ni->read($_, 8), $_] == [8, "\\0" x 8];#;
$u2=bless({$t,$s2,$v,$t2,$x,516,$y,$z},$A);
$v2=bless({$n,$r2,$p,$q,$r,$q,$s,$u2},$D);
$w2=q#File objects also provide some useful functions like atomic-updating.
      This lets you write a stream slowly into a tempfile, then rename over the
      original once the tempfile is closed. ni uses this to update itself to
      avoid race conditions.#;
$x2=[];
$y2=[];
$z2=q#ni('file:tmp1')->write_all("original contents");
{
  my $updater = ni('file:tmp1')->atomic_update;
  $updater->write_all('foo bar');
  now ni('file:tmp1')->read_all == "original contents";
}
now ni('file:tmp1')->read_all == "foo bar";
ni('file:tmp1')->rm;#;
$A2=bless({$t,$y2,$v,$z2,$x,518,$y,$z},$A);
$B2=bless({$n,$x2,$p,$q,$r,$q,$s,$A2},$D);
$C2=[$i,$q2,$v2,$w2,$B2];
$D2=[$m2,$p2,$C2];
$E2=q#/io/file#;
$F2=bless({$e,$D2,$L,$E2},$N);
$G2=q#ni.doc:/io/file_update_fd#;
$H2=q#A write fd that performs a file rename upon closing.#;
$I2=[$i,$H2];
$J2=[$I2];
$K2=q#/io/file_update_fd#;
$L2=bless({$e,$J2,$L,$K2},$N);
$M2=q#ni.doc:/io/mio#;
$N2=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$O2=[$f,$N2];
$P2=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$Q2=q#

      #;
$R2=[$i,$P2,$Q2];
$S2=[$O2,$R2];
$T2=q#/io/mio#;
$U2=bless({$e,$S2,$L,$T2},$N);
$V2=q#ni.doc:/io/mio_channel#;
$W2=q#
    #;
$X2=[$i,$W2];
$Y2=[$X2];
$Z2=q#/io/mio_channel#;
$c3=bless({$e,$Y2,$L,$Z2},$N);
$d3=q#ni.doc:/io/pid#;
$e3=q#eg#;
$f3=[];
$g3=[];
$h3=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$i3=bless({$t,$g3,$v,$h3,$x,520,$y,$z},$A);
$j3=bless({$n,$f3,$p,$q,$r,$q,$s,$i3},$D);
$k3=[$e3,$j3];
$l3=[];
$m3=[];
$n3=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$o3=bless({$t,$m3,$v,$n3,$x,522,$y,$z},$A);
$p3=bless({$n,$l3,$p,$q,$r,$q,$s,$o3},$D);
$q3=[$e3,$p3];
$r3=[];
$s3=[];
$t3=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$u3=bless({$t,$s3,$v,$t3,$x,524,$y,$z},$A);
$v3=bless({$n,$r3,$p,$q,$r,$q,$s,$u3},$D);
$w3=[$e3,$v3];
$x3=[$k3,$q3,$w3];
$y3=q#/io/pid#;
$z3=bless({$e,$x3,$L,$y3},$N);
$A3=q#ni.doc:/lib#;
$B3=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$C3=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$D3=[$i,$B3,$C3];
$E3=[$D3];
$F3=q#/lib#;
$G3=bless({$e,$E3,$L,$F3},$N);
$H3=q#ni.doc:/lib/doc#;
$I3=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$J3=[$f,$I3];
$K3=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$L3=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$M3=[];
$N3=[];
$O3=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$P3=bless({$t,$N3,$v,$O3,$x,526,$y,$z},$A);
$Q3=bless({$n,$M3,$p,$q,$r,$q,$s,$P3},$D);
$R3=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$S3=[];
$T3=[];
$U3=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = q{return 1};
my $failing_test = q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg $failing_test,
                  q[So there.]);
now scalar($doc->tests) == 2;#;
$V3=bless({$t,$T3,$v,$U3,$x,528,$y,$z},$A);
$W3=bless({$n,$S3,$p,$q,$r,$q,$s,$V3},$D);
$X3=[$i,$K3,$L3,$Q3,$R3,$W3];
$Y3=[$J3,$X3];
$Z3=q#/lib/doc#;
$c4=bless({$e,$Y3,$L,$Z3},$N);
$d4=q#ni.doc:/lib/image#;
$e4=q#
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         \# TODO#;
$f4=[$f,$e4];
$g4=q#Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.#;
$h4=[$i,$g4];
$i4=[$f4,$h4];
$j4=q#/lib/image#;
$k4=bless({$e,$i4,$L,$j4},$N);
$l4=q#ni.doc:/lib/ni#;
$m4=q#my $value = ni->resolve($name);
               my $value = ni($name);   \# alias for ni->resolve($name)
               my $self  = ni;#;
$n4=[$f,$m4];
$o4=q#The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.#;
$p4=[$i,$o4];
$q4=[$n4,$p4];
$r4=q#/lib/ni#;
$s4=bless({$e,$q4,$L,$r4},$N);
$t4=q#ni.doc:/lib/quote_simple#;
$u4=q#A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.#;
$v4=[];
$w4=[];
$x4=q#my $q = ni('ni:/lib/quote_simple')->new;
now $q->quote([1,2,3]) == "[1,2,3]";
now $q->quote({foo => 1, bar => [1, 2]}) == "{q\#bar\#,[1,2],q\#foo\#,1}";#;
$y4=bless({$t,$w4,$v,$x4,$x,530,$y,$z},$A);
$z4=bless({$n,$v4,$p,$q,$r,$q,$s,$y4},$D);
$A4=[$i,$u4,$z4];
$B4=[$A4];
$C4=q#/lib/quote_simple#;
$D4=bless({$e,$B4,$L,$C4},$N);
$E4=q#ni.doc:/lib/slice#;
$F4=q#
    ni('ni:/lib/slice')->new('/lib/foo',
      ctor => fn q{shift->say_hi},
      say_hi => fn q{print "hi from " . shift->name . "\\n"});
    $some_class->add('/lib/foo');#;
$G4=[$f,$F4];
$H4=q#A slice of methods encoding some aspect of an object's behavior. Slices
      are combined using tags and branches, and the set of slices used to
      construct a class must be disjoint except for constructors and
      destructors.#;
$I4=q#Slices are objects that provide an ->apply method, which installs their
      methods + ctors + dtors into a Perl package.#;
$J4=[];
$K4=[];
$L4=q#my $slice = ni('ni:/lib/slice')->new('foo1', foo => fn q{"bar"});
$slice->apply('test::foo1');
now bless({}, 'test::foo1')->foo == 'bar';#;
$M4=bless({$t,$K4,$v,$L4,$x,532,$y,$z},$A);
$N4=bless({$n,$J4,$p,$q,$r,$q,$s,$M4},$D);
$O4=q#Slices automatically do the equivalent of using Perl's "overload" module
      if any methods begin with an open-paren.#;
$P4=q#Classes automatically incorporate some special low-level slices that are
      used by others; one of these is /lib/instantiable.b, which implements
      ->new and ->DESTROY. These methods then call into the lists of
      constructors and destructors implemented when slices are added to a
      package.#;
$Q4=[];
$R4=[];
$S4=q#my $instances = 0;
my $class = ni('ni:/object')->child('test/foo2')
  ->def('test/foo2_init.b',
    instantiate => fn q{+{}},
    ctor => sub {++$instances},
    dtor => sub {--$instances});
now $instances == 0;
{
  my $i1 = $class->new;
  now $instances == 1;
  my $i2 = $class->new;
  now $instances == 2;
}
now $instances == 0;#;
$T4=bless({$t,$R4,$v,$S4,$x,534,$y,$z},$A);
$U4=bless({$n,$Q4,$p,$q,$r,$q,$s,$T4},$D);
$V4=[$i,$H4,$I4,$N4,$O4,$P4,$U4];
$W4=[$G4,$V4];
$X4=q#/lib/slice#;
$Y4=bless({$e,$W4,$L,$X4},$N);
$Z4=q#ni.doc:/semantic#;
$c5=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$d5=[$i,$c5];
$e5=[$d5];
$f5=q#/semantic#;
$g5=bless({$e,$e5,$L,$f5},$N);
$h5=q#ni:/class#;
$i5=q#applied_to#;
$j5=q#class#;
$k5=q#class.c#;
$l5=q#fabric/rmi.c#;
$m5=q#io/buffer.c#;
$n5=q#io/cat.c#;
$o5=q#io/exec.c#;
$p5=q#io/fd.c#;
$q5=q#io/file.c#;
$r5=q#io/file_update_fd.c#;
$s5=q#io/mio.c#;
$t5=q#io/mio_channel.c#;
$u5=q#io/null.c#;
$v5=q#io/object.c#;
$w5=q#io/pid.c#;
$x5=q#io/str.c#;
$y5=q#io/transfer.c#;
$z5=q#io/transfer_async.c#;
$A5=q#io/transfer_sync.c#;
$B5=q#lib/behavior.c#;
$C5=q#lib/branch.c#;
$D5=q#lib/dataslice.c#;
$E5=q#lib/doc.c#;
$F5=q#lib/fn.c#;
$G5=q#lib/image.c#;
$H5=q#lib/ni.c#;
$I5=q#lib/quote_simple.c#;
$J5=q#lib/slice.c#;
$K5=q#lib/tag.c#;
$L5=q#lib/test_assert_eq.c#;
$M5=q#lib/test_assertion.c#;
$N5=q#lib/test_case.c#;
$O5=q#lib/test_value.c#;
$P5=q#metaclass.c#;
$Q5=q#module.c#;
$R5=q#object.c#;
$S5=q#semantic/dimension#;
$T5=q#semantic/dimension.c#;
$U5=q#semantic/task.c#;
$V5={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$P5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$W5=q#slices#;
$X5=q#metaclass#;
$Y5=q#module#;
$Z5={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$c6=q#/module#;
$d6=q#/lib/perlbranch.b#;
$e6={};
$f6=q#ctor#;
$g6=q#dtor#;
$h6=q#methods#;
$i6=q#add#;
$j6=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$k6=bless({$v,$j6,$x,536,$y,$z},$A);
$l6=q#apply#;
$m6=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$n6=bless({$v,$m6,$x,538,$y,$z},$A);
$o6={$i6,$k6,$l6,$n6};
$p6=q#/lib/branch.b#;
$q6=q#lib/slice#;
$r6=bless({$i5,$e6,$f6,$q,$g6,$q,$h6,$o6,$L,$p6},$q6);
$s6=q#lib/branch#;
$t6=q#lib/slice::ctors#;
$u6={};
$v6=q#my $s = shift; ni->def($s->name, $s)#;
$w6=bless({$v,$v6,$x,540,$y,$z},$A);
$x6=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$y6=bless({$v,$x6,$x,542,$y,$z},$A);
$z6={$L,$y6};
$A6=q#/lib/named.b#;
$B6=bless({$i5,$u6,$f6,$w6,$g6,$q,$h6,$z6,$L,$A6},$q6);
$C6=q#lib/tag#;
$D6={};
$E6=q#namespace#;
$F6=q#'ni'#;
$G6=bless({$v,$F6,$x,544,$y,$z},$A);
$H6={$E6,$G6};
$I6=q#/lib/named_in_ni.b#;
$J6=bless({$i5,$D6,$f6,$q,$g6,$q,$h6,$H6,$L,$I6},$q6);
$K6={};
$L6=q#package#;
$M6=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$N6=bless({$v,$M6,$x,546,$y,$z},$A);
$O6={$L6,$N6};
$P6=q#/lib/namespaced.b#;
$Q6=bless({$i5,$K6,$f6,$q,$g6,$q,$h6,$O6,$L,$P6},$q6);
$R6={};
$S6=q#resolve#;
$T6=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$U6=bless({$v,$T6,$x,548,$y,$z},$A);
$V6={$S6,$U6};
$W6=q#/lib/resolver.b#;
$X6=bless({$i5,$R6,$f6,$q,$g6,$q,$h6,$V6,$L,$W6},$q6);
$Y6=[$r6,$B6,$J6,$Q6,$X6];
$Z6=bless({$L,$d6,$W5,$Y6},$C6);
$c7=q#lib/tag::ctors#;
$d7={};
$e7=q#my $s = shift; $s->apply($s->package)#;
$f7=bless({$v,$e7,$x,550,$y,$z},$A);
$g7=q#instantiate#;
$h7=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$i7=bless({$v,$h7,$x,552,$y,$z},$A);
$j7={$g7,$i7};
$k7=q#/lib/class_init.b#;
$l7=bless({$i5,$d7,$f6,$f7,$g6,$q,$h6,$j7,$L,$k7},$q6);
$m7=q#fabric/rmi#;
$n7=q#io/buffer#;
$o7=q#io/cat#;
$p7=q#io/exec#;
$q7=q#io/fd#;
$r7=q#io/file#;
$s7=q#io/file_update_fd#;
$t7=q#io/mio#;
$u7=q#io/mio_channel#;
$v7=q#io/null#;
$w7=q#io/object#;
$x7=q#io/pid#;
$y7=q#io/str#;
$z7=q#io/transfer#;
$A7=q#io/transfer_async#;
$B7=q#io/transfer_sync#;
$C7=q#lib/behavior#;
$D7=q#lib/dataslice#;
$E7=q#lib/image#;
$F7=q#lib/ni#;
$G7=q#lib/quote_simple#;
$H7=q#lib/test_assert_eq#;
$I7=q#lib/test_assertion#;
$J7=q#lib/test_value#;
$K7=q#object#;
$L7=q#semantic/task#;
$M7={$j5,1,$k5,1,$m7,1,$l5,1,$n7,1,$m5,1,$o7,1,$n5,1,$p7,1,$o5,1,$q7,1,$p5,1,$r7,1,$q5,1,$s7,1,$r5,1,$t7,1,$s5,1,$u7,1,$t5,1,$v7,1,$u5,1,$w7,1,$v5,1,$x7,1,$w5,1,$y7,1,$x5,1,$z7,1,$y5,1,$A7,1,$z5,1,$B7,1,$A5,1,$C7,1,$B5,1,$s6,1,$C5,1,$D7,1,$D5,1,$N,1,$E5,1,$A,1,$F5,1,$E7,1,$G5,1,$F7,1,$H5,1,$G7,1,$I5,1,$q6,1,$J5,1,$C6,1,$K5,1,$H7,1,$L5,1,$I7,1,$M5,1,$D,1,$N5,1,$J7,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$K7,1,$R5,1,$S5,1,$T5,1,$L7,1,$U5,1};
$N7=q#/object#;
$O7={};
$P7=q#DESTROY#;
$Q7=q#local $_;
my $self = shift;
defined($_) && $_->($self) for @{ref($self) . '::dtors'};#;
$R7=bless({$v,$Q7,$x,554,$y,$z},$A);
$S7=q#ni 'ni:/' . ref shift#;
$T7=bless({$v,$S7,$x,556,$y,$z},$A);
$U7={$P7,$R7,$j5,$T7};
$V7=q#/lib/instance.b#;
$W7=bless({$i5,$O7,$f6,$q,$g6,$q,$h6,$U7,$L,$V7},$q6);
$X7=[$W7];
$Y7=bless({$i5,$M7,$L,$N7,$W5,$X7},$R5);
$Z7=q#object.c::ctors#;
$c8={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$C7,1,$B5,1,$s6,1,$C5,1,$D7,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$q6,1,$J5,1,$C6,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$d8=q#/lib/behavior#;
$e8={};
$f8=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$g8=bless({$v,$f8,$x,558,$y,$z},$A);
$h8={$e,$g8};
$i8=q#/lib/documentable.b#;
$j8=bless({$i5,$e8,$f6,$q,$g6,$q,$h6,$h8,$L,$i8},$q6);
$k8=[$Y7,$j8];
$l8=bless({$i5,$c8,$L,$d8,$W5,$k8},$B5);
$m8=q#lib/behavior.c::ctors#;
$n8={$j5,1,$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$s6,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$X5,1,$P5,1,$Y5,1,$Q5,1,$R5,1,$S5,1,$T5,1,$U5,1};
$o8=q#/lib/definition.b#;
$p8={};
$q8=q#def#;
$r8=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$s8=bless({$v,$r8,$x,560,$y,$z},$A);
$t8={$q8,$s8};
$u8=q#/lib/definition_def.b#;
$v8=bless({$i5,$p8,$f6,$q,$g6,$q,$h6,$t8,$L,$u8},$q6);
$w8={};
$x8=q#ro#;
$y8=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$z8=bless({$v,$y8,$x,562,$y,$z},$A);
$A8=q#rw#;
$B8=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$C8=bless({$v,$B8,$x,564,$y,$z},$A);
$D8={$x8,$z8,$A8,$C8};
$E8=q#/lib/accessor.b#;
$F8=bless({$i5,$w8,$f6,$q,$g6,$q,$h6,$D8,$L,$E8},$q6);
$G8={};
$H8=q#(""#;
$I8=q#shift->name#;
$J8=bless({$v,$I8,$x,566,$y,$z},$A);
$K8={$H8,$J8};
$L8=q#/lib/name_as_string.b#;
$M8=bless({$i5,$G8,$f6,$q,$g6,$q,$h6,$K8,$L,$L8},$q6);
$N8={};
$O8=q#(eq#;
$P8=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$Q8=bless({$v,$P8,$x,568,$y,$z},$A);
$R8={$O8,$Q8};
$S8=q#/lib/ref_eq.b#;
$T8=bless({$i5,$N8,$f6,$q,$g6,$q,$h6,$R8,$L,$S8},$q6);
$U8={};
$V8=q#defdata#;
$W8=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$X8=bless({$v,$W8,$x,570,$y,$z},$A);
$Y8={$V8,$X8};
$Z8=q#/lib/definition_defdata.b#;
$c9=bless({$i5,$U8,$f6,$q,$g6,$q,$h6,$Y8,$L,$Z8},$q6);
$d9=[$v8,$F8,$M8,$T8,$c9];
$e9=bless({$i5,$n8,$L,$o8,$W5,$d9},$s6);
$f9=q#lib/branch::ctors#;
$g9=[$Z6,$l7,$Y7,$l8,$e9];
$h9=bless({$i5,$Z5,$L,$c6,$W5,$g9},$Q5);
$i9=q#module.c::ctors#;
$j9={};
$k9=q#new#;
$l9=q#local $_;
my $class   = shift;
my $package = ref $class ? $class->package : $class;
my $self    = bless &{"$package\\::instantiate"}($class, @_), $package;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$m9=bless({$v,$l9,$x,572,$y,$z},$A);
$n9={$k9,$m9};
$o9=q#/lib/instantiable.b#;
$p9=bless({$i5,$j9,$h6,$n9,$L,$o9},$q6);
$q9={};
$r9=q#child#;
$s9=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$t9=bless({$v,$s9,$x,574,$y,$z},$A);
$u9={$r9,$t9};
$v9=q#/lib/subclass.b#;
$w9=bless({$i5,$q9,$f6,$q,$g6,$q,$h6,$u9,$L,$v9},$q6);
$x9=[$h9,$p9,$l7,$h9,$w9];
$y9=bless({$i5,$V5,$L,$M,$W5,$x9},$k5);
$z9=q#class.c::ctors#;
$A9=q#ni:/class.c#;
$B9={$k5,1,$T5,1};
$C9=q#/class.c#;
$D9={$k5,1,$Q5,1,$T5,1};
$E9=q#/module.c#;
$F9={$k5,1,$l5,1,$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1,$y5,1,$z5,1,$A5,1,$B5,1,$C5,1,$D5,1,$E5,1,$F5,1,$G5,1,$H5,1,$I5,1,$J5,1,$K5,1,$L5,1,$M5,1,$N5,1,$O5,1,$Q5,1,$R5,1,$T5,1,$U5,1};
$G9=q#/object.c#;
$H9=[$y9];
$I9=bless({$i5,$F9,$L,$G9,$W5,$H9},$X5);
$J9=q#metaclass::ctors#;
$K9={$k5,1,$B5,1,$C5,1,$D5,1,$J5,1,$K5,1,$Q5,1,$T5,1};
$L9=q#/lib/behavior.c#;
$M9=[$I9];
$N9=bless({$i5,$K9,$L,$L9,$W5,$M9},$X5);
$O9=[$I9,$p9,$N9];
$P9=bless({$i5,$D9,$L,$E9,$W5,$O9},$X5);
$Q9=[$P9];
$R9=bless({$i5,$B9,$L,$C9,$W5,$Q9},$X5);
$S9=q#ni:/fabric/rmi#;
$T9={$m7,1};
$U9={};
$V9=[];
$W9=q#my ($class, $io, $quote) = @_;#;
$X9=bless({$t,$V9,$v,$W9,$x,576,$y,$z},$A);
$Y9={$g7,$X9};
$Z9=q#/fabric/rmi_init.b#;
$ca=bless({$i5,$U9,$f6,$q,$g6,$q,$h6,$Y9,$L,$Z9},$q6);
$da=[$Y7,$ca];
$ea=bless({$i5,$T9,$L,$Y,$W5,$da},$l5);
$fa=q#fabric/rmi.c::ctors#;
$ga=q#ni:/fabric/rmi.c#;
$ha={$l5,1};
$ia=q#/fabric/rmi.c#;
$ja=[$I9];
$ka=bless({$i5,$ha,$L,$ia,$W5,$ja},$X5);
$la=q#ni:/fabric/rmi_init.b#;
$ma=q#ni:/io/buffer#;
$na={$n7,1};
$oa={$n7,1,$o7,1,$p7,1,$q7,1,$r7,1,$s7,1,$t7,1,$u7,1,$v7,1,$w7,1,$x7,1,$y7,1};
$pa=q#/io/object#;
$qa={};
$ra=q#(bool#;
$sa=[];
$ta=bless({$t,$sa,$v,1,$x,578,$y,$z},$A);
$ua={$ra,$ta};
$va=q#/io/object_ops.b#;
$wa=bless({$i5,$qa,$f6,$q,$g6,$q,$h6,$ua,$L,$va},$q6);
$xa={};
$ya=q#die#;
$za=[];
$Aa=q#shift; die join " ", @_#;
$Ba=bless({$t,$za,$v,$Aa,$x,580,$y,$z},$A);
$Ca=q#io_check#;
$Da=[];
$Ea=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$Fa=bless({$t,$Da,$v,$Ea,$x,582,$y,$z},$A);
$Ga=q#io_check_defined#;
$Ha=[];
$Ia=q#shift->io_check(sub {defined shift}, @_)#;
$Ja=bless({$t,$Ha,$v,$Ia,$x,584,$y,$z},$A);
$Ka=q#io_check_true#;
$La=[];
$Ma=q#shift->io_check(sub {shift}, @_)#;
$Na=bless({$t,$La,$v,$Ma,$x,586,$y,$z},$A);
$Oa={$ya,$Ba,$Ca,$Fa,$Ga,$Ja,$Ka,$Na};
$Pa=q#/io/object_checks.b#;
$Qa=bless({$i5,$xa,$f6,$q,$g6,$q,$h6,$Oa,$L,$Pa},$q6);
$Ra={};
$Sa=q#(+#;
$Ta=[];
$Ua=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$Va=bless({$t,$Ta,$v,$Ua,$x,588,$y,$z},$A);
$Wa={$Sa,$Va};
$Xa=q#/io/object_constructors.b#;
$Ya=bless({$i5,$Ra,$f6,$q,$g6,$q,$h6,$Wa,$L,$Xa},$q6);
$Za={};
$cb=q#read_all#;
$db=[];
$eb=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$fb=bless({$t,$db,$v,$eb,$x,590,$y,$z},$A);
$gb=q#write_all#;
$hb=[];
$ib=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_sync($self);#;
$jb=bless({$t,$hb,$v,$ib,$x,592,$y,$z},$A);
$kb={$cb,$fb,$gb,$jb};
$lb=q#/io/object_memory.b#;
$mb=bless({$i5,$Za,$f6,$q,$g6,$q,$h6,$kb,$L,$lb},$q6);
$nb={};
$ob=q#connect_sync#;
$pb=[];
$qb=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$rb=bless({$t,$pb,$v,$qb,$x,594,$y,$z},$A);
$sb=q#into_sync#;
$tb=[];
$ub=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$vb=bless({$t,$tb,$v,$ub,$x,596,$y,$z},$A);
$wb={$ob,$rb,$sb,$vb};
$xb=q#/io/object_transfer_sync.b#;
$yb=bless({$i5,$nb,$f6,$q,$g6,$q,$h6,$wb,$L,$xb},$q6);
$zb={};
$Ab=q#connect_async#;
$Bb=[];
$Cb=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$Db=bless({$t,$Bb,$v,$Cb,$x,598,$y,$z},$A);
$Eb=q#into_async#;
$Fb=[];
$Gb=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$Hb=bless({$t,$Fb,$v,$Gb,$x,600,$y,$z},$A);
$Ib={$Ab,$Db,$Eb,$Hb};
$Jb=q#/io/object_transfer_async.b#;
$Kb=bless({$i5,$zb,$f6,$q,$g6,$q,$h6,$Ib,$L,$Jb},$q6);
$Lb=[$Y7,$wa,$Qa,$Ya,$mb,$yb,$Kb,$Kb,$yb,$Kb,$yb];
$Mb=bless({$i5,$oa,$L,$pa,$W5,$Lb},$v5);
$Nb=q#io/object.c::ctors#;
$Ob={};
$Pb=[];
$Qb=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$Rb=bless({$t,$Pb,$v,$Qb,$x,602,$y,$z},$A);
$Sb={$g7,$Rb};
$Tb=q#/io/buffer_init.b#;
$Ub=bless({$i5,$Ob,$f6,$q,$g6,$q,$h6,$Sb,$L,$Tb},$q6);
$Vb={};
$Wb=q#read#;
$Xb=[];
$Yb=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$Zb=bless({$t,$Xb,$v,$Yb,$x,604,$y,$z},$A);
$cc=q#read_capacity#;
$dc=[];
$ec=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$fc=bless({$t,$dc,$v,$ec,$x,606,$y,$z},$A);
$gc=q#write#;
$hc=[];
$ic=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$jc=bless({$t,$hc,$v,$ic,$x,608,$y,$z},$A);
$kc=q#write_capacity#;
$lc=[];
$mc=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$nc=bless({$t,$lc,$v,$mc,$x,610,$y,$z},$A);
$oc={$Wb,$Zb,$cc,$fc,$gc,$jc,$kc,$nc};
$pc=q#/io/buffer_io.b#;
$qc=bless({$i5,$Vb,$f6,$q,$g6,$q,$h6,$oc,$L,$pc},$q6);
$rc=[$Mb,$Ub,$qc];
$sc=bless({$i5,$na,$L,$t1,$W5,$rc},$m5);
$tc=q#io/buffer.c::ctors#;
$uc=q#ni:/io/buffer.c#;
$vc={$m5,1};
$wc=q#/io/buffer.c#;
$xc={$m5,1,$n5,1,$o5,1,$p5,1,$q5,1,$r5,1,$s5,1,$t5,1,$u5,1,$v5,1,$w5,1,$x5,1};
$yc=q#/io/object.c#;
$zc={};
$Ac=q#def_transfer_method#;
$Bc=[];
$Cc=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$Dc=bless({$t,$Bc,$v,$Cc,$x,612,$y,$z},$A);
$Ec={$Ac,$Dc};
$Fc=q#/io/object.c_transfer_def.b#;
$Gc=bless({$i5,$zc,$f6,$q,$g6,$q,$h6,$Ec,$L,$Fc},$q6);
$Hc=[$I9,$Gc];
$Ic=bless({$i5,$xc,$L,$yc,$W5,$Hc},$X5);
$Jc=[$Ic];
$Kc=bless({$i5,$vc,$L,$wc,$W5,$Jc},$X5);
$Lc=q#ni:/io/buffer_init.b#;
$Mc=q#ni:/io/buffer_io.b#;
$Nc=q#ni:/io/cat#;
$Oc={$o7,1};
$Pc={};
$Qc=[];
$Rc=q#shift; +{fs => [@_]}#;
$Sc=bless({$t,$Qc,$v,$Rc,$x,614,$y,$z},$A);
$Tc={$g7,$Sc};
$Uc=q#/io/cat_init.b#;
$Vc=bless({$i5,$Pc,$f6,$q,$g6,$q,$h6,$Tc,$L,$Uc},$q6);
$Wc={};
$Xc=[];
$Yc=q#my $fs = shift->{fs};
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;
my $n;
while (@$fs && $total_read < $length) {
  $n = $$fs[0]->read($_[0], $length - $total_read, $offset + $total_read);
  return $total_read || undef unless defined $n;
  shift @$fs unless $n;
  $total_read += $n;
}
$total_read;#;
$Zc=bless({$t,$Xc,$v,$Yc,$x,616,$y,$z},$A);
$cd={$Wb,$Zc};
$dd=q#/io/cat_read.b#;
$ed=bless({$i5,$Wc,$f6,$q,$g6,$q,$h6,$cd,$L,$dd},$q6);
$fd=[$Mb,$Vc,$ed];
$gd=bless({$i5,$Oc,$L,$G1,$W5,$fd},$n5);
$hd=q#io/cat.c::ctors#;
$id=q#ni:/io/cat.c#;
$jd={$n5,1};
$kd=q#/io/cat.c#;
$ld=[$Ic];
$md=bless({$i5,$jd,$L,$kd,$W5,$ld},$X5);
$nd=q#ni:/io/cat_init.b#;
$od=q#ni:/io/cat_read.b#;
$pd=q#ni:/io/exec#;
$qd={$p7,1};
$rd={};
$sd=q#argv#;
$td=[];
$ud=q#shift->{'argv'}#;
$vd=bless({$t,$td,$v,$ud,$x,618,$y,$z},$A);
$wd={$sd,$vd};
$xd=q#/io/exec_ro.b#;
$yd=bless({$i5,$rd,$f6,$q,$g6,$q,$h6,$wd,$L,$xd},$q6);
$zd={};
$Ad=[];
$Bd=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$Cd=bless({$t,$Ad,$v,$Bd,$x,620,$y,$z},$A);
$Dd={$g7,$Cd};
$Ed=q#/io/exec_init.b#;
$Fd=bless({$i5,$zd,$f6,$q,$g6,$q,$h6,$Dd,$L,$Ed},$q6);
$Gd={};
$Hd=q#connect#;
$Id=[];
$Jd=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$Kd=bless({$t,$Id,$v,$Jd,$x,622,$y,$z},$A);
$Ld=q#in_pipe#;
$Md=[];
$Nd=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$Od=bless({$t,$Md,$v,$Nd,$x,624,$y,$z},$A);
$Pd=q#out_pipe#;
$Qd=[];
$Rd=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$Sd=bless({$t,$Qd,$v,$Rd,$x,626,$y,$z},$A);
$Td=q#setup_stdio#;
$Ud=[];
$Vd=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Wd=bless({$t,$Ud,$v,$Vd,$x,628,$y,$z},$A);
$Xd={$Hd,$Kd,$Ld,$Od,$Pd,$Sd,$Td,$Wd};
$Yd=q#/io/exec_io_setup.b#;
$Zd=bless({$i5,$Gd,$f6,$q,$g6,$q,$h6,$Xd,$L,$Yd},$q6);
$ce={};
$de=q#binds_fd#;
$ee=[];
$fe=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$ge=bless({$t,$ee,$v,$fe,$x,630,$y,$z},$A);
$he=q#fd#;
$ie=[];
$je=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$ke=bless({$t,$ie,$v,$je,$x,632,$y,$z},$A);
$le=q#stderr#;
$me=[];
$ne=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$oe=bless({$t,$me,$v,$ne,$x,634,$y,$z},$A);
$pe=q#stdin#;
$qe=[];
$re=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$se=bless({$t,$qe,$v,$re,$x,636,$y,$z},$A);
$te=q#stdout#;
$ue=[];
$ve=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$we=bless({$t,$ue,$v,$ve,$x,638,$y,$z},$A);
$xe={$de,$ge,$he,$ke,$le,$oe,$pe,$se,$te,$we};
$ye=q#/io/exec_io_accessors.b#;
$ze=bless({$i5,$ce,$f6,$q,$g6,$q,$h6,$xe,$L,$ye},$q6);
$Ae={};
$Be=q#env#;
$Ce=[];
$De=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Ee=bless({$t,$Ce,$v,$De,$x,640,$y,$z},$A);
$Fe={$Be,$Ee};
$Ge=q#/io/exec_env.b#;
$He=bless({$i5,$Ae,$f6,$q,$g6,$q,$h6,$Fe,$L,$Ge},$q6);
$Ie={};
$Je=q#exec#;
$Ke=[];
$Le=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$Me=bless({$t,$Ke,$v,$Le,$x,642,$y,$z},$A);
$Ne=q#fork#;
$Oe=[];
$Pe=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Qe=bless({$t,$Oe,$v,$Pe,$x,644,$y,$z},$A);
$Re=q#move_fds#;
$Se=[];
$Te=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Ue=bless({$t,$Se,$v,$Te,$x,646,$y,$z},$A);
$Ve={$Je,$Me,$Ne,$Qe,$Re,$Ue};
$We=q#/io/exec_fork.b#;
$Xe=bless({$i5,$Ie,$f6,$q,$g6,$q,$h6,$Ve,$L,$We},$q6);
$Ye=[$Mb,$yd,$Fd,$Zd,$ze,$He,$Xe];
$Ze=bless({$i5,$qd,$L,$T1,$W5,$Ye},$o5);
$cf=q#io/exec.c::ctors#;
$df=q#ni:/io/exec.c#;
$ef={$o5,1};
$ff=q#/io/exec.c#;
$gf=[$Ic];
$hf=bless({$i5,$ef,$L,$ff,$W5,$gf},$X5);
$if=q#ni:/io/exec_env.b#;
$jf=q#ni:/io/exec_fork.b#;
$kf=q#ni:/io/exec_init.b#;
$lf=q#ni:/io/exec_io_accessors.b#;
$mf=q#ni:/io/exec_io_setup.b#;
$nf=q#ni:/io/exec_ro.b#;
$of=q#ni:/io/fd#;
$pf={$q7,1};
$qf={};
$rf=[];
$sf=q#shift->{'fd'}#;
$tf=bless({$t,$rf,$v,$sf,$x,648,$y,$z},$A);
$uf={$he,$tf};
$vf=q#/io/fd_readers.b#;
$wf=bless({$i5,$qf,$f6,$q,$g6,$q,$h6,$uf,$L,$vf},$q6);
$xf={};
$yf=[];
$zf=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$Af=bless({$t,$yf,$v,$zf,$x,650,$y,$z},$A);
$Bf={$g7,$Af};
$Cf=q#/io/fd_init.b#;
$Df=bless({$i5,$xf,$f6,$q,$g6,$q,$h6,$Bf,$L,$Cf},$q6);
$Ef={};
$Ff=q#be#;
$Gf=[];
$Hf=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$If=bless({$t,$Gf,$v,$Hf,$x,652,$y,$z},$A);
$Jf={$Ff,$If};
$Kf=q#/io/fd_shell.b#;
$Lf=bless({$i5,$Ef,$f6,$q,$g6,$q,$h6,$Jf,$L,$Kf},$q6);
$Mf={};
$Nf=q#cloexec#;
$Of=[];
$Pf=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Qf=bless({$t,$Of,$v,$Pf,$x,654,$y,$z},$A);
$Rf=q#fcntl_flag#;
$Sf=[];
$Tf=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Uf=bless({$t,$Sf,$v,$Tf,$x,656,$y,$z},$A);
$Vf=q#nonblock#;
$Wf=[];
$Xf=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Yf=bless({$t,$Wf,$v,$Xf,$x,658,$y,$z},$A);
$Zf={$Nf,$Qf,$Rf,$Uf,$Vf,$Yf};
$cg=q#/io/fd_fcntl.b#;
$dg=bless({$i5,$Mf,$f6,$q,$g6,$q,$h6,$Zf,$L,$cg},$q6);
$eg={};
$fg=[];
$gg=q#shift->close#;
$hg=bless({$t,$fg,$v,$gg,$x,660,$y,$z},$A);
$ig=q#close#;
$jg=[];
$kg=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd} if defined $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$lg=bless({$t,$jg,$v,$kg,$x,662,$y,$z},$A);
$mg={$ig,$lg};
$ng=q#/io/fd_gc.b#;
$og=bless({$i5,$eg,$f6,$q,$g6,$hg,$h6,$mg,$L,$ng},$q6);
$pg={};
$qg=[];
$rg=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$sg=bless({$t,$qg,$v,$rg,$x,664,$y,$z},$A);
$tg=[];
$ug=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$vg=bless({$t,$tg,$v,$ug,$x,666,$y,$z},$A);
$wg={$Wb,$sg,$gc,$vg};
$xg=q#/io/fd_perlio.b#;
$yg=bless({$i5,$pg,$f6,$q,$g6,$q,$h6,$wg,$L,$xg},$q6);
$zg=[$Mb,$wf,$Df,$Lf,$dg,$og,$yg];
$Ag=bless({$i5,$pf,$L,$i2,$W5,$zg},$p5);
$Bg=q#io/fd.c::ctors#;
$Cg=q#ni:/io/fd.c#;
$Dg={$p5,1};
$Eg=q#/io/fd.c#;
$Fg=[$Ic];
$Gg=bless({$i5,$Dg,$L,$Eg,$W5,$Fg},$X5);
$Hg=q#ni:/io/fd_fcntl.b#;
$Ig=q#ni:/io/fd_gc.b#;
$Jg=q#ni:/io/fd_init.b#;
$Kg=q#ni:/io/fd_perlio.b#;
$Lg=q#ni:/io/fd_readers.b#;
$Mg=q#ni:/io/fd_shell.b#;
$Ng=q#ni:/io/file#;
$Og={$r7,1};
$Pg={};
$Qg=[];
$Rg=q#shift->{'name'}#;
$Sg=bless({$t,$Qg,$v,$Rg,$x,668,$y,$z},$A);
$Tg={$L,$Sg};
$Ug=q#/io/file_readers.b#;
$Vg=bless({$i5,$Pg,$f6,$q,$g6,$q,$h6,$Tg,$L,$Ug},$q6);
$Wg={};
$Xg=q#mode#;
$Yg=[];
$Zg=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$ch=bless({$t,$Yg,$v,$Zg,$x,670,$y,$z},$A);
$dh={$Xg,$ch};
$eh=q#/io/file_accessors.b#;
$fh=bless({$i5,$Wg,$f6,$q,$g6,$q,$h6,$dh,$L,$eh},$q6);
$gh={};
$hh=[];
$ih=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$jh=bless({$t,$hh,$v,$ih,$x,672,$y,$z},$A);
$kh={$g7,$jh};
$lh=q#/io/file_init.b#;
$mh=bless({$i5,$gh,$f6,$q,$g6,$q,$h6,$kh,$L,$lh},$q6);
$nh={};
$oh=q#(-X#;
$ph=[];
$qh=q#my ($self, $test) = @_;
&{"-$test"}($$self{name});#;
$rh=bless({$t,$ph,$v,$qh,$x,674,$y,$z},$A);
$sh=q#mv#;
$th=[];
$uh=q#my ($self, $dest) = @_;
$dest = $dest->name if ref $dest;
$self->io_check_true(*main::rename, $self->name, $dest);
$$self{name} = $dest;
$self;#;
$vh=bless({$t,$th,$v,$uh,$x,676,$y,$z},$A);
$wh=q#rm#;
$xh=[];
$yh=q#my $self = shift;
$self->io_check_true(*main::unlink, $self->name);
$self;#;
$zh=bless({$t,$xh,$v,$yh,$x,678,$y,$z},$A);
$Ah={$oh,$rh,$sh,$vh,$wh,$zh};
$Bh=q#/io/file_fns.b#;
$Ch=bless({$i5,$nh,$f6,$q,$g6,$q,$h6,$Ah,$L,$Bh},$q6);
$Dh={};
$Eh=q#atomic_update#;
$Fh=[];
$Gh=q#my $self = shift;
my $suffix = 0;
++$suffix while -e $self->name . ".$suffix";
ni('ni:/io/file_update_fd')->new(
  $self,
  $self->class->new($self->name . ".$suffix", $self->mode));#;
$Hh=bless({$t,$Fh,$v,$Gh,$x,680,$y,$z},$A);
$Ih={$Eh,$Hh};
$Jh=q#/io/file_update.b#;
$Kh=bless({$i5,$Dh,$f6,$q,$g6,$q,$h6,$Ih,$L,$Jh},$q6);
$Lh={};
$Mh=[];
$Nh=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Oh=bless({$t,$Mh,$v,$Nh,$x,682,$y,$z},$A);
$Ph=q#r#;
$Qh=[];
$Rh=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Sh=bless({$t,$Qh,$v,$Rh,$x,684,$y,$z},$A);
$Th=[];
$Uh=q#shift->r->read(@_)#;
$Vh=bless({$t,$Th,$v,$Uh,$x,686,$y,$z},$A);
$Wh=q#w#;
$Xh=[];
$Yh=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Zh=bless({$t,$Xh,$v,$Yh,$x,688,$y,$z},$A);
$ci=[];
$di=q#shift->w->write(@_)#;
$ei=bless({$t,$ci,$v,$di,$x,690,$y,$z},$A);
$fi={$ig,$Oh,$Ph,$Sh,$Wb,$Vh,$Wh,$Zh,$gc,$ei};
$gi=q#/io/file_io.b#;
$hi=bless({$i5,$Lh,$f6,$q,$g6,$q,$h6,$fi,$L,$gi},$q6);
$ii=[$Mb,$Vg,$fh,$mh,$Ch,$Kh,$hi];
$ji=bless({$i5,$Og,$L,$E2,$W5,$ii},$q5);
$ki=q#io/file.c::ctors#;
$li=q#ni:/io/file.c#;
$mi={$q5,1};
$ni=q#/io/file.c#;
$oi=[$Ic];
$pi=bless({$i5,$mi,$L,$ni,$W5,$oi},$X5);
$qi=q#ni:/io/file_accessors.b#;
$ri=q#ni:/io/file_fns.b#;
$si=q#ni:/io/file_init.b#;
$ti=q#ni:/io/file_io.b#;
$ui=q#ni:/io/file_readers.b#;
$vi=q#ni:/io/file_update.b#;
$wi=q#ni:/io/file_update_fd#;
$xi={$s7,1};
$yi={};
$zi=[];
$Ai=q#my ($class, $file, $tempfile) = @_;
my $fd = $tempfile->w;
+{writer   => $fd,
  fd       => $fd->fd,
  wfh      => undef,
  tempfile => $tempfile,
  file     => $file};#;
$Bi=bless({$t,$zi,$v,$Ai,$x,692,$y,$z},$A);
$Ci={$g7,$Bi};
$Di=q#/io/file_update_fd_init.b#;
$Ei=bless({$i5,$yi,$f6,$q,$g6,$q,$h6,$Ci,$L,$Di},$q6);
$Fi={};
$Gi=[];
$Hi=bless({$t,$Gi,$v,$gg,$x,694,$y,$z},$A);
$Ii=[];
$Ji=q#my $self = shift;
close $$self{wfh} if $$self{wfh};
$$self{writer} = undef if $$self{writer};
if ($$self{tempfile}) {
  $$self{tempfile}->mv($$self{file}->name);
  $$self{tempfile} = undef;
}
$self;#;
$Ki=bless({$t,$Ii,$v,$Ji,$x,696,$y,$z},$A);
$Li={$ig,$Ki};
$Mi=q#/io/file_update_fd_gc.b#;
$Ni=bless({$i5,$Fi,$f6,$q,$g6,$Hi,$h6,$Li,$L,$Mi},$q6);
$Oi=[$Mb,$wf,$dg,$yg,$Ei,$Ni];
$Pi=bless({$i5,$xi,$L,$K2,$W5,$Oi},$r5);
$Qi=q#io/file_update_fd.c::ctors#;
$Ri=q#ni:/io/file_update_fd.c#;
$Si={$r5,1};
$Ti=q#/io/file_update_fd.c#;
$Ui=[$Ic];
$Vi=bless({$i5,$Si,$L,$Ti,$W5,$Ui},$X5);
$Wi=q#ni:/io/file_update_fd_gc.b#;
$Xi=q#ni:/io/file_update_fd_init.b#;
$Yi=q#ni:/io/mio#;
$Zi={$t7,1};
$cj={};
$dj=q#io#;
$ej=[];
$fj=q#shift->{'io'}#;
$gj=bless({$t,$ej,$v,$fj,$x,698,$y,$z},$A);
$hj=q#packet_size#;
$ij=[];
$jj=q#shift->{'packet_size'}#;
$kj=bless({$t,$ij,$v,$jj,$x,700,$y,$z},$A);
$lj={$dj,$gj,$hj,$kj};
$mj=q#/io/mio_ro.b#;
$nj=bless({$i5,$cj,$f6,$q,$g6,$q,$h6,$lj,$L,$mj},$q6);
$oj={};
$pj=[];
$qj=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$rj=bless({$t,$pj,$v,$qj,$x,702,$y,$z},$A);
$sj={$g7,$rj};
$tj=q#/io/mio_init.b#;
$uj=bless({$i5,$oj,$f6,$q,$g6,$q,$h6,$sj,$L,$tj},$q6);
$vj={};
$wj=q#next_sender#;
$xj=[];
$yj=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$zj=bless({$t,$xj,$v,$yj,$x,704,$y,$z},$A);
$Aj={$wj,$zj};
$Bj=q#/io/mio_rr_scheduler.b#;
$Cj=bless({$i5,$vj,$f6,$q,$g6,$q,$h6,$Aj,$L,$Bj},$q6);
$Dj={};
$Ej=[];
$Fj=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$Gj=bless({$t,$Ej,$v,$Fj,$x,706,$y,$z},$A);
$Hj=[];
$Ij=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$Jj=bless({$t,$Hj,$v,$Ij,$x,708,$y,$z},$A);
$Kj=[];
$Lj=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
\# TODO#;
$Mj=bless({$t,$Kj,$v,$Lj,$x,710,$y,$z},$A);
$Nj={$ig,$Gj,$Wb,$Jj,$gc,$Mj};
$Oj=q#/io/mio_io.b#;
$Pj=bless({$i5,$Dj,$f6,$q,$g6,$q,$h6,$Nj,$L,$Oj},$q6);
$Qj={};
$Rj=q#channel#;
$Sj=[];
$Tj=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$Uj=bless({$t,$Sj,$v,$Tj,$x,712,$y,$z},$A);
$Vj=q#channels#;
$Wj=[];
$Xj=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$Yj=bless({$t,$Wj,$v,$Xj,$x,714,$y,$z},$A);
$Zj=q#unchannel#;
$ck=[];
$dk=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$ek=bless({$t,$ck,$v,$dk,$x,716,$y,$z},$A);
$fk={$Rj,$Uj,$Vj,$Yj,$Zj,$ek};
$gk=q#/io/mio_channel.b#;
$hk=bless({$i5,$Qj,$f6,$q,$g6,$q,$h6,$fk,$L,$gk},$q6);
$ik=[$Mb,$nj,$uj,$Cj,$Pj,$hk];
$jk=bless({$i5,$Zi,$L,$T2,$W5,$ik},$s5);
$kk=q#io/mio.c::ctors#;
$lk=q#ni:/io/mio.c#;
$mk={$s5,1};
$nk=q#/io/mio.c#;
$ok=[$Ic];
$pk=bless({$i5,$mk,$L,$nk,$W5,$ok},$X5);
$qk=q#ni:/io/mio_channel#;
$rk={$u7,1};
$sk={};
$tk=q#capacity#;
$uk=[];
$vk=q#shift->{'capacity'}#;
$wk=bless({$t,$uk,$v,$vk,$x,718,$y,$z},$A);
$xk=q#id#;
$yk=[];
$zk=q#shift->{'id'}#;
$Ak=bless({$t,$yk,$v,$zk,$x,720,$y,$z},$A);
$Bk=q#mio#;
$Ck=[];
$Dk=q#shift->{'mio'}#;
$Ek=bless({$t,$Ck,$v,$Dk,$x,722,$y,$z},$A);
$Fk={$tk,$wk,$xk,$Ak,$Bk,$Ek};
$Gk=q#/io/mio_channel_ro.b#;
$Hk=bless({$i5,$sk,$f6,$q,$g6,$q,$h6,$Fk,$L,$Gk},$q6);
$Ik={};
$Jk=[];
$Kk=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$Lk=bless({$t,$Jk,$v,$Kk,$x,724,$y,$z},$A);
$Mk={$g7,$Lk};
$Nk=q#/io/mio_channel_init.b#;
$Ok=bless({$i5,$Ik,$f6,$q,$g6,$q,$h6,$Mk,$L,$Nk},$q6);
$Pk={};
$Qk=[];
$Rk=bless({$t,$Qk,$v,$gg,$x,726,$y,$z},$A);
$Sk={};
$Tk=q#/io/mio_channel_lifecycle.b#;
$Uk=bless({$i5,$Pk,$f6,$q,$g6,$Rk,$h6,$Sk,$L,$Tk},$q6);
$Vk={};
$Wk=[];
$Xk=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$Yk=bless({$t,$Wk,$v,$Xk,$x,728,$y,$z},$A);
$Zk=[];
$cl=q#shift->{read_buffer} ->read(@_)#;
$dl=bless({$t,$Zk,$v,$cl,$x,730,$y,$z},$A);
$el=[];
$fl=q#shift->{write_buffer}->write(@_)#;
$gl=bless({$t,$el,$v,$fl,$x,732,$y,$z},$A);
$hl={$ig,$Yk,$Wb,$dl,$gc,$gl};
$il=q#/io/mio_channel_io.b#;
$jl=bless({$i5,$Vk,$f6,$q,$g6,$q,$h6,$hl,$L,$il},$q6);
$kl=[$Mb,$Hk,$Ok,$Uk,$jl];
$ll=bless({$i5,$rk,$L,$Z2,$W5,$kl},$t5);
$ml=q#io/mio_channel.c::ctors#;
$nl=q#ni:/io/mio_channel.b#;
$ol=q#ni:/io/mio_channel.c#;
$pl={$t5,1};
$ql=q#/io/mio_channel.c#;
$rl=[$Ic];
$sl=bless({$i5,$pl,$L,$ql,$W5,$rl},$X5);
$tl=q#ni:/io/mio_channel_init.b#;
$ul=q#ni:/io/mio_channel_io.b#;
$vl=q#ni:/io/mio_channel_lifecycle.b#;
$wl=q#ni:/io/mio_channel_ro.b#;
$xl=q#ni:/io/mio_init.b#;
$yl=q#ni:/io/mio_io.b#;
$zl=q#ni:/io/mio_ro.b#;
$Al=q#ni:/io/mio_rr_scheduler.b#;
$Bl=q#ni:/io/named_io_fns.b#;
$Cl={};
$Dl=q#fcntl#;
$El=[];
$Fl=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$Gl=bless({$t,$El,$v,$Fl,$x,734,$y,$z},$A);
$Hl=[];
$Il=q#CORE::fork#;
$Jl=bless({$t,$Hl,$v,$Il,$x,736,$y,$z},$A);
$Kl=q#open2#;
$Ll=[];
$Ml=q#CORE::open $_[0], $_[1]#;
$Nl=bless({$t,$Ll,$v,$Ml,$x,738,$y,$z},$A);
$Ol=q#rename#;
$Pl=[];
$Ql=q#CORE::rename $_[0], $_[1]#;
$Rl=bless({$t,$Pl,$v,$Ql,$x,740,$y,$z},$A);
$Sl=q#unlink#;
$Tl=[];
$Ul=q#CORE::unlink @_#;
$Vl=bless({$t,$Tl,$v,$Ul,$x,742,$y,$z},$A);
$Wl=q#waitpid#;
$Xl=[];
$Yl=q#CORE::waitpid $_[0], $_[1]#;
$Zl=bless({$t,$Xl,$v,$Yl,$x,744,$y,$z},$A);
$cm={$Dl,$Gl,$Ne,$Jl,$Kl,$Nl,$Ol,$Rl,$Sl,$Vl,$Wl,$Zl};
$dm=q#/io/named_io_fns.b#;
$em=bless({$i5,$Cl,$f6,$q,$g6,$q,$h6,$cm,$L,$dm},$q6);
$fm=q#main#;
$gm=q#ni:/io/null#;
$hm={$v7,1};
$im=q#/io/null#;
$jm={};
$km=[];
$lm=q#+{fd => undef}#;
$mm=bless({$t,$km,$v,$lm,$x,746,$y,$z},$A);
$nm={$g7,$mm};
$om=q#/io/null_init.b#;
$pm=bless({$i5,$jm,$f6,$q,$g6,$q,$h6,$nm,$L,$om},$q6);
$qm={};
$rm=[];
$sm=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$tm=bless({$t,$rm,$v,$sm,$x,748,$y,$z},$A);
$um=[];
$vm=q#shift->fd->read(@_)#;
$wm=bless({$t,$um,$v,$vm,$x,750,$y,$z},$A);
$xm=[];
$ym=q#shift->fd->write(@_)#;
$zm=bless({$t,$xm,$v,$ym,$x,752,$y,$z},$A);
$Am={$he,$tm,$Wb,$wm,$gc,$zm};
$Bm=q#/io/null_io.b#;
$Cm=bless({$i5,$qm,$f6,$q,$g6,$q,$h6,$Am,$L,$Bm},$q6);
$Dm=[$Mb,$pm,$Cm];
$Em=bless({$i5,$hm,$L,$im,$W5,$Dm},$u5);
$Fm=q#io/null.c::ctors#;
$Gm=q#ni:/io/null.c#;
$Hm={$u5,1};
$Im=q#/io/null.c#;
$Jm=[$Ic];
$Km=bless({$i5,$Hm,$L,$Im,$W5,$Jm},$X5);
$Lm=q#ni:/io/null_init.b#;
$Mm=q#ni:/io/null_io.b#;
$Nm=q#ni:/io/object#;
$Om=q#ni:/io/object.c#;
$Pm=q#ni:/io/object.c_transfer_def.b#;
$Qm=q#ni:/io/object_checks.b#;
$Rm=q#ni:/io/object_constructors.b#;
$Sm=q#ni:/io/object_memory.b#;
$Tm=q#ni:/io/object_ops.b#;
$Um=q#ni:/io/object_transfer_async.b#;
$Vm=q#ni:/io/object_transfer_sync.b#;
$Wm=q#ni:/io/pid#;
$Xm={$x7,1};
$Ym={};
$Zm=q#pid#;
$cn=[];
$dn=q#shift->{'pid'}#;
$en=bless({$t,$cn,$v,$dn,$x,754,$y,$z},$A);
$fn=q#status#;
$gn=[];
$hn=q#shift->{'status'}#;
$in=bless({$t,$gn,$v,$hn,$x,756,$y,$z},$A);
$jn={$Zm,$en,$fn,$in};
$kn=q#/io/pid_readers.b#;
$ln=bless({$i5,$Ym,$f6,$q,$g6,$q,$h6,$jn,$L,$kn},$q6);
$mn={};
$nn=[];
$on=q#shift->await#;
$pn=bless({$t,$nn,$v,$on,$x,758,$y,$z},$A);
$qn=[];
$rn=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$sn=bless({$t,$qn,$v,$rn,$x,760,$y,$z},$A);
$tn={$g7,$sn};
$un=q#/io/pid_init.b#;
$vn=bless({$i5,$mn,$f6,$q,$g6,$pn,$h6,$tn,$L,$un},$q6);
$wn={};
$xn=q#await#;
$yn=[];
$zn=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$An=bless({$t,$yn,$v,$zn,$x,762,$y,$z},$A);
$Bn=q#running#;
$Cn=[];
$Dn=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$En=bless({$t,$Cn,$v,$Dn,$x,764,$y,$z},$A);
$Fn={$xn,$An,$Bn,$En};
$Gn=q#/io/pid_wait.b#;
$Hn=bless({$i5,$wn,$f6,$q,$g6,$q,$h6,$Fn,$L,$Gn},$q6);
$In={};
$Jn=[];
$Kn=q#shift->stdout->read(@_)#;
$Ln=bless({$t,$Jn,$v,$Kn,$x,766,$y,$z},$A);
$Mn=[];
$Nn=q#shift->stdin->write(@_)#;
$On=bless({$t,$Mn,$v,$Nn,$x,768,$y,$z},$A);
$Pn={$Wb,$Ln,$gc,$On};
$Qn=q#/io/pid_io.b#;
$Rn=bless({$i5,$In,$f6,$q,$g6,$q,$h6,$Pn,$L,$Qn},$q6);
$Sn={};
$Tn=[];
$Un=q#$_[0]->{external_fds}{$_[1]}#;
$Vn=bless({$t,$Tn,$v,$Un,$x,770,$y,$z},$A);
$Wn=[];
$Xn=q#shift->fd(2)#;
$Yn=bless({$t,$Wn,$v,$Xn,$x,772,$y,$z},$A);
$Zn=[];
$co=q#shift->fd(0)#;
$do=bless({$t,$Zn,$v,$co,$x,774,$y,$z},$A);
$eo=[];
$fo=q#shift->fd(1)#;
$go=bless({$t,$eo,$v,$fo,$x,776,$y,$z},$A);
$ho={$he,$Vn,$le,$Yn,$pe,$do,$te,$go};
$io=q#/io/pid_accessors.b#;
$jo=bless({$i5,$Sn,$f6,$q,$g6,$q,$h6,$ho,$L,$io},$q6);
$ko=[$Mb,$ln,$vn,$Hn,$Rn,$jo];
$lo=bless({$i5,$Xm,$L,$y3,$W5,$ko},$w5);
$mo=q#io/pid.c::ctors#;
$no=q#ni:/io/pid.c#;
$oo={$w5,1};
$po=q#/io/pid.c#;
$qo=[$Ic];
$ro=bless({$i5,$oo,$L,$po,$W5,$qo},$X5);
$so=q#ni:/io/pid_accessors.b#;
$to=q#ni:/io/pid_init.b#;
$uo=q#ni:/io/pid_io.b#;
$vo=q#ni:/io/pid_readers.b#;
$wo=q#ni:/io/pid_wait.b#;
$xo=q#ni:/io/str#;
$yo={$y7,1};
$zo=q#/io/str#;
$Ao={};
$Bo=q#data#;
$Co=[];
$Do=q#shift->{'data'}#;
$Eo=bless({$t,$Co,$v,$Do,$x,778,$y,$z},$A);
$Fo=q#end#;
$Go=[];
$Ho=q#shift->{'end'}#;
$Io=bless({$t,$Go,$v,$Ho,$x,780,$y,$z},$A);
$Jo=q#start#;
$Ko=[];
$Lo=q#shift->{'start'}#;
$Mo=bless({$t,$Ko,$v,$Lo,$x,782,$y,$z},$A);
$No={$Bo,$Eo,$Fo,$Io,$Jo,$Mo};
$Oo=q#/io/str_ro.b#;
$Po=bless({$i5,$Ao,$f6,$q,$g6,$q,$h6,$No,$L,$Oo},$q6);
$Qo={};
$Ro=[];
$So=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$To=bless({$t,$Ro,$v,$So,$x,784,$y,$z},$A);
$Uo={$g7,$To};
$Vo=q#/io/str_init.b#;
$Wo=bless({$i5,$Qo,$f6,$q,$g6,$q,$h6,$Uo,$L,$Vo},$q6);
$Xo={};
$Yo=[];
$Zo=q#my $self = shift;
my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
return 0 unless $l;
if ($_[2]) {
  substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$cp=bless({$t,$Yo,$v,$Zo,$x,786,$y,$z},$A);
$dp=q#remaining#;
$ep=[];
$fp=q#my $self = shift; $$self{end} - $$self{start}#;
$gp=bless({$t,$ep,$v,$fp,$x,788,$y,$z},$A);
$hp=[];
$ip=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$jp=bless({$t,$hp,$v,$ip,$x,790,$y,$z},$A);
$kp={$Wb,$cp,$dp,$gp,$gc,$jp};
$lp=q#/io/str_io.b#;
$mp=bless({$i5,$Xo,$f6,$q,$g6,$q,$h6,$kp,$L,$lp},$q6);
$np=[$Mb,$Po,$Wo,$mp];
$op=bless({$i5,$yo,$L,$zo,$W5,$np},$x5);
$pp=q#io/str.c::ctors#;
$qp=q#ni:/io/str.c#;
$rp={$x5,1};
$sp=q#/io/str.c#;
$tp=[$Ic];
$up=bless({$i5,$rp,$L,$sp,$W5,$tp},$X5);
$vp=q#ni:/io/str_init.b#;
$wp=q#ni:/io/str_io.b#;
$xp=q#ni:/io/str_ro.b#;
$yp=q#ni:/io/transfer#;
$zp={$z7,1,$A7,1,$B7,1};
$Ap=q#/io/transfer#;
$Bp={$z7,1,$A7,1,$B7,1,$L7,1};
$Cp=q#/semantic/task#;
$Dp={};
$Ep=[];
$Fp=q#shift->{'outcome'}#;
$Gp=bless({$t,$Ep,$v,$Fp,$x,792,$y,$z},$A);
$Hp={$r,$Gp};
$Ip=q#/semantic/task_ro.b#;
$Jp=bless({$i5,$Dp,$f6,$q,$g6,$q,$h6,$Hp,$L,$Ip},$q6);
$Kp={};
$Lp=q#failure#;
$Mp=[];
$Np=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$Op=bless({$t,$Mp,$v,$Np,$x,794,$y,$z},$A);
$Pp=q#success#;
$Qp=[];
$Rp=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$Sp=bless({$t,$Qp,$v,$Rp,$x,796,$y,$z},$A);
$Tp={$Lp,$Op,$Pp,$Sp};
$Up=q#/semantic/task_outcome.b#;
$Vp=bless({$i5,$Kp,$f6,$q,$g6,$q,$h6,$Tp,$L,$Up},$q6);
$Wp=[$Y7,$Jp,$Vp];
$Xp=bless({$i5,$Bp,$L,$Cp,$W5,$Wp},$U5);
$Yp=q#semantic/task.c::ctors#;
$Zp={};
$cq=[];
$dq=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$eq=bless({$t,$cq,$v,$dq,$x,798,$y,$z},$A);
$fq=[];
$gq=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$hq=bless({$t,$fq,$v,$gq,$x,800,$y,$z},$A);
$iq=[];
$jq=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$kq=bless({$t,$iq,$v,$jq,$x,802,$y,$z},$A);
$lq={$Wb,$hq,$gc,$kq};
$mq=q#/io/transfer_io_interop.b#;
$nq=bless({$i5,$Zp,$f6,$eq,$g6,$q,$h6,$lq,$L,$mq},$q6);
$oq={};
$pq=q#pressure#;
$qq=[];
$rq=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$sq=bless({$t,$qq,$v,$rq,$x,804,$y,$z},$A);
$tq=q#read_limit_throughput#;
$uq=[];
$vq=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$wq=bless({$t,$uq,$v,$vq,$x,806,$y,$z},$A);
$xq=q#throughput#;
$yq=[];
$zq=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$Aq=bless({$t,$yq,$v,$zq,$x,808,$y,$z},$A);
$Bq=q#write_limit_throughput#;
$Cq=[];
$Dq=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$Eq=bless({$t,$Cq,$v,$Dq,$x,810,$y,$z},$A);
$Fq={$pq,$sq,$tq,$wq,$xq,$Aq,$Bq,$Eq};
$Gq=q#/io/transfer_io_measurement.b#;
$Hq=bless({$i5,$oq,$f6,$q,$g6,$q,$h6,$Fq,$L,$Gq},$q6);
$Iq=[$Xp,$nq,$Hq];
$Jq=bless({$i5,$zp,$L,$Ap,$W5,$Iq},$y5);
$Kq=q#io/transfer.c::ctors#;
$Lq=q#ni:/io/transfer.c#;
$Mq={$y5,1,$z5,1,$A5,1};
$Nq=q#/io/transfer.c#;
$Oq={$y5,1,$z5,1,$A5,1,$U5,1};
$Pq=q#/semantic/task.c#;
$Qq=[$I9];
$Rq=bless({$i5,$Oq,$L,$Pq,$W5,$Qq},$X5);
$Sq={};
$Tq=[];
$Uq=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$Vq=bless({$t,$Tq,$v,$Uq,$x,814,$y,$z},$A);
$Wq={};
$Xq=q#/io/transfer.c_into.b#;
$Yq=bless({$i5,$Sq,$f6,$Vq,$g6,$q,$h6,$Wq,$L,$Xq},$q6);
$Zq=[$Rq,$Yq];
$cr=bless({$i5,$Mq,$L,$Nq,$W5,$Zq},$X5);
$dr=q#ni:/io/transfer.c_into.b#;
$er=q#ni:/io/transfer_async#;
$fr={$A7,1};
$gr=q#/io/transfer_async#;
$hr={};
$ir=q#dest_io#;
$jr=[];
$kr=q#shift->{'dest_io'}#;
$lr=bless({$t,$jr,$v,$kr,$x,816,$y,$z},$A);
$mr=[];
$nr=bless({$t,$mr,$v,$zk,$x,818,$y,$z},$A);
$or=q#source_io#;
$pr=[];
$qr=q#shift->{'source_io'}#;
$rr=bless({$t,$pr,$v,$qr,$x,820,$y,$z},$A);
$sr={$ir,$lr,$xk,$nr,$or,$rr};
$tr=q#/io/transfer_async_ro.b#;
$ur=bless({$i5,$hr,$f6,$q,$g6,$q,$h6,$sr,$L,$tr},$q6);
$vr={};
$wr=[];
$xr=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$yr=bless({$t,$wr,$v,$xr,$x,822,$y,$z},$A);
$zr={$g7,$yr};
$Ar=q#/io/transfer_async_init.b#;
$Br=bless({$i5,$vr,$f6,$q,$g6,$q,$h6,$zr,$L,$Ar},$q6);
$Cr={};
$Dr=[];
$Er=q#ni('ni:/io/transfer_async')->track(shift)#;
$Fr=bless({$t,$Dr,$v,$Er,$x,824,$y,$z},$A);
$Gr=[];
$Hr=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$Ir=bless({$t,$Gr,$v,$Hr,$x,826,$y,$z},$A);
$Jr={};
$Kr=q#/io/transfer_async_lifecycle.b#;
$Lr=bless({$i5,$Cr,$f6,$Fr,$g6,$Ir,$h6,$Jr,$L,$Kr},$q6);
$Mr={};
$Nr=q#run#;
$Or=[];
$Pr=q#shift#;
$Qr=bless({$t,$Or,$v,$Pr,$x,828,$y,$z},$A);
$Rr=q#run_async#;
$Sr=[];
$Tr=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$Ur=bless({$t,$Sr,$v,$Tr,$x,830,$y,$z},$A);
$Vr={$Nr,$Qr,$Rr,$Ur};
$Wr=q#/io/transfer_async_run.b#;
$Xr=bless({$i5,$Mr,$f6,$q,$g6,$q,$h6,$Vr,$L,$Wr},$q6);
$Yr=[$Jq,$ur,$Br,$Lr,$Xr];
$Zr=q#tracked_transfers#;
$cs={};
$ds=q#transfer_id#;
$es=bless({$i5,$fr,$L,$gr,$W5,$Yr,$Zr,$cs,$ds,0},$z5);
$fs=q#io/transfer_async.c::ctors#;
$gs=q#ni:/io/transfer_async.c#;
$hs={$z5,1};
$is=q#/io/transfer_async.c#;
$js={};
$ks=[];
$ls=q#my $self = shift;
$$self{tracked_transfers} = {};
$$self{transfer_id}       = 0;#;
$ms=bless({$t,$ks,$v,$ls,$x,840,$y,$z},$A);
$ns=q#new_id#;
$os=[];
$ps=q#++shift->{transfer_id}#;
$qs=bless({$t,$os,$v,$ps,$x,842,$y,$z},$A);
$rs=q#track#;
$ss=[];
$ts=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$us=bless({$t,$ss,$v,$ts,$x,844,$y,$z},$A);
$vs=q#untrack#;
$ws=[];
$xs=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$ys=bless({$t,$ws,$v,$xs,$x,846,$y,$z},$A);
$zs={$ns,$qs,$rs,$us,$vs,$ys};
$As=q#/io/transfer_async.c_tracker.b#;
$Bs=bless({$i5,$js,$f6,$ms,$g6,$q,$h6,$zs,$L,$As},$q6);
$Cs=[$cr,$Bs];
$Ds=bless({$i5,$hs,$L,$is,$W5,$Cs},$X5);
$Es=q#ni:/io/transfer_async.c_tracker.b#;
$Fs=q#ni:/io/transfer_async_init.b#;
$Gs=q#ni:/io/transfer_async_lifecycle.b#;
$Hs=q#ni:/io/transfer_async_ro.b#;
$Is=q#ni:/io/transfer_async_run.b#;
$Js=q#ni:/io/transfer_io_interop.b#;
$Ks=q#ni:/io/transfer_io_measurement.b#;
$Ls=q#ni:/io/transfer_sync#;
$Ms={$B7,1};
$Ns=q#/io/transfer_sync#;
$Os={};
$Ps=[];
$Qs=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$Rs=bless({$t,$Ps,$v,$Qs,$x,848,$y,$z},$A);
$Ss={$g7,$Rs};
$Ts=q#/io/transfer_sync_init.b#;
$Us=bless({$i5,$Os,$f6,$q,$g6,$q,$h6,$Ss,$L,$Ts},$q6);
$Vs={};
$Ws=[];
$Xs=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$Ys=bless({$t,$Ws,$v,$Xs,$x,850,$y,$z},$A);
$Zs={$Nr,$Ys};
$ct=q#/io/transfer_sync_run.b#;
$dt=bless({$i5,$Vs,$f6,$q,$g6,$q,$h6,$Zs,$L,$ct},$q6);
$et=[$Jq,$Us,$dt];
$ft=bless({$i5,$Ms,$L,$Ns,$W5,$et},$A5);
$gt=q#io/transfer_sync.c::ctors#;
$ht=q#ni:/io/transfer_sync.c#;
$it={$A5,1};
$jt=q#/io/transfer_sync.c#;
$kt=[$cr];
$lt=bless({$i5,$it,$L,$jt,$W5,$kt},$X5);
$mt=q#ni:/io/transfer_sync_init.b#;
$nt=q#ni:/io/transfer_sync_run.b#;
$ot=q#ni:/lib/accessor.b#;
$pt=q#ni:/lib/behavior#;
$qt=q#ni:/lib/behavior.c#;
$rt=q#ni:/lib/branch#;
$st={$s6,1};
$tt=q#/lib/branch#;
$ut={};
$vt=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$wt=bless({$v,$vt,$x,856,$y,$z},$A);
$xt={$g7,$wt};
$yt=q#/lib/branch_init.b#;
$zt=bless({$i5,$ut,$f6,$q,$g6,$q,$h6,$xt,$L,$yt},$q6);
$At=[$l8,$B6,$r6,$zt,$e9];
$Bt=bless({$i5,$st,$L,$tt,$W5,$At},$C5);
$Ct=q#lib/branch.c::ctors#;
$Dt=q#ni:/lib/branch.b#;
$Et=q#ni:/lib/branch.c#;
$Ft={$C5,1};
$Gt=q#/lib/branch.c#;
$Ht=[$N9];
$It=bless({$i5,$Ft,$L,$Gt,$W5,$Ht},$X5);
$Jt=q#ni:/lib/branch_init.b#;
$Kt=q#ni:/lib/class_init.b#;
$Lt=q#ni:/lib/dataslice#;
$Mt={$D7,1};
$Nt=q#/lib/dataslice#;
$Ot={};
$Pt=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Qt=bless({$v,$Pt,$x,858,$y,$z},$A);
$Rt={$g7,$Qt};
$St=q#/lib/dataslice_init.b#;
$Tt=bless({$i5,$Ot,$f6,$q,$g6,$q,$h6,$Rt,$L,$St},$q6);
$Ut={};
$Vt=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$Wt=bless({$v,$Vt,$x,860,$y,$z},$A);
$Xt={$l6,$Wt};
$Yt=q#/lib/dataslice_apply.b#;
$Zt=bless({$i5,$Ut,$f6,$q,$g6,$q,$h6,$Xt,$L,$Yt},$q6);
$cu=[$l8,$Tt,$Zt];
$du=bless({$i5,$Mt,$L,$Nt,$W5,$cu},$D5);
$eu=q#lib/dataslice.c::ctors#;
$fu=q#ni:/lib/dataslice.c#;
$gu={$D5,1};
$hu=q#/lib/dataslice.c#;
$iu=[$N9];
$ju=bless({$i5,$gu,$L,$hu,$W5,$iu},$X5);
$ku=q#ni:/lib/dataslice_apply.b#;
$lu=q#ni:/lib/dataslice_init.b#;
$mu=q#ni:/lib/definition.b#;
$nu=q#ni:/lib/definition_def.b#;
$ou=q#ni:/lib/definition_defdata.b#;
$pu=q#ni:/lib/doc#;
$qu={$N,1};
$ru={};
$su=q#shift; +{name => shift, doc => []}#;
$tu=bless({$v,$su,$x,862,$y,$z},$A);
$uu={$g7,$tu};
$vu=q#/lib/doc_init.b#;
$wu=bless({$i5,$ru,$f6,$q,$g6,$q,$h6,$uu,$L,$vu},$q6);
$xu={};
$yu=q#'ni.doc'#;
$zu=bless({$v,$yu,$x,864,$y,$z},$A);
$Au={$E6,$zu};
$Bu=q#/lib/doc_namespace.b#;
$Cu=bless({$i5,$xu,$f6,$q,$g6,$q,$h6,$Au,$L,$Bu},$q6);
$Du={};
$Eu=q#AUTOLOAD#;
$Fu=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Gu=bless({$v,$Fu,$x,866,$y,$z},$A);
$Hu={$Eu,$Gu};
$Iu=q#/lib/doc_define.b#;
$Ju=bless({$i5,$Du,$f6,$q,$g6,$q,$h6,$Hu,$L,$Iu},$q6);
$Ku={};
$Lu=q#shift->referent#;
$Mu=bless({$v,$Lu,$x,868,$y,$z},$A);
$Nu=q#referent#;
$Ou=q#ni 'ni:' . shift->{name}#;
$Pu=bless({$v,$Ou,$x,870,$y,$z},$A);
$Qu={$Fo,$Mu,$Nu,$Pu};
$Ru=q#/lib/doc_end.b#;
$Su=bless({$i5,$Ku,$f6,$q,$g6,$q,$h6,$Qu,$L,$Ru},$q6);
$Tu={};
$Uu=q#my $self = shift;
push @{$$self{doc}}, [eg => eg($_)] for @_;
$self;#;
$Vu=bless({$v,$Uu,$x,872,$y,$z},$A);
$Wu=q#linearized#;
$Xu=q#map @$_, @{shift->{doc}}#;
$Yu=bless({$v,$Xu,$x,874,$y,$z},$A);
$Zu=q#tests#;
$cv=q#my $self = shift;
grep ref($_) eq 'lib/test_case', $self->linearized;#;
$dv=bless({$v,$cv,$x,876,$y,$z},$A);
$ev={$e3,$Vu,$Wu,$Yu,$Zu,$dv};
$fv=q#/lib/doc_test.b#;
$gv=bless({$i5,$Tu,$f6,$q,$g6,$q,$h6,$ev,$L,$fv},$q6);
$hv=[$Y7,$B6,$wu,$Cu,$Ju,$Su,$gv];
$iv=bless({$i5,$qu,$L,$Z3,$W5,$hv},$E5);
$jv=q#lib/doc.c::ctors#;
$kv=q#ni:/lib/doc.c#;
$lv={$E5,1};
$mv=q#/lib/doc.c#;
$nv=[$I9];
$ov=bless({$i5,$lv,$L,$mv,$W5,$nv},$X5);
$pv=q#ni:/lib/doc_define.b#;
$qv=q#ni:/lib/doc_end.b#;
$rv=q#ni:/lib/doc_init.b#;
$sv=q#ni:/lib/doc_namespace.b#;
$tv=q#ni:/lib/doc_test.b#;
$uv=q#ni:/lib/documentable.b#;
$vv=q#ni:/lib/fn#;
$wv={$A,1};
$xv=q#/lib/fn#;
$yv={};
$zv=q#shift->compile#;
$Av=bless({$v,$zv,$x,878,$y,$z},$A);
$Bv=q#my $self = shift;
delete ${'lib/fn::evals'}{$$self{eval_number}}
  if defined $$self{eval_number};#;
$Cv=bless({$v,$Bv,$x,880,$y,$z},$A);
$Dv=q#compile#;
$Ev=q#local $@;
my $self = shift;
$$self{proto} ||= '';
my $code = "sub $$self{proto} {$$self{code}\\n}";
my ($en) = ni::eval('__FILE__') =~ /eval (\\d+)/;
$$self{eval_number} = ++$en;
Scalar::Util::weaken(${'lib/fn::evals'}{$en} = $self);
$$self{fn} = ni::eval $code;
die "ni:/lib/fn failed to compile $code: $@" if $@;
$$self{fn};#;
$Fv=bless({$v,$Ev,$x,882,$y,$z},$A);
$Gv=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  eval_number => undef,
  annotations => [@_]};#;
$Hv=bless({$v,$Gv,$x,884,$y,$z},$A);
$Iv={$Dv,$Fv,$g7,$Hv};
$Jv=q#/lib/fn_init.b#;
$Kv=bless({$i5,$yv,$f6,$Av,$g6,$Cv,$h6,$Iv,$L,$Jv},$q6);
$Lv={};
$Mv=[];
$Nv=q#shift->{'annotations'}#;
$Ov=bless({$t,$Mv,$v,$Nv,$x,886,$y,$z},$A);
$Pv=[];
$Qv=q#shift->{'code'}#;
$Rv=bless({$t,$Pv,$v,$Qv,$x,888,$y,$z},$A);
$Sv=[];
$Tv=q#shift->{'eval_number'}#;
$Uv=bless({$t,$Sv,$v,$Tv,$x,890,$y,$z},$A);
$Vv=q#fn#;
$Wv=[];
$Xv=q#shift->{'fn'}#;
$Yv=bless({$t,$Wv,$v,$Xv,$x,892,$y,$z},$A);
$Zv={$t,$Ov,$v,$Rv,$x,$Uv,$Vv,$Yv};
$cw=q#/lib/fn_ro.b#;
$dw=bless({$i5,$Lv,$f6,$q,$g6,$q,$h6,$Zv,$L,$cw},$q6);
$ew={};
$fw=[];
$gw=q#my $self = shift; "fn {$$self{code}}"#;
$hw=bless({$t,$fw,$v,$gw,$x,894,$y,$z},$A);
$iw=[];
$jw=bless({$t,$iw,$v,$P8,$x,896,$y,$z},$A);
$kw={$H8,$hw,$O8,$jw};
$lw=q#/lib/fn_ops.b#;
$mw=bless({$i5,$ew,$f6,$q,$g6,$q,$h6,$kw,$L,$lw},$q6);
$nw={};
$ow=q#serialize#;
$pw=[];
$qw=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$rw=bless({$t,$pw,$v,$qw,$x,898,$y,$z},$A);
$sw={$ow,$rw};
$tw=q#/lib/fn_serialize.b#;
$uw=bless({$i5,$nw,$f6,$q,$g6,$q,$h6,$sw,$L,$tw},$q6);
$vw=[$Y7,$p9,$Kv,$dw,$mw,$uw];
$ww=bless({$i5,$wv,$L,$xv,$W5,$vw},$F5);
$xw=q#lib/fn.c::ctors#;
$yw=q#ni:/lib/fn.c#;
$zw={$F5,1};
$Aw=q#/lib/fn.c#;
$Bw={};
$Cw=[];
$Dw=q#my $self = shift;
$SIG{__WARN__} = sub {warn $self->resolve_evals(shift), @_};
$SIG{__DIE__}  = sub {die  $self->resolve_evals(shift), @_};#;
$Ew=bless({$t,$Cw,$v,$Dw,$x,902,$y,$z},$A);
$Fw=q#resolve_evals#;
$Gw=[];
$Hw=q#my ($self, $trace) = @_;
1 while $trace =~ s\#\\(eval (\\d+)\\)\#
  ${'lib/fn::evals'}{$1}{code} || "(anonymous eval $1)"\#eg;
$trace;#;
$Iw=bless({$t,$Gw,$v,$Hw,$x,904,$y,$z},$A);
$Jw={$Fw,$Iw};
$Kw=q#/lib/fn.c_resolve_eval.b#;
$Lw=bless({$i5,$Bw,$f6,$Ew,$g6,$q,$h6,$Jw,$L,$Kw},$q6);
$Mw=[$I9,$Lw];
$Nw=bless({$i5,$zw,$L,$Aw,$W5,$Mw},$X5);
$Ow=q#ni:/lib/fn.c_resolve_eval.b#;
$Pw=q#ni:/lib/fn_init.b#;
$Qw=q#ni:/lib/fn_ops.b#;
$Rw=q#ni:/lib/fn_ro.b#;
$Sw=q#ni:/lib/fn_serialize.b#;
$Tw=q#ni:/lib/gensym_generator_compact.b#;
$Uw={};
$Vw=q#gensym#;
$Ww=[];
$Xw=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Yw=bless({$t,$Ww,$v,$Xw,$x,906,$y,$z},$A);
$Zw={$Vw,$Yw};
$cx=q#/lib/gensym_generator_compact.b#;
$dx=bless({$i5,$Uw,$f6,$q,$g6,$q,$h6,$Zw,$L,$cx},$q6);
$ex=q#ni:/lib/global_static_test.b#;
$fx={};
$gx=[];
$hx=q#ni('ni:/lib/test_case')->new(shift)#;
$ix=q#($)#;
$jx=bless({$t,$gx,$v,$hx,$x,908,$y,$ix},$A);
$kx=q#now#;
$lx=[];
$mx=q#ni('ni:/lib/test_value')->new(shift)#;
$nx=bless({$t,$lx,$v,$mx,$x,910,$y,$ix},$A);
$ox={$e3,$jx,$kx,$nx};
$px=q#/lib/global_static_test.b#;
$qx=bless({$i5,$fx,$f6,$q,$g6,$q,$h6,$ox,$L,$px},$q6);
$rx=q#ni:/lib/image#;
$sx={$E7,1};
$tx={};
$ux=[];
$vx=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$wx=bless({$t,$ux,$v,$vx,$x,912,$y,$z},$A);
$xx={$g7,$wx};
$yx=q#/lib/image_init.b#;
$zx=bless({$i5,$tx,$f6,$q,$g6,$q,$h6,$xx,$L,$yx},$q6);
$Ax={};
$Bx=q#address#;
$Cx=[];
$Dx=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Ex=bless({$t,$Cx,$v,$Dx,$x,914,$y,$z},$A);
$Fx=q#allocate_gensym#;
$Gx=[];
$Hx=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Ix=bless({$t,$Gx,$v,$Hx,$x,916,$y,$z},$A);
$Jx=q#boot_side_effect#;
$Kx=[];
$Lx=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Mx=bless({$t,$Kx,$v,$Lx,$x,918,$y,$z},$A);
$Nx=q#circular_links#;
$Ox=[];
$Px=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Qx=bless({$t,$Ox,$v,$Px,$x,920,$y,$z},$A);
$Rx=q#finalizer#;
$Sx=[];
$Tx=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Ux=bless({$t,$Sx,$v,$Tx,$x,922,$y,$z},$A);
$Vx=[];
$Wx=q#local $_;
my $self = shift;
ni('ni:/io/str')->new(join '',
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);",
  "\\n__DATA__\\n");#;
$Xx=bless({$t,$Vx,$v,$Wx,$x,924,$y,$z},$A);
$Yx=q#quote#;
$Zx=[];
$cy=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$dy=bless({$t,$Zx,$v,$cy,$x,926,$y,$z},$A);
$ey=q#reconstruction#;
$fy=[];
$gy=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$hy=bless({$t,$fy,$v,$gy,$x,928,$y,$z},$A);
$iy=q#side_effect#;
$jy=[];
$ky=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$ly=bless({$t,$jy,$v,$ky,$x,930,$y,$z},$A);
$my={$Bx,$Ex,$Fx,$Ix,$Jx,$Mx,$Nx,$Qx,$Rx,$Ux,$dj,$Xx,$Yx,$dy,$ey,$hy,$iy,$ly};
$ny=q#/lib/image_quoting.b#;
$oy=bless({$i5,$Ax,$f6,$q,$g6,$q,$h6,$my,$L,$ny},$q6);
$py={};
$qy=q#quote_code#;
$ry=[];
$sy=q#shift->die('cannot quote perl CODE refs', shift)#;
$ty=bless({$t,$ry,$v,$sy,$x,932,$y,$z},$A);
$uy={$qy,$ty};
$vy=q#/lib/quote_code_fail.b#;
$wy=bless({$i5,$py,$f6,$q,$g6,$q,$h6,$uy,$L,$vy},$q6);
$xy={};
$yy=q#quote_array#;
$zy=[];
$Ay=q#local $_;
my ($self, $v) = @_;
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$By=bless({$t,$zy,$v,$Ay,$x,934,$y,$z},$A);
$Cy=q#quote_hash#;
$Dy=[];
$Ey=q#local $_;
my ($self, $v) = @_;
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Fy=bless({$t,$Dy,$v,$Ey,$x,936,$y,$z},$A);
$Gy=q#quote_scalar#;
$Hy=[];
$Iy=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Jy=bless({$t,$Hy,$v,$Iy,$x,938,$y,$z},$A);
$Ky=q#quote_scalar_ref#;
$Ly=[];
$My=q#'\\\\' . shift->quote(${$_[0]})#;
$Ny=bless({$t,$Ly,$v,$My,$x,940,$y,$z},$A);
$Oy=q#quote_value#;
$Py=[];
$Qy=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Ry=bless({$t,$Py,$v,$Qy,$x,942,$y,$z},$A);
$Sy={$yy,$By,$Cy,$Fy,$Gy,$Jy,$Ky,$Ny,$Oy,$Ry};
$Ty=q#/lib/quote_values.b#;
$Uy=bless({$i5,$xy,$f6,$q,$g6,$q,$h6,$Sy,$L,$Ty},$q6);
$Vy={};
$Wy=q#quote_blessed#;
$Xy=[];
$Yy=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Zy=bless({$t,$Xy,$v,$Yy,$x,944,$y,$z},$A);
$cz=q#quote_class#;
$dz=[];
$ez=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$fz=bless({$t,$dz,$v,$ez,$x,946,$y,$z},$A);
$gz=q#quote_object#;
$hz=[];
$iz=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . '::ctors') . ';')
  if @{ref($_[0]) . '::ctors'};
$q;#;
$jz=bless({$t,$hz,$v,$iz,$x,948,$y,$z},$A);
$kz={$Wy,$Zy,$cz,$fz,$gz,$jz};
$lz=q#/lib/quote_objects.b#;
$mz=bless({$i5,$Vy,$f6,$q,$g6,$q,$h6,$kz,$L,$lz},$q6);
$nz={};
$oz=q#circular_arrayref#;
$pz=[];
$qz=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$rz=bless({$t,$pz,$v,$qz,$x,950,$y,$z},$A);
$sz=q#circular_hashref#;
$tz=[];
$uz=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$vz=bless({$t,$tz,$v,$uz,$x,952,$y,$z},$A);
$wz=q#is_circular#;
$xz=[];
$yz=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$zz=bless({$t,$xz,$v,$yz,$x,954,$y,$z},$A);
$Az={$oz,$rz,$sz,$vz,$wz,$zz};
$Bz=q#/lib/quote_circular_addressed.b#;
$Cz=bless({$i5,$nz,$f6,$q,$g6,$q,$h6,$Az,$L,$Bz},$q6);
$Dz=[$Y7,$zx,$oy,$wy,$Uy,$mz,$Cz,$dx];
$Ez=bless({$i5,$sx,$L,$j4,$W5,$Dz},$G5);
$Fz=q#lib/image.c::ctors#;
$Gz=q#ni:/lib/image.c#;
$Hz={$G5,1};
$Iz=q#/lib/image.c#;
$Jz=[$I9];
$Kz=bless({$i5,$Hz,$L,$Iz,$W5,$Jz},$X5);
$Lz=q#ni:/lib/image_init.b#;
$Mz=q#ni:/lib/image_quoting.b#;
$Nz=q#ni:/lib/instance.b#;
$Oz=q#ni:/lib/instantiable.b#;
$Pz=q#ni:/lib/json.b#;
$Qz={};
$Rz=q#json_decode#;
$Sz=[];
$Tz=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Uz=bless({$t,$Sz,$v,$Tz,$x,956,$y,$ix},$A);
$Vz=q#json_encode#;
$Wz=[];
$Xz=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Yz=bless({$t,$Wz,$v,$Xz,$x,958,$y,$ix},$A);
$Zz=q#json_escape#;
$cA=[];
$dA=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$eA=bless({$t,$cA,$v,$dA,$x,960,$y,$ix},$A);
$fA=q#json_unescape#;
$gA=[];
$hA=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$iA=bless({$t,$gA,$v,$hA,$x,962,$y,$ix},$A);
$jA=q#json_unescape_one#;
$kA=[];
$lA=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$mA=bless({$t,$kA,$v,$lA,$x,964,$y,$ix},$A);
$nA={$Rz,$Uz,$Vz,$Yz,$Zz,$eA,$fA,$iA,$jA,$mA};
$oA=q#/lib/json.b#;
$pA=bless({$i5,$Qz,$f6,$q,$g6,$q,$h6,$nA,$L,$oA},$q6);
$qA=q#ni#;
$rA=q#ni:/lib/name_as_string.b#;
$sA=q#ni:/lib/named.b#;
$tA=q#ni:/lib/named_in_ni.b#;
$uA=q#ni:/lib/namespaced.b#;
$vA=q#ni:/lib/ni#;
$wA={$F7,1};
$xA={};
$yA=q#extend#;
$zA=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$AA=bless({$v,$zA,$x,966,$y,$z},$A);
$BA=q#is_mutable#;
$CA=q#$0 ne '-' && -w $0#;
$DA=bless({$v,$CA,$x,968,$y,$z},$A);
$EA=q#modify#;
$FA=q#my ($self, $fn) = @_;
die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
&$fn(ni('ni:/io/file')->new($0, $mode)->atomic_update);#;
$GA=bless({$v,$FA,$x,970,$y,$z},$A);
$HA={$yA,$AA,$BA,$DA,$EA,$GA};
$IA=q#/lib/ni_self.b#;
$JA=bless({$i5,$xA,$f6,$q,$g6,$q,$h6,$HA,$L,$IA},$q6);
$KA={};
$LA=q#--internal/+=#;
$MA=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->io->into_sync(shift)});
0;#;
$NA=bless({$v,$MA,$x,972,$y,$z},$A);
$OA=q#--internal/eval#;
$PA=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$QA=bless({$v,$PA,$x,974,$y,$z},$A);
$RA=q#--internal/image#;
$SA=q#shift->quoted(use_newlines => 1)->io->into_sync(ni"fd:1");
0;#;
$TA=bless({$v,$SA,$x,976,$y,$z},$A);
$UA=q#--internal/test#;
$VA=q#my $self   = shift;
my $failed = 0;
my @tests  = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
for (@tests) {
  $_->run;
  print "$_\\n";
}
for my $f (grep $_->failed, @tests) {
  ++$failed;
  print "\\nTEST FAIL\\n", $f->test, "\\n";
  print "\\nERROR ", ni('ni:/lib/fn')->resolve_evals($f->error)
    if $f->error;
  print "\\nASSERTIONS\\n";
  print "  $_\\n" for @{$f->assertions};
}

print "\\nSUMMARY\\n";
printf "% 4d test(s) passed\\n", @tests - $failed;
printf "% 4d test(s) failed\\n", $failed;
!!$failed;#;
$WA=bless({$v,$VA,$x,978,$y,$z},$A);
$XA=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$YA=bless({$v,$XA,$x,980,$y,$z},$A);
$ZA={$LA,$NA,$OA,$QA,$RA,$TA,$UA,$WA,$Nr,$YA};
$cB=q#/lib/ni_main.b#;
$dB=bless({$i5,$KA,$f6,$q,$g6,$q,$h6,$ZA,$L,$cB},$q6);
$eB={};
$fB=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$gB=bless({$v,$fB,$x,982,$y,$z},$A);
$hB=q#resolver_for#;
$iB=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$jB=bless({$v,$iB,$x,984,$y,$z},$A);
$kB={$S6,$gB,$hB,$jB};
$lB=q#/lib/ni_resolver.b#;
$mB=bless({$i5,$eB,$f6,$q,$g6,$q,$h6,$kB,$L,$lB},$q6);
$nB={};
$oB=q#exists#;
$pB=q#exists $_[0]->{named}{$_[1]}#;
$qB=bless({$v,$pB,$x,986,$y,$z},$A);
$rB=q#quoted#;
$sB=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$tB=bless({$v,$sB,$x,988,$y,$z},$A);
$uB={$oB,$qB,$rB,$tB};
$vB=q#/lib/ni_image.b#;
$wB=bless({$i5,$nB,$f6,$q,$g6,$q,$h6,$uB,$L,$vB},$q6);
$xB=[$Y7,$JA,$dB,$mB,$wB];
$yB=bless({$i5,$wA,$L,$r4,$W5,$xB},$H5);
$zB=q#lib/ni.c::ctors#;
$AB=q#ni:/lib/ni.c#;
$BB={$H5,1};
$CB=q#/lib/ni.c#;
$DB=[$I9];
$EB=bless({$i5,$BB,$L,$CB,$W5,$DB},$X5);
$FB=q#ni:/lib/ni_image.b#;
$GB=q#ni:/lib/ni_main.b#;
$HB=q#ni:/lib/ni_resolver.b#;
$IB=q#ni:/lib/ni_self.b#;
$JB=q#ni:/lib/ni_static_util.b#;
$KB={};
$LB=q#abbrev#;
$MB=[];
$NB=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$OB=bless({$t,$MB,$v,$NB,$x,990,$y,$z},$A);
$PB=q#dor#;
$QB=[];
$RB=q#defined $_[0] ? $_[0] : $_[1]#;
$SB=bless({$t,$QB,$v,$RB,$x,992,$y,$z},$A);
$TB=q#indent#;
$UB=[];
$VB=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$WB=bless({$t,$UB,$v,$VB,$x,994,$y,$z},$A);
$XB=q#max#;
$YB=[];
$ZB=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$cC=bless({$t,$YB,$v,$ZB,$x,996,$y,$z},$A);
$dC=q#maxstr#;
$eC=[];
$fC=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$gC=bless({$t,$eC,$v,$fC,$x,998,$y,$z},$A);
$hC=q#mean#;
$iC=[];
$jC=q#sum(@_) / (@_ || 1)#;
$kC=bless({$t,$iC,$v,$jC,$x,1000,$y,$z},$A);
$lC=q#min#;
$mC=[];
$nC=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$oC=bless({$t,$mC,$v,$nC,$x,1002,$y,$z},$A);
$pC=q#minstr#;
$qC=[];
$rC=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$sC=bless({$t,$qC,$v,$rC,$x,1004,$y,$z},$A);
$tC=q#sgr#;
$uC=[];
$vC=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$wC=bless({$t,$uC,$v,$vC,$x,1006,$y,$z},$A);
$xC=q#sr#;
$yC=[];
$zC=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$AC=bless({$t,$yC,$v,$zC,$x,1008,$y,$z},$A);
$BC=q#sum#;
$CC=[];
$DC=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$EC=bless({$t,$CC,$v,$DC,$x,1010,$y,$z},$A);
$FC=q#swap#;
$GC=[];
$HC=q#@_[0, 1] = @_[1, 0]#;
$IC=bless({$t,$GC,$v,$HC,$x,1012,$y,$z},$A);
$JC={$LB,$OB,$PB,$SB,$TB,$WB,$XB,$cC,$dC,$gC,$hC,$kC,$lC,$oC,$pC,$sC,$tC,$wC,$xC,$AC,$BC,$EC,$FC,$IC};
$KC=q#/lib/ni_static_util.b#;
$LC=bless({$i5,$KB,$f6,$q,$g6,$q,$h6,$JC,$L,$KC},$q6);
$MC=q#ni:/lib/perlbranch.b#;
$NC=q#ni:/lib/quote_circular_addressed.b#;
$OC=q#ni:/lib/quote_code_fail.b#;
$PC=q#ni:/lib/quote_objects.b#;
$QC=q#ni:/lib/quote_simple#;
$RC={$G7,1};
$SC={};
$TC=[];
$UC=q#+{}#;
$VC=bless({$t,$TC,$v,$UC,$x,1014,$y,$z},$A);
$WC={$g7,$VC};
$XC=q#/lib/quote_simple_init.b#;
$YC=bless({$i5,$SC,$f6,$q,$g6,$q,$h6,$WC,$L,$XC},$q6);
$ZC={};
$cD=[];
$dD=bless({$t,$cD,$v,0,$x,1016,$y,$z},$A);
$eD=[];
$fD=q#shift->quote_value(shift)#;
$gD=bless({$t,$eD,$v,$fD,$x,1018,$y,$z},$A);
$hD={$wz,$dD,$Yx,$gD};
$iD=q#/lib/quote_simple_quote.b#;
$jD=bless({$i5,$ZC,$f6,$q,$g6,$q,$h6,$hD,$L,$iD},$q6);
$kD=[$Y7,$YC,$jD,$wy,$Uy,$mz];
$lD=bless({$i5,$RC,$L,$C4,$W5,$kD},$I5);
$mD=q#lib/quote_simple.c::ctors#;
$nD=q#ni:/lib/quote_simple.c#;
$oD={$I5,1};
$pD=q#/lib/quote_simple.c#;
$qD=[$I9];
$rD=bless({$i5,$oD,$L,$pD,$W5,$qD},$X5);
$sD=q#ni:/lib/quote_simple_init.b#;
$tD=q#ni:/lib/quote_simple_quote.b#;
$uD=q#ni:/lib/quote_values.b#;
$vD=q#ni:/lib/ref_eq.b#;
$wD=q#ni:/lib/resolver.b#;
$xD=q#ni:/lib/slice#;
$yD={$q6,1};
$zD=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$AD=bless({$v,$zD,$x,1020,$y,$z},$A);
$BD=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$CD=bless({$v,$BD,$x,1022,$y,$z},$A);
$DD=q#lib/slice::apply#;
$ED=q#lib/slice::apply_unsafe#;
$FD={};
$GD=q#apply_unsafe#;
$HD={$l6,$AD,$GD,$CD};
$ID=q#/lib/slice.b#;
$JD=bless({$i5,$FD,$h6,$HD,$L,$ID},$q6);
$KD={};
$LD=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$MD=bless({$v,$LD,$x,1024,$y,$z},$A);
$ND={$g7,$MD};
$OD=q#/lib/slice_init.b#;
$PD=bless({$i5,$KD,$h6,$ND,$L,$OD},$q6);
$QD={};
$RD=[];
$SD=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$TD=bless({$t,$RD,$v,$SD,$x,1026,$y,$z},$A);
$UD={$ow,$TD};
$VD=q#/lib/slice_serialize.b#;
$WD=bless({$i5,$QD,$f6,$q,$g6,$q,$h6,$UD,$L,$VD},$q6);
$XD=[$l8,$B6,$JD,$PD,$WD];
$YD=bless({$i5,$yD,$L,$X4,$W5,$XD},$J5);
$ZD=q#lib/slice.c::ctors#;
$cE=q#ni:/lib/slice.b#;
$dE=q#ni:/lib/slice.c#;
$eE={$J5,1};
$fE=q#/lib/slice.c#;
$gE=[$N9];
$hE=bless({$i5,$eE,$L,$fE,$W5,$gE},$X5);
$iE=q#ni:/lib/slice_init.b#;
$jE=q#ni:/lib/slice_serialize.b#;
$kE=q#ni:/lib/static_fn.b#;
$lE={};
$mE=[];
$nE=q#ni('ni:/lib/fn')->new(@_)#;
$oE=bless({$t,$mE,$v,$nE,$x,1028,$y,$ix},$A);
$pE=q#fp#;
$qE=[];
$rE=q#($$)#;
$sE=bless({$t,$qE,$v,$nE,$x,1030,$y,$rE},$A);
$tE={$Vv,$oE,$pE,$sE};
$uE=q#/lib/static_fn.b#;
$vE=bless({$i5,$lE,$f6,$q,$g6,$q,$h6,$tE,$L,$uE},$q6);
$wE=q#ni:/lib/subclass.b#;
$xE=q#ni:/lib/tag#;
$yE={$C6,1};
$zE=q#/lib/tag#;
$AE={};
$BE=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$CE=bless({$v,$BE,$x,1032,$y,$z},$A);
$DE={$l6,$CE};
$EE=q#/lib/tag.b#;
$FE=bless({$i5,$AE,$f6,$q,$g6,$q,$h6,$DE,$L,$EE},$q6);
$GE={};
$HE=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$IE=bless({$v,$HE,$x,1034,$y,$z},$A);
$JE={$g7,$IE};
$KE=q#/lib/tag_init.b#;
$LE=bless({$i5,$GE,$f6,$q,$g6,$q,$h6,$JE,$L,$KE},$q6);
$ME=[$l8,$B6,$FE,$LE];
$NE=bless({$i5,$yE,$L,$zE,$W5,$ME},$K5);
$OE=q#lib/tag.c::ctors#;
$PE=q#ni:/lib/tag.b#;
$QE=q#ni:/lib/tag.c#;
$RE={$K5,1};
$SE=q#/lib/tag.c#;
$TE=[$N9];
$UE=bless({$i5,$RE,$L,$SE,$W5,$TE},$X5);
$VE=q#ni:/lib/tag_init.b#;
$WE=q#ni:/lib/test_assert_eq#;
$XE={$H7,1};
$YE=q#/lib/test_assert_eq#;
$ZE={$H7,1,$I7,1};
$cF=q#/lib/test_assertion#;
$dF={};
$eF=q#commit#;
$fF=[];
$gF=q#my $self = shift;
my $test = ni('ni:/lib/test_case')->running_test;
push @{$test->assertions}, $self->result;
$self;#;
$hF=bless({$t,$fF,$v,$gF,$x,1036,$y,$z},$A);
$iF={$eF,$hF};
$jF=q#/lib/test_assertion_commit.b#;
$kF=bless({$i5,$dF,$f6,$q,$g6,$q,$h6,$iF,$L,$jF},$q6);
$lF=[$Y7,$kF];
$mF=bless({$i5,$ZE,$L,$cF,$W5,$lF},$M5);
$nF=q#lib/test_assertion.c::ctors#;
$oF={};
$pF=[];
$qF=q#my ($class, $diff) = @_;
+{diff => $diff};#;
$rF=bless({$t,$pF,$v,$qF,$x,1038,$y,$z},$A);
$sF={$g7,$rF};
$tF=q#/lib/test_assert_eq_init.b#;
$uF=bless({$i5,$oF,$f6,$q,$g6,$q,$h6,$sF,$L,$tF},$q6);
$vF={};
$wF=[];
$xF=q#my $self = shift;
$self->failed ? "FAIL " . ni::json_encode $$self{diff}
              : "PASS";#;
$yF=bless({$t,$wF,$v,$xF,$x,1040,$y,$z},$A);
$zF=q#failed#;
$AF=[];
$BF=q#defined shift->{diff}#;
$CF=bless({$t,$AF,$v,$BF,$x,1042,$y,$z},$A);
$DF=q#result#;
$EF=[];
$FF=bless({$t,$EF,$v,$Pr,$x,1044,$y,$z},$A);
$GF={$H8,$yF,$zF,$CF,$DF,$FF};
$HF=q#/lib/test_assert_eq_result.b#;
$IF=bless({$i5,$vF,$f6,$q,$g6,$q,$h6,$GF,$L,$HF},$q6);
$JF=[$mF,$uF,$IF];
$KF=bless({$i5,$XE,$L,$YE,$W5,$JF},$L5);
$LF=q#lib/test_assert_eq.c::ctors#;
$MF=q#ni:/lib/test_assert_eq.c#;
$NF={$L5,1};
$OF=q#/lib/test_assert_eq.c#;
$PF={$L5,1,$M5,1};
$QF=q#/lib/test_assertion.c#;
$RF=[$I9];
$SF=bless({$i5,$PF,$L,$QF,$W5,$RF},$X5);
$TF=[$SF];
$UF=bless({$i5,$NF,$L,$OF,$W5,$TF},$X5);
$VF=q#ni:/lib/test_assert_eq_init.b#;
$WF=q#ni:/lib/test_assert_eq_result.b#;
$XF=q#ni:/lib/test_assertion#;
$YF=q#ni:/lib/test_assertion.c#;
$ZF=q#ni:/lib/test_assertion_commit.b#;
$cG=q#ni:/lib/test_case#;
$dG={$D,1};
$eG=q#/lib/test_case#;
$fG=q#running_test#;
$gG={};
$hG=[];
$iG=q#shift->{'assertions'}#;
$jG=bless({$t,$hG,$v,$iG,$x,1046,$y,$z},$A);
$kG=[];
$lG=q#shift->{'test'}#;
$mG=bless({$t,$kG,$v,$lG,$x,1048,$y,$z},$A);
$nG={$n,$jG,$s,$mG};
$oG=q#/lib/test_case_ro.b#;
$pG=bless({$i5,$gG,$f6,$q,$g6,$q,$h6,$nG,$L,$oG},$q6);
$qG={};
$rG=[];
$sG=q#@_ == 2 ? $_[0]->{'error'} = $_[1] : shift->{'error'}#;
$tG=bless({$t,$rG,$v,$sG,$x,1050,$y,$z},$A);
$uG={$p,$tG};
$vG=q#/lib/test_case_rw.b#;
$wG=bless({$i5,$qG,$f6,$q,$g6,$q,$h6,$uG,$L,$vG},$q6);
$xG={};
$yG=[];
$zG=q#my $class = shift;
my $test  = fn shift;
+{test       => $test,
  assertions => [],
  error      => undef,
  outcome    => undef};#;
$AG=bless({$t,$yG,$v,$zG,$x,1052,$y,$z},$A);
$BG={$g7,$AG};
$CG=q#/lib/test_case_init.b#;
$DG=bless({$i5,$xG,$f6,$q,$g6,$q,$h6,$BG,$L,$CG},$q6);
$EG={};
$FG=[];
$GG=q#my $self = shift;
join '', $self->failed  ? 'FAIL ' : 'PASS ',
         $self->error   ? 'E'     : ':',
         map $_->failed ? 'X'     : '.', @{$$self{assertions}};#;
$HG=bless({$t,$FG,$v,$GG,$x,1054,$y,$z},$A);
$IG=[];
$JG=q#!shift->{outcome}->[0]#;
$KG=bless({$t,$IG,$v,$JG,$x,1056,$y,$z},$A);
$LG={$H8,$HG,$zF,$KG};
$MG=q#/lib/test_case_metrics.b#;
$NG=bless({$i5,$EG,$f6,$q,$g6,$q,$h6,$LG,$L,$MG},$q6);
$OG={};
$PG=q#done#;
$QG=[];
$RG=q#my $self = shift;
my @failed = grep $_->failed, @{$$self{assertions}};
my $any_failed = @failed || defined $$self{error};
$$self{outcome} = [!$any_failed, $$self{error}, @failed];#;
$SG=bless({$t,$QG,$v,$RG,$x,1058,$y,$z},$A);
$TG=[];
$UG=q#local $_;
my $self = shift;
$self->class->with_test($self, \\&{$$self{test}});
$self;#;
$VG=bless({$t,$TG,$v,$UG,$x,1060,$y,$z},$A);
$WG={$PG,$SG,$Nr,$VG};
$XG=q#/lib/test_case_run.b#;
$YG=bless({$i5,$OG,$f6,$q,$g6,$q,$h6,$WG,$L,$XG},$q6);
$ZG=[$Y7,$pG,$wG,$DG,$NG,$YG];
$cH=bless({$i5,$dG,$L,$eG,$fG,$q,$W5,$ZG},$N5);
$dH=q#lib/test_case.c::ctors#;
$eH=q#ni:/lib/test_case.c#;
$fH={$N5,1};
$gH=q#/lib/test_case.c#;
$hH={};
$iH=[];
$jH=q#shift->{'running_test'}#;
$kH=bless({$t,$iH,$v,$jH,$x,1064,$y,$z},$A);
$lH={$fG,$kH};
$mH=q#/lib/test_case.c_test_ro.b#;
$nH=bless({$i5,$hH,$f6,$q,$g6,$q,$h6,$lH,$L,$mH},$q6);
$oH={};
$pH=[];
$qH=q#shift->{running_test} = undef#;
$rH=bless({$t,$pH,$v,$qH,$x,1066,$y,$z},$A);
$sH=q#with_test#;
$tH=[];
$uH=q#my ($self, $test, $f) = @_;
local $$self{running_test} = $test;
eval {&$f};
$test->error($@) if $@;
$test->done;#;
$vH=bless({$t,$tH,$v,$uH,$x,1068,$y,$z},$A);
$wH={$sH,$vH};
$xH=q#/lib/test_case.c_test.b#;
$yH=bless({$i5,$oH,$f6,$rH,$g6,$q,$h6,$wH,$L,$xH},$q6);
$zH=[$I9,$nH,$yH];
$AH=bless({$i5,$fH,$L,$gH,$W5,$zH},$X5);
$BH=q#ni:/lib/test_case.c_test.b#;
$CH=q#ni:/lib/test_case.c_test_ro.b#;
$DH=q#ni:/lib/test_case_init.b#;
$EH=q#ni:/lib/test_case_metrics.b#;
$FH=q#ni:/lib/test_case_ro.b#;
$GH=q#ni:/lib/test_case_run.b#;
$HH=q#ni:/lib/test_case_rw.b#;
$IH=q#ni:/lib/test_value#;
$JH={$J7,1};
$KH=q#/lib/test_value#;
$LH={};
$MH=[];
$NH=q#\\$_[1]#;
$OH=bless({$t,$MH,$v,$NH,$x,1070,$y,$z},$A);
$PH={$g7,$OH};
$QH=q#/lib/test_value_init.b#;
$RH=bless({$i5,$LH,$f6,$q,$g6,$q,$h6,$PH,$L,$QH},$q6);
$SH={};
$TH=q#(==#;
$UH=[];
$VH=q#my ($self, $rhs) = @_;
ni('ni:/lib/test_assert_eq')
  ->new($self->diff($rhs))
  ->commit;#;
$WH=bless({$t,$UH,$v,$VH,$x,1072,$y,$z},$A);
$XH=q#diff#;
$YH=[];
$ZH=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  no warnings 'uninitialized';
  return {scalar_difference => [$lhs, $rhs]} if $lhs ne $rhs;
}
return undef;#;
$cI=bless({$t,$YH,$v,$ZH,$x,1074,$y,$z},$A);
$dI={$TH,$WH,$XH,$cI};
$eI=q#/lib/test_value_eq.b#;
$fI=bless({$i5,$SH,$f6,$q,$g6,$q,$h6,$dI,$L,$eI},$q6);
$gI={};
$hI=[];
$iI=q#ni::json_encode ${$_[0]}#;
$jI=bless({$t,$hI,$v,$iI,$x,1076,$y,$z},$A);
$kI={$H8,$jI};
$lI=q#/lib/test_value_str.b#;
$mI=bless({$i5,$gI,$f6,$q,$g6,$q,$h6,$kI,$L,$lI},$q6);
$nI=[$Y7,$RH,$fI,$mI];
$oI=bless({$i5,$JH,$L,$KH,$W5,$nI},$O5);
$pI=q#lib/test_value.c::ctors#;
$qI=q#ni:/lib/test_value.c#;
$rI={$O5,1};
$sI=q#/lib/test_value.c#;
$tI=[$I9];
$uI=bless({$i5,$rI,$L,$sI,$W5,$tI},$X5);
$vI=q#ni:/lib/test_value_eq.b#;
$wI=q#ni:/lib/test_value_init.b#;
$xI=q#ni:/lib/test_value_str.b#;
$yI=q#ni:/metaclass#;
$zI={$X5,1};
$AI=q#/metaclass#;
$BI=[$Z6,$p9,$l7,$h9];
$CI=bless({$i5,$zI,$L,$AI,$W5,$BI},$P5);
$DI=q#metaclass.c::ctors#;
$EI=q#ni:/metaclass.c#;
$FI={$P5,1};
$GI=q#/metaclass.c#;
$HI=[$y9];
$II=bless({$i5,$FI,$L,$GI,$W5,$HI},$X5);
$JI=q#ni:/module#;
$KI=q#ni:/module.c#;
$LI=q#ni:/object#;
$MI=q#ni:/object.c#;
$NI=q#ni:/semantic/dimension#;
$OI={$S5,1};
$PI=q#/semantic/dimension#;
$QI=[$y9];
$RI=bless({$i5,$OI,$L,$PI,$W5,$QI},$T5);
$SI=q#semantic/dimension.c::ctors#;
$TI=q#ni:/semantic/dimension.c#;
$UI={$T5,1};
$VI=q#/semantic/dimension.c#;
$WI=[$R9];
$XI=bless({$i5,$UI,$L,$VI,$W5,$WI},$X5);
$YI=q#ni:/semantic/task#;
$ZI=q#ni:/semantic/task.c#;
$cJ=q#ni:/semantic/task_outcome.b#;
$dJ=q#ni:/semantic/task_ro.b#;
$eJ=q#ni:main#;
$fJ={$fm,1};
$gJ=[$vE,$qx,$em];
$hJ=bless({$i5,$fJ,$L,$fm,$W5,$gJ},$Y5);
$iJ=q#module::ctors#;
$jJ=q#ni:ni#;
$kJ={$qA,1};
$lJ={$qA,1};
$mJ=q#json_escapes#;
$nJ=q##;
$oJ=q#b#;
$pJ=q#	#;
$qJ=q#t#;
$rJ=q#
#;
$sJ=q#n#;
$tJ=q##;
$uJ=q#"#;
$vJ=q#/#;
$wJ=q#\\#;
$xJ={$nJ,$oJ,$pJ,$qJ,$rJ,$sJ,$tJ,$Ph,$uJ,$uJ,$vJ,$vJ,$wJ,$wJ};
$yJ=q#json_unescapes#;
$zJ={$uJ,$uJ,$vJ,$vJ,$wJ,$wJ,$oJ,$nJ,$sJ,$rJ,$Ph,$tJ,$qJ,$pJ};
$AJ={$mJ,$xJ,$yJ,$zJ};
$BJ=q#/lib/json_data.b#;
$CJ=bless({$i5,$lJ,$Bo,$AJ,$L,$BJ},$D7);
$DJ=[$CJ,$pA,$LC];
$EJ=bless({$i5,$kJ,$L,$qA,$W5,$DJ},$Y5);
$FJ={$d,$O,$Q,$V,$W,$Z,$c1,$h1,$i1,$u1,$v1,$H1,$I1,$U1,$V1,$j2,$k2,$F2,$G2,$L2,$M2,$U2,$V2,$c3,$d3,$z3,$A3,$G3,$H3,$c4,$d4,$k4,$l4,$s4,$t4,$D4,$E4,$Y4,$Z4,$g5,$h5,$y9,$A9,$R9,$S9,$ea,$ga,$ka,$la,$ca,$ma,$sc,$uc,$Kc,$Lc,$Ub,$Mc,$qc,$Nc,$gd,$id,$md,$nd,$Vc,$od,$ed,$pd,$Ze,$df,$hf,$if,$He,$jf,$Xe,$kf,$Fd,$lf,$ze,$mf,$Zd,$nf,$yd,$of,$Ag,$Cg,$Gg,$Hg,$dg,$Ig,$og,$Jg,$Df,$Kg,$yg,$Lg,$wf,$Mg,$Lf,$Ng,$ji,$li,$pi,$qi,$fh,$ri,$Ch,$si,$mh,$ti,$hi,$ui,$Vg,$vi,$Kh,$wi,$Pi,$Ri,$Vi,$Wi,$Ni,$Xi,$Ei,$Yi,$jk,$lk,$pk,$qk,$ll,$nl,$hk,$ol,$sl,$tl,$Ok,$ul,$jl,$vl,$Uk,$wl,$Hk,$xl,$uj,$yl,$Pj,$zl,$nj,$Al,$Cj,$Bl,$em,$gm,$Em,$Gm,$Km,$Lm,$pm,$Mm,$Cm,$Nm,$Mb,$Om,$Ic,$Pm,$Gc,$Qm,$Qa,$Rm,$Ya,$Sm,$mb,$Tm,$wa,$Um,$Kb,$Vm,$yb,$Wm,$lo,$no,$ro,$so,$jo,$to,$vn,$uo,$Rn,$vo,$ln,$wo,$Hn,$xo,$op,$qp,$up,$vp,$Wo,$wp,$mp,$xp,$Po,$yp,$Jq,$Lq,$cr,$dr,$Yq,$er,$es,$gs,$Ds,$Es,$Bs,$Fs,$Br,$Gs,$Lr,$Hs,$ur,$Is,$Xr,$Js,$nq,$Ks,$Hq,$Ls,$ft,$ht,$lt,$mt,$Us,$nt,$dt,$ot,$F8,$pt,$l8,$qt,$N9,$rt,$Bt,$Dt,$r6,$Et,$It,$Jt,$zt,$Kt,$l7,$Lt,$du,$fu,$ju,$ku,$Zt,$lu,$Tt,$mu,$e9,$nu,$v8,$ou,$c9,$pu,$iv,$kv,$ov,$pv,$Ju,$qv,$Su,$rv,$wu,$sv,$Cu,$tv,$gv,$uv,$j8,$vv,$ww,$yw,$Nw,$Ow,$Lw,$Pw,$Kv,$Qw,$mw,$Rw,$dw,$Sw,$uw,$Tw,$dx,$ex,$qx,$rx,$Ez,$Gz,$Kz,$Lz,$zx,$Mz,$oy,$Nz,$W7,$Oz,$p9,$Pz,$pA,$rA,$M8,$sA,$B6,$tA,$J6,$uA,$Q6,$vA,$yB,$AB,$EB,$FB,$wB,$GB,$dB,$HB,$mB,$IB,$JA,$JB,$LC,$MC,$Z6,$NC,$Cz,$OC,$wy,$PC,$mz,$QC,$lD,$nD,$rD,$sD,$YC,$tD,$jD,$uD,$Uy,$vD,$T8,$wD,$X6,$xD,$YD,$cE,$JD,$dE,$hE,$iE,$PD,$jE,$WD,$kE,$vE,$wE,$w9,$xE,$NE,$PE,$FE,$QE,$UE,$VE,$LE,$WE,$KF,$MF,$UF,$VF,$uF,$WF,$IF,$XF,$mF,$YF,$SF,$ZF,$kF,$cG,$cH,$eH,$AH,$BH,$yH,$CH,$nH,$DH,$DG,$EH,$NG,$FH,$pG,$GH,$YG,$HH,$wG,$IH,$oI,$qI,$uI,$vI,$fI,$wI,$RH,$xI,$mI,$yI,$CI,$EI,$II,$JI,$h9,$KI,$P9,$LI,$Y7,$MI,$I9,$NI,$RI,$TI,$XI,$YI,$Xp,$ZI,$Rq,$cJ,$Vp,$dJ,$Jp,$eJ,$hJ,$jJ,$EJ};
$GJ=q#resolvers#;
$HJ=[];
$IJ=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$JJ=bless({$t,$HJ,$v,$IJ,$x,1078,$y,$z},$A);
$KJ=q#file#;
$LJ=[];
$MJ=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$NJ=bless({$t,$LJ,$v,$MJ,$x,1080,$y,$z},$A);
$OJ=q#null#;
$PJ=[];
$QJ=q#ni('ni:/io/null')->new#;
$RJ=bless({$t,$PJ,$v,$QJ,$x,1082,$y,$z},$A);
$SJ=q#sh#;
$TJ=[];
$UJ=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$VJ=bless({$t,$TJ,$v,$UJ,$x,1084,$y,$z},$A);
$WJ=q#str#;
$XJ=[];
$YJ=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$ZJ=bless({$t,$XJ,$v,$YJ,$x,1086,$y,$z},$A);
$cK={$he,$JJ,$KJ,$NJ,$OJ,$RJ,$SJ,$VJ,$WJ,$ZJ};
$dK=bless({$c,$FJ,$GJ,$cK},$F7);
*$ED=\&$CD;
*$DD=\&$AD;
$r6->apply_unsafe($j5);
$r6->apply_unsafe($k5);
$r6->apply_unsafe($l5);
$r6->apply_unsafe($m5);
$r6->apply_unsafe($n5);
$r6->apply_unsafe($o5);
$r6->apply_unsafe($p5);
$r6->apply_unsafe($q5);
$r6->apply_unsafe($r5);
$r6->apply_unsafe($s5);
$r6->apply_unsafe($t5);
$r6->apply_unsafe($u5);
$r6->apply_unsafe($v5);
$r6->apply_unsafe($w5);
$r6->apply_unsafe($x5);
$r6->apply_unsafe($y5);
$r6->apply_unsafe($z5);
$r6->apply_unsafe($A5);
$r6->apply_unsafe($B5);
$r6->apply_unsafe($s6);
$r6->apply_unsafe($C5);
$r6->apply_unsafe($D5);
$r6->apply_unsafe($E5);
$r6->apply_unsafe($F5);
$r6->apply_unsafe($G5);
$r6->apply_unsafe($H5);
$r6->apply_unsafe($I5);
$r6->apply_unsafe($J5);
$r6->apply_unsafe($K5);
$r6->apply_unsafe($L5);
$r6->apply_unsafe($M5);
$r6->apply_unsafe($N5);
$r6->apply_unsafe($O5);
$r6->apply_unsafe($X5);
$r6->apply_unsafe($P5);
$r6->apply_unsafe($Y5);
$r6->apply_unsafe($Q5);
$r6->apply_unsafe($R5);
$r6->apply_unsafe($S5);
$r6->apply_unsafe($T5);
$r6->apply_unsafe($U5);
$B6->apply_unsafe($j5);
$B6->apply_unsafe($k5);
$B6->apply_unsafe($l5);
$B6->apply_unsafe($m5);
$B6->apply_unsafe($n5);
$B6->apply_unsafe($o5);
$B6->apply_unsafe($p5);
$B6->apply_unsafe($q5);
$B6->apply_unsafe($r5);
$B6->apply_unsafe($s5);
$B6->apply_unsafe($t5);
$B6->apply_unsafe($u5);
$B6->apply_unsafe($v5);
$B6->apply_unsafe($w5);
$B6->apply_unsafe($x5);
$B6->apply_unsafe($y5);
$B6->apply_unsafe($z5);
$B6->apply_unsafe($A5);
$B6->apply_unsafe($B5);
$B6->apply_unsafe($s6);
$B6->apply_unsafe($C5);
$B6->apply_unsafe($D5);
$B6->apply_unsafe($N);
$B6->apply_unsafe($E5);
$B6->apply_unsafe($F5);
$B6->apply_unsafe($G5);
$B6->apply_unsafe($H5);
$B6->apply_unsafe($I5);
$B6->apply_unsafe($q6);
$B6->apply_unsafe($J5);
$B6->apply_unsafe($C6);
$B6->apply_unsafe($K5);
$B6->apply_unsafe($L5);
$B6->apply_unsafe($M5);
$B6->apply_unsafe($N5);
$B6->apply_unsafe($O5);
$B6->apply_unsafe($X5);
$B6->apply_unsafe($P5);
$B6->apply_unsafe($Y5);
$B6->apply_unsafe($Q5);
$B6->apply_unsafe($R5);
$B6->apply_unsafe($S5);
$B6->apply_unsafe($T5);
$B6->apply_unsafe($U5);
$J6->apply_unsafe($j5);
$J6->apply_unsafe($k5);
$J6->apply_unsafe($l5);
$J6->apply_unsafe($m5);
$J6->apply_unsafe($n5);
$J6->apply_unsafe($o5);
$J6->apply_unsafe($p5);
$J6->apply_unsafe($q5);
$J6->apply_unsafe($r5);
$J6->apply_unsafe($s5);
$J6->apply_unsafe($t5);
$J6->apply_unsafe($u5);
$J6->apply_unsafe($v5);
$J6->apply_unsafe($w5);
$J6->apply_unsafe($x5);
$J6->apply_unsafe($y5);
$J6->apply_unsafe($z5);
$J6->apply_unsafe($A5);
$J6->apply_unsafe($B5);
$J6->apply_unsafe($s6);
$J6->apply_unsafe($C5);
$J6->apply_unsafe($D5);
$J6->apply_unsafe($E5);
$J6->apply_unsafe($F5);
$J6->apply_unsafe($G5);
$J6->apply_unsafe($H5);
$J6->apply_unsafe($I5);
$J6->apply_unsafe($q6);
$J6->apply_unsafe($J5);
$J6->apply_unsafe($C6);
$J6->apply_unsafe($K5);
$J6->apply_unsafe($L5);
$J6->apply_unsafe($M5);
$J6->apply_unsafe($N5);
$J6->apply_unsafe($O5);
$J6->apply_unsafe($X5);
$J6->apply_unsafe($P5);
$J6->apply_unsafe($Y5);
$J6->apply_unsafe($Q5);
$J6->apply_unsafe($R5);
$J6->apply_unsafe($S5);
$J6->apply_unsafe($T5);
$J6->apply_unsafe($U5);
$Q6->apply_unsafe($j5);
$Q6->apply_unsafe($k5);
$Q6->apply_unsafe($l5);
$Q6->apply_unsafe($m5);
$Q6->apply_unsafe($n5);
$Q6->apply_unsafe($o5);
$Q6->apply_unsafe($p5);
$Q6->apply_unsafe($q5);
$Q6->apply_unsafe($r5);
$Q6->apply_unsafe($s5);
$Q6->apply_unsafe($t5);
$Q6->apply_unsafe($u5);
$Q6->apply_unsafe($v5);
$Q6->apply_unsafe($w5);
$Q6->apply_unsafe($x5);
$Q6->apply_unsafe($y5);
$Q6->apply_unsafe($z5);
$Q6->apply_unsafe($A5);
$Q6->apply_unsafe($B5);
$Q6->apply_unsafe($s6);
$Q6->apply_unsafe($C5);
$Q6->apply_unsafe($D5);
$Q6->apply_unsafe($E5);
$Q6->apply_unsafe($F5);
$Q6->apply_unsafe($G5);
$Q6->apply_unsafe($H5);
$Q6->apply_unsafe($I5);
$Q6->apply_unsafe($q6);
$Q6->apply_unsafe($J5);
$Q6->apply_unsafe($C6);
$Q6->apply_unsafe($K5);
$Q6->apply_unsafe($L5);
$Q6->apply_unsafe($M5);
$Q6->apply_unsafe($N5);
$Q6->apply_unsafe($O5);
$Q6->apply_unsafe($X5);
$Q6->apply_unsafe($P5);
$Q6->apply_unsafe($Y5);
$Q6->apply_unsafe($Q5);
$Q6->apply_unsafe($R5);
$Q6->apply_unsafe($S5);
$Q6->apply_unsafe($T5);
$Q6->apply_unsafe($U5);
$X6->apply_unsafe($j5);
$X6->apply_unsafe($k5);
$X6->apply_unsafe($l5);
$X6->apply_unsafe($m5);
$X6->apply_unsafe($n5);
$X6->apply_unsafe($o5);
$X6->apply_unsafe($p5);
$X6->apply_unsafe($q5);
$X6->apply_unsafe($r5);
$X6->apply_unsafe($s5);
$X6->apply_unsafe($t5);
$X6->apply_unsafe($u5);
$X6->apply_unsafe($v5);
$X6->apply_unsafe($w5);
$X6->apply_unsafe($x5);
$X6->apply_unsafe($y5);
$X6->apply_unsafe($z5);
$X6->apply_unsafe($A5);
$X6->apply_unsafe($B5);
$X6->apply_unsafe($s6);
$X6->apply_unsafe($C5);
$X6->apply_unsafe($D5);
$X6->apply_unsafe($E5);
$X6->apply_unsafe($F5);
$X6->apply_unsafe($G5);
$X6->apply_unsafe($H5);
$X6->apply_unsafe($I5);
$X6->apply_unsafe($J5);
$X6->apply_unsafe($C6);
$X6->apply_unsafe($K5);
$X6->apply_unsafe($L5);
$X6->apply_unsafe($M5);
$X6->apply_unsafe($N5);
$X6->apply_unsafe($O5);
$X6->apply_unsafe($X5);
$X6->apply_unsafe($P5);
$X6->apply_unsafe($Y5);
$X6->apply_unsafe($Q5);
$X6->apply_unsafe($R5);
$X6->apply_unsafe($S5);
$X6->apply_unsafe($T5);
$X6->apply_unsafe($U5);
$l7->apply_unsafe($j5);
$l7->apply_unsafe($k5);
$l7->apply_unsafe($l5);
$l7->apply_unsafe($m5);
$l7->apply_unsafe($n5);
$l7->apply_unsafe($o5);
$l7->apply_unsafe($p5);
$l7->apply_unsafe($q5);
$l7->apply_unsafe($r5);
$l7->apply_unsafe($s5);
$l7->apply_unsafe($t5);
$l7->apply_unsafe($u5);
$l7->apply_unsafe($v5);
$l7->apply_unsafe($w5);
$l7->apply_unsafe($x5);
$l7->apply_unsafe($y5);
$l7->apply_unsafe($z5);
$l7->apply_unsafe($A5);
$l7->apply_unsafe($B5);
$l7->apply_unsafe($C5);
$l7->apply_unsafe($D5);
$l7->apply_unsafe($E5);
$l7->apply_unsafe($F5);
$l7->apply_unsafe($G5);
$l7->apply_unsafe($H5);
$l7->apply_unsafe($I5);
$l7->apply_unsafe($J5);
$l7->apply_unsafe($K5);
$l7->apply_unsafe($L5);
$l7->apply_unsafe($M5);
$l7->apply_unsafe($N5);
$l7->apply_unsafe($O5);
$l7->apply_unsafe($X5);
$l7->apply_unsafe($P5);
$l7->apply_unsafe($Y5);
$l7->apply_unsafe($Q5);
$l7->apply_unsafe($R5);
$l7->apply_unsafe($S5);
$l7->apply_unsafe($T5);
$l7->apply_unsafe($U5);
$W7->apply_unsafe($j5);
$W7->apply_unsafe($k5);
$W7->apply_unsafe($m7);
$W7->apply_unsafe($l5);
$W7->apply_unsafe($n7);
$W7->apply_unsafe($m5);
$W7->apply_unsafe($o7);
$W7->apply_unsafe($n5);
$W7->apply_unsafe($p7);
$W7->apply_unsafe($o5);
$W7->apply_unsafe($q7);
$W7->apply_unsafe($p5);
$W7->apply_unsafe($r7);
$W7->apply_unsafe($q5);
$W7->apply_unsafe($s7);
$W7->apply_unsafe($r5);
$W7->apply_unsafe($t7);
$W7->apply_unsafe($s5);
$W7->apply_unsafe($u7);
$W7->apply_unsafe($t5);
$W7->apply_unsafe($v7);
$W7->apply_unsafe($u5);
$W7->apply_unsafe($w7);
$W7->apply_unsafe($v5);
$W7->apply_unsafe($x7);
$W7->apply_unsafe($w5);
$W7->apply_unsafe($y7);
$W7->apply_unsafe($x5);
$W7->apply_unsafe($z7);
$W7->apply_unsafe($y5);
$W7->apply_unsafe($A7);
$W7->apply_unsafe($z5);
$W7->apply_unsafe($B7);
$W7->apply_unsafe($A5);
$W7->apply_unsafe($C7);
$W7->apply_unsafe($B5);
$W7->apply_unsafe($s6);
$W7->apply_unsafe($C5);
$W7->apply_unsafe($D7);
$W7->apply_unsafe($D5);
$W7->apply_unsafe($N);
$W7->apply_unsafe($E5);
$W7->apply_unsafe($A);
$W7->apply_unsafe($F5);
$W7->apply_unsafe($E7);
$W7->apply_unsafe($G5);
$W7->apply_unsafe($F7);
$W7->apply_unsafe($H5);
$W7->apply_unsafe($G7);
$W7->apply_unsafe($I5);
$W7->apply_unsafe($q6);
$W7->apply_unsafe($J5);
$W7->apply_unsafe($C6);
$W7->apply_unsafe($K5);
$W7->apply_unsafe($H7);
$W7->apply_unsafe($L5);
$W7->apply_unsafe($I7);
$W7->apply_unsafe($M5);
$W7->apply_unsafe($D);
$W7->apply_unsafe($N5);
$W7->apply_unsafe($J7);
$W7->apply_unsafe($O5);
$W7->apply_unsafe($X5);
$W7->apply_unsafe($P5);
$W7->apply_unsafe($Y5);
$W7->apply_unsafe($Q5);
$W7->apply_unsafe($K7);
$W7->apply_unsafe($R5);
$W7->apply_unsafe($S5);
$W7->apply_unsafe($T5);
$W7->apply_unsafe($L7);
$W7->apply_unsafe($U5);
$j8->apply_unsafe($j5);
$j8->apply_unsafe($k5);
$j8->apply_unsafe($l5);
$j8->apply_unsafe($m5);
$j8->apply_unsafe($n5);
$j8->apply_unsafe($o5);
$j8->apply_unsafe($p5);
$j8->apply_unsafe($q5);
$j8->apply_unsafe($r5);
$j8->apply_unsafe($s5);
$j8->apply_unsafe($t5);
$j8->apply_unsafe($u5);
$j8->apply_unsafe($v5);
$j8->apply_unsafe($w5);
$j8->apply_unsafe($x5);
$j8->apply_unsafe($y5);
$j8->apply_unsafe($z5);
$j8->apply_unsafe($A5);
$j8->apply_unsafe($C7);
$j8->apply_unsafe($B5);
$j8->apply_unsafe($s6);
$j8->apply_unsafe($C5);
$j8->apply_unsafe($D7);
$j8->apply_unsafe($D5);
$j8->apply_unsafe($E5);
$j8->apply_unsafe($F5);
$j8->apply_unsafe($G5);
$j8->apply_unsafe($H5);
$j8->apply_unsafe($I5);
$j8->apply_unsafe($q6);
$j8->apply_unsafe($J5);
$j8->apply_unsafe($C6);
$j8->apply_unsafe($K5);
$j8->apply_unsafe($L5);
$j8->apply_unsafe($M5);
$j8->apply_unsafe($N5);
$j8->apply_unsafe($O5);
$j8->apply_unsafe($X5);
$j8->apply_unsafe($P5);
$j8->apply_unsafe($Y5);
$j8->apply_unsafe($Q5);
$j8->apply_unsafe($R5);
$j8->apply_unsafe($S5);
$j8->apply_unsafe($T5);
$j8->apply_unsafe($U5);
$v8->apply_unsafe($j5);
$v8->apply_unsafe($k5);
$v8->apply_unsafe($l5);
$v8->apply_unsafe($m5);
$v8->apply_unsafe($n5);
$v8->apply_unsafe($o5);
$v8->apply_unsafe($p5);
$v8->apply_unsafe($q5);
$v8->apply_unsafe($r5);
$v8->apply_unsafe($s5);
$v8->apply_unsafe($t5);
$v8->apply_unsafe($u5);
$v8->apply_unsafe($v5);
$v8->apply_unsafe($w5);
$v8->apply_unsafe($x5);
$v8->apply_unsafe($y5);
$v8->apply_unsafe($z5);
$v8->apply_unsafe($A5);
$v8->apply_unsafe($B5);
$v8->apply_unsafe($s6);
$v8->apply_unsafe($C5);
$v8->apply_unsafe($D5);
$v8->apply_unsafe($E5);
$v8->apply_unsafe($F5);
$v8->apply_unsafe($G5);
$v8->apply_unsafe($H5);
$v8->apply_unsafe($I5);
$v8->apply_unsafe($J5);
$v8->apply_unsafe($K5);
$v8->apply_unsafe($L5);
$v8->apply_unsafe($M5);
$v8->apply_unsafe($N5);
$v8->apply_unsafe($O5);
$v8->apply_unsafe($X5);
$v8->apply_unsafe($P5);
$v8->apply_unsafe($Y5);
$v8->apply_unsafe($Q5);
$v8->apply_unsafe($R5);
$v8->apply_unsafe($S5);
$v8->apply_unsafe($T5);
$v8->apply_unsafe($U5);
$F8->apply_unsafe($j5);
$F8->apply_unsafe($k5);
$F8->apply_unsafe($l5);
$F8->apply_unsafe($m5);
$F8->apply_unsafe($n5);
$F8->apply_unsafe($o5);
$F8->apply_unsafe($p5);
$F8->apply_unsafe($q5);
$F8->apply_unsafe($r5);
$F8->apply_unsafe($s5);
$F8->apply_unsafe($t5);
$F8->apply_unsafe($u5);
$F8->apply_unsafe($v5);
$F8->apply_unsafe($w5);
$F8->apply_unsafe($x5);
$F8->apply_unsafe($y5);
$F8->apply_unsafe($z5);
$F8->apply_unsafe($A5);
$F8->apply_unsafe($B5);
$F8->apply_unsafe($s6);
$F8->apply_unsafe($C5);
$F8->apply_unsafe($D5);
$F8->apply_unsafe($E5);
$F8->apply_unsafe($F5);
$F8->apply_unsafe($G5);
$F8->apply_unsafe($H5);
$F8->apply_unsafe($I5);
$F8->apply_unsafe($J5);
$F8->apply_unsafe($K5);
$F8->apply_unsafe($L5);
$F8->apply_unsafe($M5);
$F8->apply_unsafe($N5);
$F8->apply_unsafe($O5);
$F8->apply_unsafe($X5);
$F8->apply_unsafe($P5);
$F8->apply_unsafe($Y5);
$F8->apply_unsafe($Q5);
$F8->apply_unsafe($R5);
$F8->apply_unsafe($S5);
$F8->apply_unsafe($T5);
$F8->apply_unsafe($U5);
$M8->apply_unsafe($j5);
$M8->apply_unsafe($k5);
$M8->apply_unsafe($l5);
$M8->apply_unsafe($m5);
$M8->apply_unsafe($n5);
$M8->apply_unsafe($o5);
$M8->apply_unsafe($p5);
$M8->apply_unsafe($q5);
$M8->apply_unsafe($r5);
$M8->apply_unsafe($s5);
$M8->apply_unsafe($t5);
$M8->apply_unsafe($u5);
$M8->apply_unsafe($v5);
$M8->apply_unsafe($w5);
$M8->apply_unsafe($x5);
$M8->apply_unsafe($y5);
$M8->apply_unsafe($z5);
$M8->apply_unsafe($A5);
$M8->apply_unsafe($B5);
$M8->apply_unsafe($s6);
$M8->apply_unsafe($C5);
$M8->apply_unsafe($D5);
$M8->apply_unsafe($E5);
$M8->apply_unsafe($F5);
$M8->apply_unsafe($G5);
$M8->apply_unsafe($H5);
$M8->apply_unsafe($I5);
$M8->apply_unsafe($J5);
$M8->apply_unsafe($K5);
$M8->apply_unsafe($L5);
$M8->apply_unsafe($M5);
$M8->apply_unsafe($N5);
$M8->apply_unsafe($O5);
$M8->apply_unsafe($X5);
$M8->apply_unsafe($P5);
$M8->apply_unsafe($Y5);
$M8->apply_unsafe($Q5);
$M8->apply_unsafe($R5);
$M8->apply_unsafe($S5);
$M8->apply_unsafe($T5);
$M8->apply_unsafe($U5);
$T8->apply_unsafe($j5);
$T8->apply_unsafe($k5);
$T8->apply_unsafe($l5);
$T8->apply_unsafe($m5);
$T8->apply_unsafe($n5);
$T8->apply_unsafe($o5);
$T8->apply_unsafe($p5);
$T8->apply_unsafe($q5);
$T8->apply_unsafe($r5);
$T8->apply_unsafe($s5);
$T8->apply_unsafe($t5);
$T8->apply_unsafe($u5);
$T8->apply_unsafe($v5);
$T8->apply_unsafe($w5);
$T8->apply_unsafe($x5);
$T8->apply_unsafe($y5);
$T8->apply_unsafe($z5);
$T8->apply_unsafe($A5);
$T8->apply_unsafe($B5);
$T8->apply_unsafe($s6);
$T8->apply_unsafe($C5);
$T8->apply_unsafe($D5);
$T8->apply_unsafe($E5);
$T8->apply_unsafe($F5);
$T8->apply_unsafe($G5);
$T8->apply_unsafe($H5);
$T8->apply_unsafe($I5);
$T8->apply_unsafe($J5);
$T8->apply_unsafe($K5);
$T8->apply_unsafe($L5);
$T8->apply_unsafe($M5);
$T8->apply_unsafe($N5);
$T8->apply_unsafe($O5);
$T8->apply_unsafe($X5);
$T8->apply_unsafe($P5);
$T8->apply_unsafe($Y5);
$T8->apply_unsafe($Q5);
$T8->apply_unsafe($R5);
$T8->apply_unsafe($S5);
$T8->apply_unsafe($T5);
$T8->apply_unsafe($U5);
$c9->apply_unsafe($j5);
$c9->apply_unsafe($k5);
$c9->apply_unsafe($l5);
$c9->apply_unsafe($m5);
$c9->apply_unsafe($n5);
$c9->apply_unsafe($o5);
$c9->apply_unsafe($p5);
$c9->apply_unsafe($q5);
$c9->apply_unsafe($r5);
$c9->apply_unsafe($s5);
$c9->apply_unsafe($t5);
$c9->apply_unsafe($u5);
$c9->apply_unsafe($v5);
$c9->apply_unsafe($w5);
$c9->apply_unsafe($x5);
$c9->apply_unsafe($y5);
$c9->apply_unsafe($z5);
$c9->apply_unsafe($A5);
$c9->apply_unsafe($B5);
$c9->apply_unsafe($s6);
$c9->apply_unsafe($C5);
$c9->apply_unsafe($D5);
$c9->apply_unsafe($E5);
$c9->apply_unsafe($F5);
$c9->apply_unsafe($G5);
$c9->apply_unsafe($H5);
$c9->apply_unsafe($I5);
$c9->apply_unsafe($J5);
$c9->apply_unsafe($K5);
$c9->apply_unsafe($L5);
$c9->apply_unsafe($M5);
$c9->apply_unsafe($N5);
$c9->apply_unsafe($O5);
$c9->apply_unsafe($X5);
$c9->apply_unsafe($P5);
$c9->apply_unsafe($Y5);
$c9->apply_unsafe($Q5);
$c9->apply_unsafe($R5);
$c9->apply_unsafe($S5);
$c9->apply_unsafe($T5);
$c9->apply_unsafe($U5);
$p9->apply_unsafe($j5);
$p9->apply_unsafe($k5);
$p9->apply_unsafe($l5);
$p9->apply_unsafe($m5);
$p9->apply_unsafe($n5);
$p9->apply_unsafe($o5);
$p9->apply_unsafe($p5);
$p9->apply_unsafe($q5);
$p9->apply_unsafe($r5);
$p9->apply_unsafe($s5);
$p9->apply_unsafe($t5);
$p9->apply_unsafe($u5);
$p9->apply_unsafe($v5);
$p9->apply_unsafe($w5);
$p9->apply_unsafe($x5);
$p9->apply_unsafe($y5);
$p9->apply_unsafe($z5);
$p9->apply_unsafe($A5);
$p9->apply_unsafe($B5);
$p9->apply_unsafe($C5);
$p9->apply_unsafe($D5);
$p9->apply_unsafe($E5);
$p9->apply_unsafe($A);
$p9->apply_unsafe($F5);
$p9->apply_unsafe($G5);
$p9->apply_unsafe($H5);
$p9->apply_unsafe($I5);
$p9->apply_unsafe($q6);
$p9->apply_unsafe($J5);
$p9->apply_unsafe($C6);
$p9->apply_unsafe($K5);
$p9->apply_unsafe($L5);
$p9->apply_unsafe($M5);
$p9->apply_unsafe($N5);
$p9->apply_unsafe($O5);
$p9->apply_unsafe($X5);
$p9->apply_unsafe($P5);
$p9->apply_unsafe($Q5);
$p9->apply_unsafe($R5);
$p9->apply_unsafe($S5);
$p9->apply_unsafe($T5);
$p9->apply_unsafe($U5);
$w9->apply_unsafe($j5);
$w9->apply_unsafe($k5);
$w9->apply_unsafe($l5);
$w9->apply_unsafe($m5);
$w9->apply_unsafe($n5);
$w9->apply_unsafe($o5);
$w9->apply_unsafe($p5);
$w9->apply_unsafe($q5);
$w9->apply_unsafe($r5);
$w9->apply_unsafe($s5);
$w9->apply_unsafe($t5);
$w9->apply_unsafe($u5);
$w9->apply_unsafe($v5);
$w9->apply_unsafe($w5);
$w9->apply_unsafe($x5);
$w9->apply_unsafe($y5);
$w9->apply_unsafe($z5);
$w9->apply_unsafe($A5);
$w9->apply_unsafe($B5);
$w9->apply_unsafe($C5);
$w9->apply_unsafe($D5);
$w9->apply_unsafe($E5);
$w9->apply_unsafe($F5);
$w9->apply_unsafe($G5);
$w9->apply_unsafe($H5);
$w9->apply_unsafe($I5);
$w9->apply_unsafe($J5);
$w9->apply_unsafe($K5);
$w9->apply_unsafe($L5);
$w9->apply_unsafe($M5);
$w9->apply_unsafe($N5);
$w9->apply_unsafe($O5);
$w9->apply_unsafe($P5);
$w9->apply_unsafe($Q5);
$w9->apply_unsafe($R5);
$w9->apply_unsafe($S5);
$w9->apply_unsafe($T5);
$w9->apply_unsafe($U5);
$ca->apply_unsafe($m7);
$wa->apply_unsafe($n7);
$wa->apply_unsafe($o7);
$wa->apply_unsafe($p7);
$wa->apply_unsafe($q7);
$wa->apply_unsafe($r7);
$wa->apply_unsafe($s7);
$wa->apply_unsafe($t7);
$wa->apply_unsafe($u7);
$wa->apply_unsafe($v7);
$wa->apply_unsafe($w7);
$wa->apply_unsafe($x7);
$wa->apply_unsafe($y7);
$Qa->apply_unsafe($n7);
$Qa->apply_unsafe($o7);
$Qa->apply_unsafe($p7);
$Qa->apply_unsafe($q7);
$Qa->apply_unsafe($r7);
$Qa->apply_unsafe($s7);
$Qa->apply_unsafe($t7);
$Qa->apply_unsafe($u7);
$Qa->apply_unsafe($v7);
$Qa->apply_unsafe($w7);
$Qa->apply_unsafe($x7);
$Qa->apply_unsafe($y7);
$Ya->apply_unsafe($n7);
$Ya->apply_unsafe($o7);
$Ya->apply_unsafe($p7);
$Ya->apply_unsafe($q7);
$Ya->apply_unsafe($r7);
$Ya->apply_unsafe($s7);
$Ya->apply_unsafe($t7);
$Ya->apply_unsafe($u7);
$Ya->apply_unsafe($v7);
$Ya->apply_unsafe($w7);
$Ya->apply_unsafe($x7);
$Ya->apply_unsafe($y7);
$mb->apply_unsafe($n7);
$mb->apply_unsafe($o7);
$mb->apply_unsafe($p7);
$mb->apply_unsafe($q7);
$mb->apply_unsafe($r7);
$mb->apply_unsafe($s7);
$mb->apply_unsafe($t7);
$mb->apply_unsafe($u7);
$mb->apply_unsafe($v7);
$mb->apply_unsafe($w7);
$mb->apply_unsafe($x7);
$mb->apply_unsafe($y7);
$yb->apply_unsafe($n7);
$yb->apply_unsafe($o7);
$yb->apply_unsafe($p7);
$yb->apply_unsafe($q7);
$yb->apply_unsafe($r7);
$yb->apply_unsafe($s7);
$yb->apply_unsafe($t7);
$yb->apply_unsafe($u7);
$yb->apply_unsafe($v7);
$yb->apply_unsafe($w7);
$yb->apply_unsafe($x7);
$yb->apply_unsafe($y7);
$Kb->apply_unsafe($n7);
$Kb->apply_unsafe($o7);
$Kb->apply_unsafe($p7);
$Kb->apply_unsafe($q7);
$Kb->apply_unsafe($r7);
$Kb->apply_unsafe($s7);
$Kb->apply_unsafe($t7);
$Kb->apply_unsafe($u7);
$Kb->apply_unsafe($v7);
$Kb->apply_unsafe($w7);
$Kb->apply_unsafe($x7);
$Kb->apply_unsafe($y7);
$Ub->apply_unsafe($n7);
$qc->apply_unsafe($n7);
$Gc->apply_unsafe($m5);
$Gc->apply_unsafe($n5);
$Gc->apply_unsafe($o5);
$Gc->apply_unsafe($p5);
$Gc->apply_unsafe($q5);
$Gc->apply_unsafe($r5);
$Gc->apply_unsafe($s5);
$Gc->apply_unsafe($t5);
$Gc->apply_unsafe($u5);
$Gc->apply_unsafe($v5);
$Gc->apply_unsafe($w5);
$Gc->apply_unsafe($x5);
$Vc->apply_unsafe($o7);
$ed->apply_unsafe($o7);
$yd->apply_unsafe($p7);
$Fd->apply_unsafe($p7);
$Zd->apply_unsafe($p7);
$ze->apply_unsafe($p7);
$He->apply_unsafe($p7);
$Xe->apply_unsafe($p7);
$wf->apply_unsafe($q7);
$wf->apply_unsafe($s7);
$Df->apply_unsafe($q7);
$Lf->apply_unsafe($q7);
$dg->apply_unsafe($q7);
$dg->apply_unsafe($s7);
$og->apply_unsafe($q7);
$yg->apply_unsafe($q7);
$yg->apply_unsafe($s7);
$Vg->apply_unsafe($r7);
$fh->apply_unsafe($r7);
$mh->apply_unsafe($r7);
$Ch->apply_unsafe($r7);
$Kh->apply_unsafe($r7);
$hi->apply_unsafe($r7);
$Ei->apply_unsafe($s7);
$Ni->apply_unsafe($s7);
$nj->apply_unsafe($t7);
$uj->apply_unsafe($t7);
$Cj->apply_unsafe($t7);
$Pj->apply_unsafe($t7);
$hk->apply_unsafe($t7);
$Hk->apply_unsafe($u7);
$Ok->apply_unsafe($u7);
$Uk->apply_unsafe($u7);
$jl->apply_unsafe($u7);
$em->apply_unsafe($fm);
$pm->apply_unsafe($v7);
$Cm->apply_unsafe($v7);
$ln->apply_unsafe($x7);
$vn->apply_unsafe($x7);
$Hn->apply_unsafe($x7);
$Rn->apply_unsafe($x7);
$jo->apply_unsafe($x7);
$Po->apply_unsafe($y7);
$Wo->apply_unsafe($y7);
$mp->apply_unsafe($y7);
$Jp->apply_unsafe($z7);
$Jp->apply_unsafe($A7);
$Jp->apply_unsafe($B7);
$Jp->apply_unsafe($L7);
$Vp->apply_unsafe($z7);
$Vp->apply_unsafe($A7);
$Vp->apply_unsafe($B7);
$Vp->apply_unsafe($L7);
$nq->apply_unsafe($z7);
$nq->apply_unsafe($A7);
$nq->apply_unsafe($B7);
$Hq->apply_unsafe($z7);
$Hq->apply_unsafe($A7);
$Hq->apply_unsafe($B7);
$Yq->apply_unsafe($y5);
$Yq->apply_unsafe($z5);
$Yq->apply_unsafe($A5);
$ur->apply_unsafe($A7);
$Br->apply_unsafe($A7);
$Lr->apply_unsafe($A7);
$Xr->apply_unsafe($A7);
$Bs->apply_unsafe($z5);
$Us->apply_unsafe($B7);
$dt->apply_unsafe($B7);
$zt->apply_unsafe($s6);
$Tt->apply_unsafe($D7);
$Zt->apply_unsafe($D7);
$wu->apply_unsafe($N);
$Cu->apply_unsafe($N);
$Ju->apply_unsafe($N);
$Su->apply_unsafe($N);
$gv->apply_unsafe($N);
$Kv->apply_unsafe($A);
$dw->apply_unsafe($A);
$mw->apply_unsafe($A);
$uw->apply_unsafe($A);
$Lw->apply_unsafe($F5);
$dx->apply_unsafe($E7);
$qx->apply_unsafe($fm);
$zx->apply_unsafe($E7);
$oy->apply_unsafe($E7);
$wy->apply_unsafe($E7);
$wy->apply_unsafe($G7);
$Uy->apply_unsafe($E7);
$Uy->apply_unsafe($G7);
$mz->apply_unsafe($E7);
$mz->apply_unsafe($G7);
$Cz->apply_unsafe($E7);
$pA->apply_unsafe($qA);
$JA->apply_unsafe($F7);
$dB->apply_unsafe($F7);
$mB->apply_unsafe($F7);
$wB->apply_unsafe($F7);
$LC->apply_unsafe($qA);
$YC->apply_unsafe($G7);
$jD->apply_unsafe($G7);
$JD->apply_unsafe($q6);
$PD->apply_unsafe($q6);
$WD->apply_unsafe($q6);
$vE->apply_unsafe($fm);
$FE->apply_unsafe($C6);
$LE->apply_unsafe($C6);
$kF->apply_unsafe($H7);
$kF->apply_unsafe($I7);
$uF->apply_unsafe($H7);
$IF->apply_unsafe($H7);
$pG->apply_unsafe($D);
$wG->apply_unsafe($D);
$DG->apply_unsafe($D);
$NG->apply_unsafe($D);
$YG->apply_unsafe($D);
$nH->apply_unsafe($N5);
$yH->apply_unsafe($N5);
$RH->apply_unsafe($J7);
$fI->apply_unsafe($J7);
$mI->apply_unsafe($J7);
$ni::self=$dK;
&$_($B)for@$C;
&$_($O)for@$P;
&$_($V)for@$P;
&$_($Z)for@$P;
&$_($h1)for@$P;
&$_($p1)for@$C;
&$_($u1)for@$P;
&$_($C1)for@$C;
&$_($H1)for@$P;
&$_($P1)for@$C;
&$_($U1)for@$P;
&$_($e2)for@$C;
&$_($j2)for@$P;
&$_($u2)for@$C;
&$_($A2)for@$C;
&$_($F2)for@$P;
&$_($L2)for@$P;
&$_($U2)for@$P;
&$_($c3)for@$P;
&$_($i3)for@$C;
&$_($o3)for@$C;
&$_($u3)for@$C;
&$_($z3)for@$P;
&$_($G3)for@$P;
&$_($P3)for@$C;
&$_($V3)for@$C;
&$_($c4)for@$P;
&$_($k4)for@$P;
&$_($s4)for@$P;
&$_($y4)for@$C;
&$_($D4)for@$P;
&$_($M4)for@$C;
&$_($T4)for@$C;
&$_($Y4)for@$P;
&$_($g5)for@$P;
&$_($k6)for@$C;
&$_($n6)for@$C;
&$_($r6)for@$t6;
&$_($w6)for@$C;
&$_($y6)for@$C;
&$_($B6)for@$t6;
&$_($G6)for@$C;
&$_($J6)for@$t6;
&$_($N6)for@$C;
&$_($Q6)for@$t6;
&$_($U6)for@$C;
&$_($X6)for@$t6;
&$_($Z6)for@$c7;
&$_($f7)for@$C;
&$_($i7)for@$C;
&$_($l7)for@$t6;
&$_($R7)for@$C;
&$_($T7)for@$C;
&$_($W7)for@$t6;
&$_($Y7)for@$Z7;
&$_($g8)for@$C;
&$_($j8)for@$t6;
&$_($l8)for@$m8;
&$_($s8)for@$C;
&$_($v8)for@$t6;
&$_($z8)for@$C;
&$_($C8)for@$C;
&$_($F8)for@$t6;
&$_($J8)for@$C;
&$_($M8)for@$t6;
&$_($Q8)for@$C;
&$_($T8)for@$t6;
&$_($X8)for@$C;
&$_($c9)for@$t6;
&$_($e9)for@$f9;
&$_($h9)for@$i9;
&$_($m9)for@$C;
&$_($p9)for@$t6;
&$_($t9)for@$C;
&$_($w9)for@$t6;
&$_($y9)for@$z9;
&$_($I9)for@$J9;
&$_($N9)for@$J9;
&$_($P9)for@$J9;
&$_($R9)for@$J9;
&$_($X9)for@$C;
&$_($ca)for@$t6;
&$_($ea)for@$fa;
&$_($ka)for@$J9;
&$_($ta)for@$C;
&$_($wa)for@$t6;
&$_($Ba)for@$C;
&$_($Fa)for@$C;
&$_($Ja)for@$C;
&$_($Na)for@$C;
&$_($Qa)for@$t6;
&$_($Va)for@$C;
&$_($Ya)for@$t6;
&$_($fb)for@$C;
&$_($jb)for@$C;
&$_($mb)for@$t6;
&$_($rb)for@$C;
&$_($vb)for@$C;
&$_($yb)for@$t6;
&$_($Db)for@$C;
&$_($Hb)for@$C;
&$_($Kb)for@$t6;
&$_($Mb)for@$Nb;
&$_($Rb)for@$C;
&$_($Ub)for@$t6;
&$_($Zb)for@$C;
&$_($fc)for@$C;
&$_($jc)for@$C;
&$_($nc)for@$C;
&$_($qc)for@$t6;
&$_($sc)for@$tc;
&$_($Dc)for@$C;
&$_($Gc)for@$t6;
&$_($Ic)for@$J9;
&$_($Kc)for@$J9;
&$_($Sc)for@$C;
&$_($Vc)for@$t6;
&$_($Zc)for@$C;
&$_($ed)for@$t6;
&$_($gd)for@$hd;
&$_($md)for@$J9;
&$_($vd)for@$C;
&$_($yd)for@$t6;
&$_($Cd)for@$C;
&$_($Fd)for@$t6;
&$_($Kd)for@$C;
&$_($Od)for@$C;
&$_($Sd)for@$C;
&$_($Wd)for@$C;
&$_($Zd)for@$t6;
&$_($ge)for@$C;
&$_($ke)for@$C;
&$_($oe)for@$C;
&$_($se)for@$C;
&$_($we)for@$C;
&$_($ze)for@$t6;
&$_($Ee)for@$C;
&$_($He)for@$t6;
&$_($Me)for@$C;
&$_($Qe)for@$C;
&$_($Ue)for@$C;
&$_($Xe)for@$t6;
&$_($Ze)for@$cf;
&$_($hf)for@$J9;
&$_($tf)for@$C;
&$_($wf)for@$t6;
&$_($Af)for@$C;
&$_($Df)for@$t6;
&$_($If)for@$C;
&$_($Lf)for@$t6;
&$_($Qf)for@$C;
&$_($Uf)for@$C;
&$_($Yf)for@$C;
&$_($dg)for@$t6;
&$_($hg)for@$C;
&$_($lg)for@$C;
&$_($og)for@$t6;
&$_($sg)for@$C;
&$_($vg)for@$C;
&$_($yg)for@$t6;
&$_($Ag)for@$Bg;
&$_($Gg)for@$J9;
&$_($Sg)for@$C;
&$_($Vg)for@$t6;
&$_($ch)for@$C;
&$_($fh)for@$t6;
&$_($jh)for@$C;
&$_($mh)for@$t6;
&$_($rh)for@$C;
&$_($vh)for@$C;
&$_($zh)for@$C;
&$_($Ch)for@$t6;
&$_($Hh)for@$C;
&$_($Kh)for@$t6;
&$_($Oh)for@$C;
&$_($Sh)for@$C;
&$_($Vh)for@$C;
&$_($Zh)for@$C;
&$_($ei)for@$C;
&$_($hi)for@$t6;
&$_($ji)for@$ki;
&$_($pi)for@$J9;
&$_($Bi)for@$C;
&$_($Ei)for@$t6;
&$_($Hi)for@$C;
&$_($Ki)for@$C;
&$_($Ni)for@$t6;
&$_($Pi)for@$Qi;
&$_($Vi)for@$J9;
&$_($gj)for@$C;
&$_($kj)for@$C;
&$_($nj)for@$t6;
&$_($rj)for@$C;
&$_($uj)for@$t6;
&$_($zj)for@$C;
&$_($Cj)for@$t6;
&$_($Gj)for@$C;
&$_($Jj)for@$C;
&$_($Mj)for@$C;
&$_($Pj)for@$t6;
&$_($Uj)for@$C;
&$_($Yj)for@$C;
&$_($ek)for@$C;
&$_($hk)for@$t6;
&$_($jk)for@$kk;
&$_($pk)for@$J9;
&$_($wk)for@$C;
&$_($Ak)for@$C;
&$_($Ek)for@$C;
&$_($Hk)for@$t6;
&$_($Lk)for@$C;
&$_($Ok)for@$t6;
&$_($Rk)for@$C;
&$_($Uk)for@$t6;
&$_($Yk)for@$C;
&$_($dl)for@$C;
&$_($gl)for@$C;
&$_($jl)for@$t6;
&$_($ll)for@$ml;
&$_($sl)for@$J9;
&$_($Gl)for@$C;
&$_($Jl)for@$C;
&$_($Nl)for@$C;
&$_($Rl)for@$C;
&$_($Vl)for@$C;
&$_($Zl)for@$C;
&$_($em)for@$t6;
&$_($mm)for@$C;
&$_($pm)for@$t6;
&$_($tm)for@$C;
&$_($wm)for@$C;
&$_($zm)for@$C;
&$_($Cm)for@$t6;
&$_($Em)for@$Fm;
&$_($Km)for@$J9;
&$_($en)for@$C;
&$_($in)for@$C;
&$_($ln)for@$t6;
&$_($pn)for@$C;
&$_($sn)for@$C;
&$_($vn)for@$t6;
&$_($An)for@$C;
&$_($En)for@$C;
&$_($Hn)for@$t6;
&$_($Ln)for@$C;
&$_($On)for@$C;
&$_($Rn)for@$t6;
&$_($Vn)for@$C;
&$_($Yn)for@$C;
&$_($do)for@$C;
&$_($go)for@$C;
&$_($jo)for@$t6;
&$_($lo)for@$mo;
&$_($ro)for@$J9;
&$_($Eo)for@$C;
&$_($Io)for@$C;
&$_($Mo)for@$C;
&$_($Po)for@$t6;
&$_($To)for@$C;
&$_($Wo)for@$t6;
&$_($cp)for@$C;
&$_($gp)for@$C;
&$_($jp)for@$C;
&$_($mp)for@$t6;
&$_($op)for@$pp;
&$_($up)for@$J9;
&$_($Gp)for@$C;
&$_($Jp)for@$t6;
&$_($Op)for@$C;
&$_($Sp)for@$C;
&$_($Vp)for@$t6;
&$_($Xp)for@$Yp;
&$_($eq)for@$C;
&$_($hq)for@$C;
&$_($kq)for@$C;
&$_($nq)for@$t6;
&$_($sq)for@$C;
&$_($wq)for@$C;
&$_($Aq)for@$C;
&$_($Eq)for@$C;
&$_($Hq)for@$t6;
&$_($Jq)for@$Kq;
&$_($Rq)for@$J9;
&$_($Vq)for@$C;
&$_($Yq)for@$t6;
&$_($cr)for@$J9;
&$_($lr)for@$C;
&$_($nr)for@$C;
&$_($rr)for@$C;
&$_($ur)for@$t6;
&$_($yr)for@$C;
&$_($Br)for@$t6;
&$_($Fr)for@$C;
&$_($Ir)for@$C;
&$_($Lr)for@$t6;
&$_($Qr)for@$C;
&$_($Ur)for@$C;
&$_($Xr)for@$t6;
&$_($es)for@$fs;
&$_($ms)for@$C;
&$_($qs)for@$C;
&$_($us)for@$C;
&$_($ys)for@$C;
&$_($Bs)for@$t6;
&$_($Ds)for@$J9;
&$_($Rs)for@$C;
&$_($Us)for@$t6;
&$_($Ys)for@$C;
&$_($dt)for@$t6;
&$_($ft)for@$gt;
&$_($lt)for@$J9;
&$_($wt)for@$C;
&$_($zt)for@$t6;
&$_($Bt)for@$Ct;
&$_($It)for@$J9;
&$_($Qt)for@$C;
&$_($Tt)for@$t6;
&$_($Wt)for@$C;
&$_($Zt)for@$t6;
&$_($du)for@$eu;
&$_($ju)for@$J9;
&$_($tu)for@$C;
&$_($wu)for@$t6;
&$_($zu)for@$C;
&$_($Cu)for@$t6;
&$_($Gu)for@$C;
&$_($Ju)for@$t6;
&$_($Mu)for@$C;
&$_($Pu)for@$C;
&$_($Su)for@$t6;
&$_($Vu)for@$C;
&$_($Yu)for@$C;
&$_($dv)for@$C;
&$_($gv)for@$t6;
&$_($iv)for@$jv;
&$_($ov)for@$J9;
&$_($Av)for@$C;
&$_($Cv)for@$C;
&$_($Fv)for@$C;
&$_($Hv)for@$C;
&$_($Kv)for@$t6;
&$_($Ov)for@$C;
&$_($Rv)for@$C;
&$_($Uv)for@$C;
&$_($Yv)for@$C;
&$_($dw)for@$t6;
&$_($hw)for@$C;
&$_($jw)for@$C;
&$_($mw)for@$t6;
&$_($rw)for@$C;
&$_($uw)for@$t6;
&$_($ww)for@$xw;
&$_($Ew)for@$C;
&$_($Iw)for@$C;
&$_($Lw)for@$t6;
&$_($Nw)for@$J9;
&$_($Yw)for@$C;
&$_($dx)for@$t6;
&$_($jx)for@$C;
&$_($nx)for@$C;
&$_($qx)for@$t6;
&$_($wx)for@$C;
&$_($zx)for@$t6;
&$_($Ex)for@$C;
&$_($Ix)for@$C;
&$_($Mx)for@$C;
&$_($Qx)for@$C;
&$_($Ux)for@$C;
&$_($Xx)for@$C;
&$_($dy)for@$C;
&$_($hy)for@$C;
&$_($ly)for@$C;
&$_($oy)for@$t6;
&$_($ty)for@$C;
&$_($wy)for@$t6;
&$_($By)for@$C;
&$_($Fy)for@$C;
&$_($Jy)for@$C;
&$_($Ny)for@$C;
&$_($Ry)for@$C;
&$_($Uy)for@$t6;
&$_($Zy)for@$C;
&$_($fz)for@$C;
&$_($jz)for@$C;
&$_($mz)for@$t6;
&$_($rz)for@$C;
&$_($vz)for@$C;
&$_($zz)for@$C;
&$_($Cz)for@$t6;
&$_($Ez)for@$Fz;
&$_($Kz)for@$J9;
&$_($Uz)for@$C;
&$_($Yz)for@$C;
&$_($eA)for@$C;
&$_($iA)for@$C;
&$_($mA)for@$C;
&$_($pA)for@$t6;
&$_($AA)for@$C;
&$_($DA)for@$C;
&$_($GA)for@$C;
&$_($JA)for@$t6;
&$_($NA)for@$C;
&$_($QA)for@$C;
&$_($TA)for@$C;
&$_($WA)for@$C;
&$_($YA)for@$C;
&$_($dB)for@$t6;
&$_($gB)for@$C;
&$_($jB)for@$C;
&$_($mB)for@$t6;
&$_($qB)for@$C;
&$_($tB)for@$C;
&$_($wB)for@$t6;
&$_($yB)for@$zB;
&$_($EB)for@$J9;
&$_($OB)for@$C;
&$_($SB)for@$C;
&$_($WB)for@$C;
&$_($cC)for@$C;
&$_($gC)for@$C;
&$_($kC)for@$C;
&$_($oC)for@$C;
&$_($sC)for@$C;
&$_($wC)for@$C;
&$_($AC)for@$C;
&$_($EC)for@$C;
&$_($IC)for@$C;
&$_($LC)for@$t6;
&$_($VC)for@$C;
&$_($YC)for@$t6;
&$_($dD)for@$C;
&$_($gD)for@$C;
&$_($jD)for@$t6;
&$_($lD)for@$mD;
&$_($rD)for@$J9;
&$_($AD)for@$C;
&$_($CD)for@$C;
&$_($JD)for@$t6;
&$_($MD)for@$C;
&$_($PD)for@$t6;
&$_($TD)for@$C;
&$_($WD)for@$t6;
&$_($YD)for@$ZD;
&$_($hE)for@$J9;
&$_($oE)for@$C;
&$_($sE)for@$C;
&$_($vE)for@$t6;
&$_($CE)for@$C;
&$_($FE)for@$t6;
&$_($IE)for@$C;
&$_($LE)for@$t6;
&$_($NE)for@$OE;
&$_($UE)for@$J9;
&$_($hF)for@$C;
&$_($kF)for@$t6;
&$_($mF)for@$nF;
&$_($rF)for@$C;
&$_($uF)for@$t6;
&$_($yF)for@$C;
&$_($CF)for@$C;
&$_($FF)for@$C;
&$_($IF)for@$t6;
&$_($KF)for@$LF;
&$_($SF)for@$J9;
&$_($UF)for@$J9;
&$_($jG)for@$C;
&$_($mG)for@$C;
&$_($pG)for@$t6;
&$_($tG)for@$C;
&$_($wG)for@$t6;
&$_($AG)for@$C;
&$_($DG)for@$t6;
&$_($HG)for@$C;
&$_($KG)for@$C;
&$_($NG)for@$t6;
&$_($SG)for@$C;
&$_($VG)for@$C;
&$_($YG)for@$t6;
&$_($cH)for@$dH;
&$_($kH)for@$C;
&$_($nH)for@$t6;
&$_($rH)for@$C;
&$_($vH)for@$C;
&$_($yH)for@$t6;
&$_($AH)for@$J9;
&$_($OH)for@$C;
&$_($RH)for@$t6;
&$_($WH)for@$C;
&$_($cI)for@$C;
&$_($fI)for@$t6;
&$_($jI)for@$C;
&$_($mI)for@$t6;
&$_($oI)for@$pI;
&$_($uI)for@$J9;
&$_($CI)for@$DI;
&$_($II)for@$J9;
&$_($RI)for@$SI;
&$_($XI)for@$J9;
&$_($hJ)for@$iJ;
&$_($EJ)for@$iJ;
&$_($JJ)for@$C;
&$_($NJ)for@$C;
&$_($RJ)for@$C;
&$_($VJ)for@$C;
&$_($ZJ)for@$C;
ni->run(@ARGV);
__DATA__
