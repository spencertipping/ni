#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Errno;
use Fcntl;
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/buffer#;
$V=q#
    my $buf = ni("ni:/io/buffer")->new(8192);
    $buf->write("foo");
    $buf->read($_, 256);        \# reads "foo"#;
$W=[$f,$V];
$X=q#A bounded, memory-backed FIFO data queue. In IO terms, this object
      behaves like a nonblocking socket and sets errno accordingly.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $buf = ni('ni:/io/buffer')->new(128);
now [$buf->read_capacity, $buf->write_capacity] == [0, 128];
now $buf->write("foobarbif") == 9;
now [$buf->read_capacity, $buf->write_capacity] == [9, 119];
now [$buf->read($_, 5), $_] == [5, "fooba"];

now $buf->write(" " x 125) == 124;
now $buf->read($_, 120) == 120;
now [$buf->read($_, 100), $_, $buf->read_capacity] == [8, " " x 8, 0];
now [$buf->read($_, 100), 0 + $!] == [undef, Errno::EWOULDBLOCK];#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/buffer#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/cat#;
$j1=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into_sync($destination_io);
  #;
$k1=[$f,$j1];
$l1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$m1=q#/io/cat objects don't yet combine IOs even when it's possible, but they
      probably should.#;
$n1=[$i,$l1,$m1];
$o1=[];
$p1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$q1=bless({$o,$o1,$q,$p1,$s,$t},$u);
$r1=[$n,$q1];
$s1=[];
$t1=q#\# this doesn't work yet
my $cat = ni('str:foo') + ni('str:bar');
now [$cat->read($_, 16), $_] == [8, "foo\\nbar\\n"];#;
$u1=bless({$o,$s1,$q,$t1,$s,$t},$u);
$v1=[$n,$u1];
$w1=[$k1,$n1,$r1,$v1];
$x1=q#/io/cat#;
$y1=bless({$e,$w1,$D,$x1},$F);
$z1=q#ni.doc:/io/exec#;
$A1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$B1=[$f,$A1];
$C1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$D1=[$i,$C1];
$E1=[];
$F1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$G1=bless({$o,$E1,$q,$F1,$s,$t},$u);
$H1=[$n,$G1];
$I1=[$B1,$D1,$H1];
$J1=q#/io/exec#;
$K1=bless({$e,$I1,$D,$J1},$F);
$L1=q#ni.doc:/io/mio#;
$M1=q#
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);#;
$N1=[$f,$M1];
$O1=q#Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.#;
$P1=q#
      #;
$Q1=[$i,$O1,$P1];
$R1=[$N1,$Q1];
$S1=q#/io/mio#;
$T1=bless({$e,$R1,$D,$S1},$F);
$U1=q#ni.doc:/io/pid#;
$V1=[];
$W1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$X1=bless({$o,$V1,$q,$W1,$s,$t},$u);
$Y1=[$n,$X1];
$Z1=[];
$c2=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$d2=bless({$o,$Z1,$q,$c2,$s,$t},$u);
$e2=[$n,$d2];
$f2=[];
$g2=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now [$grep->read_all, $seq->await, $grep->await]
 == ["1\\n3\\n5\\n7\\n9\\n", 0, 0];#;
$h2=bless({$o,$f2,$q,$g2,$s,$t},$u);
$i2=[$n,$h2];
$j2=[$Y1,$e2,$i2];
$k2=q#/io/pid#;
$l2=bless({$e,$j2,$D,$k2},$F);
$m2=q#ni.doc:/lib#;
$n2=q#Bootstrapping code for the core abstractions in ni, and almost everything
      about its introspection. This includes definitions for documentation,
      unit tests, classes, support for basic image generation, etc -- and when
      possible, it's written with some awareness of downstream use cases (for
      instance, image serialization and RMI share logic).#;
$o2=q#/lib is the place where things don't quite work yet, so the code here is
      written differently from other modules.#;
$p2=[$i,$n2,$o2];
$q2=[$p2];
$r2=q#/lib#;
$s2=bless({$e,$q2,$D,$r2},$F);
$t2=q#ni.doc:/lib/doc#;
$u2=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$v2=[$f,$u2];
$w2=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$x2=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$y2=[];
$z2=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$A2=bless({$o,$y2,$q,$z2,$s,$t},$u);
$B2=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$C2=[];
$D2=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$E2=bless({$o,$C2,$q,$D2,$s,$t},$u);
$F2=[$i,$w2,$x2,$n,$A2,$B2,$n,$E2];
$G2=[$v2,$F2];
$H2=q#/lib/doc#;
$I2=bless({$e,$G2,$D,$H2},$F);
$J2=q#ni.doc:/semantic#;
$K2=q#Opportunities to assign real-world semantics to objects. This is a
      collection of behaviors that don't necessarily imply a Perl-level
      protocol, but which may end up meaning something at some point.#;
$L2=[$i,$K2];
$M2=[$L2];
$N2=q#/semantic#;
$O2=bless({$e,$M2,$D,$N2},$F);
$P2=q#ni:/class#;
$Q2=q#applied_to#;
$R2=q#class#;
$S2=q#class.c#;
$T2=q#fabric/rmi.c#;
$U2=q#io/buffer.c#;
$V2=q#io/cat.c#;
$W2=q#io/exec.c#;
$X2=q#io/fd.c#;
$Y2=q#io/file.c#;
$Z2=q#io/mio.c#;
$c3=q#io/mio_channel.c#;
$d3=q#io/null.c#;
$e3=q#io/object.c#;
$f3=q#io/pid.c#;
$g3=q#io/str.c#;
$h3=q#io/transfer.c#;
$i3=q#io/transfer_async.c#;
$j3=q#io/transfer_sync.c#;
$k3=q#lib/behavior.c#;
$l3=q#lib/branch.c#;
$m3=q#lib/dataslice.c#;
$n3=q#lib/doc.c#;
$o3=q#lib/fn.c#;
$p3=q#lib/image.c#;
$q3=q#lib/ni.c#;
$r3=q#lib/quote_simple.c#;
$s3=q#lib/slice.c#;
$t3=q#lib/tag.c#;
$u3=q#lib/test_value.c#;
$v3=q#metaclass.c#;
$w3=q#module.c#;
$x3=q#object.c#;
$y3=q#semantic/dimension#;
$z3=q#semantic/dimension.c#;
$A3=q#semantic/task.c#;
$B3={$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$v3,1,$w3,1,$x3,1,$y3,1,$z3,1,$A3,1};
$C3=q#slices#;
$D3=q#metaclass#;
$E3=q#module#;
$F3={$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$D3,1,$v3,1,$E3,1,$w3,1,$x3,1,$y3,1,$z3,1,$A3,1};
$G3=q#/module#;
$H3=q#/lib/perlbranch.b#;
$I3={};
$J3=q#ctor#;
$K3=undef;
$L3=q#dtor#;
$M3=q#methods#;
$N3=q#add#;
$O3=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$P3=bless({$q,$O3,$s,$t},$u);
$Q3=q#apply#;
$R3=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$S3=bless({$q,$R3,$s,$t},$u);
$T3={$N3,$P3,$Q3,$S3};
$U3=q#/lib/branch.b#;
$V3=q#lib/slice#;
$W3=bless({$Q2,$I3,$J3,$K3,$L3,$K3,$M3,$T3,$D,$U3},$V3);
$X3=q#lib/branch#;
$Y3=q#lib/slice::ctors#;
$Z3={};
$c4=q#my $s = shift; ni->def($s->name, $s)#;
$d4=bless({$q,$c4,$s,$t},$u);
$e4=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$f4=bless({$q,$e4,$s,$t},$u);
$g4={$D,$f4};
$h4=q#/lib/named.b#;
$i4=bless({$Q2,$Z3,$J3,$d4,$L3,$K3,$M3,$g4,$D,$h4},$V3);
$j4=q#lib/tag#;
$k4={};
$l4=q#namespace#;
$m4=q#'ni'#;
$n4=bless({$q,$m4,$s,$t},$u);
$o4={$l4,$n4};
$p4=q#/lib/named_in_ni.b#;
$q4=bless({$Q2,$k4,$J3,$K3,$L3,$K3,$M3,$o4,$D,$p4},$V3);
$r4={};
$s4=q#package#;
$t4=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$u4=bless({$q,$t4,$s,$t},$u);
$v4={$s4,$u4};
$w4=q#/lib/namespaced.b#;
$x4=bless({$Q2,$r4,$J3,$K3,$L3,$K3,$M3,$v4,$D,$w4},$V3);
$y4={};
$z4=q#resolve#;
$A4=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$B4=bless({$q,$A4,$s,$t},$u);
$C4={$z4,$B4};
$D4=q#/lib/resolver.b#;
$E4=bless({$Q2,$y4,$J3,$K3,$L3,$K3,$M3,$C4,$D,$D4},$V3);
$F4=[$W3,$i4,$q4,$x4,$E4];
$G4=bless({$D,$H3,$C3,$F4},$j4);
$H4=q#lib/tag::ctors#;
$I4={};
$J4=q#my $s = shift; $s->apply($s->package)#;
$K4=bless({$q,$J4,$s,$t},$u);
$L4=q#instantiate#;
$M4=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$N4=bless({$q,$M4,$s,$t},$u);
$O4={$L4,$N4};
$P4=q#/lib/class_init.b#;
$Q4=bless({$Q2,$I4,$J3,$K4,$L3,$K3,$M3,$O4,$D,$P4},$V3);
$R4=q#fabric/rmi#;
$S4=q#io/buffer#;
$T4=q#io/cat#;
$U4=q#io/exec#;
$V4=q#io/fd#;
$W4=q#io/file#;
$X4=q#io/mio#;
$Y4=q#io/mio_channel#;
$Z4=q#io/null#;
$c5=q#io/object#;
$d5=q#io/pid#;
$e5=q#io/str#;
$f5=q#io/transfer#;
$g5=q#io/transfer_async#;
$h5=q#io/transfer_sync#;
$i5=q#lib/behavior#;
$j5=q#lib/dataslice#;
$k5=q#lib/image#;
$l5=q#lib/ni#;
$m5=q#lib/quote_simple#;
$n5=q#lib/test_value#;
$o5=q#object#;
$p5=q#semantic/task#;
$q5={$R2,1,$S2,1,$R4,1,$T2,1,$S4,1,$U2,1,$T4,1,$V2,1,$U4,1,$W2,1,$V4,1,$X2,1,$W4,1,$Y2,1,$X4,1,$Z2,1,$Y4,1,$c3,1,$Z4,1,$d3,1,$c5,1,$e3,1,$d5,1,$f3,1,$e5,1,$g3,1,$f5,1,$h3,1,$g5,1,$i3,1,$h5,1,$j3,1,$i5,1,$k3,1,$X3,1,$l3,1,$j5,1,$m3,1,$F,1,$n3,1,$u,1,$o3,1,$k5,1,$p3,1,$l5,1,$q3,1,$m5,1,$r3,1,$V3,1,$s3,1,$j4,1,$t3,1,$n5,1,$u3,1,$D3,1,$v3,1,$E3,1,$w3,1,$o5,1,$x3,1,$y3,1,$z3,1,$p5,1,$A3,1};
$r5=q#/object#;
$s5={};
$t5=q#ni 'ni:/' . ref shift#;
$u5=bless({$q,$t5,$s,$t},$u);
$v5={$R2,$u5};
$w5=q#/lib/instance.b#;
$x5=bless({$Q2,$s5,$J3,$K3,$L3,$K3,$M3,$v5,$D,$w5},$V3);
$y5=[$x5];
$z5=bless({$Q2,$q5,$D,$r5,$C3,$y5},$x3);
$A5=q#object.c::ctors#;
$B5={$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$i5,1,$k3,1,$X3,1,$l3,1,$j5,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$V3,1,$s3,1,$j4,1,$t3,1,$u3,1,$D3,1,$v3,1,$E3,1,$w3,1,$x3,1,$y3,1,$z3,1,$A3,1};
$C5=q#/lib/behavior#;
$D5={};
$E5=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$F5=bless({$q,$E5,$s,$t},$u);
$G5={$e,$F5};
$H5=q#/lib/documentable.b#;
$I5=bless({$Q2,$D5,$J3,$K3,$L3,$K3,$M3,$G5,$D,$H5},$V3);
$J5=[$z5,$I5];
$K5=bless({$Q2,$B5,$D,$C5,$C3,$J5},$k3);
$L5=q#lib/behavior.c::ctors#;
$M5={$R2,1,$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$X3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$D3,1,$v3,1,$E3,1,$w3,1,$x3,1,$y3,1,$z3,1,$A3,1};
$N5=q#/lib/definition.b#;
$O5={};
$P5=q#def#;
$Q5=q#my $self = shift;
my $name = shift;
$self->add(ni->exists("ni:$name")
  ? ni"ni:$name"
  : ni('ni:/lib/slice')->new($name, @_));
$self;#;
$R5=bless({$q,$Q5,$s,$t},$u);
$S5={$P5,$R5};
$T5=q#/lib/definition_def.b#;
$U5=bless({$Q2,$O5,$J3,$K3,$L3,$K3,$M3,$S5,$D,$T5},$V3);
$V5={};
$W5=q#ro#;
$X5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$Y5=bless({$q,$X5,$s,$t},$u);
$Z5=q#rw#;
$c6=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$d6=bless({$q,$c6,$s,$t},$u);
$e6={$W5,$Y5,$Z5,$d6};
$f6=q#/lib/accessor.b#;
$g6=bless({$Q2,$V5,$J3,$K3,$L3,$K3,$M3,$e6,$D,$f6},$V3);
$h6={};
$i6=q#(""#;
$j6=q#shift->name#;
$k6=bless({$q,$j6,$s,$t},$u);
$l6={$i6,$k6};
$m6=q#/lib/name_as_string.b#;
$n6=bless({$Q2,$h6,$J3,$K3,$L3,$K3,$M3,$l6,$D,$m6},$V3);
$o6={};
$p6=q#(eq#;
$q6=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$r6=bless({$q,$q6,$s,$t},$u);
$s6={$p6,$r6};
$t6=q#/lib/ref_eq.b#;
$u6=bless({$Q2,$o6,$J3,$K3,$L3,$K3,$M3,$s6,$D,$t6},$V3);
$v6={};
$w6=q#defdata#;
$x6=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$y6=bless({$q,$x6,$s,$t},$u);
$z6={$w6,$y6};
$A6=q#/lib/definition_defdata.b#;
$B6=bless({$Q2,$v6,$J3,$K3,$L3,$K3,$M3,$z6,$D,$A6},$V3);
$C6=[$U5,$g6,$n6,$u6,$B6];
$D6=bless({$Q2,$M5,$D,$N5,$C3,$C6},$X3);
$E6=q#lib/branch::ctors#;
$F6=[$G4,$Q4,$z5,$K5,$D6];
$G6=bless({$Q2,$F3,$D,$G3,$C3,$F6},$w3);
$H6=q#module.c::ctors#;
$I6={};
$J6=q#DESTROY#;
$K6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$L6=bless({$q,$K6,$s,$t},$u);
$M6=q#new#;
$N6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$O6=bless({$q,$N6,$s,$t},$u);
$P6={$J6,$L6,$M6,$O6};
$Q6=q#/lib/instantiable.b#;
$R6=bless({$Q2,$I6,$M3,$P6,$D,$Q6},$V3);
$S6={};
$T6=q#child#;
$U6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$V6=bless({$q,$U6,$s,$t},$u);
$W6={$T6,$V6};
$X6=q#/lib/subclass.b#;
$Y6=bless({$Q2,$S6,$J3,$K3,$L3,$K3,$M3,$W6,$D,$X6},$V3);
$Z6=[$G6,$R6,$Q4,$G6,$Y6];
$c7=bless({$Q2,$B3,$D,$E,$C3,$Z6},$S2);
$d7=q#class.c::ctors#;
$e7=q#ni:/class.c#;
$f7={$S2,1,$z3,1};
$g7=q#/class.c#;
$h7={$S2,1,$w3,1,$z3,1};
$i7=q#/module.c#;
$j7={$S2,1,$T2,1,$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1,$h3,1,$i3,1,$j3,1,$k3,1,$l3,1,$m3,1,$n3,1,$o3,1,$p3,1,$q3,1,$r3,1,$s3,1,$t3,1,$u3,1,$w3,1,$x3,1,$z3,1,$A3,1};
$k7=q#/object.c#;
$l7=[$c7];
$m7=bless({$Q2,$j7,$D,$k7,$C3,$l7},$D3);
$n7=q#metaclass::ctors#;
$o7={$S2,1,$k3,1,$l3,1,$m3,1,$s3,1,$t3,1,$w3,1,$z3,1};
$p7=q#/lib/behavior.c#;
$q7=[$m7];
$r7=bless({$Q2,$o7,$D,$p7,$C3,$q7},$D3);
$s7=[$m7,$R6,$r7];
$t7=bless({$Q2,$h7,$D,$i7,$C3,$s7},$D3);
$u7=[$t7];
$v7=bless({$Q2,$f7,$D,$g7,$C3,$u7},$D3);
$w7=q#ni:/fabric/rmi#;
$x7={$R4,1};
$y7=q#/fabric/rmi#;
$z7={};
$A7=[];
$B7=q#my ($class, $io, $quote) = @_;#;
$C7=bless({$o,$A7,$q,$B7,$s,$t},$u);
$D7={$L4,$C7};
$E7=q#/fabric/rmi_init.b#;
$F7=bless({$Q2,$z7,$J3,$K3,$L3,$K3,$M3,$D7,$D,$E7},$V3);
$G7=[$z5,$F7];
$H7=bless({$Q2,$x7,$D,$y7,$C3,$G7},$T2);
$I7=q#fabric/rmi.c::ctors#;
$J7=q#ni:/fabric/rmi.c#;
$K7={$T2,1};
$L7=q#/fabric/rmi.c#;
$M7=[$m7];
$N7=bless({$Q2,$K7,$D,$L7,$C3,$M7},$D3);
$O7=q#ni:/fabric/rmi_init.b#;
$P7=q#ni:/io/buffer#;
$Q7={$S4,1};
$R7={$S4,1,$T4,1,$U4,1,$V4,1,$W4,1,$X4,1,$Y4,1,$Z4,1,$c5,1,$d5,1,$e5,1};
$S7=q#/io/object#;
$T7={};
$U7=q#(bool#;
$V7=[];
$W7=bless({$o,$V7,$q,1,$s,$t},$u);
$X7={$U7,$W7};
$Y7=q#/io/object_ops.b#;
$Z7=bless({$Q2,$T7,$J3,$K3,$L3,$K3,$M3,$X7,$D,$Y7},$V3);
$c8={};
$d8=q#die#;
$e8=[];
$f8=q#shift; die join " ", @_#;
$g8=bless({$o,$e8,$q,$f8,$s,$t},$u);
$h8=q#io_check#;
$i8=[];
$j8=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$k8=bless({$o,$i8,$q,$j8,$s,$t},$u);
$l8=q#io_check_defined#;
$m8=[];
$n8=q#shift->io_check(sub {defined shift}, @_)#;
$o8=bless({$o,$m8,$q,$n8,$s,$t},$u);
$p8=q#io_check_true#;
$q8=[];
$r8=q#shift->io_check(sub {shift}, @_)#;
$s8=bless({$o,$q8,$q,$r8,$s,$t},$u);
$t8={$d8,$g8,$h8,$k8,$l8,$o8,$p8,$s8};
$u8=q#/io/object_checks.b#;
$v8=bless({$Q2,$c8,$J3,$K3,$L3,$K3,$M3,$t8,$D,$u8},$V3);
$w8={};
$x8=q#(+#;
$y8=[];
$z8=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$A8=bless({$o,$y8,$q,$z8,$s,$t},$u);
$B8={$x8,$A8};
$C8=q#/io/object_constructors.b#;
$D8=bless({$Q2,$w8,$J3,$K3,$L3,$K3,$M3,$B8,$D,$C8},$V3);
$E8={};
$F8=q#read_all#;
$G8=[];
$H8=q#shift->into_sync(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$I8=bless({$o,$G8,$q,$H8,$s,$t},$u);
$J8=q#write_all#;
$K8=[];
$L8=q#my $self = shift;
ni('ni:/io/str')->new($_[0])->into_async($self);#;
$M8=bless({$o,$K8,$q,$L8,$s,$t},$u);
$N8={$F8,$I8,$J8,$M8};
$O8=q#/io/object_memory.b#;
$P8=bless({$Q2,$E8,$J3,$K3,$L3,$K3,$M3,$N8,$D,$O8},$V3);
$Q8={};
$R8=q#connect_sync#;
$S8=[];
$T8=q#my ($self, $rhs) = @_;
($self->into_sync($rhs),
 $rhs->into_sync($self));#;
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8=q#into_sync#;
$W8=[];
$X8=q#ni('ni:/io/transfer_sync')->new(@_)->run#;
$Y8=bless({$o,$W8,$q,$X8,$s,$t},$u);
$Z8={$R8,$U8,$V8,$Y8};
$c9=q#/io/object_transfer_sync.b#;
$d9=bless({$Q2,$Q8,$J3,$K3,$L3,$K3,$M3,$Z8,$D,$c9},$V3);
$e9={};
$f9=q#connect_async#;
$g9=[];
$h9=q#my ($self, $rhs) = @_;
($self->into_async($rhs),
 $rhs->into_async($self));#;
$i9=bless({$o,$g9,$q,$h9,$s,$t},$u);
$j9=q#into_async#;
$k9=[];
$l9=q#ni('ni:/io/transfer_async')->new(@_)->run#;
$m9=bless({$o,$k9,$q,$l9,$s,$t},$u);
$n9={$f9,$i9,$j9,$m9};
$o9=q#/io/object_transfer_async.b#;
$p9=bless({$Q2,$e9,$J3,$K3,$L3,$K3,$M3,$n9,$D,$o9},$V3);
$q9=[$z5,$Z7,$v8,$D8,$P8,$d9,$p9,$p9,$d9];
$r9=bless({$Q2,$R7,$D,$S7,$C3,$q9},$e3);
$s9=q#io/object.c::ctors#;
$t9={};
$u9=[];
$v9=q#my ($class, $capacity) = @_;
$capacity ||= 65536;
$class->die("buffer capacity must be a power of two (got $capacity)")
  if $capacity & $capacity - 1;
+{capacity    => $capacity,
  data        => "\\0" x $capacity,
  read_point  => 0,
  write_point => 0};#;
$w9=bless({$o,$u9,$q,$v9,$s,$t},$u);
$x9={$L4,$w9};
$y9=q#/io/buffer_init.b#;
$z9=bless({$Q2,$t9,$J3,$K3,$L3,$K3,$M3,$x9,$D,$y9},$V3);
$A9={};
$B9=q#read#;
$C9=[];
$D9=q#my $self = shift;
my $rcap = $self->read_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $rcap;

my $length = $_[1];
my $offset = $_[2] || 0;
$length = $rcap if $length > $rcap;

my $capacity   = $$self{capacity};
my $read_index = $$self{read_point} & $capacity - 1;
if ($read_index + $length > $capacity) {
  my $read_size = $capacity - $read_index;
  if ($offset) {
    $_[0] ||= "\\0" x $length;
    substr $_[0], $offset, $read_size,
           substr $$self{data}, $read_index, $read_size;
    substr $_[0], $offset + $read_size, $length - $read_size,
           substr $$self{data}, 0, $length - $read_size;
  } else {
    $_[0] = substr($$self{data}, $read_index, $read_size)
          . substr($$self{data}, 0, $length - $read_size);
  }
  $$self{read_point} += $length;
  return $length;
} else {
  if ($offset) {
    substr $_[0], $offset, $length,
           substr $$self{data}, $read_index, $length;
  } else {
    $_[0] = substr $$self{data}, $read_index, $length;
  }
  $$self{read_point} += $length;
  return $length;
}#;
$E9=bless({$o,$C9,$q,$D9,$s,$t},$u);
$F9=q#read_capacity#;
$G9=[];
$H9=q#my $self = shift;
$$self{write_point} - $$self{read_point};#;
$I9=bless({$o,$G9,$q,$H9,$s,$t},$u);
$J9=q#write#;
$K9=[];
$L9=q#my $self = shift;
my $wcap = $self->write_capacity;
$! = Errno::EWOULDBLOCK, return undef unless $wcap;

my $length = @_ > 1 ? $_[1] : length $_[0];
my $offset = $_[2] || 0;
$length    = $wcap if $length > $wcap;

my $capacity    = $$self{capacity};
my $write_index = $$self{write_point} & $capacity - 1;
if ($write_index + $length > $capacity) {
  \# Two-part write
  my $write_size = $capacity - $write_index;
  substr $$self{data}, $write_index, $write_size,
         substr $_[0], 0, $write_size;
  substr $$self{data}, 0, $length - $write_size,
         substr $_[0], $offset + $write_size, $length - $write_size;
  $$self{write_point} += $length;
  return $length;
} else {
  \# One-part write
  substr $$self{data}, $write_index, $length,
         length $_[0] == $length && !$offset
           ? $_[0]
           : substr $_[0], $offset, $length;
  $$self{write_point} += $length;
  return $length;
}#;
$M9=bless({$o,$K9,$q,$L9,$s,$t},$u);
$N9=q#write_capacity#;
$O9=[];
$P9=q#my $self = shift;
$$self{capacity} - $$self{write_point} + $$self{read_point};#;
$Q9=bless({$o,$O9,$q,$P9,$s,$t},$u);
$R9={$B9,$E9,$F9,$I9,$J9,$M9,$N9,$Q9};
$S9=q#/io/buffer_io.b#;
$T9=bless({$Q2,$A9,$J3,$K3,$L3,$K3,$M3,$R9,$D,$S9},$V3);
$U9=[$r9,$z9,$T9];
$V9=bless({$Q2,$Q7,$D,$g1,$C3,$U9},$U2);
$W9=q#io/buffer.c::ctors#;
$X9=q#ni:/io/buffer.c#;
$Y9={$U2,1};
$Z9=q#/io/buffer.c#;
$ca={$U2,1,$V2,1,$W2,1,$X2,1,$Y2,1,$Z2,1,$c3,1,$d3,1,$e3,1,$f3,1,$g3,1};
$da=q#/io/object.c#;
$ea={};
$fa=q#def_transfer_method#;
$ga=[];
$ha=q#my ($class, $transfer_class, $method_name) = @_;
my $transfer_name = $transfer_class->name;
$class->def("/io/object_transfer_$method_name.b",
  "into_$method_name" => fn qq{ni('$transfer_name')->new(\\@_)->run},
  "connect_$method_name" => fn qq{
    my (\\$self, \\$rhs) = \\@_;
    (\\$self->into_$method_name(\\$rhs),
     \\$rhs->into_$method_name(\\$self));
  });#;
$ia=bless({$o,$ga,$q,$ha,$s,$t},$u);
$ja={$fa,$ia};
$ka=q#/io/object.c_transfer_def.b#;
$la=bless({$Q2,$ea,$J3,$K3,$L3,$K3,$M3,$ja,$D,$ka},$V3);
$ma=[$m7,$la];
$na=bless({$Q2,$ca,$D,$da,$C3,$ma},$D3);
$oa=[$na];
$pa=bless({$Q2,$Y9,$D,$Z9,$C3,$oa},$D3);
$qa=q#ni:/io/buffer_init.b#;
$ra=q#ni:/io/buffer_io.b#;
$sa=q#ni:/io/cat#;
$ta={$T4,1};
$ua={};
$va=[];
$wa=q#shift; +{fs => [@_]}#;
$xa=bless({$o,$va,$q,$wa,$s,$t},$u);
$ya={$L4,$xa};
$za=q#/io/cat_init.b#;
$Aa=bless({$Q2,$ua,$J3,$K3,$L3,$K3,$M3,$ya,$D,$za},$V3);
$Ba={};
$Ca=[];
$Da=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa={$B9,$Ea};
$Ga=q#/io/cat_read.b#;
$Ha=bless({$Q2,$Ba,$J3,$K3,$L3,$K3,$M3,$Fa,$D,$Ga},$V3);
$Ia=[$r9,$Aa,$Ha];
$Ja=bless({$Q2,$ta,$D,$x1,$C3,$Ia},$V2);
$Ka=q#io/cat.c::ctors#;
$La=q#ni:/io/cat.c#;
$Ma={$V2,1};
$Na=q#/io/cat.c#;
$Oa=[$na];
$Pa=bless({$Q2,$Ma,$D,$Na,$C3,$Oa},$D3);
$Qa=q#ni:/io/cat_init.b#;
$Ra=q#ni:/io/cat_read.b#;
$Sa=q#ni:/io/exec#;
$Ta={$U4,1};
$Ua={};
$Va=q#argv#;
$Wa=[];
$Xa=q#shift->{'argv'}#;
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za={$Va,$Ya};
$cb=q#/io/exec_ro.b#;
$db=bless({$Q2,$Ua,$J3,$K3,$L3,$K3,$M3,$Za,$D,$cb},$V3);
$eb={};
$fb=[];
$gb=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$hb=bless({$o,$fb,$q,$gb,$s,$t},$u);
$ib={$L4,$hb};
$jb=q#/io/exec_init.b#;
$kb=bless({$Q2,$eb,$J3,$K3,$L3,$K3,$M3,$ib,$D,$jb},$V3);
$lb={};
$mb=q#connect#;
$nb=[];
$ob=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$pb=bless({$o,$nb,$q,$ob,$s,$t},$u);
$qb=q#in_pipe#;
$rb=[];
$sb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$tb=bless({$o,$rb,$q,$sb,$s,$t},$u);
$ub=q#out_pipe#;
$vb=[];
$wb=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$xb=bless({$o,$vb,$q,$wb,$s,$t},$u);
$yb=q#setup_stdio#;
$zb=[];
$Ab=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$Bb=bless({$o,$zb,$q,$Ab,$s,$t},$u);
$Cb={$mb,$pb,$qb,$tb,$ub,$xb,$yb,$Bb};
$Db=q#/io/exec_io_setup.b#;
$Eb=bless({$Q2,$lb,$J3,$K3,$L3,$K3,$M3,$Cb,$D,$Db},$V3);
$Fb={};
$Gb=q#binds_fd#;
$Hb=[];
$Ib=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$Jb=bless({$o,$Hb,$q,$Ib,$s,$t},$u);
$Kb=q#fd#;
$Lb=[];
$Mb=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$Nb=bless({$o,$Lb,$q,$Mb,$s,$t},$u);
$Ob=q#stderr#;
$Pb=[];
$Qb=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Rb=bless({$o,$Pb,$q,$Qb,$s,$t},$u);
$Sb=q#stdin#;
$Tb=[];
$Ub=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$Vb=bless({$o,$Tb,$q,$Ub,$s,$t},$u);
$Wb=q#stdout#;
$Xb=[];
$Yb=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Zb=bless({$o,$Xb,$q,$Yb,$s,$t},$u);
$cc={$Gb,$Jb,$Kb,$Nb,$Ob,$Rb,$Sb,$Vb,$Wb,$Zb};
$dc=q#/io/exec_io_accessors.b#;
$ec=bless({$Q2,$Fb,$J3,$K3,$L3,$K3,$M3,$cc,$D,$dc},$V3);
$fc={};
$gc=q#env#;
$hc=[];
$ic=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$jc=bless({$o,$hc,$q,$ic,$s,$t},$u);
$kc={$gc,$jc};
$lc=q#/io/exec_env.b#;
$mc=bless({$Q2,$fc,$J3,$K3,$L3,$K3,$M3,$kc,$D,$lc},$V3);
$nc={};
$oc=q#exec#;
$pc=[];
$qc=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$rc=bless({$o,$pc,$q,$qc,$s,$t},$u);
$sc=q#fork#;
$tc=[];
$uc=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*main::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$vc=bless({$o,$tc,$q,$uc,$s,$t},$u);
$wc=q#move_fds#;
$xc=[];
$yc=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$zc=bless({$o,$xc,$q,$yc,$s,$t},$u);
$Ac={$oc,$rc,$sc,$vc,$wc,$zc};
$Bc=q#/io/exec_fork.b#;
$Cc=bless({$Q2,$nc,$J3,$K3,$L3,$K3,$M3,$Ac,$D,$Bc},$V3);
$Dc=[$r9,$db,$kb,$Eb,$ec,$mc,$Cc];
$Ec=bless({$Q2,$Ta,$D,$J1,$C3,$Dc},$W2);
$Fc=q#io/exec.c::ctors#;
$Gc=q#ni:/io/exec.c#;
$Hc={$W2,1};
$Ic=q#/io/exec.c#;
$Jc=[$na];
$Kc=bless({$Q2,$Hc,$D,$Ic,$C3,$Jc},$D3);
$Lc=q#ni:/io/exec_env.b#;
$Mc=q#ni:/io/exec_fork.b#;
$Nc=q#ni:/io/exec_init.b#;
$Oc=q#ni:/io/exec_io_accessors.b#;
$Pc=q#ni:/io/exec_io_setup.b#;
$Qc=q#ni:/io/exec_ro.b#;
$Rc=q#ni:/io/fd#;
$Sc={$V4,1};
$Tc=q#/io/fd#;
$Uc={};
$Vc=[];
$Wc=q#shift->{'fd'}#;
$Xc=bless({$o,$Vc,$q,$Wc,$s,$t},$u);
$Yc={$Kb,$Xc};
$Zc=q#/io/fd_readers.b#;
$cd=bless({$Q2,$Uc,$J3,$K3,$L3,$K3,$M3,$Yc,$D,$Zc},$V3);
$dd={};
$ed=[];
$fd=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$gd=bless({$o,$ed,$q,$fd,$s,$t},$u);
$hd={$L4,$gd};
$id=q#/io/fd_init.b#;
$jd=bless({$Q2,$dd,$J3,$K3,$L3,$K3,$M3,$hd,$D,$id},$V3);
$kd={};
$ld=q#be#;
$md=[];
$nd=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$od=bless({$o,$md,$q,$nd,$s,$t},$u);
$pd={$ld,$od};
$qd=q#/io/fd_shell.b#;
$rd=bless({$Q2,$kd,$J3,$K3,$L3,$K3,$M3,$pd,$D,$qd},$V3);
$sd={};
$td=q#cloexec#;
$ud=[];
$vd=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd=q#fcntl_flag#;
$yd=[];
$zd=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  if (shift) {$flags |= $flag}
  else       {$flags &= ~$flag}
  $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=q#nonblock#;
$Cd=[];
$Dd=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd={$td,$wd,$xd,$Ad,$Bd,$Ed};
$Gd=q#/io/fd_fcntl.b#;
$Hd=bless({$Q2,$sd,$J3,$K3,$L3,$K3,$M3,$Fd,$D,$Gd},$V3);
$Id={};
$Jd=[];
$Kd=q#shift->close#;
$Ld=bless({$o,$Jd,$q,$Kd,$s,$t},$u);
$Md=q#close#;
$Nd=[];
$Od=q#my $self = shift;
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Pd=bless({$o,$Nd,$q,$Od,$s,$t},$u);
$Qd={$Md,$Pd};
$Rd=q#/io/fd_gc.b#;
$Sd=bless({$Q2,$Id,$J3,$K3,$L3,$Ld,$M3,$Qd,$D,$Rd},$V3);
$Td={};
$Ud=[];
$Vd=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;#;
$Wd=bless({$o,$Ud,$q,$Vd,$s,$t},$u);
$Xd=[];
$Yd=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;#;
$Zd=bless({$o,$Xd,$q,$Yd,$s,$t},$u);
$ce={$B9,$Wd,$J9,$Zd};
$de=q#/io/fd_perlio.b#;
$ee=bless({$Q2,$Td,$J3,$K3,$L3,$K3,$M3,$ce,$D,$de},$V3);
$fe=[$r9,$cd,$jd,$rd,$Hd,$Sd,$ee];
$ge=bless({$Q2,$Sc,$D,$Tc,$C3,$fe},$X2);
$he=q#io/fd.c::ctors#;
$ie=q#ni:/io/fd.c#;
$je={$X2,1};
$ke=q#/io/fd.c#;
$le=[$na];
$me=bless({$Q2,$je,$D,$ke,$C3,$le},$D3);
$ne=q#ni:/io/fd_fcntl.b#;
$oe=q#ni:/io/fd_gc.b#;
$pe=q#ni:/io/fd_init.b#;
$qe=q#ni:/io/fd_perlio.b#;
$re=q#ni:/io/fd_readers.b#;
$se=q#ni:/io/fd_shell.b#;
$te=q#ni:/io/file#;
$ue={$W4,1};
$ve=q#/io/file#;
$we={};
$xe=[];
$ye=q#shift->{'name'}#;
$ze=bless({$o,$xe,$q,$ye,$s,$t},$u);
$Ae={$D,$ze};
$Be=q#/io/file_readers.b#;
$Ce=bless({$Q2,$we,$J3,$K3,$L3,$K3,$M3,$Ae,$D,$Be},$V3);
$De={};
$Ee=q#mode#;
$Fe=[];
$Ge=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$He=bless({$o,$Fe,$q,$Ge,$s,$t},$u);
$Ie={$Ee,$He};
$Je=q#/io/file_accessors.b#;
$Ke=bless({$Q2,$De,$J3,$K3,$L3,$K3,$M3,$Ie,$D,$Je},$V3);
$Le={};
$Me=[];
$Ne=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Oe=bless({$o,$Me,$q,$Ne,$s,$t},$u);
$Pe={$L4,$Oe};
$Qe=q#/io/file_init.b#;
$Re=bless({$Q2,$Le,$J3,$K3,$L3,$K3,$M3,$Pe,$D,$Qe},$V3);
$Se={};
$Te=[];
$Ue=q#my $self = shift;
$$self{r}->close if $$self{r};
$$self{w}->close if $$self{w};
$$self{r} = $$self{w} = undef;
$self;#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We=q#r#;
$Xe=[];
$Ye=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ze=bless({$o,$Xe,$q,$Ye,$s,$t},$u);
$cf=[];
$df=q#shift->r->read(@_)#;
$ef=bless({$o,$cf,$q,$df,$s,$t},$u);
$ff=q#w#;
$gf=[];
$hf=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$if=bless({$o,$gf,$q,$hf,$s,$t},$u);
$jf=[];
$kf=q#shift->w->write(@_)#;
$lf=bless({$o,$jf,$q,$kf,$s,$t},$u);
$mf={$Md,$Ve,$We,$Ze,$B9,$ef,$ff,$if,$J9,$lf};
$nf=q#/io/file_io.b#;
$of=bless({$Q2,$Se,$J3,$K3,$L3,$K3,$M3,$mf,$D,$nf},$V3);
$pf=[$r9,$Ce,$Ke,$Re,$of];
$qf=bless({$Q2,$ue,$D,$ve,$C3,$pf},$Y2);
$rf=q#io/file.c::ctors#;
$sf=q#ni:/io/file.c#;
$tf={$Y2,1};
$uf=q#/io/file.c#;
$vf=[$na];
$wf=bless({$Q2,$tf,$D,$uf,$C3,$vf},$D3);
$xf=q#ni:/io/file_accessors.b#;
$yf=q#ni:/io/file_init.b#;
$zf=q#ni:/io/file_io.b#;
$Af=q#ni:/io/file_readers.b#;
$Bf=q#ni:/io/mio#;
$Cf={$X4,1};
$Df={};
$Ef=q#io#;
$Ff=[];
$Gf=q#shift->{'io'}#;
$Hf=bless({$o,$Ff,$q,$Gf,$s,$t},$u);
$If=q#packet_size#;
$Jf=[];
$Kf=q#shift->{'packet_size'}#;
$Lf=bless({$o,$Jf,$q,$Kf,$s,$t},$u);
$Mf={$Ef,$Hf,$If,$Lf};
$Nf=q#/io/mio_ro.b#;
$Of=bless({$Q2,$Df,$J3,$K3,$L3,$K3,$M3,$Mf,$D,$Nf},$V3);
$Pf={};
$Qf=[];
$Rf=q#my ($self, %args) = @_;
+{channel_capacity => $args{channel_capacity} || 65536,
  closed           => 0,
  send_index       => 0,
  read_buffers     => [],
  write_buffers    => [],
  channel_id       => 0,
  channels         => []};#;
$Sf=bless({$o,$Qf,$q,$Rf,$s,$t},$u);
$Tf={$L4,$Sf};
$Uf=q#/io/mio_init.b#;
$Vf=bless({$Q2,$Pf,$J3,$K3,$L3,$K3,$M3,$Tf,$D,$Uf},$V3);
$Wf={};
$Xf=q#next_sender#;
$Yf=[];
$Zf=q#my $self = shift;
my $rs   = $$self{read_buffers};
my $a    = $$self{send_index} + 1;
for (my $i = 0; $i < @$rs; ++$i) {
  my $ai = ($a + $i) % @$rs;
  return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
}
undef;#;
$cg=bless({$o,$Yf,$q,$Zf,$s,$t},$u);
$dg={$Xf,$cg};
$eg=q#/io/mio_rr_scheduler.b#;
$fg=bless({$Q2,$Wf,$J3,$K3,$L3,$K3,$M3,$dg,$D,$eg},$V3);
$gg={};
$hg=[];
$ig=q#my $self = shift;
$$self{closed} = 1;
$self;#;
$jg=bless({$o,$hg,$q,$ig,$s,$t},$u);
$kg=[];
$lg=q#my $self   = shift;
my $length = $_[1];
my $offset = $_[2] || 0;
my $total_read = 0;

while ($total_read + 8 < $length) {
  my $next_id = $self->next_sender;
  unless (defined $next_id) {
    return 0 if $$self{closed};
    $! = Errno::EWOULDBLOCK, return undef unless $total_read;
    return $total_read;
  }

  my $n = $$self{channels}[$next_id]->read(
    $_[0],
    $length - $total_read - 8,
    $offset + $total_read + 8);
  if ($n) {
    substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
    $total_read += $n + 8;
  } elsif (!defined $n) {
    return $total_read || undef;
  }
}

return $total_read if $total_read;
$! = Errno::EWOULDBLOCK;
undef;#;
$mg=bless({$o,$kg,$q,$lg,$s,$t},$u);
$ng=[];
$og=q#my $self = shift;
my $length = $\#_ ? $_[1] : length $_[0];
my $offset = $_[2] || 0;#;
$pg=bless({$o,$ng,$q,$og,$s,$t},$u);
$qg={$Md,$jg,$B9,$mg,$J9,$pg};
$rg=q#/io/mio_io.b#;
$sg=bless({$Q2,$gg,$J3,$K3,$L3,$K3,$M3,$qg,$D,$rg},$V3);
$tg={};
$ug=q#channel#;
$vg=[];
$wg=q#my $self = shift;
my $id = @_ ? shift : ++$$self{channel_id};
return $$self{channels}{$id} if exists $$self{channels}{$id};
my $c = ni('ni:/io/mio_channel')->new($self, $id);
Scalar::Util::weaken($$self{channels}{$id} = $c);
$$self{read_buffers}{$id}  = $$c{read_buffer};
$$self{write_buffers}{$id} = $$c{write_buffer};
push @{$$self{send_rr}}, $id;
$c;#;
$xg=bless({$o,$vg,$q,$wg,$s,$t},$u);
$yg=q#channels#;
$zg=[];
$Ag=q#sort {$a <=> $b} keys %{shift->{channels}}#;
$Bg=bless({$o,$zg,$q,$Ag,$s,$t},$u);
$Cg=q#unchannel#;
$Dg=[];
$Eg=q#my ($self, $id) = @_;
delete $$self{channels}{$id};
delete $$self{read_buffers}{$id}
  unless $$self{read_buffers}{$id}->read_capacity;
delete $$self{write_buffers}{$id}
  unless $$self{write_buffers}{$id}->write_capacity;
$$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
$self;#;
$Fg=bless({$o,$Dg,$q,$Eg,$s,$t},$u);
$Gg={$ug,$xg,$yg,$Bg,$Cg,$Fg};
$Hg=q#/io/mio_channel.b#;
$Ig=bless({$Q2,$tg,$J3,$K3,$L3,$K3,$M3,$Gg,$D,$Hg},$V3);
$Jg=[$r9,$Of,$Vf,$fg,$sg,$Ig];
$Kg=bless({$Q2,$Cf,$D,$S1,$C3,$Jg},$Z2);
$Lg=q#io/mio.c::ctors#;
$Mg=q#ni:/io/mio.c#;
$Ng={$Z2,1};
$Og=q#/io/mio.c#;
$Pg=[$na];
$Qg=bless({$Q2,$Ng,$D,$Og,$C3,$Pg},$D3);
$Rg=q#ni:/io/mio_channel#;
$Sg={$Y4,1};
$Tg=q#/io/mio_channel#;
$Ug={};
$Vg=q#capacity#;
$Wg=[];
$Xg=q#shift->{'capacity'}#;
$Yg=bless({$o,$Wg,$q,$Xg,$s,$t},$u);
$Zg=q#id#;
$ch=[];
$dh=q#shift->{'id'}#;
$eh=bless({$o,$ch,$q,$dh,$s,$t},$u);
$fh=q#mio#;
$gh=[];
$hh=q#shift->{'mio'}#;
$ih=bless({$o,$gh,$q,$hh,$s,$t},$u);
$jh={$Vg,$Yg,$Zg,$eh,$fh,$ih};
$kh=q#/io/mio_channel_ro.b#;
$lh=bless({$Q2,$Ug,$J3,$K3,$L3,$K3,$M3,$jh,$D,$kh},$V3);
$mh={};
$nh=[];
$oh=q#my ($self, $mio, $id, $capacity) = @_;
+{mio          => $mio,
  id           => $id,
  capacity     => $capacity,
  write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
  read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};#;
$ph=bless({$o,$nh,$q,$oh,$s,$t},$u);
$qh={$L4,$ph};
$rh=q#/io/mio_channel_init.b#;
$sh=bless({$Q2,$mh,$J3,$K3,$L3,$K3,$M3,$qh,$D,$rh},$V3);
$th={};
$uh=[];
$vh=bless({$o,$uh,$q,$Kd,$s,$t},$u);
$wh={};
$xh=q#/io/mio_channel_lifecycle.b#;
$yh=bless({$Q2,$th,$J3,$K3,$L3,$vh,$M3,$wh,$D,$xh},$V3);
$zh={};
$Ah=[];
$Bh=q#my $self = shift;
$$self{mio}->unchannel($$self{channel_id});#;
$Ch=bless({$o,$Ah,$q,$Bh,$s,$t},$u);
$Dh=[];
$Eh=q#shift->{read_buffer} ->read(@_)#;
$Fh=bless({$o,$Dh,$q,$Eh,$s,$t},$u);
$Gh=[];
$Hh=q#shift->{write_buffer}->write(@_)#;
$Ih=bless({$o,$Gh,$q,$Hh,$s,$t},$u);
$Jh={$Md,$Ch,$B9,$Fh,$J9,$Ih};
$Kh=q#/io/mio_channel_io.b#;
$Lh=bless({$Q2,$zh,$J3,$K3,$L3,$K3,$M3,$Jh,$D,$Kh},$V3);
$Mh=[$r9,$lh,$sh,$yh,$Lh];
$Nh=bless({$Q2,$Sg,$D,$Tg,$C3,$Mh},$c3);
$Oh=q#io/mio_channel.c::ctors#;
$Ph=q#ni:/io/mio_channel.b#;
$Qh=q#ni:/io/mio_channel.c#;
$Rh={$c3,1};
$Sh=q#/io/mio_channel.c#;
$Th=[$na];
$Uh=bless({$Q2,$Rh,$D,$Sh,$C3,$Th},$D3);
$Vh=q#ni:/io/mio_channel_init.b#;
$Wh=q#ni:/io/mio_channel_io.b#;
$Xh=q#ni:/io/mio_channel_lifecycle.b#;
$Yh=q#ni:/io/mio_channel_ro.b#;
$Zh=q#ni:/io/mio_init.b#;
$ci=q#ni:/io/mio_io.b#;
$di=q#ni:/io/mio_ro.b#;
$ei=q#ni:/io/mio_rr_scheduler.b#;
$fi=q#ni:/io/named_io_fns.b#;
$gi={};
$hi=q#fcntl#;
$ii=[];
$ji=q#CORE::fcntl $_[0], $_[1], $_[2]#;
$ki=bless({$o,$ii,$q,$ji,$s,$t},$u);
$li=[];
$mi=q#CORE::fork#;
$ni=bless({$o,$li,$q,$mi,$s,$t},$u);
$oi=q#open2#;
$pi=[];
$qi=q#CORE::open $_[0], $_[1]#;
$ri=bless({$o,$pi,$q,$qi,$s,$t},$u);
$si=q#waitpid#;
$ti=[];
$ui=q#CORE::waitpid $_[0], $_[1]#;
$vi=bless({$o,$ti,$q,$ui,$s,$t},$u);
$wi={$hi,$ki,$sc,$ni,$oi,$ri,$si,$vi};
$xi=q#/io/named_io_fns.b#;
$yi=bless({$Q2,$gi,$J3,$K3,$L3,$K3,$M3,$wi,$D,$xi},$V3);
$zi=q#main#;
$Ai=q#ni:/io/null#;
$Bi={$Z4,1};
$Ci=q#/io/null#;
$Di={};
$Ei=[];
$Fi=q#+{fd => undef}#;
$Gi=bless({$o,$Ei,$q,$Fi,$s,$t},$u);
$Hi={$L4,$Gi};
$Ii=q#/io/null_init.b#;
$Ji=bless({$Q2,$Di,$J3,$K3,$L3,$K3,$M3,$Hi,$D,$Ii},$V3);
$Ki={};
$Li=[];
$Mi=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$Ni=bless({$o,$Li,$q,$Mi,$s,$t},$u);
$Oi=[];
$Pi=q#shift->fd->read(@_)#;
$Qi=bless({$o,$Oi,$q,$Pi,$s,$t},$u);
$Ri=[];
$Si=q#shift->fd->write(@_)#;
$Ti=bless({$o,$Ri,$q,$Si,$s,$t},$u);
$Ui={$Kb,$Ni,$B9,$Qi,$J9,$Ti};
$Vi=q#/io/null_io.b#;
$Wi=bless({$Q2,$Ki,$J3,$K3,$L3,$K3,$M3,$Ui,$D,$Vi},$V3);
$Xi=[$r9,$Ji,$Wi];
$Yi=bless({$Q2,$Bi,$D,$Ci,$C3,$Xi},$d3);
$Zi=q#io/null.c::ctors#;
$cj=q#ni:/io/null.c#;
$dj={$d3,1};
$ej=q#/io/null.c#;
$fj=[$na];
$gj=bless({$Q2,$dj,$D,$ej,$C3,$fj},$D3);
$hj=q#ni:/io/null_init.b#;
$ij=q#ni:/io/null_io.b#;
$jj=q#ni:/io/object#;
$kj=q#ni:/io/object.c#;
$lj=q#ni:/io/object.c_transfer_def.b#;
$mj=q#ni:/io/object_checks.b#;
$nj=q#ni:/io/object_constructors.b#;
$oj=q#ni:/io/object_memory.b#;
$pj=q#ni:/io/object_ops.b#;
$qj=q#ni:/io/object_transfer_async.b#;
$rj=q#ni:/io/object_transfer_sync.b#;
$sj=q#ni:/io/pid#;
$tj={$d5,1};
$uj={};
$vj=q#pid#;
$wj=[];
$xj=q#shift->{'pid'}#;
$yj=bless({$o,$wj,$q,$xj,$s,$t},$u);
$zj=q#status#;
$Aj=[];
$Bj=q#shift->{'status'}#;
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj={$vj,$yj,$zj,$Cj};
$Ej=q#/io/pid_readers.b#;
$Fj=bless({$Q2,$uj,$J3,$K3,$L3,$K3,$M3,$Dj,$D,$Ej},$V3);
$Gj={};
$Hj=[];
$Ij=q#shift->await#;
$Jj=bless({$o,$Hj,$q,$Ij,$s,$t},$u);
$Kj=[];
$Lj=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$Mj=bless({$o,$Kj,$q,$Lj,$s,$t},$u);
$Nj={$L4,$Mj};
$Oj=q#/io/pid_init.b#;
$Pj=bless({$Q2,$Gj,$J3,$K3,$L3,$Jj,$M3,$Nj,$D,$Oj},$V3);
$Qj={};
$Rj=q#await#;
$Sj=[];
$Tj=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*main::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Uj=bless({$o,$Sj,$q,$Tj,$s,$t},$u);
$Vj=q#running#;
$Wj=[];
$Xj=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Yj=bless({$o,$Wj,$q,$Xj,$s,$t},$u);
$Zj={$Rj,$Uj,$Vj,$Yj};
$ck=q#/io/pid_wait.b#;
$dk=bless({$Q2,$Qj,$J3,$K3,$L3,$K3,$M3,$Zj,$D,$ck},$V3);
$ek={};
$fk=[];
$gk=q#shift->stdout->read(@_)#;
$hk=bless({$o,$fk,$q,$gk,$s,$t},$u);
$ik=[];
$jk=q#shift->stdin->write(@_)#;
$kk=bless({$o,$ik,$q,$jk,$s,$t},$u);
$lk={$B9,$hk,$J9,$kk};
$mk=q#/io/pid_io.b#;
$nk=bless({$Q2,$ek,$J3,$K3,$L3,$K3,$M3,$lk,$D,$mk},$V3);
$ok={};
$pk=[];
$qk=q#$_[0]->{external_fds}{$_[1]}#;
$rk=bless({$o,$pk,$q,$qk,$s,$t},$u);
$sk=[];
$tk=q#shift->fd(2)#;
$uk=bless({$o,$sk,$q,$tk,$s,$t},$u);
$vk=[];
$wk=q#shift->fd(0)#;
$xk=bless({$o,$vk,$q,$wk,$s,$t},$u);
$yk=[];
$zk=q#shift->fd(1)#;
$Ak=bless({$o,$yk,$q,$zk,$s,$t},$u);
$Bk={$Kb,$rk,$Ob,$uk,$Sb,$xk,$Wb,$Ak};
$Ck=q#/io/pid_accessors.b#;
$Dk=bless({$Q2,$ok,$J3,$K3,$L3,$K3,$M3,$Bk,$D,$Ck},$V3);
$Ek=[$r9,$Fj,$Pj,$dk,$nk,$Dk];
$Fk=bless({$Q2,$tj,$D,$k2,$C3,$Ek},$f3);
$Gk=q#io/pid.c::ctors#;
$Hk=q#ni:/io/pid.c#;
$Ik={$f3,1};
$Jk=q#/io/pid.c#;
$Kk=[$na];
$Lk=bless({$Q2,$Ik,$D,$Jk,$C3,$Kk},$D3);
$Mk=q#ni:/io/pid_accessors.b#;
$Nk=q#ni:/io/pid_init.b#;
$Ok=q#ni:/io/pid_io.b#;
$Pk=q#ni:/io/pid_readers.b#;
$Qk=q#ni:/io/pid_wait.b#;
$Rk=q#ni:/io/str#;
$Sk={$e5,1};
$Tk=q#/io/str#;
$Uk={};
$Vk=q#data#;
$Wk=[];
$Xk=q#shift->{'data'}#;
$Yk=bless({$o,$Wk,$q,$Xk,$s,$t},$u);
$Zk=q#end#;
$cl=[];
$dl=q#shift->{'end'}#;
$el=bless({$o,$cl,$q,$dl,$s,$t},$u);
$fl=q#start#;
$gl=[];
$hl=q#shift->{'start'}#;
$il=bless({$o,$gl,$q,$hl,$s,$t},$u);
$jl={$Vk,$Yk,$Zk,$el,$fl,$il};
$kl=q#/io/str_ro.b#;
$ll=bless({$Q2,$Uk,$J3,$K3,$L3,$K3,$M3,$jl,$D,$kl},$V3);
$ml={};
$nl=[];
$ol=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$pl=bless({$o,$nl,$q,$ol,$s,$t},$u);
$ql={$L4,$pl};
$rl=q#/io/str_init.b#;
$sl=bless({$Q2,$ml,$J3,$K3,$L3,$K3,$M3,$ql,$D,$rl},$V3);
$tl={};
$ul=[];
$vl=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$wl=bless({$o,$ul,$q,$vl,$s,$t},$u);
$xl=q#remaining#;
$yl=[];
$zl=q#my $self = shift; $$self{end} - $$self{start}#;
$Al=bless({$o,$yl,$q,$zl,$s,$t},$u);
$Bl=[];
$Cl=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El={$B9,$wl,$xl,$Al,$J9,$Dl};
$Fl=q#/io/str_io.b#;
$Gl=bless({$Q2,$tl,$J3,$K3,$L3,$K3,$M3,$El,$D,$Fl},$V3);
$Hl=[$r9,$ll,$sl,$Gl];
$Il=bless({$Q2,$Sk,$D,$Tk,$C3,$Hl},$g3);
$Jl=q#io/str.c::ctors#;
$Kl=q#ni:/io/str.c#;
$Ll={$g3,1};
$Ml=q#/io/str.c#;
$Nl=[$na];
$Ol=bless({$Q2,$Ll,$D,$Ml,$C3,$Nl},$D3);
$Pl=q#ni:/io/str_init.b#;
$Ql=q#ni:/io/str_io.b#;
$Rl=q#ni:/io/str_ro.b#;
$Sl=q#ni:/io/transfer#;
$Tl={$f5,1,$g5,1,$h5,1};
$Ul=q#/io/transfer#;
$Vl={$f5,1,$g5,1,$h5,1,$p5,1};
$Wl=q#/semantic/task#;
$Xl={};
$Yl=q#outcome#;
$Zl=[];
$cm=q#shift->{'outcome'}#;
$dm=bless({$o,$Zl,$q,$cm,$s,$t},$u);
$em={$Yl,$dm};
$fm=q#/semantic/task_ro.b#;
$gm=bless({$Q2,$Xl,$J3,$K3,$L3,$K3,$M3,$em,$D,$fm},$V3);
$hm={};
$im=q#failure#;
$jm=[];
$km=q#my $self = shift;
$$self{outcome} = [0, @_];
$self->die($_[0]);#;
$lm=bless({$o,$jm,$q,$km,$s,$t},$u);
$mm=q#success#;
$nm=[];
$om=q#my $self = shift;
$$self{outcome} = [1, @_];
$self;#;
$pm=bless({$o,$nm,$q,$om,$s,$t},$u);
$qm={$im,$lm,$mm,$pm};
$rm=q#/semantic/task_outcome.b#;
$sm=bless({$Q2,$hm,$J3,$K3,$L3,$K3,$M3,$qm,$D,$rm},$V3);
$tm=[$z5,$gm,$sm];
$um=bless({$Q2,$Vl,$D,$Wl,$C3,$tm},$A3);
$vm=q#semantic/task.c::ctors#;
$wm={};
$xm=[];
$ym=q#my $self = shift;
@$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);#;
$zm=bless({$o,$xm,$q,$ym,$s,$t},$u);
$Am=[];
$Bm=q#my $self = shift;
my $start_time = time;
my $n = $$self{source_io}->read(@_);
my $end_time = time;
$$self{start_time} ||= $start_time;
$$self{read_bytes} += $n if defined $n;
$$self{read_time} += $end_time - $start_time;
$n;#;
$Cm=bless({$o,$Am,$q,$Bm,$s,$t},$u);
$Dm=[];
$Em=q#my $self = shift;
my $start_time = time;
my $n = $$self{dest_io}->write(@_);
my $end_time = time;
$$self{write_bytes} += $n if defined $n;
$$self{write_time} += $end_time - $start_time;
$n;#;
$Fm=bless({$o,$Dm,$q,$Em,$s,$t},$u);
$Gm={$B9,$Cm,$J9,$Fm};
$Hm=q#/io/transfer_io_interop.b#;
$Im=bless({$Q2,$wm,$J3,$zm,$L3,$K3,$M3,$Gm,$D,$Hm},$V3);
$Jm={};
$Km=q#pressure#;
$Lm=[];
$Mm=q#my $self = shift;
my $in_impedance  = log($$self{read_time}  || 1);
my $out_impedance = log($$self{write_time} || 1);
($out_impedance - $in_impedance) / log 20;#;
$Nm=bless({$o,$Lm,$q,$Mm,$s,$t},$u);
$Om=q#read_limit_throughput#;
$Pm=[];
$Qm=q#my $self = shift;
$$self{read_bytes} / ($$self{read_time} || 1);#;
$Rm=bless({$o,$Pm,$q,$Qm,$s,$t},$u);
$Sm=q#throughput#;
$Tm=[];
$Um=q#my $self = shift;
my $end_time = $$self{end_time} || time;
my $dt       = $end_time - $$self{start_time} || 1;
$$self{write_bytes} / $dt;#;
$Vm=bless({$o,$Tm,$q,$Um,$s,$t},$u);
$Wm=q#write_limit_throughput#;
$Xm=[];
$Ym=q#my $self = shift;
$$self{write_bytes} / ($$self{write_time} || 1);#;
$Zm=bless({$o,$Xm,$q,$Ym,$s,$t},$u);
$cn={$Km,$Nm,$Om,$Rm,$Sm,$Vm,$Wm,$Zm};
$dn=q#/io/transfer_io_measurement.b#;
$en=bless({$Q2,$Jm,$J3,$K3,$L3,$K3,$M3,$cn,$D,$dn},$V3);
$fn=[$um,$Im,$en];
$gn=bless({$Q2,$Tl,$D,$Ul,$C3,$fn},$h3);
$hn=q#io/transfer.c::ctors#;
$in=q#ni:/io/transfer.c#;
$jn={$h3,1,$i3,1,$j3,1};
$kn=q#/io/transfer.c#;
$ln={$h3,1,$i3,1,$j3,1,$A3,1};
$mn=q#/semantic/task.c#;
$nn=[$m7];
$on=bless({$Q2,$ln,$D,$mn,$C3,$nn},$D3);
$pn={};
$qn=[];
$rn=q#my $self = shift;
ni('ni:/io/object')->def_transfer_method($self, $1)
  if $self->name =~ /transfer_(\\w+)$/;#;
$sn=bless({$o,$qn,$q,$rn,$s,$t},$u);
$tn={};
$un=q#/io/transfer.c_into.b#;
$vn=bless({$Q2,$pn,$J3,$sn,$L3,$K3,$M3,$tn,$D,$un},$V3);
$wn=[$on,$vn];
$xn=bless({$Q2,$jn,$D,$kn,$C3,$wn},$D3);
$yn=q#ni:/io/transfer.c_into.b#;
$zn=q#ni:/io/transfer_async#;
$An={$g5,1};
$Bn=q#/io/transfer_async#;
$Cn={};
$Dn=q#dest_io#;
$En=[];
$Fn=q#shift->{'dest_io'}#;
$Gn=bless({$o,$En,$q,$Fn,$s,$t},$u);
$Hn=[];
$In=bless({$o,$Hn,$q,$dh,$s,$t},$u);
$Jn=q#source_io#;
$Kn=[];
$Ln=q#shift->{'source_io'}#;
$Mn=bless({$o,$Kn,$q,$Ln,$s,$t},$u);
$Nn={$Dn,$Gn,$Zg,$In,$Jn,$Mn};
$On=q#/io/transfer_async_ro.b#;
$Pn=bless({$Q2,$Cn,$J3,$K3,$L3,$K3,$M3,$Nn,$D,$On},$V3);
$Qn={};
$Rn=[];
$Sn=q#my ($class, $source, $dest) = @_;
$source->nonblock(1) if $source->can('nonblock');
$dest  ->nonblock(1) if $dest  ->can('nonblock');
+{source_io => $source,
  dest_io   => $dest,
  pending   => '',
  outcome   => undef,
  id        => $class->new_id};#;
$Tn=bless({$o,$Rn,$q,$Sn,$s,$t},$u);
$Un={$L4,$Tn};
$Vn=q#/io/transfer_async_init.b#;
$Wn=bless({$Q2,$Qn,$J3,$K3,$L3,$K3,$M3,$Un,$D,$Vn},$V3);
$Xn={};
$Yn=[];
$Zn=q#ni('ni:/io/transfer_async')->track(shift)#;
$co=bless({$o,$Yn,$q,$Zn,$s,$t},$u);
$do=[];
$eo=q#ni('ni:/io/transfer_async')->untrack(shift->{id})#;
$fo=bless({$o,$do,$q,$eo,$s,$t},$u);
$go={};
$ho=q#/io/transfer_async_lifecycle.b#;
$io=bless({$Q2,$Xn,$J3,$co,$L3,$fo,$M3,$go,$D,$ho},$V3);
$jo={};
$ko=q#run#;
$lo=[];
$mo=q#shift#;
$no=bless({$o,$lo,$q,$mo,$s,$t},$u);
$oo=q#run_async#;
$po=[];
$qo=q#my $self = shift;
my $n;

\# Step one: write everything in the pending queue, if possible. Invariant
\# after this if() condition is that $$self{pending} is empty unless there
\# was something preventing IO.
if (length $$self{pending}) {
write_branch:
  $n = 0;
  while ($n < length $$self{pending}) {
    my $x = $self->write($n ? substr($$self{pending}, $n)
                            : $$self{pending});
    last unless defined $x;
    $n += $x;
  }
  $$self{pending} = substr $$self{pending}, $n;
}

\# Step two: load more data into $$self{pending} and, if successful, go
\# back to step one and write it.
unless (length $$self{pending}) {
  goto write_branch if $n = $self->read($$self{pending}, 32768);
  return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
  if (defined $n) {
    $$self{end_time} = time;
    return $self->success;
  } else {
    $self->failure($!);
  }
}

$self;#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so={$ko,$no,$oo,$ro};
$to=q#/io/transfer_async_run.b#;
$uo=bless({$Q2,$jo,$J3,$K3,$L3,$K3,$M3,$so,$D,$to},$V3);
$vo=[$gn,$Pn,$Wn,$io,$uo];
$wo=q#tracked_transfers#;
$xo={};
$yo=bless({$Q2,$An,$D,$Bn,$C3,$vo,$wo,$xo},$i3);
$zo=q#io/transfer_async.c::ctors#;
$Ao=q#ni:/io/transfer_async.c#;
$Bo={$i3,1};
$Co=q#/io/transfer_async.c#;
$Do={};
$Eo=[];
$Fo=q#shift->{tracked_transfers} = {}#;
$Go=bless({$o,$Eo,$q,$Fo,$s,$t},$u);
$Ho=q#track#;
$Io=[];
$Jo=q#my ($self, $transfer) = @_;
Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
$self;#;
$Ko=bless({$o,$Io,$q,$Jo,$s,$t},$u);
$Lo=q#untrack#;
$Mo=[];
$No=q#my ($self, $id) = @_;
delete $$self{tracked_transfers}{$id};
$self;#;
$Oo=bless({$o,$Mo,$q,$No,$s,$t},$u);
$Po={$Ho,$Ko,$Lo,$Oo};
$Qo=q#/io/transfer_async.c_tracker.b#;
$Ro=bless({$Q2,$Do,$J3,$Go,$L3,$K3,$M3,$Po,$D,$Qo},$V3);
$So=[$xn,$Ro];
$To=bless({$Q2,$Bo,$D,$Co,$C3,$So},$D3);
$Uo=q#ni:/io/transfer_async.c_tracker.b#;
$Vo=q#ni:/io/transfer_async_init.b#;
$Wo=q#ni:/io/transfer_async_lifecycle.b#;
$Xo=q#ni:/io/transfer_async_ro.b#;
$Yo=q#ni:/io/transfer_async_run.b#;
$Zo=q#ni:/io/transfer_io_interop.b#;
$cp=q#ni:/io/transfer_io_measurement.b#;
$dp=q#ni:/io/transfer_sync#;
$ep={$h5,1};
$fp=q#/io/transfer_sync#;
$gp={};
$hp=[];
$ip=q#my ($class, $source, $dest) = @_;
+{source_io => $source,
  dest_io   => $dest};#;
$jp=bless({$o,$hp,$q,$ip,$s,$t},$u);
$kp={$L4,$jp};
$lp=q#/io/transfer_sync_init.b#;
$mp=bless({$Q2,$gp,$J3,$K3,$L3,$K3,$M3,$kp,$D,$lp},$V3);
$np={};
$op=[];
$pp=q#my $self = shift;
my $buf;
my $r;
while (($r = $self->read($buf, 32768)) || $!{EINTR}) {
  my $n = $self->write($buf);
  $self->failure($!) unless $n || $!{EINTR};
  while ($n < $r) {
    my $n0 = $self->write($buf, $r - $n, $n);
    $self->failure($!) unless $!{EINTR} || $n0;
    $n += $n0 || 0;
  }
}
$$self{end_time} = time;
$self->success;#;
$qp=bless({$o,$op,$q,$pp,$s,$t},$u);
$rp={$ko,$qp};
$sp=q#/io/transfer_sync_run.b#;
$tp=bless({$Q2,$np,$J3,$K3,$L3,$K3,$M3,$rp,$D,$sp},$V3);
$up=[$gn,$mp,$tp];
$vp=bless({$Q2,$ep,$D,$fp,$C3,$up},$j3);
$wp=q#io/transfer_sync.c::ctors#;
$xp=q#ni:/io/transfer_sync.c#;
$yp={$j3,1};
$zp=q#/io/transfer_sync.c#;
$Ap=[$xn];
$Bp=bless({$Q2,$yp,$D,$zp,$C3,$Ap},$D3);
$Cp=q#ni:/io/transfer_sync_init.b#;
$Dp=q#ni:/io/transfer_sync_run.b#;
$Ep=q#ni:/lib/accessor.b#;
$Fp=q#ni:/lib/behavior#;
$Gp=q#ni:/lib/behavior.c#;
$Hp=q#ni:/lib/branch#;
$Ip={$X3,1};
$Jp=q#/lib/branch#;
$Kp={};
$Lp=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Mp=bless({$q,$Lp,$s,$t},$u);
$Np={$L4,$Mp};
$Op=q#/lib/branch_init.b#;
$Pp=bless({$Q2,$Kp,$J3,$K3,$L3,$K3,$M3,$Np,$D,$Op},$V3);
$Qp=[$K5,$i4,$W3,$Pp,$D6];
$Rp=bless({$Q2,$Ip,$D,$Jp,$C3,$Qp},$l3);
$Sp=q#lib/branch.c::ctors#;
$Tp=q#ni:/lib/branch.b#;
$Up=q#ni:/lib/branch.c#;
$Vp={$l3,1};
$Wp=q#/lib/branch.c#;
$Xp=[$r7];
$Yp=bless({$Q2,$Vp,$D,$Wp,$C3,$Xp},$D3);
$Zp=q#ni:/lib/branch_init.b#;
$cq=q#ni:/lib/class_init.b#;
$dq=q#ni:/lib/dataslice#;
$eq={$j5,1};
$fq=q#/lib/dataslice#;
$gq={};
$hq=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$iq=bless({$q,$hq,$s,$t},$u);
$jq={$L4,$iq};
$kq=q#/lib/dataslice_init.b#;
$lq=bless({$Q2,$gq,$J3,$K3,$L3,$K3,$M3,$jq,$D,$kq},$V3);
$mq={};
$nq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$oq=bless({$q,$nq,$s,$t},$u);
$pq={$Q3,$oq};
$qq=q#/lib/dataslice_apply.b#;
$rq=bless({$Q2,$mq,$J3,$K3,$L3,$K3,$M3,$pq,$D,$qq},$V3);
$sq=[$K5,$lq,$rq];
$tq=bless({$Q2,$eq,$D,$fq,$C3,$sq},$m3);
$uq=q#lib/dataslice.c::ctors#;
$vq=q#ni:/lib/dataslice.c#;
$wq={$m3,1};
$xq=q#/lib/dataslice.c#;
$yq=[$r7];
$zq=bless({$Q2,$wq,$D,$xq,$C3,$yq},$D3);
$Aq=q#ni:/lib/dataslice_apply.b#;
$Bq=q#ni:/lib/dataslice_init.b#;
$Cq=q#ni:/lib/definition.b#;
$Dq=q#ni:/lib/definition_def.b#;
$Eq=q#ni:/lib/definition_defdata.b#;
$Fq=q#ni:/lib/doc#;
$Gq={$F,1};
$Hq={};
$Iq=q#shift; +{name => shift, doc => []}#;
$Jq=bless({$q,$Iq,$s,$t},$u);
$Kq={$L4,$Jq};
$Lq=q#/lib/doc_init.b#;
$Mq=bless({$Q2,$Hq,$J3,$K3,$L3,$K3,$M3,$Kq,$D,$Lq},$V3);
$Nq={};
$Oq=q#'ni.doc'#;
$Pq=bless({$q,$Oq,$s,$t},$u);
$Qq={$l4,$Pq};
$Rq=q#/lib/doc_namespace.b#;
$Sq=bless({$Q2,$Nq,$J3,$K3,$L3,$K3,$M3,$Qq,$D,$Rq},$V3);
$Tq={};
$Uq=q#AUTOLOAD#;
$Vq=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Wq=bless({$q,$Vq,$s,$t},$u);
$Xq={$Uq,$Wq};
$Yq=q#/lib/doc_define.b#;
$Zq=bless({$Q2,$Tq,$J3,$K3,$L3,$K3,$M3,$Xq,$D,$Yq},$V3);
$cr={};
$dr=q#shift->referent#;
$er=bless({$q,$dr,$s,$t},$u);
$fr=q#referent#;
$gr=q#ni 'ni:' . shift->{name}#;
$hr=bless({$q,$gr,$s,$t},$u);
$ir={$Zk,$er,$fr,$hr};
$jr=q#/lib/doc_end.b#;
$kr=bless({$Q2,$cr,$J3,$K3,$L3,$K3,$M3,$ir,$D,$jr},$V3);
$lr={};
$mr=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$nr=bless({$q,$mr,$s,$t},$u);
$or=q#tests#;
$pr=q#\# TODO: not even close to the right way to do this.
my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$qr=bless({$q,$pr,$s,$t},$u);
$rr={$n,$nr,$or,$qr};
$sr=q#/lib/doc_test.b#;
$tr=bless({$Q2,$lr,$J3,$K3,$L3,$K3,$M3,$rr,$D,$sr},$V3);
$ur=[$z5,$i4,$Mq,$Sq,$Zq,$kr,$tr];
$vr=bless({$Q2,$Gq,$D,$H2,$C3,$ur},$n3);
$wr=q#lib/doc.c::ctors#;
$xr=q#ni:/lib/doc.c#;
$yr={$n3,1};
$zr=q#/lib/doc.c#;
$Ar=[$m7];
$Br=bless({$Q2,$yr,$D,$zr,$C3,$Ar},$D3);
$Cr=q#ni:/lib/doc_define.b#;
$Dr=q#ni:/lib/doc_end.b#;
$Er=q#ni:/lib/doc_init.b#;
$Fr=q#ni:/lib/doc_namespace.b#;
$Gr=q#ni:/lib/doc_test.b#;
$Hr=q#ni:/lib/documentable.b#;
$Ir=q#ni:/lib/fn#;
$Jr={$u,1};
$Kr=q#/lib/fn#;
$Lr={};
$Mr=q#shift->compile#;
$Nr=bless({$q,$Mr,$s,$t},$u);
$Or=q#compile#;
$Pr=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Qr=bless({$q,$Pr,$s,$t},$u);
$Rr=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Sr=bless({$q,$Rr,$s,$t},$u);
$Tr={$Or,$Qr,$L4,$Sr};
$Ur=q#/lib/fn_init.b#;
$Vr=bless({$Q2,$Lr,$J3,$Nr,$L3,$K3,$M3,$Tr,$D,$Ur},$V3);
$Wr={};
$Xr=[];
$Yr=q#shift->{'annotations'}#;
$Zr=bless({$o,$Xr,$q,$Yr,$s,$t},$u);
$cs=[];
$ds=q#shift->{'code'}#;
$es=bless({$o,$cs,$q,$ds,$s,$t},$u);
$fs=q#fn#;
$gs=[];
$hs=q#shift->{'fn'}#;
$is=bless({$o,$gs,$q,$hs,$s,$t},$u);
$js={$o,$Zr,$q,$es,$fs,$is};
$ks=q#/lib/fn_ro.b#;
$ls=bless({$Q2,$Wr,$J3,$K3,$L3,$K3,$M3,$js,$D,$ks},$V3);
$ms={};
$ns=[];
$os=q#shift->{code}#;
$ps=bless({$o,$ns,$q,$os,$s,$t},$u);
$qs=[];
$rs=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$ss=bless({$o,$qs,$q,$rs,$s,$t},$u);
$ts={$i6,$ps,$p6,$ss};
$us=q#/lib/fn_ops.b#;
$vs=bless({$Q2,$ms,$J3,$K3,$L3,$K3,$M3,$ts,$D,$us},$V3);
$ws={};
$xs=q#serialize#;
$ys=[];
$zs=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$As=bless({$o,$ys,$q,$zs,$s,$t},$u);
$Bs={$xs,$As};
$Cs=q#/lib/fn_serialize.b#;
$Ds=bless({$Q2,$ws,$J3,$K3,$L3,$K3,$M3,$Bs,$D,$Cs},$V3);
$Es=[$z5,$R6,$Vr,$ls,$vs,$Ds];
$Fs=bless({$Q2,$Jr,$D,$Kr,$C3,$Es},$o3);
$Gs=q#lib/fn.c::ctors#;
$Hs=q#ni:/lib/fn.c#;
$Is={$o3,1};
$Js=q#/lib/fn.c#;
$Ks=[$m7];
$Ls=bless({$Q2,$Is,$D,$Js,$C3,$Ks},$D3);
$Ms=q#ni:/lib/fn_init.b#;
$Ns=q#ni:/lib/fn_ops.b#;
$Os=q#ni:/lib/fn_ro.b#;
$Ps=q#ni:/lib/fn_serialize.b#;
$Qs=q#ni:/lib/gensym_generator_compact.b#;
$Rs={};
$Ss=q#gensym#;
$Ts=[];
$Us=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Vs=bless({$o,$Ts,$q,$Us,$s,$t},$u);
$Ws={$Ss,$Vs};
$Xs=q#/lib/gensym_generator_compact.b#;
$Ys=bless({$Q2,$Rs,$J3,$K3,$L3,$K3,$M3,$Ws,$D,$Xs},$V3);
$Zs=q#ni:/lib/global_static_test.b#;
$ct={};
$dt=q#now#;
$et=[];
$ft=q#ni('ni:/lib/test_value')->new(shift)#;
$gt=q#($)#;
$ht=bless({$o,$et,$q,$ft,$s,$gt},$u);
$it={$dt,$ht};
$jt=q#/lib/global_static_test.b#;
$kt=bless({$Q2,$ct,$J3,$K3,$L3,$K3,$M3,$it,$D,$jt},$V3);
$lt=q#ni:/lib/image#;
$mt={$k5,1};
$nt=q#/lib/image#;
$ot={};
$pt=[];
$qt=q#+{gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$rt=bless({$o,$pt,$q,$qt,$s,$t},$u);
$st={$L4,$rt};
$tt=q#/lib/image_init.b#;
$ut=bless({$Q2,$ot,$J3,$K3,$L3,$K3,$M3,$st,$D,$tt},$V3);
$vt={};
$wt=q#address#;
$xt=[];
$yt=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$zt=bless({$o,$xt,$q,$yt,$s,$t},$u);
$At=q#allocate_gensym#;
$Bt=[];
$Ct=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Dt=bless({$o,$Bt,$q,$Ct,$s,$t},$u);
$Et=q#boot_side_effect#;
$Ft=[];
$Gt=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ht=bless({$o,$Ft,$q,$Gt,$s,$t},$u);
$It=q#circular_links#;
$Jt=[];
$Kt=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Lt=bless({$o,$Jt,$q,$Kt,$s,$t},$u);
$Mt=q#finalizer#;
$Nt=[];
$Ot=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Pt=bless({$o,$Nt,$q,$Ot,$s,$t},$u);
$Qt=q#quote#;
$Rt=[];
$St=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? '0' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Tt=bless({$o,$Rt,$q,$St,$s,$t},$u);
$Ut=q#reconstruction#;
$Vt=[];
$Wt=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Xt=bless({$o,$Vt,$q,$Wt,$s,$t},$u);
$Yt=q#side_effect#;
$Zt=[];
$cu=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$du=bless({$o,$Zt,$q,$cu,$s,$t},$u);
$eu=[];
$fu=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  "\#!/usr/bin/env perl\\n",
  "chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", $self->reconstruction),
  "ni->run(\\@ARGV);", "\\n__DATA__\\n";#;
$gu=bless({$o,$eu,$q,$fu,$s,$t},$u);
$hu={$wt,$zt,$At,$Dt,$Et,$Ht,$It,$Lt,$Mt,$Pt,$Qt,$Tt,$Ut,$Xt,$Yt,$du,$J9,$gu};
$iu=q#/lib/image_quoting.b#;
$ju=bless({$Q2,$vt,$J3,$K3,$L3,$K3,$M3,$hu,$D,$iu},$V3);
$ku={};
$lu=q#quote_code#;
$mu=[];
$nu=q#shift->die('cannot quote perl CODE refs', shift)#;
$ou=bless({$o,$mu,$q,$nu,$s,$t},$u);
$pu={$lu,$ou};
$qu=q#/lib/quote_code_fail.b#;
$ru=bless({$Q2,$ku,$J3,$K3,$L3,$K3,$M3,$pu,$D,$qu},$V3);
$su={};
$tu=q#quote_array#;
$uu=[];
$vu=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
  for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$wu=bless({$o,$uu,$q,$vu,$s,$t},$u);
$xu=q#quote_hash#;
$yu=[];
$zu=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  $self->circular_hashref($v, $k, $$v{$k})
    if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Au=bless({$o,$yu,$q,$zu,$s,$t},$u);
$Bu=q#quote_scalar#;
$Cu=[];
$Du=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Eu=bless({$o,$Cu,$q,$Du,$s,$t},$u);
$Fu=q#quote_scalar_ref#;
$Gu=[];
$Hu=q#'\\\\' . shift->quote(${$_[0]})#;
$Iu=bless({$o,$Gu,$q,$Hu,$s,$t},$u);
$Ju=q#quote_value#;
$Ku=[];
$Lu=q#my $self = shift;
return $self->quote_scalar($_[0])     unless ref $_[0];
return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
$self->quote_object($_[0]);#;
$Mu=bless({$o,$Ku,$q,$Lu,$s,$t},$u);
$Nu={$tu,$wu,$xu,$Au,$Bu,$Eu,$Fu,$Iu,$Ju,$Mu};
$Ou=q#/lib/quote_values.b#;
$Pu=bless({$Q2,$su,$J3,$K3,$L3,$K3,$M3,$Nu,$D,$Ou},$V3);
$Qu={};
$Ru=q#quote_blessed#;
$Su=[];
$Tu=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Uu=bless({$o,$Su,$q,$Tu,$s,$t},$u);
$Vu=q#quote_class#;
$Wu=[];
$Xu=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Yu=bless({$o,$Wu,$q,$Xu,$s,$t},$u);
$Zu=q#quote_object#;
$cv=[];
$dv=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$ev=bless({$o,$cv,$q,$dv,$s,$t},$u);
$fv={$Ru,$Uu,$Vu,$Yu,$Zu,$ev};
$gv=q#/lib/quote_objects.b#;
$hv=bless({$Q2,$Qu,$J3,$K3,$L3,$K3,$M3,$fv,$D,$gv},$V3);
$iv={};
$jv=q#circular_arrayref#;
$kv=[];
$lv=q#my $self          = shift;
my $address       = $self->address(shift);
my $index         = shift;
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "[$index]", $value_address];
$self;#;
$mv=bless({$o,$kv,$q,$lv,$s,$t},$u);
$nv=q#circular_hashref#;
$ov=[];
$pv=q#my $self          = shift;
my $address       = $self->address(shift);
my $quoted_key    = $self->quote(shift);
my $value_address = $self->address(shift);
push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
$self;#;
$qv=bless({$o,$ov,$q,$pv,$s,$t},$u);
$rv=q#is_circular#;
$sv=[];
$tv=q#my $self = shift;
ref $$self{visited}{$self->address(shift)};#;
$uv=bless({$o,$sv,$q,$tv,$s,$t},$u);
$vv={$jv,$mv,$nv,$qv,$rv,$uv};
$wv=q#/lib/quote_circular_addressed.b#;
$xv=bless({$Q2,$iv,$J3,$K3,$L3,$K3,$M3,$vv,$D,$wv},$V3);
$yv=[$z5,$ut,$ju,$ru,$Pu,$hv,$xv,$Ys];
$zv=bless({$Q2,$mt,$D,$nt,$C3,$yv},$p3);
$Av=q#lib/image.c::ctors#;
$Bv=q#ni:/lib/image.c#;
$Cv={$p3,1};
$Dv=q#/lib/image.c#;
$Ev=[$m7];
$Fv=bless({$Q2,$Cv,$D,$Dv,$C3,$Ev},$D3);
$Gv=q#ni:/lib/image_init.b#;
$Hv=q#ni:/lib/image_quoting.b#;
$Iv=q#ni:/lib/instance.b#;
$Jv=q#ni:/lib/instantiable.b#;
$Kv=q#ni:/lib/json.b#;
$Lv={};
$Mv=q#json_decode#;
$Nv=[];
$Ov=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Pv=bless({$o,$Nv,$q,$Ov,$s,$gt},$u);
$Qv=q#json_encode#;
$Rv=[];
$Sv=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Tv=bless({$o,$Rv,$q,$Sv,$s,$gt},$u);
$Uv=q#json_escape#;
$Vv=[];
$Wv=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Xv=bless({$o,$Vv,$q,$Wv,$s,$gt},$u);
$Yv=q#json_unescape#;
$Zv=[];
$cw=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$dw=bless({$o,$Zv,$q,$cw,$s,$gt},$u);
$ew=q#json_unescape_one#;
$fw=[];
$gw=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$hw=bless({$o,$fw,$q,$gw,$s,$gt},$u);
$iw={$Mv,$Pv,$Qv,$Tv,$Uv,$Xv,$Yv,$dw,$ew,$hw};
$jw=q#/lib/json.b#;
$kw=bless({$Q2,$Lv,$J3,$K3,$L3,$K3,$M3,$iw,$D,$jw},$V3);
$lw=q#ni#;
$mw=q#ni:/lib/name_as_string.b#;
$nw=q#ni:/lib/named.b#;
$ow=q#ni:/lib/named_in_ni.b#;
$pw=q#ni:/lib/namespaced.b#;
$qw=q#ni:/lib/ni#;
$rw={$l5,1};
$sw=q#/lib/ni#;
$tw={};
$uw=q#extend#;
$vw=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$ww=bless({$q,$vw,$s,$t},$u);
$xw=q#is_mutable#;
$yw=q#$0 ne "-" && -w $0#;
$zw=bless({$q,$yw,$s,$t},$u);
$Aw=q#modify#;
$Bw=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Cw=bless({$q,$Bw,$s,$t},$u);
$Dw={$uw,$ww,$xw,$zw,$Aw,$Cw};
$Ew=q#/lib/ni_self.b#;
$Fw=bless({$Q2,$tw,$J3,$K3,$L3,$K3,$M3,$Dw,$D,$Ew},$V3);
$Gw={};
$Hw=q#--internal/+=#;
$Iw=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Jw=bless({$q,$Iw,$s,$t},$u);
$Kw=q#--internal/eval#;
$Lw=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Mw=bless({$q,$Lw,$s,$t},$u);
$Nw=q#--internal/image#;
$Ow=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Pw=bless({$q,$Ow,$s,$t},$u);
$Qw=q#--internal/test#;
$Rw=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Sw=bless({$q,$Rw,$s,$t},$u);
$Tw=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Uw=bless({$q,$Tw,$s,$t},$u);
$Vw={$Hw,$Jw,$Kw,$Mw,$Nw,$Pw,$Qw,$Sw,$ko,$Uw};
$Ww=q#/lib/ni_main.b#;
$Xw=bless({$Q2,$Gw,$J3,$K3,$L3,$K3,$M3,$Vw,$D,$Ww},$V3);
$Yw={};
$Zw=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$cx=bless({$q,$Zw,$s,$t},$u);
$dx=q#resolver_for#;
$ex=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$fx=bless({$q,$ex,$s,$t},$u);
$gx={$z4,$cx,$dx,$fx};
$hx=q#/lib/ni_resolver.b#;
$ix=bless({$Q2,$Yw,$J3,$K3,$L3,$K3,$M3,$gx,$D,$hx},$V3);
$jx={};
$kx=q#exists#;
$lx=q#exists $_[0]->{named}{$_[1]}#;
$mx=bless({$q,$lx,$s,$t},$u);
$nx=q#quoted#;
$ox=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$px=bless({$q,$ox,$s,$t},$u);
$qx={$kx,$mx,$nx,$px};
$rx=q#/lib/ni_image.b#;
$sx=bless({$Q2,$jx,$J3,$K3,$L3,$K3,$M3,$qx,$D,$rx},$V3);
$tx=[$z5,$Fw,$Xw,$ix,$sx];
$ux=bless({$Q2,$rw,$D,$sw,$C3,$tx},$q3);
$vx=q#lib/ni.c::ctors#;
$wx=q#ni:/lib/ni.c#;
$xx={$q3,1};
$yx=q#/lib/ni.c#;
$zx=[$m7];
$Ax=bless({$Q2,$xx,$D,$yx,$C3,$zx},$D3);
$Bx=q#ni:/lib/ni_image.b#;
$Cx=q#ni:/lib/ni_main.b#;
$Dx=q#ni:/lib/ni_resolver.b#;
$Ex=q#ni:/lib/ni_self.b#;
$Fx=q#ni:/lib/ni_static_util.b#;
$Gx={};
$Hx=q#abbrev#;
$Ix=[];
$Jx=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Kx=bless({$o,$Ix,$q,$Jx,$s,$t},$u);
$Lx=q#dor#;
$Mx=[];
$Nx=q#defined $_[0] ? $_[0] : $_[1]#;
$Ox=bless({$o,$Mx,$q,$Nx,$s,$t},$u);
$Px=q#indent#;
$Qx=[];
$Rx=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Sx=bless({$o,$Qx,$q,$Rx,$s,$t},$u);
$Tx=q#max#;
$Ux=[];
$Vx=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Wx=bless({$o,$Ux,$q,$Vx,$s,$t},$u);
$Xx=q#maxstr#;
$Yx=[];
$Zx=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$cy=bless({$o,$Yx,$q,$Zx,$s,$t},$u);
$dy=q#mean#;
$ey=[];
$fy=q#sum(@_) / (@_ || 1)#;
$gy=bless({$o,$ey,$q,$fy,$s,$t},$u);
$hy=q#min#;
$iy=[];
$jy=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$ky=bless({$o,$iy,$q,$jy,$s,$t},$u);
$ly=q#minstr#;
$my=[];
$ny=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$oy=bless({$o,$my,$q,$ny,$s,$t},$u);
$py=q#sgr#;
$qy=[];
$ry=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$sy=bless({$o,$qy,$q,$ry,$s,$t},$u);
$ty=q#sr#;
$uy=[];
$vy=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$wy=bless({$o,$uy,$q,$vy,$s,$t},$u);
$xy=q#sum#;
$yy=[];
$zy=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Ay=bless({$o,$yy,$q,$zy,$s,$t},$u);
$By=q#swap#;
$Cy=[];
$Dy=q#@_[0, 1] = @_[1, 0]#;
$Ey=bless({$o,$Cy,$q,$Dy,$s,$t},$u);
$Fy={$Hx,$Kx,$Lx,$Ox,$Px,$Sx,$Tx,$Wx,$Xx,$cy,$dy,$gy,$hy,$ky,$ly,$oy,$py,$sy,$ty,$wy,$xy,$Ay,$By,$Ey};
$Gy=q#/lib/ni_static_util.b#;
$Hy=bless({$Q2,$Gx,$J3,$K3,$L3,$K3,$M3,$Fy,$D,$Gy},$V3);
$Iy=q#ni:/lib/perlbranch.b#;
$Jy=q#ni:/lib/quote_circular_addressed.b#;
$Ky=q#ni:/lib/quote_code_fail.b#;
$Ly=q#ni:/lib/quote_objects.b#;
$My=q#ni:/lib/quote_simple#;
$Ny={$m5,1};
$Oy=q#/lib/quote_simple#;
$Py={};
$Qy=[];
$Ry=q#+{}#;
$Sy=bless({$o,$Qy,$q,$Ry,$s,$t},$u);
$Ty={$L4,$Sy};
$Uy=q#/lib/quote_simple_init.b#;
$Vy=bless({$Q2,$Py,$J3,$K3,$L3,$K3,$M3,$Ty,$D,$Uy},$V3);
$Wy={};
$Xy=[];
$Yy=bless({$o,$Xy,$q,0,$s,$t},$u);
$Zy=[];
$cz=q#shift->quote_value(shift)#;
$dz=bless({$o,$Zy,$q,$cz,$s,$t},$u);
$ez={$rv,$Yy,$Qt,$dz};
$fz=q#/lib/quote_simple_quote.b#;
$gz=bless({$Q2,$Wy,$J3,$K3,$L3,$K3,$M3,$ez,$D,$fz},$V3);
$hz=[$z5,$Vy,$gz,$ru,$Pu,$hv];
$iz=bless({$Q2,$Ny,$D,$Oy,$C3,$hz},$r3);
$jz=q#lib/quote_simple.c::ctors#;
$kz=q#ni:/lib/quote_simple.c#;
$lz={$r3,1};
$mz=q#/lib/quote_simple.c#;
$nz=[$m7];
$oz=bless({$Q2,$lz,$D,$mz,$C3,$nz},$D3);
$pz=q#ni:/lib/quote_simple_init.b#;
$qz=q#ni:/lib/quote_simple_quote.b#;
$rz=q#ni:/lib/quote_values.b#;
$sz=q#ni:/lib/ref_eq.b#;
$tz=q#ni:/lib/resolver.b#;
$uz=q#ni:/lib/slice#;
$vz={$V3,1};
$wz=q#/lib/slice#;
$xz=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$yz=bless({$q,$xz,$s,$t},$u);
$zz=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Az=bless({$q,$zz,$s,$t},$u);
$Bz=q#lib/slice::apply#;
$Cz=q#lib/slice::apply_unsafe#;
$Dz={};
$Ez=q#apply_unsafe#;
$Fz={$Q3,$yz,$Ez,$Az};
$Gz=q#/lib/slice.b#;
$Hz=bless({$Q2,$Dz,$M3,$Fz,$D,$Gz},$V3);
$Iz={};
$Jz=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Kz=bless({$q,$Jz,$s,$t},$u);
$Lz={$L4,$Kz};
$Mz=q#/lib/slice_init.b#;
$Nz=bless({$Q2,$Iz,$M3,$Lz,$D,$Mz},$V3);
$Oz={};
$Pz=[];
$Qz=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Rz=bless({$o,$Pz,$q,$Qz,$s,$t},$u);
$Sz={$xs,$Rz};
$Tz=q#/lib/slice_serialize.b#;
$Uz=bless({$Q2,$Oz,$J3,$K3,$L3,$K3,$M3,$Sz,$D,$Tz},$V3);
$Vz=[$K5,$i4,$Hz,$Nz,$Uz];
$Wz=bless({$Q2,$vz,$D,$wz,$C3,$Vz},$s3);
$Xz=q#lib/slice.c::ctors#;
$Yz=q#ni:/lib/slice.b#;
$Zz=q#ni:/lib/slice.c#;
$cA={$s3,1};
$dA=q#/lib/slice.c#;
$eA=[$r7];
$fA=bless({$Q2,$cA,$D,$dA,$C3,$eA},$D3);
$gA=q#ni:/lib/slice_init.b#;
$hA=q#ni:/lib/slice_serialize.b#;
$iA=q#ni:/lib/static_fn.b#;
$jA={};
$kA=[];
$lA=q#ni('ni:/lib/fn')->new(@_)#;
$mA=bless({$o,$kA,$q,$lA,$s,$gt},$u);
$nA=q#fp#;
$oA=[];
$pA=q#($$)#;
$qA=bless({$o,$oA,$q,$lA,$s,$pA},$u);
$rA={$fs,$mA,$nA,$qA};
$sA=q#/lib/static_fn.b#;
$tA=bless({$Q2,$jA,$J3,$K3,$L3,$K3,$M3,$rA,$D,$sA},$V3);
$uA=q#ni:/lib/subclass.b#;
$vA=q#ni:/lib/tag#;
$wA={$j4,1};
$xA=q#/lib/tag#;
$yA={};
$zA=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$AA=bless({$q,$zA,$s,$t},$u);
$BA={$Q3,$AA};
$CA=q#/lib/tag.b#;
$DA=bless({$Q2,$yA,$J3,$K3,$L3,$K3,$M3,$BA,$D,$CA},$V3);
$EA={};
$FA=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$GA=bless({$q,$FA,$s,$t},$u);
$HA={$L4,$GA};
$IA=q#/lib/tag_init.b#;
$JA=bless({$Q2,$EA,$J3,$K3,$L3,$K3,$M3,$HA,$D,$IA},$V3);
$KA=[$K5,$i4,$DA,$JA];
$LA=bless({$Q2,$wA,$D,$xA,$C3,$KA},$t3);
$MA=q#lib/tag.c::ctors#;
$NA=q#ni:/lib/tag.b#;
$OA=q#ni:/lib/tag.c#;
$PA={$t3,1};
$QA=q#/lib/tag.c#;
$RA=[$r7];
$SA=bless({$Q2,$PA,$D,$QA,$C3,$RA},$D3);
$TA=q#ni:/lib/tag_init.b#;
$UA=q#ni:/lib/test_value#;
$VA={$n5,1};
$WA=q#/lib/test_value#;
$XA={};
$YA=[];
$ZA=q#\\$_[1]#;
$cB=bless({$o,$YA,$q,$ZA,$s,$t},$u);
$dB={$L4,$cB};
$eB=q#/lib/test_value_init.b#;
$fB=bless({$Q2,$XA,$J3,$K3,$L3,$K3,$M3,$dB,$D,$eB},$V3);
$gB={};
$hB=q#(==#;
$iB=[];
$jB=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$kB=bless({$o,$iB,$q,$jB,$s,$t},$u);
$lB=q#diff#;
$mB=[];
$nB=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
    unless @$lhs == @$rhs;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]}
    unless !defined($lhs) && !defined($rhs) || $lhs eq $rhs;
}
return undef;#;
$oB=bless({$o,$mB,$q,$nB,$s,$t},$u);
$pB={$hB,$kB,$lB,$oB};
$qB=q#/lib/test_value_eq.b#;
$rB=bless({$Q2,$gB,$J3,$K3,$L3,$K3,$M3,$pB,$D,$qB},$V3);
$sB={};
$tB=[];
$uB=q#ni::json_encode ${$_[0]}#;
$vB=bless({$o,$tB,$q,$uB,$s,$t},$u);
$wB={$i6,$vB};
$xB=q#/lib/test_value_str.b#;
$yB=bless({$Q2,$sB,$J3,$K3,$L3,$K3,$M3,$wB,$D,$xB},$V3);
$zB=[$z5,$fB,$rB,$yB];
$AB=bless({$Q2,$VA,$D,$WA,$C3,$zB},$u3);
$BB=q#lib/test_value.c::ctors#;
$CB=q#ni:/lib/test_value.c#;
$DB={$u3,1};
$EB=q#/lib/test_value.c#;
$FB=[$m7];
$GB=bless({$Q2,$DB,$D,$EB,$C3,$FB},$D3);
$HB=q#ni:/lib/test_value_eq.b#;
$IB=q#ni:/lib/test_value_init.b#;
$JB=q#ni:/lib/test_value_str.b#;
$KB=q#ni:/metaclass#;
$LB={$D3,1};
$MB=q#/metaclass#;
$NB=[$G4,$R6,$Q4,$G6];
$OB=bless({$Q2,$LB,$D,$MB,$C3,$NB},$v3);
$PB=q#metaclass.c::ctors#;
$QB=q#ni:/metaclass.c#;
$RB={$v3,1};
$SB=q#/metaclass.c#;
$TB=[$c7];
$UB=bless({$Q2,$RB,$D,$SB,$C3,$TB},$D3);
$VB=q#ni:/module#;
$WB=q#ni:/module.c#;
$XB=q#ni:/object#;
$YB=q#ni:/object.c#;
$ZB=q#ni:/semantic/dimension#;
$cC={$y3,1};
$dC=q#/semantic/dimension#;
$eC=[$c7];
$fC=bless({$Q2,$cC,$D,$dC,$C3,$eC},$z3);
$gC=q#semantic/dimension.c::ctors#;
$hC=q#ni:/semantic/dimension.c#;
$iC={$z3,1};
$jC=q#/semantic/dimension.c#;
$kC=[$v7];
$lC=bless({$Q2,$iC,$D,$jC,$C3,$kC},$D3);
$mC=q#ni:/semantic/task#;
$nC=q#ni:/semantic/task.c#;
$oC=q#ni:/semantic/task_outcome.b#;
$pC=q#ni:/semantic/task_ro.b#;
$qC=q#ni:main#;
$rC={$zi,1};
$sC=[$tA,$kt,$yi];
$tC=bless({$Q2,$rC,$D,$zi,$C3,$sC},$E3);
$uC=q#module::ctors#;
$vC=q#ni:ni#;
$wC={$lw,1};
$xC={$lw,1};
$yC=q#json_escapes#;
$zC=q##;
$AC=q#b#;
$BC=q#	#;
$CC=q#t#;
$DC=q#
#;
$EC=q#n#;
$FC=q##;
$GC=q#"#;
$HC=q#/#;
$IC=q#\\#;
$JC={$zC,$AC,$BC,$CC,$DC,$EC,$FC,$We,$GC,$GC,$HC,$HC,$IC,$IC};
$KC=q#json_unescapes#;
$LC={$GC,$GC,$HC,$HC,$IC,$IC,$AC,$zC,$EC,$DC,$We,$FC,$CC,$BC};
$MC={$yC,$JC,$KC,$LC};
$NC=q#/lib/json_data.b#;
$OC=bless({$Q2,$xC,$Vk,$MC,$D,$NC},$j5);
$PC=q#lib/dataslice::ctors#;
$QC=[$OC,$kw,$Hy];
$RC=bless({$Q2,$wC,$D,$lw,$C3,$QC},$E3);
$SC={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$y1,$z1,$K1,$L1,$T1,$U1,$l2,$m2,$s2,$t2,$I2,$J2,$O2,$P2,$c7,$e7,$v7,$w7,$H7,$J7,$N7,$O7,$F7,$P7,$V9,$X9,$pa,$qa,$z9,$ra,$T9,$sa,$Ja,$La,$Pa,$Qa,$Aa,$Ra,$Ha,$Sa,$Ec,$Gc,$Kc,$Lc,$mc,$Mc,$Cc,$Nc,$kb,$Oc,$ec,$Pc,$Eb,$Qc,$db,$Rc,$ge,$ie,$me,$ne,$Hd,$oe,$Sd,$pe,$jd,$qe,$ee,$re,$cd,$se,$rd,$te,$qf,$sf,$wf,$xf,$Ke,$yf,$Re,$zf,$of,$Af,$Ce,$Bf,$Kg,$Mg,$Qg,$Rg,$Nh,$Ph,$Ig,$Qh,$Uh,$Vh,$sh,$Wh,$Lh,$Xh,$yh,$Yh,$lh,$Zh,$Vf,$ci,$sg,$di,$Of,$ei,$fg,$fi,$yi,$Ai,$Yi,$cj,$gj,$hj,$Ji,$ij,$Wi,$jj,$r9,$kj,$na,$lj,$la,$mj,$v8,$nj,$D8,$oj,$P8,$pj,$Z7,$qj,$p9,$rj,$d9,$sj,$Fk,$Hk,$Lk,$Mk,$Dk,$Nk,$Pj,$Ok,$nk,$Pk,$Fj,$Qk,$dk,$Rk,$Il,$Kl,$Ol,$Pl,$sl,$Ql,$Gl,$Rl,$ll,$Sl,$gn,$in,$xn,$yn,$vn,$zn,$yo,$Ao,$To,$Uo,$Ro,$Vo,$Wn,$Wo,$io,$Xo,$Pn,$Yo,$uo,$Zo,$Im,$cp,$en,$dp,$vp,$xp,$Bp,$Cp,$mp,$Dp,$tp,$Ep,$g6,$Fp,$K5,$Gp,$r7,$Hp,$Rp,$Tp,$W3,$Up,$Yp,$Zp,$Pp,$cq,$Q4,$dq,$tq,$vq,$zq,$Aq,$rq,$Bq,$lq,$Cq,$D6,$Dq,$U5,$Eq,$B6,$Fq,$vr,$xr,$Br,$Cr,$Zq,$Dr,$kr,$Er,$Mq,$Fr,$Sq,$Gr,$tr,$Hr,$I5,$Ir,$Fs,$Hs,$Ls,$Ms,$Vr,$Ns,$vs,$Os,$ls,$Ps,$Ds,$Qs,$Ys,$Zs,$kt,$lt,$zv,$Bv,$Fv,$Gv,$ut,$Hv,$ju,$Iv,$x5,$Jv,$R6,$Kv,$kw,$mw,$n6,$nw,$i4,$ow,$q4,$pw,$x4,$qw,$ux,$wx,$Ax,$Bx,$sx,$Cx,$Xw,$Dx,$ix,$Ex,$Fw,$Fx,$Hy,$Iy,$G4,$Jy,$xv,$Ky,$ru,$Ly,$hv,$My,$iz,$kz,$oz,$pz,$Vy,$qz,$gz,$rz,$Pu,$sz,$u6,$tz,$E4,$uz,$Wz,$Yz,$Hz,$Zz,$fA,$gA,$Nz,$hA,$Uz,$iA,$tA,$uA,$Y6,$vA,$LA,$NA,$DA,$OA,$SA,$TA,$JA,$UA,$AB,$CB,$GB,$HB,$rB,$IB,$fB,$JB,$yB,$KB,$OB,$QB,$UB,$VB,$G6,$WB,$t7,$XB,$z5,$YB,$m7,$ZB,$fC,$hC,$lC,$mC,$um,$nC,$on,$oC,$sm,$pC,$gm,$qC,$tC,$vC,$RC};
$TC=q#resolvers#;
$UC=[];
$VC=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$WC=bless({$o,$UC,$q,$VC,$s,$t},$u);
$XC=q#file#;
$YC=[];
$ZC=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$cD=bless({$o,$YC,$q,$ZC,$s,$t},$u);
$dD=q#null#;
$eD=[];
$fD=q#ni('ni:/io/null')->new#;
$gD=bless({$o,$eD,$q,$fD,$s,$t},$u);
$hD=q#sh#;
$iD=[];
$jD=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$kD=bless({$o,$iD,$q,$jD,$s,$t},$u);
$lD=q#str#;
$mD=[];
$nD=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$oD=bless({$o,$mD,$q,$nD,$s,$t},$u);
$pD={$Kb,$WC,$XC,$cD,$dD,$gD,$hD,$kD,$lD,$oD};
$qD=bless({$c,$SC,$TC,$pD},$l5);
$rD=q#lib/ni::ctors#;
*$Cz=\&$Az;
*$Bz=\&$yz;
$W3->apply_unsafe($R2);
$W3->apply_unsafe($S2);
$W3->apply_unsafe($T2);
$W3->apply_unsafe($U2);
$W3->apply_unsafe($V2);
$W3->apply_unsafe($W2);
$W3->apply_unsafe($X2);
$W3->apply_unsafe($Y2);
$W3->apply_unsafe($Z2);
$W3->apply_unsafe($c3);
$W3->apply_unsafe($d3);
$W3->apply_unsafe($e3);
$W3->apply_unsafe($f3);
$W3->apply_unsafe($g3);
$W3->apply_unsafe($h3);
$W3->apply_unsafe($i3);
$W3->apply_unsafe($j3);
$W3->apply_unsafe($k3);
$W3->apply_unsafe($X3);
$W3->apply_unsafe($l3);
$W3->apply_unsafe($m3);
$W3->apply_unsafe($n3);
$W3->apply_unsafe($o3);
$W3->apply_unsafe($p3);
$W3->apply_unsafe($q3);
$W3->apply_unsafe($r3);
$W3->apply_unsafe($s3);
$W3->apply_unsafe($t3);
$W3->apply_unsafe($u3);
$W3->apply_unsafe($D3);
$W3->apply_unsafe($v3);
$W3->apply_unsafe($E3);
$W3->apply_unsafe($w3);
$W3->apply_unsafe($x3);
$W3->apply_unsafe($y3);
$W3->apply_unsafe($z3);
$W3->apply_unsafe($A3);
$i4->apply_unsafe($R2);
$i4->apply_unsafe($S2);
$i4->apply_unsafe($T2);
$i4->apply_unsafe($U2);
$i4->apply_unsafe($V2);
$i4->apply_unsafe($W2);
$i4->apply_unsafe($X2);
$i4->apply_unsafe($Y2);
$i4->apply_unsafe($Z2);
$i4->apply_unsafe($c3);
$i4->apply_unsafe($d3);
$i4->apply_unsafe($e3);
$i4->apply_unsafe($f3);
$i4->apply_unsafe($g3);
$i4->apply_unsafe($h3);
$i4->apply_unsafe($i3);
$i4->apply_unsafe($j3);
$i4->apply_unsafe($k3);
$i4->apply_unsafe($X3);
$i4->apply_unsafe($l3);
$i4->apply_unsafe($m3);
$i4->apply_unsafe($F);
$i4->apply_unsafe($n3);
$i4->apply_unsafe($o3);
$i4->apply_unsafe($p3);
$i4->apply_unsafe($q3);
$i4->apply_unsafe($r3);
$i4->apply_unsafe($V3);
$i4->apply_unsafe($s3);
$i4->apply_unsafe($j4);
$i4->apply_unsafe($t3);
$i4->apply_unsafe($u3);
$i4->apply_unsafe($D3);
$i4->apply_unsafe($v3);
$i4->apply_unsafe($E3);
$i4->apply_unsafe($w3);
$i4->apply_unsafe($x3);
$i4->apply_unsafe($y3);
$i4->apply_unsafe($z3);
$i4->apply_unsafe($A3);
$q4->apply_unsafe($R2);
$q4->apply_unsafe($S2);
$q4->apply_unsafe($T2);
$q4->apply_unsafe($U2);
$q4->apply_unsafe($V2);
$q4->apply_unsafe($W2);
$q4->apply_unsafe($X2);
$q4->apply_unsafe($Y2);
$q4->apply_unsafe($Z2);
$q4->apply_unsafe($c3);
$q4->apply_unsafe($d3);
$q4->apply_unsafe($e3);
$q4->apply_unsafe($f3);
$q4->apply_unsafe($g3);
$q4->apply_unsafe($h3);
$q4->apply_unsafe($i3);
$q4->apply_unsafe($j3);
$q4->apply_unsafe($k3);
$q4->apply_unsafe($X3);
$q4->apply_unsafe($l3);
$q4->apply_unsafe($m3);
$q4->apply_unsafe($n3);
$q4->apply_unsafe($o3);
$q4->apply_unsafe($p3);
$q4->apply_unsafe($q3);
$q4->apply_unsafe($r3);
$q4->apply_unsafe($V3);
$q4->apply_unsafe($s3);
$q4->apply_unsafe($j4);
$q4->apply_unsafe($t3);
$q4->apply_unsafe($u3);
$q4->apply_unsafe($D3);
$q4->apply_unsafe($v3);
$q4->apply_unsafe($E3);
$q4->apply_unsafe($w3);
$q4->apply_unsafe($x3);
$q4->apply_unsafe($y3);
$q4->apply_unsafe($z3);
$q4->apply_unsafe($A3);
$x4->apply_unsafe($R2);
$x4->apply_unsafe($S2);
$x4->apply_unsafe($T2);
$x4->apply_unsafe($U2);
$x4->apply_unsafe($V2);
$x4->apply_unsafe($W2);
$x4->apply_unsafe($X2);
$x4->apply_unsafe($Y2);
$x4->apply_unsafe($Z2);
$x4->apply_unsafe($c3);
$x4->apply_unsafe($d3);
$x4->apply_unsafe($e3);
$x4->apply_unsafe($f3);
$x4->apply_unsafe($g3);
$x4->apply_unsafe($h3);
$x4->apply_unsafe($i3);
$x4->apply_unsafe($j3);
$x4->apply_unsafe($k3);
$x4->apply_unsafe($X3);
$x4->apply_unsafe($l3);
$x4->apply_unsafe($m3);
$x4->apply_unsafe($n3);
$x4->apply_unsafe($o3);
$x4->apply_unsafe($p3);
$x4->apply_unsafe($q3);
$x4->apply_unsafe($r3);
$x4->apply_unsafe($V3);
$x4->apply_unsafe($s3);
$x4->apply_unsafe($j4);
$x4->apply_unsafe($t3);
$x4->apply_unsafe($u3);
$x4->apply_unsafe($D3);
$x4->apply_unsafe($v3);
$x4->apply_unsafe($E3);
$x4->apply_unsafe($w3);
$x4->apply_unsafe($x3);
$x4->apply_unsafe($y3);
$x4->apply_unsafe($z3);
$x4->apply_unsafe($A3);
$E4->apply_unsafe($R2);
$E4->apply_unsafe($S2);
$E4->apply_unsafe($T2);
$E4->apply_unsafe($U2);
$E4->apply_unsafe($V2);
$E4->apply_unsafe($W2);
$E4->apply_unsafe($X2);
$E4->apply_unsafe($Y2);
$E4->apply_unsafe($Z2);
$E4->apply_unsafe($c3);
$E4->apply_unsafe($d3);
$E4->apply_unsafe($e3);
$E4->apply_unsafe($f3);
$E4->apply_unsafe($g3);
$E4->apply_unsafe($h3);
$E4->apply_unsafe($i3);
$E4->apply_unsafe($j3);
$E4->apply_unsafe($k3);
$E4->apply_unsafe($X3);
$E4->apply_unsafe($l3);
$E4->apply_unsafe($m3);
$E4->apply_unsafe($n3);
$E4->apply_unsafe($o3);
$E4->apply_unsafe($p3);
$E4->apply_unsafe($q3);
$E4->apply_unsafe($r3);
$E4->apply_unsafe($s3);
$E4->apply_unsafe($j4);
$E4->apply_unsafe($t3);
$E4->apply_unsafe($u3);
$E4->apply_unsafe($D3);
$E4->apply_unsafe($v3);
$E4->apply_unsafe($E3);
$E4->apply_unsafe($w3);
$E4->apply_unsafe($x3);
$E4->apply_unsafe($y3);
$E4->apply_unsafe($z3);
$E4->apply_unsafe($A3);
$Q4->apply_unsafe($R2);
$Q4->apply_unsafe($S2);
$Q4->apply_unsafe($T2);
$Q4->apply_unsafe($U2);
$Q4->apply_unsafe($V2);
$Q4->apply_unsafe($W2);
$Q4->apply_unsafe($X2);
$Q4->apply_unsafe($Y2);
$Q4->apply_unsafe($Z2);
$Q4->apply_unsafe($c3);
$Q4->apply_unsafe($d3);
$Q4->apply_unsafe($e3);
$Q4->apply_unsafe($f3);
$Q4->apply_unsafe($g3);
$Q4->apply_unsafe($h3);
$Q4->apply_unsafe($i3);
$Q4->apply_unsafe($j3);
$Q4->apply_unsafe($k3);
$Q4->apply_unsafe($l3);
$Q4->apply_unsafe($m3);
$Q4->apply_unsafe($n3);
$Q4->apply_unsafe($o3);
$Q4->apply_unsafe($p3);
$Q4->apply_unsafe($q3);
$Q4->apply_unsafe($r3);
$Q4->apply_unsafe($s3);
$Q4->apply_unsafe($t3);
$Q4->apply_unsafe($u3);
$Q4->apply_unsafe($D3);
$Q4->apply_unsafe($v3);
$Q4->apply_unsafe($E3);
$Q4->apply_unsafe($w3);
$Q4->apply_unsafe($x3);
$Q4->apply_unsafe($y3);
$Q4->apply_unsafe($z3);
$Q4->apply_unsafe($A3);
$x5->apply_unsafe($R2);
$x5->apply_unsafe($S2);
$x5->apply_unsafe($R4);
$x5->apply_unsafe($T2);
$x5->apply_unsafe($S4);
$x5->apply_unsafe($U2);
$x5->apply_unsafe($T4);
$x5->apply_unsafe($V2);
$x5->apply_unsafe($U4);
$x5->apply_unsafe($W2);
$x5->apply_unsafe($V4);
$x5->apply_unsafe($X2);
$x5->apply_unsafe($W4);
$x5->apply_unsafe($Y2);
$x5->apply_unsafe($X4);
$x5->apply_unsafe($Z2);
$x5->apply_unsafe($Y4);
$x5->apply_unsafe($c3);
$x5->apply_unsafe($Z4);
$x5->apply_unsafe($d3);
$x5->apply_unsafe($c5);
$x5->apply_unsafe($e3);
$x5->apply_unsafe($d5);
$x5->apply_unsafe($f3);
$x5->apply_unsafe($e5);
$x5->apply_unsafe($g3);
$x5->apply_unsafe($f5);
$x5->apply_unsafe($h3);
$x5->apply_unsafe($g5);
$x5->apply_unsafe($i3);
$x5->apply_unsafe($h5);
$x5->apply_unsafe($j3);
$x5->apply_unsafe($i5);
$x5->apply_unsafe($k3);
$x5->apply_unsafe($X3);
$x5->apply_unsafe($l3);
$x5->apply_unsafe($j5);
$x5->apply_unsafe($m3);
$x5->apply_unsafe($F);
$x5->apply_unsafe($n3);
$x5->apply_unsafe($u);
$x5->apply_unsafe($o3);
$x5->apply_unsafe($k5);
$x5->apply_unsafe($p3);
$x5->apply_unsafe($l5);
$x5->apply_unsafe($q3);
$x5->apply_unsafe($m5);
$x5->apply_unsafe($r3);
$x5->apply_unsafe($V3);
$x5->apply_unsafe($s3);
$x5->apply_unsafe($j4);
$x5->apply_unsafe($t3);
$x5->apply_unsafe($n5);
$x5->apply_unsafe($u3);
$x5->apply_unsafe($D3);
$x5->apply_unsafe($v3);
$x5->apply_unsafe($E3);
$x5->apply_unsafe($w3);
$x5->apply_unsafe($o5);
$x5->apply_unsafe($x3);
$x5->apply_unsafe($y3);
$x5->apply_unsafe($z3);
$x5->apply_unsafe($p5);
$x5->apply_unsafe($A3);
$I5->apply_unsafe($R2);
$I5->apply_unsafe($S2);
$I5->apply_unsafe($T2);
$I5->apply_unsafe($U2);
$I5->apply_unsafe($V2);
$I5->apply_unsafe($W2);
$I5->apply_unsafe($X2);
$I5->apply_unsafe($Y2);
$I5->apply_unsafe($Z2);
$I5->apply_unsafe($c3);
$I5->apply_unsafe($d3);
$I5->apply_unsafe($e3);
$I5->apply_unsafe($f3);
$I5->apply_unsafe($g3);
$I5->apply_unsafe($h3);
$I5->apply_unsafe($i3);
$I5->apply_unsafe($j3);
$I5->apply_unsafe($i5);
$I5->apply_unsafe($k3);
$I5->apply_unsafe($X3);
$I5->apply_unsafe($l3);
$I5->apply_unsafe($j5);
$I5->apply_unsafe($m3);
$I5->apply_unsafe($n3);
$I5->apply_unsafe($o3);
$I5->apply_unsafe($p3);
$I5->apply_unsafe($q3);
$I5->apply_unsafe($r3);
$I5->apply_unsafe($V3);
$I5->apply_unsafe($s3);
$I5->apply_unsafe($j4);
$I5->apply_unsafe($t3);
$I5->apply_unsafe($u3);
$I5->apply_unsafe($D3);
$I5->apply_unsafe($v3);
$I5->apply_unsafe($E3);
$I5->apply_unsafe($w3);
$I5->apply_unsafe($x3);
$I5->apply_unsafe($y3);
$I5->apply_unsafe($z3);
$I5->apply_unsafe($A3);
$U5->apply_unsafe($R2);
$U5->apply_unsafe($S2);
$U5->apply_unsafe($T2);
$U5->apply_unsafe($U2);
$U5->apply_unsafe($V2);
$U5->apply_unsafe($W2);
$U5->apply_unsafe($X2);
$U5->apply_unsafe($Y2);
$U5->apply_unsafe($Z2);
$U5->apply_unsafe($c3);
$U5->apply_unsafe($d3);
$U5->apply_unsafe($e3);
$U5->apply_unsafe($f3);
$U5->apply_unsafe($g3);
$U5->apply_unsafe($h3);
$U5->apply_unsafe($i3);
$U5->apply_unsafe($j3);
$U5->apply_unsafe($k3);
$U5->apply_unsafe($X3);
$U5->apply_unsafe($l3);
$U5->apply_unsafe($m3);
$U5->apply_unsafe($n3);
$U5->apply_unsafe($o3);
$U5->apply_unsafe($p3);
$U5->apply_unsafe($q3);
$U5->apply_unsafe($r3);
$U5->apply_unsafe($s3);
$U5->apply_unsafe($t3);
$U5->apply_unsafe($u3);
$U5->apply_unsafe($D3);
$U5->apply_unsafe($v3);
$U5->apply_unsafe($E3);
$U5->apply_unsafe($w3);
$U5->apply_unsafe($x3);
$U5->apply_unsafe($y3);
$U5->apply_unsafe($z3);
$U5->apply_unsafe($A3);
$g6->apply_unsafe($R2);
$g6->apply_unsafe($S2);
$g6->apply_unsafe($T2);
$g6->apply_unsafe($U2);
$g6->apply_unsafe($V2);
$g6->apply_unsafe($W2);
$g6->apply_unsafe($X2);
$g6->apply_unsafe($Y2);
$g6->apply_unsafe($Z2);
$g6->apply_unsafe($c3);
$g6->apply_unsafe($d3);
$g6->apply_unsafe($e3);
$g6->apply_unsafe($f3);
$g6->apply_unsafe($g3);
$g6->apply_unsafe($h3);
$g6->apply_unsafe($i3);
$g6->apply_unsafe($j3);
$g6->apply_unsafe($k3);
$g6->apply_unsafe($X3);
$g6->apply_unsafe($l3);
$g6->apply_unsafe($m3);
$g6->apply_unsafe($n3);
$g6->apply_unsafe($o3);
$g6->apply_unsafe($p3);
$g6->apply_unsafe($q3);
$g6->apply_unsafe($r3);
$g6->apply_unsafe($s3);
$g6->apply_unsafe($t3);
$g6->apply_unsafe($u3);
$g6->apply_unsafe($D3);
$g6->apply_unsafe($v3);
$g6->apply_unsafe($E3);
$g6->apply_unsafe($w3);
$g6->apply_unsafe($x3);
$g6->apply_unsafe($y3);
$g6->apply_unsafe($z3);
$g6->apply_unsafe($A3);
$n6->apply_unsafe($R2);
$n6->apply_unsafe($S2);
$n6->apply_unsafe($T2);
$n6->apply_unsafe($U2);
$n6->apply_unsafe($V2);
$n6->apply_unsafe($W2);
$n6->apply_unsafe($X2);
$n6->apply_unsafe($Y2);
$n6->apply_unsafe($Z2);
$n6->apply_unsafe($c3);
$n6->apply_unsafe($d3);
$n6->apply_unsafe($e3);
$n6->apply_unsafe($f3);
$n6->apply_unsafe($g3);
$n6->apply_unsafe($h3);
$n6->apply_unsafe($i3);
$n6->apply_unsafe($j3);
$n6->apply_unsafe($k3);
$n6->apply_unsafe($X3);
$n6->apply_unsafe($l3);
$n6->apply_unsafe($m3);
$n6->apply_unsafe($n3);
$n6->apply_unsafe($o3);
$n6->apply_unsafe($p3);
$n6->apply_unsafe($q3);
$n6->apply_unsafe($r3);
$n6->apply_unsafe($s3);
$n6->apply_unsafe($t3);
$n6->apply_unsafe($u3);
$n6->apply_unsafe($D3);
$n6->apply_unsafe($v3);
$n6->apply_unsafe($E3);
$n6->apply_unsafe($w3);
$n6->apply_unsafe($x3);
$n6->apply_unsafe($y3);
$n6->apply_unsafe($z3);
$n6->apply_unsafe($A3);
$u6->apply_unsafe($R2);
$u6->apply_unsafe($S2);
$u6->apply_unsafe($T2);
$u6->apply_unsafe($U2);
$u6->apply_unsafe($V2);
$u6->apply_unsafe($W2);
$u6->apply_unsafe($X2);
$u6->apply_unsafe($Y2);
$u6->apply_unsafe($Z2);
$u6->apply_unsafe($c3);
$u6->apply_unsafe($d3);
$u6->apply_unsafe($e3);
$u6->apply_unsafe($f3);
$u6->apply_unsafe($g3);
$u6->apply_unsafe($h3);
$u6->apply_unsafe($i3);
$u6->apply_unsafe($j3);
$u6->apply_unsafe($k3);
$u6->apply_unsafe($X3);
$u6->apply_unsafe($l3);
$u6->apply_unsafe($m3);
$u6->apply_unsafe($n3);
$u6->apply_unsafe($o3);
$u6->apply_unsafe($p3);
$u6->apply_unsafe($q3);
$u6->apply_unsafe($r3);
$u6->apply_unsafe($s3);
$u6->apply_unsafe($t3);
$u6->apply_unsafe($u3);
$u6->apply_unsafe($D3);
$u6->apply_unsafe($v3);
$u6->apply_unsafe($E3);
$u6->apply_unsafe($w3);
$u6->apply_unsafe($x3);
$u6->apply_unsafe($y3);
$u6->apply_unsafe($z3);
$u6->apply_unsafe($A3);
$B6->apply_unsafe($R2);
$B6->apply_unsafe($S2);
$B6->apply_unsafe($T2);
$B6->apply_unsafe($U2);
$B6->apply_unsafe($V2);
$B6->apply_unsafe($W2);
$B6->apply_unsafe($X2);
$B6->apply_unsafe($Y2);
$B6->apply_unsafe($Z2);
$B6->apply_unsafe($c3);
$B6->apply_unsafe($d3);
$B6->apply_unsafe($e3);
$B6->apply_unsafe($f3);
$B6->apply_unsafe($g3);
$B6->apply_unsafe($h3);
$B6->apply_unsafe($i3);
$B6->apply_unsafe($j3);
$B6->apply_unsafe($k3);
$B6->apply_unsafe($X3);
$B6->apply_unsafe($l3);
$B6->apply_unsafe($m3);
$B6->apply_unsafe($n3);
$B6->apply_unsafe($o3);
$B6->apply_unsafe($p3);
$B6->apply_unsafe($q3);
$B6->apply_unsafe($r3);
$B6->apply_unsafe($s3);
$B6->apply_unsafe($t3);
$B6->apply_unsafe($u3);
$B6->apply_unsafe($D3);
$B6->apply_unsafe($v3);
$B6->apply_unsafe($E3);
$B6->apply_unsafe($w3);
$B6->apply_unsafe($x3);
$B6->apply_unsafe($y3);
$B6->apply_unsafe($z3);
$B6->apply_unsafe($A3);
$R6->apply_unsafe($R2);
$R6->apply_unsafe($S2);
$R6->apply_unsafe($T2);
$R6->apply_unsafe($U2);
$R6->apply_unsafe($V2);
$R6->apply_unsafe($W2);
$R6->apply_unsafe($X2);
$R6->apply_unsafe($Y2);
$R6->apply_unsafe($Z2);
$R6->apply_unsafe($c3);
$R6->apply_unsafe($d3);
$R6->apply_unsafe($e3);
$R6->apply_unsafe($f3);
$R6->apply_unsafe($g3);
$R6->apply_unsafe($h3);
$R6->apply_unsafe($i3);
$R6->apply_unsafe($j3);
$R6->apply_unsafe($k3);
$R6->apply_unsafe($l3);
$R6->apply_unsafe($m3);
$R6->apply_unsafe($n3);
$R6->apply_unsafe($u);
$R6->apply_unsafe($o3);
$R6->apply_unsafe($p3);
$R6->apply_unsafe($q3);
$R6->apply_unsafe($r3);
$R6->apply_unsafe($V3);
$R6->apply_unsafe($s3);
$R6->apply_unsafe($j4);
$R6->apply_unsafe($t3);
$R6->apply_unsafe($u3);
$R6->apply_unsafe($D3);
$R6->apply_unsafe($v3);
$R6->apply_unsafe($w3);
$R6->apply_unsafe($x3);
$R6->apply_unsafe($y3);
$R6->apply_unsafe($z3);
$R6->apply_unsafe($A3);
$Y6->apply_unsafe($R2);
$Y6->apply_unsafe($S2);
$Y6->apply_unsafe($T2);
$Y6->apply_unsafe($U2);
$Y6->apply_unsafe($V2);
$Y6->apply_unsafe($W2);
$Y6->apply_unsafe($X2);
$Y6->apply_unsafe($Y2);
$Y6->apply_unsafe($Z2);
$Y6->apply_unsafe($c3);
$Y6->apply_unsafe($d3);
$Y6->apply_unsafe($e3);
$Y6->apply_unsafe($f3);
$Y6->apply_unsafe($g3);
$Y6->apply_unsafe($h3);
$Y6->apply_unsafe($i3);
$Y6->apply_unsafe($j3);
$Y6->apply_unsafe($k3);
$Y6->apply_unsafe($l3);
$Y6->apply_unsafe($m3);
$Y6->apply_unsafe($n3);
$Y6->apply_unsafe($o3);
$Y6->apply_unsafe($p3);
$Y6->apply_unsafe($q3);
$Y6->apply_unsafe($r3);
$Y6->apply_unsafe($s3);
$Y6->apply_unsafe($t3);
$Y6->apply_unsafe($u3);
$Y6->apply_unsafe($v3);
$Y6->apply_unsafe($w3);
$Y6->apply_unsafe($x3);
$Y6->apply_unsafe($y3);
$Y6->apply_unsafe($z3);
$Y6->apply_unsafe($A3);
$F7->apply_unsafe($R4);
$Z7->apply_unsafe($S4);
$Z7->apply_unsafe($T4);
$Z7->apply_unsafe($U4);
$Z7->apply_unsafe($V4);
$Z7->apply_unsafe($W4);
$Z7->apply_unsafe($X4);
$Z7->apply_unsafe($Y4);
$Z7->apply_unsafe($Z4);
$Z7->apply_unsafe($c5);
$Z7->apply_unsafe($d5);
$Z7->apply_unsafe($e5);
$v8->apply_unsafe($S4);
$v8->apply_unsafe($T4);
$v8->apply_unsafe($U4);
$v8->apply_unsafe($V4);
$v8->apply_unsafe($W4);
$v8->apply_unsafe($X4);
$v8->apply_unsafe($Y4);
$v8->apply_unsafe($Z4);
$v8->apply_unsafe($c5);
$v8->apply_unsafe($d5);
$v8->apply_unsafe($e5);
$D8->apply_unsafe($S4);
$D8->apply_unsafe($T4);
$D8->apply_unsafe($U4);
$D8->apply_unsafe($V4);
$D8->apply_unsafe($W4);
$D8->apply_unsafe($X4);
$D8->apply_unsafe($Y4);
$D8->apply_unsafe($Z4);
$D8->apply_unsafe($c5);
$D8->apply_unsafe($d5);
$D8->apply_unsafe($e5);
$P8->apply_unsafe($S4);
$P8->apply_unsafe($T4);
$P8->apply_unsafe($U4);
$P8->apply_unsafe($V4);
$P8->apply_unsafe($W4);
$P8->apply_unsafe($X4);
$P8->apply_unsafe($Y4);
$P8->apply_unsafe($Z4);
$P8->apply_unsafe($c5);
$P8->apply_unsafe($d5);
$P8->apply_unsafe($e5);
$d9->apply_unsafe($S4);
$d9->apply_unsafe($T4);
$d9->apply_unsafe($U4);
$d9->apply_unsafe($V4);
$d9->apply_unsafe($W4);
$d9->apply_unsafe($X4);
$d9->apply_unsafe($Y4);
$d9->apply_unsafe($Z4);
$d9->apply_unsafe($c5);
$d9->apply_unsafe($d5);
$d9->apply_unsafe($e5);
$p9->apply_unsafe($S4);
$p9->apply_unsafe($T4);
$p9->apply_unsafe($U4);
$p9->apply_unsafe($V4);
$p9->apply_unsafe($W4);
$p9->apply_unsafe($X4);
$p9->apply_unsafe($Y4);
$p9->apply_unsafe($Z4);
$p9->apply_unsafe($c5);
$p9->apply_unsafe($d5);
$p9->apply_unsafe($e5);
$z9->apply_unsafe($S4);
$T9->apply_unsafe($S4);
$la->apply_unsafe($U2);
$la->apply_unsafe($V2);
$la->apply_unsafe($W2);
$la->apply_unsafe($X2);
$la->apply_unsafe($Y2);
$la->apply_unsafe($Z2);
$la->apply_unsafe($c3);
$la->apply_unsafe($d3);
$la->apply_unsafe($e3);
$la->apply_unsafe($f3);
$la->apply_unsafe($g3);
$Aa->apply_unsafe($T4);
$Ha->apply_unsafe($T4);
$db->apply_unsafe($U4);
$kb->apply_unsafe($U4);
$Eb->apply_unsafe($U4);
$ec->apply_unsafe($U4);
$mc->apply_unsafe($U4);
$Cc->apply_unsafe($U4);
$cd->apply_unsafe($V4);
$jd->apply_unsafe($V4);
$rd->apply_unsafe($V4);
$Hd->apply_unsafe($V4);
$Sd->apply_unsafe($V4);
$ee->apply_unsafe($V4);
$Ce->apply_unsafe($W4);
$Ke->apply_unsafe($W4);
$Re->apply_unsafe($W4);
$of->apply_unsafe($W4);
$Of->apply_unsafe($X4);
$Vf->apply_unsafe($X4);
$fg->apply_unsafe($X4);
$sg->apply_unsafe($X4);
$Ig->apply_unsafe($X4);
$lh->apply_unsafe($Y4);
$sh->apply_unsafe($Y4);
$yh->apply_unsafe($Y4);
$Lh->apply_unsafe($Y4);
$yi->apply_unsafe($zi);
$Ji->apply_unsafe($Z4);
$Wi->apply_unsafe($Z4);
$Fj->apply_unsafe($d5);
$Pj->apply_unsafe($d5);
$dk->apply_unsafe($d5);
$nk->apply_unsafe($d5);
$Dk->apply_unsafe($d5);
$ll->apply_unsafe($e5);
$sl->apply_unsafe($e5);
$Gl->apply_unsafe($e5);
$gm->apply_unsafe($f5);
$gm->apply_unsafe($g5);
$gm->apply_unsafe($h5);
$gm->apply_unsafe($p5);
$sm->apply_unsafe($f5);
$sm->apply_unsafe($g5);
$sm->apply_unsafe($h5);
$sm->apply_unsafe($p5);
$Im->apply_unsafe($f5);
$Im->apply_unsafe($g5);
$Im->apply_unsafe($h5);
$en->apply_unsafe($f5);
$en->apply_unsafe($g5);
$en->apply_unsafe($h5);
$vn->apply_unsafe($h3);
$vn->apply_unsafe($i3);
$vn->apply_unsafe($j3);
$Pn->apply_unsafe($g5);
$Wn->apply_unsafe($g5);
$io->apply_unsafe($g5);
$uo->apply_unsafe($g5);
$Ro->apply_unsafe($i3);
$mp->apply_unsafe($h5);
$tp->apply_unsafe($h5);
$Pp->apply_unsafe($X3);
$lq->apply_unsafe($j5);
$rq->apply_unsafe($j5);
$Mq->apply_unsafe($F);
$Sq->apply_unsafe($F);
$Zq->apply_unsafe($F);
$kr->apply_unsafe($F);
$tr->apply_unsafe($F);
$Vr->apply_unsafe($u);
$ls->apply_unsafe($u);
$vs->apply_unsafe($u);
$Ds->apply_unsafe($u);
$Ys->apply_unsafe($k5);
$kt->apply_unsafe($zi);
$ut->apply_unsafe($k5);
$ju->apply_unsafe($k5);
$ru->apply_unsafe($k5);
$ru->apply_unsafe($m5);
$Pu->apply_unsafe($k5);
$Pu->apply_unsafe($m5);
$hv->apply_unsafe($k5);
$hv->apply_unsafe($m5);
$xv->apply_unsafe($k5);
$kw->apply_unsafe($lw);
$Fw->apply_unsafe($l5);
$Xw->apply_unsafe($l5);
$ix->apply_unsafe($l5);
$sx->apply_unsafe($l5);
$Hy->apply_unsafe($lw);
$Vy->apply_unsafe($m5);
$gz->apply_unsafe($m5);
$Hz->apply_unsafe($V3);
$Nz->apply_unsafe($V3);
$Uz->apply_unsafe($V3);
$tA->apply_unsafe($zi);
$DA->apply_unsafe($j4);
$JA->apply_unsafe($j4);
$fB->apply_unsafe($n5);
$rB->apply_unsafe($n5);
$yB->apply_unsafe($n5);
$ni::self=$qD;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($q1)for@$w;
&$_($u1)for@$w;
&$_($y1)for@$H;
&$_($G1)for@$w;
&$_($K1)for@$H;
&$_($T1)for@$H;
&$_($X1)for@$w;
&$_($d2)for@$w;
&$_($h2)for@$w;
&$_($l2)for@$H;
&$_($s2)for@$H;
&$_($A2)for@$w;
&$_($E2)for@$w;
&$_($I2)for@$H;
&$_($O2)for@$H;
&$_($P3)for@$w;
&$_($S3)for@$w;
&$_($W3)for@$Y3;
&$_($d4)for@$w;
&$_($f4)for@$w;
&$_($i4)for@$Y3;
&$_($n4)for@$w;
&$_($q4)for@$Y3;
&$_($u4)for@$w;
&$_($x4)for@$Y3;
&$_($B4)for@$w;
&$_($E4)for@$Y3;
&$_($G4)for@$H4;
&$_($K4)for@$w;
&$_($N4)for@$w;
&$_($Q4)for@$Y3;
&$_($u5)for@$w;
&$_($x5)for@$Y3;
&$_($z5)for@$A5;
&$_($F5)for@$w;
&$_($I5)for@$Y3;
&$_($K5)for@$L5;
&$_($R5)for@$w;
&$_($U5)for@$Y3;
&$_($Y5)for@$w;
&$_($d6)for@$w;
&$_($g6)for@$Y3;
&$_($k6)for@$w;
&$_($n6)for@$Y3;
&$_($r6)for@$w;
&$_($u6)for@$Y3;
&$_($y6)for@$w;
&$_($B6)for@$Y3;
&$_($D6)for@$E6;
&$_($G6)for@$H6;
&$_($L6)for@$w;
&$_($O6)for@$w;
&$_($R6)for@$Y3;
&$_($V6)for@$w;
&$_($Y6)for@$Y3;
&$_($c7)for@$d7;
&$_($m7)for@$n7;
&$_($r7)for@$n7;
&$_($t7)for@$n7;
&$_($v7)for@$n7;
&$_($C7)for@$w;
&$_($F7)for@$Y3;
&$_($H7)for@$I7;
&$_($N7)for@$n7;
&$_($W7)for@$w;
&$_($Z7)for@$Y3;
&$_($g8)for@$w;
&$_($k8)for@$w;
&$_($o8)for@$w;
&$_($s8)for@$w;
&$_($v8)for@$Y3;
&$_($A8)for@$w;
&$_($D8)for@$Y3;
&$_($I8)for@$w;
&$_($M8)for@$w;
&$_($P8)for@$Y3;
&$_($U8)for@$w;
&$_($Y8)for@$w;
&$_($d9)for@$Y3;
&$_($i9)for@$w;
&$_($m9)for@$w;
&$_($p9)for@$Y3;
&$_($r9)for@$s9;
&$_($w9)for@$w;
&$_($z9)for@$Y3;
&$_($E9)for@$w;
&$_($I9)for@$w;
&$_($M9)for@$w;
&$_($Q9)for@$w;
&$_($T9)for@$Y3;
&$_($V9)for@$W9;
&$_($ia)for@$w;
&$_($la)for@$Y3;
&$_($na)for@$n7;
&$_($pa)for@$n7;
&$_($xa)for@$w;
&$_($Aa)for@$Y3;
&$_($Ea)for@$w;
&$_($Ha)for@$Y3;
&$_($Ja)for@$Ka;
&$_($Pa)for@$n7;
&$_($Ya)for@$w;
&$_($db)for@$Y3;
&$_($hb)for@$w;
&$_($kb)for@$Y3;
&$_($pb)for@$w;
&$_($tb)for@$w;
&$_($xb)for@$w;
&$_($Bb)for@$w;
&$_($Eb)for@$Y3;
&$_($Jb)for@$w;
&$_($Nb)for@$w;
&$_($Rb)for@$w;
&$_($Vb)for@$w;
&$_($Zb)for@$w;
&$_($ec)for@$Y3;
&$_($jc)for@$w;
&$_($mc)for@$Y3;
&$_($rc)for@$w;
&$_($vc)for@$w;
&$_($zc)for@$w;
&$_($Cc)for@$Y3;
&$_($Ec)for@$Fc;
&$_($Kc)for@$n7;
&$_($Xc)for@$w;
&$_($cd)for@$Y3;
&$_($gd)for@$w;
&$_($jd)for@$Y3;
&$_($od)for@$w;
&$_($rd)for@$Y3;
&$_($wd)for@$w;
&$_($Ad)for@$w;
&$_($Ed)for@$w;
&$_($Hd)for@$Y3;
&$_($Ld)for@$w;
&$_($Pd)for@$w;
&$_($Sd)for@$Y3;
&$_($Wd)for@$w;
&$_($Zd)for@$w;
&$_($ee)for@$Y3;
&$_($ge)for@$he;
&$_($me)for@$n7;
&$_($ze)for@$w;
&$_($Ce)for@$Y3;
&$_($He)for@$w;
&$_($Ke)for@$Y3;
&$_($Oe)for@$w;
&$_($Re)for@$Y3;
&$_($Ve)for@$w;
&$_($Ze)for@$w;
&$_($ef)for@$w;
&$_($if)for@$w;
&$_($lf)for@$w;
&$_($of)for@$Y3;
&$_($qf)for@$rf;
&$_($wf)for@$n7;
&$_($Hf)for@$w;
&$_($Lf)for@$w;
&$_($Of)for@$Y3;
&$_($Sf)for@$w;
&$_($Vf)for@$Y3;
&$_($cg)for@$w;
&$_($fg)for@$Y3;
&$_($jg)for@$w;
&$_($mg)for@$w;
&$_($pg)for@$w;
&$_($sg)for@$Y3;
&$_($xg)for@$w;
&$_($Bg)for@$w;
&$_($Fg)for@$w;
&$_($Ig)for@$Y3;
&$_($Kg)for@$Lg;
&$_($Qg)for@$n7;
&$_($Yg)for@$w;
&$_($eh)for@$w;
&$_($ih)for@$w;
&$_($lh)for@$Y3;
&$_($ph)for@$w;
&$_($sh)for@$Y3;
&$_($vh)for@$w;
&$_($yh)for@$Y3;
&$_($Ch)for@$w;
&$_($Fh)for@$w;
&$_($Ih)for@$w;
&$_($Lh)for@$Y3;
&$_($Nh)for@$Oh;
&$_($Uh)for@$n7;
&$_($ki)for@$w;
&$_($ni)for@$w;
&$_($ri)for@$w;
&$_($vi)for@$w;
&$_($yi)for@$Y3;
&$_($Gi)for@$w;
&$_($Ji)for@$Y3;
&$_($Ni)for@$w;
&$_($Qi)for@$w;
&$_($Ti)for@$w;
&$_($Wi)for@$Y3;
&$_($Yi)for@$Zi;
&$_($gj)for@$n7;
&$_($yj)for@$w;
&$_($Cj)for@$w;
&$_($Fj)for@$Y3;
&$_($Jj)for@$w;
&$_($Mj)for@$w;
&$_($Pj)for@$Y3;
&$_($Uj)for@$w;
&$_($Yj)for@$w;
&$_($dk)for@$Y3;
&$_($hk)for@$w;
&$_($kk)for@$w;
&$_($nk)for@$Y3;
&$_($rk)for@$w;
&$_($uk)for@$w;
&$_($xk)for@$w;
&$_($Ak)for@$w;
&$_($Dk)for@$Y3;
&$_($Fk)for@$Gk;
&$_($Lk)for@$n7;
&$_($Yk)for@$w;
&$_($el)for@$w;
&$_($il)for@$w;
&$_($ll)for@$Y3;
&$_($pl)for@$w;
&$_($sl)for@$Y3;
&$_($wl)for@$w;
&$_($Al)for@$w;
&$_($Dl)for@$w;
&$_($Gl)for@$Y3;
&$_($Il)for@$Jl;
&$_($Ol)for@$n7;
&$_($dm)for@$w;
&$_($gm)for@$Y3;
&$_($lm)for@$w;
&$_($pm)for@$w;
&$_($sm)for@$Y3;
&$_($um)for@$vm;
&$_($zm)for@$w;
&$_($Cm)for@$w;
&$_($Fm)for@$w;
&$_($Im)for@$Y3;
&$_($Nm)for@$w;
&$_($Rm)for@$w;
&$_($Vm)for@$w;
&$_($Zm)for@$w;
&$_($en)for@$Y3;
&$_($gn)for@$hn;
&$_($on)for@$n7;
&$_($sn)for@$w;
&$_($vn)for@$Y3;
&$_($xn)for@$n7;
&$_($Gn)for@$w;
&$_($In)for@$w;
&$_($Mn)for@$w;
&$_($Pn)for@$Y3;
&$_($Tn)for@$w;
&$_($Wn)for@$Y3;
&$_($co)for@$w;
&$_($fo)for@$w;
&$_($io)for@$Y3;
&$_($no)for@$w;
&$_($ro)for@$w;
&$_($uo)for@$Y3;
&$_($yo)for@$zo;
&$_($Go)for@$w;
&$_($Ko)for@$w;
&$_($Oo)for@$w;
&$_($Ro)for@$Y3;
&$_($To)for@$n7;
&$_($jp)for@$w;
&$_($mp)for@$Y3;
&$_($qp)for@$w;
&$_($tp)for@$Y3;
&$_($vp)for@$wp;
&$_($Bp)for@$n7;
&$_($Mp)for@$w;
&$_($Pp)for@$Y3;
&$_($Rp)for@$Sp;
&$_($Yp)for@$n7;
&$_($iq)for@$w;
&$_($lq)for@$Y3;
&$_($oq)for@$w;
&$_($rq)for@$Y3;
&$_($tq)for@$uq;
&$_($zq)for@$n7;
&$_($Jq)for@$w;
&$_($Mq)for@$Y3;
&$_($Pq)for@$w;
&$_($Sq)for@$Y3;
&$_($Wq)for@$w;
&$_($Zq)for@$Y3;
&$_($er)for@$w;
&$_($hr)for@$w;
&$_($kr)for@$Y3;
&$_($nr)for@$w;
&$_($qr)for@$w;
&$_($tr)for@$Y3;
&$_($vr)for@$wr;
&$_($Br)for@$n7;
&$_($Nr)for@$w;
&$_($Qr)for@$w;
&$_($Sr)for@$w;
&$_($Vr)for@$Y3;
&$_($Zr)for@$w;
&$_($es)for@$w;
&$_($is)for@$w;
&$_($ls)for@$Y3;
&$_($ps)for@$w;
&$_($ss)for@$w;
&$_($vs)for@$Y3;
&$_($As)for@$w;
&$_($Ds)for@$Y3;
&$_($Fs)for@$Gs;
&$_($Ls)for@$n7;
&$_($Vs)for@$w;
&$_($Ys)for@$Y3;
&$_($ht)for@$w;
&$_($kt)for@$Y3;
&$_($rt)for@$w;
&$_($ut)for@$Y3;
&$_($zt)for@$w;
&$_($Dt)for@$w;
&$_($Ht)for@$w;
&$_($Lt)for@$w;
&$_($Pt)for@$w;
&$_($Tt)for@$w;
&$_($Xt)for@$w;
&$_($du)for@$w;
&$_($gu)for@$w;
&$_($ju)for@$Y3;
&$_($ou)for@$w;
&$_($ru)for@$Y3;
&$_($wu)for@$w;
&$_($Au)for@$w;
&$_($Eu)for@$w;
&$_($Iu)for@$w;
&$_($Mu)for@$w;
&$_($Pu)for@$Y3;
&$_($Uu)for@$w;
&$_($Yu)for@$w;
&$_($ev)for@$w;
&$_($hv)for@$Y3;
&$_($mv)for@$w;
&$_($qv)for@$w;
&$_($uv)for@$w;
&$_($xv)for@$Y3;
&$_($zv)for@$Av;
&$_($Fv)for@$n7;
&$_($Pv)for@$w;
&$_($Tv)for@$w;
&$_($Xv)for@$w;
&$_($dw)for@$w;
&$_($hw)for@$w;
&$_($kw)for@$Y3;
&$_($ww)for@$w;
&$_($zw)for@$w;
&$_($Cw)for@$w;
&$_($Fw)for@$Y3;
&$_($Jw)for@$w;
&$_($Mw)for@$w;
&$_($Pw)for@$w;
&$_($Sw)for@$w;
&$_($Uw)for@$w;
&$_($Xw)for@$Y3;
&$_($cx)for@$w;
&$_($fx)for@$w;
&$_($ix)for@$Y3;
&$_($mx)for@$w;
&$_($px)for@$w;
&$_($sx)for@$Y3;
&$_($ux)for@$vx;
&$_($Ax)for@$n7;
&$_($Kx)for@$w;
&$_($Ox)for@$w;
&$_($Sx)for@$w;
&$_($Wx)for@$w;
&$_($cy)for@$w;
&$_($gy)for@$w;
&$_($ky)for@$w;
&$_($oy)for@$w;
&$_($sy)for@$w;
&$_($wy)for@$w;
&$_($Ay)for@$w;
&$_($Ey)for@$w;
&$_($Hy)for@$Y3;
&$_($Sy)for@$w;
&$_($Vy)for@$Y3;
&$_($Yy)for@$w;
&$_($dz)for@$w;
&$_($gz)for@$Y3;
&$_($iz)for@$jz;
&$_($oz)for@$n7;
&$_($yz)for@$w;
&$_($Az)for@$w;
&$_($Hz)for@$Y3;
&$_($Kz)for@$w;
&$_($Nz)for@$Y3;
&$_($Rz)for@$w;
&$_($Uz)for@$Y3;
&$_($Wz)for@$Xz;
&$_($fA)for@$n7;
&$_($mA)for@$w;
&$_($qA)for@$w;
&$_($tA)for@$Y3;
&$_($AA)for@$w;
&$_($DA)for@$Y3;
&$_($GA)for@$w;
&$_($JA)for@$Y3;
&$_($LA)for@$MA;
&$_($SA)for@$n7;
&$_($cB)for@$w;
&$_($fB)for@$Y3;
&$_($kB)for@$w;
&$_($oB)for@$w;
&$_($rB)for@$Y3;
&$_($vB)for@$w;
&$_($yB)for@$Y3;
&$_($AB)for@$BB;
&$_($GB)for@$n7;
&$_($OB)for@$PB;
&$_($UB)for@$n7;
&$_($fC)for@$gC;
&$_($lC)for@$n7;
&$_($tC)for@$uC;
&$_($OC)for@$PC;
&$_($RC)for@$uC;
&$_($WC)for@$w;
&$_($cD)for@$w;
&$_($gD)for@$w;
&$_($kD)for@$w;
&$_($oD)for@$w;
&$_($qD)for@$rD;
ni->run(@ARGV);
__DATA__
