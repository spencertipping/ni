ni('ni:class')->doc
  ->synopsis(q[
    ni('ni:object')->child('message')
      ->add('behaviorname.b')           # add existing behavior
      ->def('message_init.b',           # define new behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def('behaviorname.b',           # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\n";
        });
    ni('ni:child')->new('hello world!')->method1;
  ])

  ->description(
    q[ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.])

  ->behaviors(
    q[ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:lib/slice, which represents a set of methods you can add to a
      package. TODO...])

  ->classes(
    q[ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.],

    q[TODO...]);
