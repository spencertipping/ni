ni('ni:/object')->child('/lib/quote_simple')
  ->doc
  ->description(
    q[A stateless object that serializes values with direct quotation; that
      is, the serialization contains no variables. If your objects have
      circular or shared references, you should probably use
      /lib/quote_circular or similar.],

    eg q{
      my $q = ni('ni:/lib/quote_simple')->new;
      now $q->quote([1,2,3]) == "[1,2,3]";
      now $q->quote({foo => 1, bar => [1, 2]}) == "{q#bar#,[1,2],q#foo#,1}";
    })
  ->end

  ->def('/lib/quote_simple_init.b', instantiate => fn q{+{}})
  ->def('/lib/quote_simple_quote.b',
    is_circular => fn q{0},
    quote => fn q{shift->quote_value(shift)})

  ->def('/lib/quote_code_fail.b',
    quote_code => fn q{shift->die('cannot quote perl CODE refs', shift)})

  ->def('/lib/quote_values.b',
    quote_value => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0])     unless ref $_[0];
      return $self->quote_scalar_ref($_[0]) if 'SCALAR' eq ref $_[0];
      return $self->quote_array($_[0])      if 'ARRAY'  eq ref $_[0];
      return $self->quote_hash($_[0])       if 'HASH'   eq ref $_[0];
      return $self->quote_code($_[0])       if 'CODE'   eq ref $_[0];
      $self->quote_object($_[0]);
    },

    quote_hash => fn q{
      local $_;
      my ($self, $v) = @_;
      my @ks = sort keys %$v;
      my @qs;
      for my $k (@ks) {
        $self->circular_hashref($v, $k, $$v{$k})
          if $self->is_circular($$v{$k});
        push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
      }
      '{' . join(",", @qs) . '}';
    },

    quote_array => fn q{
      local $_;
      my ($self, $v) = @_;
      $self->is_circular($$v[$_]) && $self->circular_arrayref($v, $_, $$v[$_])
        for 0..$#{$v};
      '[' . join(',', map $self->quote($_), @$v) . ']';
    },

    quote_scalar_ref => fn q{'\\\\' . shift->quote(${$_[0]})},

    quote_scalar => fn q{
      my $v = $_[1];
      return 'undef' unless defined $v;
      return $v if Scalar::Util::looks_like_number $v;
      $v =~ s/([\\\\#])/\\\\$1/g;
      "q#$v#";
    })

  ->def('/lib/quote_objects.b',
    quote_blessed => fn q{
      my ($self, $x, $r) = @_;
      $r ||= ref $x;
      $self->quote_class($r);
      my $t = Scalar::Util::reftype $x;
      my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
      "bless($quoted," . $self->quote($r) . ")";
    },

    quote_class => fn q{
      my ($self, $class) = @_;
      $self->quote(ni"ni:$class") if ni->exists("ni:$class");
    },

    quote_object => fn q{
      local $_;
      my $self = shift;
      my $q = $self->allocate_gensym($_[0],
        $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
      $self->finalizer('&' . $self->quote($_) . "($q);")
        for @{ref($_[0]) . '::ctors'};
      $q;
    });

ni('ni:/lib/slice')->new('/lib/gensym_generator_compact.b',
  gensym => fn q{
    my $n = shift->{gensym_n}++;
    my $s = '$' .
      substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
             $n % 50, 1;
    $n = int $n / 50;
    while ($n) {
      $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
                   $n % 63, 1;
      $n = int $n / 63;
    }
    $s;
  });

ni('ni:/lib/slice')->new('/lib/quote_circular_addressed.b',
  is_circular => fn q{
    my $self = shift;
    ref $$self{visited}{$self->address(shift)};
  },

  circular_hashref => fn q{
    my $self          = shift;
    my $address       = $self->address(shift);
    my $quoted_key    = $self->quote(shift);
    my $value_address = $self->address(shift);
    push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
    $self;
  },

  circular_arrayref => fn q{
    my $self          = shift;
    my $address       = $self->address(shift);
    my $index         = shift;
    my $value_address = $self->address(shift);
    push @{$$self{circular}}, [$address, "[$index]", $value_address];
    $self;
  });

ni('ni:/lib/slice')->new('/lib/quote_gensym_identity.b',
  circular_links => fn q{
    local $_;
    my $self = shift;
    map "\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
        @{$$self{circular}};
  },

  address => fn q{
    return 'undef' unless defined $_[1];
    return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
    "addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \$_[1]);
  },

  quote => fn q{
    my $self = shift;
    return $self->quote_scalar($_[0])
      if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
    my $a = $self->address($_[0]);
    $$self{objects}{$a} = \$_[0];
    my $v = $$self{visited}{$a};
    return ref $v ? '0' : $v if defined $v;
    $$self{visited}{$a} = \'undef';
    $self->allocate_gensym($_[0], $self->quote_value($_[0]));
  },

  allocate_gensym => fn q{
    my $self = shift;
    my $a = $self->address(shift);
    return $$self{visited}{$a} if $_[0] =~ /^\$\w+$/;
    my $g = $$self{visited}{$a} = $self->gensym;
    $$self{definitions}{$g} = "$g=$_[0];";
    push @{$$self{ordering}}, $g;
    $g;
  });
