ni('ni:/lib/slice')->new('/lib/fn_init.b',
  instantiate => fn q{
    my $class = shift;
    my $code  = pop;
    my $proto = @_ && $_[-1] =~ /^\(/ ? pop : '';
    +{code        => $code,
      proto       => $proto,
      eval_number => undef,
      annotations => [@_]};
  },
  compile => fn q{
    local $@;
    my $self = shift;
    $$self{proto} ||= '';
    # FIXME: the problem is that on second-bootup, no base lib/ni::resolve
    # implementation exists; that means we can't pull $self->class (and even if
    # we could, it might not yet support ->eval, for instance if this is the
    # apply_unsafe method).
    $$self{fn} = $self->class->eval(
      "sub $$self{proto} {$$self{code}\n}",
      $self);
    $$self{fn};
  },
  ctor => fn q{shift->compile},
  dtor => fn q{
    my $self = shift;
    $self->class->uneval($$self{eval_number});
  });

ni('ni:/lib/slice')->new('/lib/fn.c_eval.b',
  ctor => fn q{shift->{evals} = {}},
  eval => fn q{
    my ($self, $code, $fn) = @_;
    my ($en) = ni::eval('__FILE__') =~ /eval (\d+)/;
    Scalar::Util::weaken($$self{evals}{++$en} = $fn);
    $$fn{eval_number} = $en;
    my $r = ni::eval $code;
    die "ni:/lib/fn: failed to compile $code: $@" if $@;
    $r;
  },
  uneval => fn q{
    my ($self, $en) = @_;
    delete $$self{evals}{$en} if defined $en;
  });

delete @{'lib/fn::'}{qw/new compile/};
ni('ni:/object')->child('/lib/fn', '/lib/instantiable.b', '/lib/fn_init.b')
                ->class->add('/lib/fn.c_eval.b');

delete ${main::}{fn};

ni('ni:main')->def('/lib/static_fn.b',
  fn => ni('ni:/lib/fn')->new('($)',  q{ni('ni:/lib/fn')->new(@_)}),
  fp => ni('ni:/lib/fn')->new('($$)', q{ni('ni:/lib/fn')->new(@_)}));

ni('ni:/lib/fn')
  ->ro('/lib/fn_ro.b', qw/code annotations fn eval_number/)
  ->def('/lib/fn_ops.b',
    '(""' => fn q{my $self = shift; "fn {$$self{code}}"},
    '(eq' => fn q{
      ref($_[0]) eq ref($_[1])
        and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);
    });
