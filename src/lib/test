ni('ni:/object')->child('/lib/test_assertion')
  ->def('/lib/test_assertion_commit.b',
    commit => fn q{
      my $self = shift;
      my $test = ni('ni:/lib/test_case')->running_test;
      push @{$test->assertions}, $self->result;
      $self;
    });

ni('ni:/lib/test_assertion')->child('/lib/test_assert_eq')
  ->def('/lib/test_assert_eq_init.b',
    instantiate => fn q{
      my ($class, $diff) = @_;
      +{diff => $diff};
    })

  ->def('/lib/test_assert_eq_result.b',
    '(""' => fn q{
      my $self = shift;
      $self->failed ? "FAIL " . ni::json_encode_pretty $$self{diff}
                    : "PASS";
    },
    result => fn q{shift},
    failed => fn q{defined shift->{diff}});

ni('ni:/object')->child('/lib/test_value')
  ->def('/lib/test_value_init.b', instantiate => fn q{\$_[1]})
  ->def('/lib/test_value_eq.b',
    detailed_scalar_diff => fn q{
      local $_;
      my ($self, $lhs, $rhs, $lpos, $rpos) = @_;
      my ($prefix) = ($lhs ^ $rhs) =~ /^(\0*)/;

      my $l = length $prefix;
      return $self->detailed_scalar_diff(substr($lhs, $l), substr($rhs, $l),
                                         $lpos + $l,       $rpos + $l)
        if $l;

      my $minlength = ni::min(length $lhs, length $rhs);
      my ($suffix) = (  substr($lhs, length($lhs) - $minlength)
                      ^ substr($rhs, length($rhs) - $minlength)) =~ /(\0*)$/;
      return $self->detailed_scalar_diff(substr($lhs, 0, length($lhs) - $l),
                                         substr($rhs, 0, length($rhs) - $l),
                                         $lpos, $rpos)
        if $l = length $suffix;

      my $d = length($rhs) - length($lhs);
      my $best_offset = 0;
      my $best_match  = 0;
      for (0..abs $d) {
        my $diff = substr($d < 0 ? $lhs : $rhs, $_, $minlength)
                 ^ ($d < 0 ? $rhs : $lhs);
        my @matching = $diff =~ /\0\0\0\0\0\0\0\0+/g;
        my $match = ni::sum(map length, @matching);
        if ($match > $best_match) {
          $best_offset = $_;
          $best_match  = $match;
        }
      }

      # TODO: rewrite this

      return [] unless $lhs ne $rhs;
      +{lpos  => $lpos,
        rpos  => $rpos,
        ltext => $lhs,
        rtext => $rhs}
    },

    diff => fn q{
      my ($self, $rhs) = @_;
      my $class = $self->class;
      my $lhs = $$self;
      my $rl = ref $lhs;
      my $rr = ref $rhs;
      my $realtype = Scalar::Util::reftype($lhs) || "";
      return {type_difference => [$rl, $rr]} unless $rl eq $rr;
      if ($realtype eq 'HASH') {
        my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
        my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
        return {hash_key_mismatch => 1,
                object_type       => $rl,
                left_only         => \@left_only,
                right_only        => \@right_only}
          if @left_only || @right_only;
        my %diff;
        $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
          for keys %$lhs;
        delete @diff{grep !defined($diff{$_}), keys %diff};
        return {hash_value_mismatch => 1,
                object_type         => $rl,
                diffs               => \%diff} if keys %diff;
      } elsif ($realtype eq 'ARRAY') {
        return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
          unless @$lhs == @$rhs;
        my %diff;
        $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
          for 0..$#{$lhs};
        delete @diff{grep !defined($diff{$_}), keys %diff};
        return {array_value_mismatch => 1,
                object_type          => $rl,
                diffs                => \%diff} if keys %diff;
      } elsif ($realtype eq 'SCALAR') {
        return $class->new($$lhs)->diff($$rhs);
      } elsif (!$rl) {
        no warnings 'uninitialized';
        return undef if $lhs eq $rhs;
        return {scalar_difference => $self->detailed_scalar_diff($lhs, $rhs)}
          if length($lhs) + length($rhs) > 80;
        return {scalar_difference => [$lhs, $rhs]};
      }
      return undef;
    },

    '(==' => fn q{
      my ($self, $rhs) = @_;
      ni('ni:/lib/test_assert_eq')
        ->new($self->diff($rhs))
        ->commit;
    })

  ->def('/lib/test_value_str.b',
    '(""' => fn q{ni::json_encode ${$_[0]}});

ni('ni:/object')->child('/lib/test_case')
  ->ro('/lib/test_case_ro.b', qw/test assertions/)
  ->rw('/lib/test_case_rw.b', qw/error/)
  ->def('/lib/test_case_init.b',
    instantiate => fn q{
      my $class = shift;
      my $test  = fn shift;
      +{test       => $test,
        assertions => [],
        error      => undef,
        outcome    => undef};
    })

  ->def('/lib/test_case_metrics.b',
    '(""' => fn q{
      my $self = shift;
      join '', $self->failed  ? 'FAIL ' : 'PASS ',
               $self->error   ? 'E'     : ':',
               map $_->failed ? 'X'     : '.', @{$$self{assertions}};
    },

    failed => fn q{!shift->{outcome}->[0]})

  ->def('/lib/test_case_run.b',
    done => fn q{
      my $self = shift;
      my @failed = grep $_->failed, @{$$self{assertions}};
      my $any_failed = @failed || defined $$self{error};
      $$self{outcome} = [!$any_failed, $$self{error}, @failed];
    },

    run => fn q{
      local $_;
      my $self = shift;
      $self->class->with_test($self, \&{$$self{test}});
      $self;
    });

ni('ni:/lib/test_case.c')
  ->ro('/lib/test_case.c_test_ro.b', qw/running_test/)
  ->def('/lib/test_case.c_test.b',
    ctor => fn q{shift->{running_test} = undef},
    with_test => fn q{
      my ($self, $test, $f) = @_;
      local $$self{running_test} = $test;
      eval {&$f};
      $test->error($@) if $@;
      $test->done;
    });

ni('ni:main')->def('/lib/global_static_test.b',
  eg  => fp('($)', q{ni('ni:/lib/test_case')->new(shift)}),
  now => fp('($)', q{ni('ni:/lib/test_value')->new(shift)}));
