ni('ni:/object')->child('/lib/test_value')
  ->def('/lib/test_value_init.b', instantiate => fn q{\$_[1]})
  ->def('/lib/test_value_eq.b',
    diff => fn q{
      my ($self, $rhs) = @_;
      my $class = $self->class;
      my $lhs = $$self;
      my $rl = ref $lhs;
      my $rr = ref $rhs;
      my $realtype = Scalar::Util::reftype($lhs) || "";
      return {type_difference => [$rl, $rr]} unless $rl eq $rr;
      if ($realtype eq 'HASH') {
        my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
        my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
        return {hash_key_mismatch => 1,
                object_type       => $rl,
                left_only         => \@left_only,
                right_only        => \@right_only}
          if @left_only || @right_only;
        my %diff;
        $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
          for keys %$lhs;
        delete @diff{grep !defined($diff{$_}), keys %diff};
        return {hash_value_mismatch => 1,
                object_type         => $rl,
                diffs               => \%diff} if keys %diff;
      } elsif ($realtype eq 'ARRAY') {
        return {array_length_mismatch => [scalar(@$lhs), scalar(@$rhs)]}
          unless @$lhs == @$rhs;
        my %diff;
        $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
          for 0..$#{$lhs};
        delete @diff{grep !defined($diff{$_}), keys %diff};
        return {array_value_mismatch => 1,
                object_type          => $rl,
                diffs                => \%diff} if keys %diff;
      } elsif ($realtype eq 'SCALAR') {
        return $class->new($$lhs)->diff($$rhs);
      } elsif (!$rl) {
        return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
      }
      return undef;
    },

    '(==' => fn q{
      my ($self, $rhs) = @_;
      my $diff = $self->diff($rhs);
      die $self->class->new($diff) if defined $diff;
      1;
    })

  ->def('/lib/test_value_str.b',
    '(""' => fn q{ni::json_encode ${$_[0]}});

ni('ni:main')->def('/lib/global_static_test.b',
  now => fp('($)', q{ni('ni:/lib/test_value')->new(shift)}));
