# /lib/slice.b
ni->def('ni:/lib/slice.b' =>
  bless {
    name => '/lib/slice.b',
    header => undef,
    commit => undef,
    methods => {
      ctor => fn q{shift->commit},
      commit => fn q{
        my $self = shift;
        $$self{commit} ||= 'ni::/lib/commit'->new(
          join "\n", "# line 1 \"$$self{name}\"",
                     ($$self{header} ? ($$self{header}) : ()),
                     map "# line 1 \"$$self{name}\::$_\"\n"
                       . "sub $_ {${$$self{methods}}{$_}\n}",
                     sort keys %{$$self{methods}});
      },
    }
  }, 'ni::/lib/slice');

my $slice_commit = eval("sub {" . ni('ni:/lib/slice.b')->{methods}->{commit}
                                . "\n}")->(ni('ni:/lib/slice.b'));
@{'ni::/lib/slice::ISA'} = $slice_commit->package;

ni->def('ni:/lib/slice_init.b' =>
  bless {
    name => '/lib/slice_init.b',
    header => undef,
    commit => undef,
    methods => {
      instantiate => fn q{
        my $class = shift;
        my $name  = shift;
        my %args  = @_;
        +{header  => delete($args{header}) || '',
          name    => $name,
          methods => \%args};
      }
    }
  }, 'ni::/lib/slice');

ni('ni:/lib/slice_init.b')->commit;

ni->def('ni:/lib/instantiable.b' =>
  bless {
    name => '/lib/instantiable.b',
    header => undef,
    commit => undef,
    methods => {
      new => fn q{
        local $_;
        my $class   = shift;
        my $package = ref $class ? $class->package : $class;

        # TODO: this needs to be virtual
        my $self    = bless &{"$package\::instantiate"}($class, @_), $package;

        # TODO: traverse superclasses
        &$_($self) for @{ref($self) . "::ctors"};
        $self;
      }
    }
  }, 'ni::/lib/slice');

ni('ni:/lib/instantiable.b')->commit;

ni->def(
  'ni:/lib/named_in_ni.b' =>
    'lib/slice'->new('/lib/named_in_ni.b',
      namespace => fn q{'ni'}),
  'ni:/lib/named.b' =>
    'lib/slice'->new('/lib/named.b',
      ctor => fn q{my $s = shift; ni->def($s->name, $s)},
      name => fn q{$_[0]->namespace . ":" . $_[0]->{name}}));

ni('ni:/lib/named.b')->apply('lib/slice');
ni('ni:/lib/named_in_ni.b')->apply('lib/slice');

'lib/slice'->new('/lib/namespaced.b',
  package => fn q{(my $name = shift->{name}) =~ s/^\///; $name});

ni('ni:/lib/namespaced.b')->apply('lib/slice');

# /lib/tag.b
'lib/slice'->new('/lib/resolver.b',
  resolve => fn q{ref $_[1] ? $_[1] : ni"ni:$_[1]"});

'lib/slice'->new('/lib/tag.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $self->resolve($_)->apply($p) for @{$$self{slices}};
    $self;
  });

'lib/slice'->new('/lib/tag_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name => $name, slices => [@_]};
  });

ni('ni:/lib/tag.b')->apply('lib/tag');
ni('ni:/lib/tag_init.b')->apply('lib/tag');
ni('ni:/lib/named.b')->apply('lib/tag');
ni('ni:/lib/named_in_ni.b')->apply('lib/tag');
ni('ni:/lib/namespaced.b')->apply('lib/tag');
ni('ni:/lib/instantiable.b')->apply('lib/tag');
ni('ni:/lib/resolver.b')->apply('lib/tag');

# /lib/branch.b
'lib/slice'->new('/lib/branch.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $p = $p->package if ref $p;
    $$self{applied_to}{$p} = 1;
    $self->resolve($_)->apply($p) for @{$$self{slices}};
    $self;
  },
  add => fn q{
    local $_;
    my $self = shift;
    push @{$$self{slices}}, @_;
    for my $p (sort keys %{$$self{applied_to}}) {
      $self->resolve($_)->apply($p) for @_;
    }
    $self;
  });

'lib/slice'->new('/lib/branch_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name       => $name,
      applied_to => {},
      slices     => [@_]};
  });

'lib/tag'->new('/lib/perlbranch.b',
  '/lib/branch.b',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/namespaced.b',
  '/lib/resolver.b');

ni('ni:/lib/perlbranch.b')->apply('lib/branch');
ni('ni:/lib/branch_init.b')->apply('lib/branch');

'lib/slice'->new('/lib/instance.b',
  DESTROY => fn q{
    local $_;
    my $self = shift;
    defined($_) && $_->($self) for @{ref($self) . '::dtors'};
  },
  class => fn q{ni 'ni:/' . ref shift});

# /lib/dataslice.b
'lib/slice'->new('/lib/dataslice_init.b',
  instantiate => fn q{
    my $class = shift;
    my $name = shift;
    +{name => $name, data => {@_}};
  });

'lib/slice'->new('/lib/dataslice.b',
  apply  => fn q{shift->apply_(@_)},
  apply_ => fn q{
    local $_;
    my ($self, $p) = @_;
    $p = $p->package if ref $p;
    return if $$self{applied_to}{$p};
    $$self{applied_to}{$p} = 1;
    *{"$p\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
    $self;
  });
