# /lib/slice.b
ni->def('ni:/lib/slice.b' =>
  bless {
    name => '/lib/slice.b',
    methods => {
      apply => fn q{
        local $_;
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p};
        for (keys %{$$self{methods}}) {
          die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
        }
        $self->apply_($p);
      },

      apply_ => fn q{
        local $_;
        my ($self, $p) = @_;
        return if $$self{applied_to}{$p};
        $$self{applied_to}{$p} = 1;
        push @{"$p\::ctors"}, $$self{ctor} if $$self{ctor};
        push @{"$p\::dtors"}, $$self{dtor} if $$self{dtor};
        if (grep /^\(/, keys %{$$self{methods}}) {
          *{"$p\::()"} = *{"$p\::(("} = sub {};
          *{"$p\::OVERLOAD"} = {dummy => 1};
        }
        *{"$p\::$_"} = \&{$$self{methods}{$_}} for keys %{$$self{methods}};
        $self;
      }
    }
  }, 'ni::/lib/slice');

ni('ni:/lib/slice.b')->{methods}->{apply_}
  ->(ni('ni:/lib/slice.b'), 'ni::/lib/slice');

ni->def('ni:/lib/slice_init.b' =>
  bless {
    name => '/lib/slice_init.b',
    methods => {
      instantiate => fn q{
        my $class = shift;
        my $name  = shift;
        my %args  = @_;
        +{ctor       => delete($args{ctor}),
          dtor       => delete($args{dtor}),
          applied_to => delete($args{applied_to}),
          name       => $name,
          methods    => \%args};
      }
    }
  }, 'ni::/lib/slice');

ni('ni:/lib/slice_init.b')->apply('ni::/lib/slice');

ni->def('ni:/lib/instantiable.b' =>
  bless {
    name => '/lib/instantiable.b',
    methods => {
      new => fn q{
        local $_;
        my $class   = shift;
        my $package = ref $class ? $class->package : $class;
        my $self    = bless &{"$package\::instantiate"}($class, @_), $package;
        $_->($self) for @{ref($self) . "::ctors"};
        $self;
      }
    }
  }, 'ni::/lib/slice');

ni('ni:/lib/instantiable.b')->apply('ni::/lib/slice');

ni->def(
  'ni:/lib/named_in_ni.b' =>
    'ni::/lib/slice'->new('/lib/named_in_ni.b',
      namespace => fn q{'ni'}),
  'ni:/lib/named.b' =>
    'ni::/lib/slice'->new('/lib/named.b',
      ctor => fn q{my $s = shift; ni->def($s->name, $s)},
      name => fn q{$_[0]->namespace . ":" . $_[0]->{name}}));

ni('ni:/lib/named.b')->apply('ni::/lib/slice');
ni('ni:/lib/named_in_ni.b')->apply('ni::/lib/slice');

'ni::/lib/slice'->new('/lib/namespaced.b',
  package => fn q{
    my $name = shift->{name};
    $name =~ /^\// ? "ni::$name" : $name;
  });

ni('ni:/lib/namespaced.b')->apply('ni::/lib/slice');

# /lib/tag.b
'ni::/lib/slice'->new('/lib/resolver.b',
  resolve => fn q{ref $_[1] ? $_[1] : ni"ni:$_[1]"});

'ni::/lib/slice'->new('/lib/tag.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $_->apply($p) for @{$$self{slices}};
    $self;
  });

'ni::/lib/slice'->new('/lib/tag_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name   => $name,
      slices => [map $class->resolve($_), @_]};
  });

ni('ni:/lib/tag.b')->apply('ni::/lib/tag');
ni('ni:/lib/tag_init.b')->apply('ni::/lib/tag');
ni('ni:/lib/named.b')->apply('ni::/lib/tag');
ni('ni:/lib/named_in_ni.b')->apply('ni::/lib/tag');
ni('ni:/lib/namespaced.b')->apply('ni::/lib/tag');
ni('ni:/lib/instantiable.b')->apply('ni::/lib/tag');
ni('ni:/lib/resolver.b')->apply('ni::/lib/tag');

# /lib/branch.b
'ni::/lib/slice'->new('/lib/branch.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $p = $p->package if ref $p;
    $$self{applied_to}{$p} = 1;
    $_->apply($p) for @{$$self{slices}};
    $self;
  },
  add => fn q{
    local $_;
    my $self = shift;
    my @s = map $self->resolve($_), @_;
    push @{$$self{slices}}, @s;
    for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
    $self;
  });

'ni::/lib/slice'->new('/lib/branch_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name       => $name,
      applied_to => {},
      slices     => [map $class->resolve($_), @_]};
  });

'ni::/lib/tag'->new('/lib/perlbranch.b',
  '/lib/branch.b',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/namespaced.b',
  '/lib/resolver.b');

ni('ni:/lib/perlbranch.b')->apply('ni::/lib/branch');
ni('ni:/lib/branch_init.b')->apply('ni::/lib/branch');

'ni::/lib/slice'->new('/lib/instance.b',
  DESTROY => fn q{
    local $_;
    my $self = shift;
    defined($_) && $_->($self) for @{ref($self) . '::dtors'};
  },
  class => fn q{(my $r = ref shift) =~ s/^ni::/ni:/; ni$r});

# /lib/dataslice.b
'ni::/lib/slice'->new('/lib/dataslice_init.b',
  instantiate => fn q{
    my $class = shift;
    my $name = shift;
    +{name => $name, data => {@_}};
  });

'ni::/lib/slice'->new('/lib/dataslice.b',
  apply  => fn q{shift->apply_(@_)},
  apply_ => fn q{
    local $_;
    my ($self, $p) = @_;
    $p = $p->package if ref $p;
    return if $$self{applied_to}{$p};
    $$self{applied_to}{$p} = 1;
    *{"$p\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
    $self;
  });
