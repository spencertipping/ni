# /lib/slice.b
ni->def('ni:/lib/slice.b' =>
  bless {
    name => '/lib/slice.b',
    header => undef,
    commit => undef,
    methods => {
      ctor => fn q{shift->commit},
      commit => fn q{
        my $self = shift;
        $$self{commit} ||= 'ni::/lib/commit'->new(
          join "\n",
            'my $commit_package = __PACKAGE__;',
            "# line 1 \"$$self{name}\"",
            ($$self{header} ? ($$self{header},';') : ()),
            map "# line 0 \"$$self{name}\::$_\"\n"
              . "{package ni;*{\$commit_package . '\::$_'}=sub{\n${$$self{methods}}{$_}\n}}",
            sort keys %{$$self{methods}});
      },
    }
  }, 'ni::/lib/slice');

my $slice_commit = eval("sub {" . ni('ni:/lib/slice.b')->{methods}->{commit}
                                . "\n}")->(ni('ni:/lib/slice.b'));
push @{'ni::/lib/slice::ISA'}, $slice_commit->package;

ni->def('ni:/lib/slice_init.b' =>
  bless {
    name => '/lib/slice_init.b',
    header => undef,
    commit => undef,
    methods => {
      instantiate => fn q{
        my $class = shift;
        my $name  = shift;
        my %args  = @_;
        +{header  => delete($args{header}) || '',
          name    => $name,
          methods => \%args};
      }
    }
  }, 'ni::/lib/slice');

push @{'ni::/lib/slice::ISA'}, ni('ni:/lib/slice_init.b')->commit->package;

ni->def('ni:/lib/instantiable.b' =>
  bless {
    name => '/lib/instantiable.b',
    header => undef,
    commit => undef,
    methods => {
      ancestors => fn q{
        my $package  = ref shift;
        my %supers   = ($package => $package);
        my @frontier = $package;
        @supers{@frontier} = @frontier
          while @frontier = grep !$supers{$_}, map @{"$_\::ISA"}, @frontier;
        sort keys %supers;
      },

      invoke_ctors => fn q{
        local $_;
        my $self = shift;
        defined *{"$_\::ctor"}{CODE} && &{"$_\::ctor"}($self)
          for $self->ancestors;
        $self;
      },

      new => fn q{
        my $class   = shift;
        my $package = ref $class ? $class->package : $class;
        my $ctor    = $package->can('instantiate');
        die "no ::instantiate method defined for $package"
          unless defined $ctor;
        bless(&$ctor($class, @_), $package)->invoke_ctors;
      }
    }
  }, 'ni::/lib/slice');

push @{'ni::/lib/slice::ISA'}, ni('ni:/lib/instantiable.b')->commit->package;

ni->def(
  'ni:/lib/named_in_ni.b' =>
    'ni::/lib/slice'->new('/lib/named_in_ni.b',
      namespace => fn q{'ni'}),
  'ni:/lib/named.b' =>
    'ni::/lib/slice'->new('/lib/named.b',
      ctor => fn q{my $s = shift; ::ni->def($s->name, $s)},
      name => fn q{$_[0]->namespace . ":" . $_[0]->{name}}));

push @{'ni::/lib/slice::ISA'}, ni('ni:/lib/named_in_ni.b')->commit->package;
push @{'ni::/lib/slice::ISA'}, ni('ni:/lib/named.b')->commit->package;

'ni::/lib/slice'->new('/lib/namespaced_by_commit.b',
  package => fn q{shift->commit->package});

push @{'ni::/lib/slice::ISA'},
  ni('ni:/lib/namespaced_by_commit.b')->commit->package;

'ni::/lib/slice'->new('/lib/namespaced_by_symbol.b',
  package => fn q{'ni::' . shift->{name}});

# /lib/tag.b
'ni::/lib/slice'->new('/lib/resolver.b',
  resolve => fn q{ref $_[1] ? $_[1] : ::ni"ni:$_[1]"});

'ni::/lib/slice'->new('/lib/tag.b',
  ctor => fn q{shift->commit},
  commit => fn q{
    local $_;
    my $self = shift;
    return $$self{commit} if $$self{commit};
    my @parents = map $_->commit, @{$$self{slices}};
    my $parent_packages = join ' ', map $_->package, @{$$self{slices}};
    my $package = $self->package;
    $$self{commit} = 'ni::/lib/commit'->new(@parents,
      qq{our \@ISA = qw($parent_packages);\@{'$package\::ISA'} = __PACKAGE__});
  });

'ni::/lib/slice'->new('/lib/tag_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name => $name, slices => [map $class->resolve($_), @_]};
  });

push @{'ni::/lib/tag::ISA'},
  map ni("ni:/lib/$_.b")->commit->package,
      qw/tag tag_init named named_in_ni namespaced_by_symbol instantiable
         resolver/;

# /lib/branch.b
'ni::/lib/slice'->new('/lib/branch.b',
  apply => fn q{
    my ($self, $p) = @_;
    my $package = $self->package;
    $self->add('ni::/lib/commit'->new(qq{push \@{'$p\::ISA'}, '$package'}));
  },

  add => fn q{
    local $_;
    my $self = shift;
    push @{$$self{slices}}, map $self->resolve($_), @_;
    $$self{commit} = undef;
    $self->commit;
    $self;
  });

push @{'ni::/lib/branch::ISA'},
  'ni::/lib/tag',
  ni('ni:/lib/branch.b')->package;

'ni::/lib/slice'->new('/lib/instance.b',
  DESTROY => fn q{
    local $_;
    my $self = shift;
    defined *{"$_\::dtor"}{CODE} && &{"$_\::dtor"}($self)
      for $self->ancestors;
  },
  class => fn q{
    (my $package = ref shift) =~ s/^ni::/ni:/;
    ::ni($package);
  });
