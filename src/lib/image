ni('ni:/object')->child('/lib/image')
  ->doc
  ->synopsis(q'
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->into_sync($a_file);         # TODO')
  ->description(
    q[Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.])
  ->end

  ->def('/lib/image_init.b',
    instantiate => fn q{
      +{gensym_n     => 0,
        circular     => [],
        definitions  => {},
        objects      => {},
        side_effects => [],
        finalizers   => [],
        visited      => {},
        ordering     => []};
    })

  ->def('/lib/image_quoting.b',
    circular_links => fn q{
      local $_;
      my $self = shift;
      map "\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
          @{$$self{circular}};
    },

    reconstruction => fn q{
      my $self = shift;
      (@{$$self{definitions}}{@{$$self{ordering}}},
       $self->circular_links,
       @{$$self{side_effects}},
       @{$$self{finalizers}});
    },

    # TODO: replace this with an IO-idiomatic cat structure thing
    r => fn q{
      local $_;
      my $self = shift;
      ni('ni:/io/cat')->new(map ni('ni:/io/str')->new("" . $_),
        "#!/usr/bin/env perl\n",
        "chomp(\$ni::license=<<'_');\n", $ni::license, "\n_\n",
        "BEGIN{eval(\$ni::boot=<<'_')}\n", $ni::boot, "\n_\n",
        map("$_\n", $self->reconstruction),
        "ni->run(\@ARGV);", "\n__DATA__\n");
    },

    address => fn q{
      return 'undef' unless defined $_[1];
      return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
      "addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \$_[1]);
    },

    quote => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0])
        if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
      my $a = $self->address($_[0]);
      $$self{objects}{$a} = \$_[0];
      my $v = $$self{visited}{$a};
      return ref $v ? '0' : $v if defined $v;
      $$self{visited}{$a} = \'undef';
      $self->allocate_gensym($_[0], $self->quote_value($_[0]));
    },

    allocate_gensym => fn q{
      my $self = shift;
      my $a = $self->address(shift);
      return $$self{visited}{$a} if $_[0] =~ /^\$\w+$/;
      my $g = $$self{visited}{$a} = $self->gensym;
      $$self{definitions}{$g} = "$g=$_[0];";
      push @{$$self{ordering}}, $g;
      $g;
    },

    # TODO: replace this with more structured alternatives
    side_effect      => fn q{push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    boot_side_effect => fn q{unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    finalizer        => fn q{push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]})

  ->add('/lib/quote_code_fail.b',
        '/lib/quote_values.b',
        '/lib/quote_objects.b',
        '/lib/quote_circular_addressed.b',
        '/lib/gensym_generator_compact.b');

ni('ni:/lib/fn')->def('/lib/fn_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    $quote->quote_class(ref $self);

    (my $code = $$self{code}) =~ s/^\s*\n|\s*$//g;
    my @lines = split /\n/, $code;
    my $spaces = length $code;
    for (@lines) {
      $spaces = length $1 if /^([ \t]*)\S/ && length $1 < $spaces;
    }
    $spaces = ' ' x $spaces;
    s/^$spaces// for @lines;

    my %state = %$self;
    delete $state{fn};
    $state{code} = join "\n", @lines;
    $quote->quote_blessed(\%state, ref $self);
  });

ni('ni:/lib/slice')->def('/lib/slice_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    my $name = $self->name;
    $quote->quote_class(ref $self);

    if (defined $name and $name eq 'ni:/lib/slice.b') {
      my %methods;
      my @ks = sort keys %{$$self{methods}};
      @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
      for my $p (sort keys %{$$self{applied_to}}) {
        $quote->boot_side_effect(
          '*' . $quote->quote("$p\::$_") . "=\\\\\&$methods{$_};")
          for @ks;
      }
    }

    my $g = $quote->allocate_gensym($self,
      $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
    $quote->side_effect("$g\->apply_unsafe(" . $quote->quote($_) . ");")
      for sort keys %{$$self{applied_to}};
    $g;
  });
