ni('ni:/object')->child('/lib/image')
  ->doc
  ->synopsis(q'
    my $image = ni("ni:/lib/image")->new;
    my $gensym = $image->quote($value);
    $image->io->into_sync($a_file);')
  ->description(
    q[Generates Perl code that reconstructs the state of objects at the
      behavior/slice level. Since classes are self-describing, this results in
      a replica of the runtime object-oriented state.],

    q[ni ends up being a quine:],
    eg q{
      if (-r $0) {
        my $contents = ni("file:$0")->read_all;
        my $replica  = ni->quoted->io->read_all;
        now $replica == $contents;
      }
    })

  ->end

  ->def('/lib/image_init.b',
    instantiate => fn q{
      +{gensym_n     => 0,
        circular     => [],
        definitions  => {},
        objects      => {},
        side_effects => [],
        finalizers   => [],
        visited      => {},
        ordering     => []};
    })

  ->def('/lib/image_quoting.b',
    reconstruction => fn q{
      my $self = shift;
      (@{$$self{definitions}}{@{$$self{ordering}}},
       $self->circular_links,
       @{$$self{side_effects}},
       @{$$self{finalizers}});
    },

    io => fn q{
      local $_;
      my $self = shift;
      ni('ni:/io/str')->new(join '',
        "#!/usr/bin/env perl\n",
        "chomp(\$ni::license=<<'_');\n", $ni::license, "\n_\n",
        "BEGIN{eval(\$ni::boot=<<'_')}\n", $ni::boot, "\n_\n",
        $self->reconstruction,
        "ni->run(\@ARGV);",
        "\n__DATA__\n");
    },

    # TODO: replace this with more structured alternatives
    side_effect      => fn q{push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    boot_side_effect => fn q{unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    finalizer        => fn q{push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]})

  ->add('/lib/quote_code_fail.b',
        '/lib/quote_values.b',
        '/lib/quote_objects.b',
        '/lib/quote_circular_addressed.b',
        '/lib/quote_gensym_identity.b',
        '/lib/gensym_generator_compact.b');

ni('ni:/lib/fn')->def('/lib/fn_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    $quote->quote_class(ref $self);

    (my $code = $$self{code}) =~ s/^\s*\n|\s*$//g;
    my @lines = split /\n/, $code;
    my $spaces = length $code;
    for (@lines) {
      $spaces = length $1 if /^([ \t]*)\S/ && length $1 < $spaces;
    }
    $spaces = ' ' x $spaces;
    s/^$spaces// for @lines;

    my %state = %$self;
    delete @state{qw/fn eval_number/};
    $state{code} = join "\n", @lines;
    $quote->quote_blessed(\%state, ref $self);
  });

ni('ni:/lib/slice')->def('/lib/slice_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    my $name = $self->name;
    $quote->quote_class(ref $self);

    if (defined $name and $name eq 'ni:/lib/slice.b') {
      my %methods;
      my @ks = sort keys %{$$self{methods}};
      @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
      for my $p (sort keys %{$$self{applied_to}}) {
        $quote->boot_side_effect(
          '*' . $quote->quote("$p\::$_") . "=\\\\\&$methods{$_};")
          for @ks;
      }
    }

    my $g = $quote->allocate_gensym($self,
      $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
    $quote->side_effect("$g\->apply_(" . $quote->quote($_) . ");")
      for sort keys %{$$self{applied_to}};
    $g;
  });
