ni('ni:/object')->child('/lib/image')
  ->def('/lib/image_init.b',
    instantiate => fn q{
      my $class = shift;
      my %args  = (
        include_shebang => 1,
        include_license => 1,
        include_boot    => 1,
        include_classes => 1,
        include_run     => 1,
        local_vars      => 0,
        use_newlines    => 0,
        @_);

      +{include_shebang => $args{include_shebang},
        include_license => $args{include_license},
        include_boot    => $args{include_boot},
        include_classes => $args{include_classes},
        include_run     => $args{include_run},
        local_vars      => $args{local_vars},
        use_newlines    => $args{use_newlines},

        gensym_n     => 0,
        circular     => [],
        definitions  => {},
        objects      => {},
        side_effects => [],
        finalizers   => [],
        visited      => {},
        ordering     => []};
    })

  ->def('/lib/image_quoting.b',
    gensym => fn q{
      my $n = shift->{gensym_n}++;
      my $s = '$' .
        substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
               $n % 50, 1;
      $n = int $n / 50;
      while ($n) {
        $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
                     $n % 63, 1;
        $n = int $n / 63;
      }
      $s;
    },

    circular_links => fn q{
      local $_;
      my $self = shift;
      map "\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
          @{$$self{circular}};
    },

    reconstruction => fn q{
      my $self = shift;
      (@{$$self{definitions}}{@{$$self{ordering}}},
       $self->circular_links,
       @{$$self{side_effects}},
       @{$$self{finalizers}});
    },

    write => fn q{
      local $_;
      my ($self, $fh) = @_;
      $fh->print($_) for
        ($$self{include_shebang} ? ("#!/usr/bin/env perl\n") : ()),
        ($$self{include_license} ? ("chomp(\$ni::license=<<'_');\n", $ni::license, "\n_\n") : ()),
        ($$self{include_boot}    ? ("BEGIN{eval(\$ni::boot=<<'_')}\n", $ni::boot, "\n_\n") : ()),
        ($$self{use_newlines}    ? map("$_\n", $self->reconstruction) : $self->reconstruction),
        ($$self{include_run}     ? ("ni->run(\@ARGV);", "\n__DATA__\n") : ());
    },

    address => fn q{
      return 'undef' unless defined $_[1];
      return "id:$_[1]" if !ref $_[1] && length $_[1] < 256;
      "addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \$_[1]);
    },

    quote => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0])
        if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
      my $a = $self->address($_[0]);
      $$self{objects}{$a} = \$_[0];
      my $v = $$self{visited}{$a};
      return ref $v ? 'undef' : $v if defined $v;
      $$self{visited}{$a} = \'undef';
      $self->allocate_gensym($_[0], $self->quote_value($_[0]));
    },

    allocate_gensym => fn q{
      my $self = shift;
      my $a = $self->address(shift);
      return $$self{visited}{$a} if $_[0] =~ /^\$\w+$/;
      my $g = $$self{visited}{$a} = $self->gensym;
      $$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
      push @{$$self{ordering}}, $g;
      $g;
    },

    is_circular => fn q{
      my $self = shift;
      ref $$self{visited}{$self->address($_[0])};
    },

    # TODO: replace this with more structured alternatives
    side_effect      => fn q{push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    boot_side_effect => fn q{unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    finalizer        => fn q{push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]},

    circular_hashref => fn q{
      my $self          = shift;
      my $address       = $self->address(shift);
      my $quoted_key    = $self->quote(shift);
      my $value_address = $self->address(shift);
      push @{$$self{circular}}, [$address, "{$quoted_key}", $value_address];
      $self;
    },

    circular_arrayref => fn q{
      my $self          = shift;
      my $address       = $self->address(shift);
      my $index         = shift;
      my $value_address = $self->address(shift);
      push @{$$self{circular}}, [$address, "[$index]", $value_address];
      $self;
    })

  ->add('/lib/no_code_quoting.b',
        '/lib/quote_values.b',
        '/lib/quote_objects.b');

ni('ni:/lib/fn')->def('/lib/fn_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    $quote->quote_class(ref $self);

    (my $code = $$self{code}) =~ s/^\s*\n|\s*$//g;
    my @lines = split /\n/, $code;
    my $spaces = length $code;
    for (@lines) {
      $spaces = length $1 if /^([ \t]*)\S/ && length $1 < $spaces;
    }
    $spaces = ' ' x $spaces;
    s/^$spaces// for @lines;

    my %state = %$self;
    delete $state{fn};
    $state{code} = join "\n", @lines;
    $quote->quote_blessed(\%state, ref $self);
  });

ni('ni:/lib/slice')->def('/lib/slice_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    my $name = $self->name;
    $quote->quote_class(ref $self);

    if (defined $name and $name eq 'ni:/lib/slice.b') {
      my %methods;
      my @ks = sort keys %{$$self{methods}};
      @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
      for my $p (sort keys %{$$self{applied_to}}) {
        $quote->boot_side_effect(
          '*' . $quote->quote("$p\::$_") . "=\\\\\&$methods{$_};")
          for @ks;
      }
    }

    my $g = $quote->allocate_gensym($self,
      $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
    $quote->side_effect("$g\->apply_unsafe(" . $quote->quote($_) . ");")
      for sort keys %{$$self{applied_to}};
    $g;
  });
