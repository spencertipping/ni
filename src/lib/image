# TODO
# Extend the serialization protocol by making a "running context" that is aware
# of sessions and can be used to implement RMI.

ni('ni:/object')->child('/lib/image')
  ->def('/lib/image_init.b',
    instantiate => fn q{
      my $class = shift;
      my %args  = (
        include_shebang => 1,
        include_license => 1,
        include_boot    => 1,
        include_classes => 1,
        include_run     => 1,
        local_vars      => 0,
        use_newlines    => 0,
        @_);

      +{include_shebang => $args{include_shebang},
        include_license => $args{include_license},
        include_boot    => $args{include_boot},
        include_classes => $args{include_classes},
        include_run     => $args{include_run},
        local_vars      => $args{local_vars},
        use_newlines    => $args{use_newlines},

        gensym_n     => 0,
        circular     => [],
        definitions  => {},
        objects      => {},
        side_effects => [],
        finalizers   => [],
        visited      => {},
        ordering     => []};
    })

  ->def('/lib/image_quoting.b',
    gensym => fn q{
      my $n = shift->{gensym_n}++;
      my $s = '$' .
        substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
               $n % 50, 1;
      $n = int $n / 50;
      while ($n) {
        $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
                     $n % 63, 1;
        $n = int $n / 63;
      }
      $s;
    },

    circular_links => fn q{
      local $_;
      my $self = shift;
      map "\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
          @{$$self{circular}};
    },

    reconstruction => fn q{
      my $self = shift;
      (@{$$self{definitions}}{@{$$self{ordering}}},
       $self->circular_links,
       @{$$self{side_effects}},
       @{$$self{finalizers}});
    },

    write => fn q{
      local $_;
      my ($self, $fh) = @_;
      $fh->print($_) for
        ($$self{include_shebang} ? ("#!/usr/bin/env perl\n") : ()),
        ($$self{include_license} ? ("chomp(\$ni::license=<<'_');\n", $ni::license, "\n_\n") : ()),
        ($$self{include_boot}    ? ("BEGIN{eval(\$ni::boot=<<'_')}\n", $ni::boot, "\n_\n") : ()),
        ($$self{use_newlines}    ? map("$_\n", $self->reconstruction) : $self->reconstruction),
        ($$self{include_run}     ? ("ni->run(\@ARGV);", "\n__DATA__\n") : ());
    },

    address => fn q{
      return 'undef' unless defined $_[1];
      return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
      "addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \$_[1]);
    },

    quote => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0])
        if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
      my $a = $self->address($_[0]);
      $$self{objects}{$a} = \$_[0];
      my $v = $$self{visited}{$a};
      return ref $v ? 'undef' : $v if defined $v;
      $$self{visited}{$a} = \'undef';
      $self->allocate_gensym($_[0], $self->quote_value($_[0]));
    },

    allocate_gensym => fn q{
      my $self = shift;
      my $a = $self->address(shift);
      return $$self{visited}{$a} if $_[0] =~ /^\$\w+$/;
      my $g = $$self{visited}{$a} = $self->gensym;
      $$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
      push @{$$self{ordering}}, $g;
      $g;
    },

    # TODO: replace this with more structured alternatives
    side_effect      => fn q{push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    boot_side_effect => fn q{unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    finalizer        => fn q{push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]},

    quote_value => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0]) unless ref $_[0];
      return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
      return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
      die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
      $self->quote_object($_[0]);
    },

    is_circular => fn q{
      my $self = shift;
      ref $$self{visited}{$self->address($_[0])};
    },

    quote_hash => fn q{
      local $_;
      my ($self, $v) = @_;
      my $a = $self->address($v);
      my @ks = sort keys %$v;
      my @qs;
      for my $k (@ks) {
        push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                       $self->address($$v{$k})]
        if $self->is_circular($$v{$k});
        push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
      }
      '{' . join(",", @qs) . '}';
    },

    quote_array => fn q{
      local $_;
      my ($self, $v) = @_;
      my $a = $self->address($v);
      $self->is_circular($$v[$_])
        && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
      for 0..$#{$v};
      '[' . join(',', map $self->quote($_), @$v) . ']';
    },

    quote_scalar => fn q{
      my $v = $_[1];
      return 'undef' unless defined $v;
      return $v if Scalar::Util::looks_like_number $v;
      $v =~ s/([\\\\#])/\\\\$1/g;
      "q#$v#";
    },

    quote_blessed => fn q{
      my ($self, $x, $r) = @_;
      $r ||= ref $x;
      $self->quote_class($r);
      my $t = Scalar::Util::reftype $x;
      my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
      "bless($quoted," . $self->quote($r) . ")";
    },

    quote_class => fn q{
      my ($self, $class) = @_;
      $self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");
    },

    quote_object => fn q{
      my $self = shift;
      my $q = $self->allocate_gensym($_[0],
        $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
      $self->finalizer("&\$_($q)for\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
      $q;
    });

ni('ni:/lib/fn')->def('/lib/fn_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    $quote->quote_class(ref $self);

    (my $code = $$self{code}) =~ s/^\s*\n|\s*$//g;
    my @lines = split /\n/, $code;
    my $spaces = length $code;
    for (@lines) {
      $spaces = length $1 if /^([ \t]*)\S/ && length $1 < $spaces;
    }
    $spaces = ' ' x $spaces;
    s/^$spaces// for @lines;

    my %state = %$self;
    delete $state{fn};
    $state{code} = join "\n", @lines;
    $quote->quote_blessed(\%state, ref $self);
  });

ni('ni:/lib/slice')->def('/lib/slice_serialize.b',
  serialize => fn q{
    local $_;
    my ($self, $quote) = @_;
    my $name = $self->name;
    $quote->quote_class(ref $self);

    if (defined $name and $name eq 'ni:/lib/slice.b') {
      my %methods;
      my @ks = sort keys %{$$self{methods}};
      @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
      for my $p (sort keys %{$$self{applied_to}}) {
        $quote->boot_side_effect(
          '*' . $quote->quote("$p\::$_") . "=\\\\\&$methods{$_};")
          for @ks;
      }
    }

    my $g = $quote->allocate_gensym($self,
      $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
    $quote->side_effect("$g\->apply_unsafe(" . $quote->quote($_) . ");")
      for sort keys %{$$self{applied_to}};
    $g;
  });
