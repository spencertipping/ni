ni('ni:/object')->child('/lib/doc', '/lib/named.b')
  ->def('/lib/doc_init.b',
    instantiate => fn q{shift; +{name => shift, doc => []}})

  ->def('/lib/doc_namespace.b', namespace => fn q{'ni.doc'})
  ->def('/lib/doc_define.b',
    fix_indentation => fn q{
      my ($self, $x) = @_;
      return $x if ref $x;
      my @lines = split /\n/, $x;
      return $x unless @lines > 1;
      my $indent = $lines[1] =~ /^(\s*)/ && length $1;
      for (@lines[2..$#lines]) {
        my $li = /^(\s*)/ && length $1;
        $indent = length $1 if length $1 < $indent;
      }
      my $spaces = ' ' x $indent;
      s/^$spaces// for @lines;
      join "\n", @lines;
    },

    AUTOLOAD => fn q{
      my $self = shift;
      (my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
      push @{$$self{doc}}, [$method, map $self->fix_indentation($_), @_];
      $self;
    })

  ->def('/lib/doc_end.b',
    referent => fn q{ni 'ni:' . shift->{name}},
    end      => fn q{shift->referent})

  ->def('/lib/doc_test.b',
    linearized => fn q{map @$_, @{shift->{doc}}},

    tests => fn q{
      my $self = shift;
      grep ref($_) eq 'lib/test_case', $self->linearized;
    },

    eg => fn q{
      my $self = shift;
      push @{$$self{doc}}, [eg => eg($_)] for @_;
      $self;
    });

ni('ni:/lib/behavior')->def('/lib/documentable.b',
  doc => fn q{
    my $self = shift;
    (my $name = $self->name) =~ s/^[^:]*://;
    return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
    ni('ni:/lib/doc')->new($name);
  });
