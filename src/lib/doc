ni('ni:/object')->child('/lib/doc', '/lib/named.b')
  ->def('/lib/doc_init.b',
    instantiate => fn q{shift; +{name => shift, doc => []}})

  ->def('/lib/doc_namespace.b', namespace => fn q{'ni.doc'})
  ->def('/lib/doc_define.b',
    AUTOLOAD => fn q{
      my $self = shift;
      (my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
      push @{$$self{doc}}, [$method, @_];
      $self;
    })

  ->def('/lib/doc_end.b',
    referent => fn q{ni 'ni:' . shift->{name}},
    end      => fn q{shift->referent})

  ->def('/lib/doc_test.b',
    tests => fn q{
      # TODO: not even close to the right way to do this.
      my $self = shift;
      my @flattened = map @$_, @{$$self{doc}};
      my @tests;
      return () unless @flattened;
      for (0..$#flattened - 1) {
        push @tests, $flattened[$_ + 1]
          if !ref $flattened[$_] && $flattened[$_] eq 'eg';
      }
      @tests;
    },

    eg => fn q{
      my $self = shift;
      push @{$$self{doc}}, [eg => $_] for @_;
      $self;
    });

ni('ni:/lib/behavior')->def('/lib/documentable.b',
  doc => fn q{
    my $self = shift;
    (my $name = $self->name) =~ s/^[^:]*://;
    return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
    ni('ni:/lib/doc')->new($name);
  });
