ni('ni:object')->child('lib/doc', 'lib/named.b')
  ->def('lib/doc_init.b',
    instantiate => fn q{shift; +{name => shift, doc => []}})

  ->def('lib/doc_namespace.b', namespace => fn q{'ni.doc'})
  ->def('lib/doc_define.b',
    AUTOLOAD => fn q{
      my $self = shift;
      (my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
      push @{$$self{doc}}, [$method, @_];
      $self;
    })

  ->def('lib/doc_test.b',
    tests => fn q{
      my $self = shift;
      my @flattened = map @$_, @{$$self{doc}};
      my @tests;
      return () unless @flattened;
      for (0..$#flattened - 1) {
        push @tests, $flattened[$_ + 1]
          if !ref $flattened[$_] && $flattened[$_] eq 'eg';
      }
      @tests;
    },

    eg => fn q{
      my $self = shift;
      push @{$$self{doc}}, [eg => $_] for @_;
      $self;
    });

ni('ni:lib/behavior')->def('lib/documentable.b',
  doc => fn q{
    my $self = shift;
    (my $name = $self->name) =~ s/^[^:]*://;
    return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
    ni('ni:lib/doc')->new($name);
  });
