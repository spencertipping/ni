ni('ni:/object')->child('/lib/doc', '/lib/named.b')
  ->def('/lib/doc_init.b',
    instantiate => fn q{shift; +{name => shift, doc => []}})

  ->def('/lib/doc_namespace.b', namespace => fn q{'ni.doc'})
  ->def('/lib/doc_define.b',
    AUTOLOAD => fn q{
      my $self = shift;
      (my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
      push @{$$self{doc}}, [$method, @_];
      $self;
    })

  ->def('/lib/doc_end.b',
    referent => fn q{ni 'ni:' . shift->{name}},
    end      => fn q{shift->referent})

  ->def('/lib/doc_test.b',
    linearized => fn q{map @$_, @{shift->{doc}}},

    tests => fn q{
      my $self = shift;
      my @flattened = $self->linearized;
      return () unless @flattened;
      my @eg_indexes = grep $flattened[$_] eq 'eg', 0..$#flattened;
      for (@eg_indexes) {
        ++$_ until $_ > @flattened or ref $flattened[$_] eq 'lib/fn';
      }
      @flattened[@eg_indexes];
    },

    eg => fn q{
      my $self = shift;
      push @{$$self{doc}}, [eg => $_] for @_;
      $self;
    });

ni('ni:/lib/behavior')->def('/lib/documentable.b',
  doc => fn q{
    my $self = shift;
    (my $name = $self->name) =~ s/^[^:]*://;
    return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
    ni('ni:/lib/doc')->new($name);
  });
