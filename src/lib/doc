ni('ni:/object')->child('/lib/doc', '/lib/named.b')
  ->def('/lib/doc_init.b',
    instantiate => fn q{shift; +{name => shift, doc => []}})

  ->def('/lib/doc_namespace.b', namespace => fn q{'ni.doc'})
  ->def('/lib/doc_define.b',
    AUTOLOAD => fn q{
      my $self = shift;
      (my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
      push @{$$self{doc}}, [$method, map ni::outdent($_), @_];
      $self;
    },

    '(@{}' => fn q{[map @$_, @{shift->{doc}}]})

  ->def('/lib/doc_end.b',
    referent => fn q{ni 'ni:' . shift->{name}},
    end      => fn q{shift->referent});

ni('ni:/lib/behavior')->def('/lib/documentable.b',
  doc => fn q{
    my $self = shift;
    (my $name = $self->name) =~ s/^[^:]*://;
    return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
    ni('ni:/lib/doc')->new($name);
  });

ni('ni:/lib/doc.c')->def('/lib/doc.c_defannotation.b',
  defannotation => fn q{
    my $class = shift;
    $class->def("$$class{name}_$_.b",
      $_ => fn qq{
        my \$self = shift;
        push \@{\$\$self{doc}},
             [$_ => $_(\$_)->referent(\$self->referent)] for \@_;
        \$self;
      }) for @_;
    $class;
  });

ni('ni:/object')
  ->child('/lib/object_metadata')
    ->rw('/lib/object_metadata_rw.b', qw/referent/)
  ->child('/lib/todo')
    ->def('/lib/todo_init.b',
      instantiate => fn q{
        my $class = shift;
        +{todo => [map ni::outdent($_), @_]};
      })
    ->def('/lib/todo_str.b',
      '(""' => fn q{
        my $self = shift;
        my $referent = $$self{referent} || '(anonymous)';
        "TODO $referent\n" . ni::indent(join("\n- ", @{$$self{todo}}), 2);
      });

ni('ni:/lib/doc')
  ->defannotation(qw/TODO eg/)
  ->def('/lib/doc_process.b',
    tests => fn q{grep ref($_) eq 'lib/test_case', @{$_[0]}},
    todos => fn q{grep ref($_) eq 'lib/todo', @{$_[0]}});

ni('ni:main')->def('/lib/todo_ctor.b',
  TODO => fn q{ni('ni:/lib/todo')->new(@_)});
