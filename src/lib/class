# /class and /metaclass
'ni::/lib/branch'->new('/lib/module_base.b',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/namespaced_by_symbol.b',
  '/lib/resolver.b');

'ni::/lib/branch'->new('/lib/class_base.b',
  '/lib/branch.b',
  '/lib/tag.b',
  '/lib/module_base.b',
  '/lib/instantiable.b',
  '/lib/tag_init.b');

ni('ni:/lib/class_base.b')->apply("ni::/$_")
  for qw/class metaclass class.c metaclass.c module.c/;

'ni::/metaclass.c'->new('/metaclass', '/lib/class_base.b');

ni('ni:/metaclass')->new('/metaclass.c', '/lib/class_base.b');
ni('ni:/metaclass')->new('/object.c', '/lib/class_base.b');
ni('ni:/metaclass')->new('/module.c', '/object.c');
ni('ni:/module.c')->new('/module', '/lib/class_base.b');

ni('ni:/metaclass')->new('/class.c', '/module.c');
ni('ni:/class.c')->new('/class', '/module', '/lib/instantiable.b');
ni('ni:/metaclass.c')->add('/class');

ni('ni:/object.c')->add('/class');
ni('ni:/object.c')->new('/object', '/lib/instance.b');

ni('ni:/module')->add('/object');

ni('ni:/class')->add('/module');
ni('ni:/metaclass')->add('/module');

# /lib/{slice,tag,branch}
ni('ni:/metaclass')->new('/lib/behavior.c', '/object.c');
ni('ni:/metaclass')->new('/lib/slice.c',    '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/tag.c',      '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/branch.c',   '/lib/tag.c');

ni('ni:/lib/behavior.c')->new('/lib/behavior', '/object');
ni('ni:/lib/tag.c')->new('/lib/tag',
  '/lib/behavior',
  '/lib/module_base.b',
  '/lib/instantiable.b',
  '/lib/tag_init.b',
  '/lib/tag.b');

ni('ni:/lib/branch.c')->new('/lib/branch',
  '/lib/tag',
  '/lib/branch.b');

ni('ni:/lib/slice.c')->new('/lib/slice',
  '/lib/behavior',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/namespaced_by_commit.b',
  '/lib/instantiable.b',
  '/lib/slice.b',
  '/lib/slice_init.b');

ni('ni:/module')->add('/lib/behavior');
ni('ni:/module.c')->add('/lib/behavior.c');

# Definition
ni('ni:/lib/branch')->new('/lib/definition.b');
ni('ni:/lib/branch')->add('/lib/definition.b');

ni('ni:/module')->add('/lib/definition.b');

ni('ni:/lib/definition.b')->add(
  ni('ni:/lib/slice')->new('/lib/definition_def.b',
    def => fn q{
      my $self = shift;
      my $name = shift;
      $name = "$$self{name}_$name" unless $name =~ /^\//;
      $self->add(::ni->exists("ni:$name")
        ? ::ni"ni:$name"
        : ::ni('ni:/lib/slice')->new($name, @_));
      $self;
    }));

# Encoding variants
ni('ni:/lib/branch')->new('/lib/hash_encoding.b');
ni('ni:/lib/branch')->new('/lib/array_encoding.b');
ni('ni:/lib/branch')->new('/lib/packed_encoding.b');

ni('ni:/object')->add('/lib/hash_encoding.b');

ni('ni:/lib/hash_encoding.b')->def('/lib/hash_accessor.b',
  ro => fn q{
    my ($self, $slice, @rs) = @_;
    $self->def($slice, map +($_ => qq{shift->{'$_'}}), @rs);
  },
  rw => fn q{
    my ($self, $slice, @as) = @_;
    $self->def($slice,
      map +($_ => qq{
        if (\@_ == 2) {
          \$_[0]->{'$_'} = \$_[1];
          \$_[0];
        } else {
          shift->{'$_'};
        }
      }), @as);
  });

# Subclassing
ni('ni:/class')->def('/lib/subclass.b',
  child => fn q{
    my ($self, $name, @slices) = @_;
    ::ni('ni:/metaclass')->new('$name.c', $self->class)
    ->new($name, $self, @slices);
  });

# Common behaviors
ni('ni:/lib/definition.b')
  ->def('/lib/name_as_string.b', header => q{use overload qw/"" name/})
  ->def('/lib/ref_eq.b',
    header => fn q{use overload qw/eq equals/},
    equals => fn q{
      ref($_[0]) eq ref($_[1])
        and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);
    });
