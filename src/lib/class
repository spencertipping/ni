# /class and /metaclass
'ni::/lib/slice'->new('/lib/class_init.b',
  ctor => fn q{my $s = shift; $s->apply($s->package)},
  instantiate => fn q{
    local $_;
    my ($class, $name, @slices) = @_;
    +{name   => $name,
      slices => [map $class->resolve($_), @slices]};
  }); 

'ni::/lib/tag'->new('/lib/class_base.b',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/tag.b',
  '/lib/namespaced_by_symbol.b',
  '/lib/instantiable.b',
  '/lib/resolver.b',
  '/lib/branch.b',
  '/lib/class_init.b');

ni('ni:/lib/class_base.b')->apply("ni::/$_")
  for qw/class metaclass class.c metaclass.c module.c/;

'ni::/metaclass.c'->new('/metaclass', '/lib/class_base.b');

ni('ni:/metaclass')->new('/metaclass.c');
ni('ni:/metaclass')->new('/object.c');
ni('ni:/metaclass')->new('/module.c', '/object.c');
ni('ni:/module.c')->new('/module', '/lib/class_init.b');

ni('ni:/metaclass')->new('/class.c', '/module.c');
ni('ni:/class.c')->new('/class', '/module', '/lib/instantiable.b', '/lib/class_init.b');
ni('ni:/metaclass.c')->add('/class');

ni('ni:/object.c')->add('/class');
ni('ni:/object.c')->new('/object', '/lib/instance.b');

ni('ni:/module')->add('/object');

ni('ni:/class')->add('/module');
ni('ni:/metaclass')->add('/module');

# /lib/{slice,dataslice,tag,branch}
ni('ni:/metaclass')->new('/lib/behavior.c',  '/object.c');
ni('ni:/metaclass')->new('/lib/slice.c',     '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/dataslice.c', '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/tag.c',       '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/branch.c',    '/lib/behavior.c');

ni('ni:/lib/behavior.c')->new('/lib/behavior', '/object');
ni("ni:/lib/$_.c")->new("/lib/$_",
  '/lib/behavior', '/lib/named.b',
  "/lib/$_.b", "/lib/$_\_init.b") for qw/dataslice slice branch tag/;

ni('ni:/lib/dataslice')->add(
  '/lib/named_in_ni.b',
  '/lib/namespaced.b',
  '/lib/resolver.b');

ni('ni:/module')->add('/lib/behavior');
ni('ni:/module.c')->add('/lib/behavior.c');

# Definition
ni('ni:/lib/branch')->new('/lib/definition.b');
ni('ni:/lib/branch')->add('/lib/definition.b');

ni('ni:/module')->add('/lib/definition.b');

ni('ni:/lib/definition.b')->add(
  ni('ni:/lib/slice')->new('/lib/definition_def.b',
    def => fn q{
      my $self = shift;
      my $name = shift;
      $name = "$$self{name}_$name" unless $name =~ /^\//;
      $self->add(ni->exists("ni:$name")
        ? ni"ni:$name"
        : ni('ni:/lib/slice')->new($name, @_));
      $self;
    }));

# Encoding variants
ni('ni:/lib/branch')->new('/lib/hash_encoding.b');
ni('ni:/lib/branch')->new('/lib/array_encoding.b');
ni('ni:/lib/branch')->new('/lib/packed_encoding.b');

ni('ni:/lib/definition.b')->add('/lib/hash_encoding.b');

ni('ni:/lib/hash_encoding.b')->def('/lib/hash_accessor.b',
  ro => fn q{
    my ($self, $slice, @rs) = @_;
    $self->def($slice, map +($_ => fn qq{shift->{'$_'}}), @rs);
  },
  rw => fn q{
    my ($self, $slice, @as) = @_;
    $self->def($slice,
      map +($_ => fn qq{
        if (\@_ == 2) {
          \$_[0]->{'$_'} = \$_[1];
          \$_[0];
        } else {
          shift->{'$_'};
        }
      }), @as);
  });

# Subclassing
ni('ni:/class')->def('/lib/subclass.b',
  child => fn q{
    my ($self, $name, @slices) = @_;
    ni("ni:/metaclass")->new("$name.c", $self->class)
    ->new($name, $self, @slices);
  });

# Common behaviors
ni('ni:/lib/definition.b')
  ->def('/lib/name_as_string.b', '(""' => fn q{shift->name})
  ->def('/lib/ref_eq.b',
    '(eq' => fn q{
      ref($_[0]) eq ref($_[1])
        and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);
    });

ni('ni:/lib/definition.b')->def('/lib/definition_defdata.b',
  defdata => fn q{shift->add(ni('ni:/lib/dataslice')->new(@_))});

# Constructor patterns
ni('ni:/lib/hash_encoding.b')->def('/lib/hash_encoding_init_with_defaults.b',
  instantiate_with_defaults => fn q{
    my ($class, @slots) = @_;
    my $generator = pop @slots;
    $class->def("$$class{name}_init.b",
      instantiate => fc(
        generator => $generator,
        '@slots'  => \@slots,
        q{
          my %defaults = &$generator(@_);
          my $class    = shift;
          my %args     = @_;
          $defaults{$_} = $args{$_} for @slots;
          \%defaults;
        }));
  });

# Static function support
ni('ni:/module')->new('ni');
ni('ni:/module')->new('main');
