ni::name(
  'ni:/behavior/class_init' =>
    '/behavior/slice'->new(
      ctor => sub {my $s = shift; $s->apply($s->package)},
      instantiate => sub {
        my ($class, $name, @slices) = @_;
        +{name   => $name,
          slices => [map ref($_) ? $_ : ni($_), @slices]};
      }),

  'ni:/class/behavior' =>
    bless {name   => '/class/behavior',
           slices => [ni"ni:/behavior/lifecycle",
                      ni"ni:/behavior/mapped_to_package",
                      ni"ni:/behavior/ni_namespaced",
                      ni"ni:/behavior/named_persistent"]},
    '/class/class');

# TODO: how do we implement a metaclass protocol if we don't have inheritance?
# Branches don't create subclasses; that's about instantiation.
#
# Maybe the implementation here is that each class has a backing metaclass like
# in ST-80, but they're built from meta-slices? I'm not sure the pairing makes
# sense here. If we have MC -> C, then MS1 + MS2 -> S1 + S2?
#
# More to the point ... does this really solve the problem? If MS1 instanceof
# MS, then its ->new is fixed by MS -- but if S1 instanceof MS1, then S1's
# ->new is free. Is this good enough? (It has to be: any instance methods must
# all come from a class.)
#
# How about this.

ni('ni:/behavior/class_init')->apply('/class/class');
ni('ni:/behavior/branch')->apply('/class/class');

ni('ni:/class/behavior')->apply('/class/class');

'/class/class'->new('/class/class',
  ni"ni:/class/behavior",
  ni"ni:/behavior/branch");

ni::name('ni:/behavior/slice_named_init' =>
  '/behavior/slice'->new(
    instantiate => sub {
      my ($class, $name, @methods) = @_;
      my $self = &{'/behavior/slice::instantiate'}($class, @methods);
      $$self{name} = $name;
      $self;
    }));

# TODO: here's the problem.
# ni:/class/slice is an instance of ni:/class/class, whose package is
# /class/class. /class/class is an instance of itself. Because of this instance
# relationship, /class/slice->new is the instance-method version of
# '/class/class'->new -- there's no distinction.
#
# So the object form ni("foo")->new is analogous to
# ref(ni("foo"))->new(ni("foo")) -- not the usual instantiation strategy. This
# seems like a real problem in a world where perl-style instantiation is even a
# remote possibility. Need to think about how to resolve this.
#
# I think the ST-80 metaclass protocol solves this for us.

'/class/class'->new('/class/slice',
  ni"ni:/class/behavior",
  ni"ni:/behavior/slice",
  ni"ni:/behavior/slice_named_init");

'/class/slice'->new("/behavior/$_" => ni("ni:/behavior/$_")->instantiation)
  for qw/slice slice_init lifecycle tag branch named ni_namespaced
         mapped_to_package named_transient named_persistent class_init
         slice_named_init/;

'/class/slice'->new('/behavior/class_method_def',
  def => sub {shift->add('/behavior/slice'->new(@_))});

'/class/slice'->new('/behavior/anonymous_fn_init',
  initialize => sub {
    my $class = shift;
    my $code  = pop;
    my $fn = ni::eval "sub {$code\n}";
    die "ni:/behavior/anonymous_fn_init: failed to compile $code: $@" if $@;
    +{code        => $code,
      annotations => [@_],
      fn          => $fn};
  });

delete ${'/class/fn::'}{new};

'/class/class'->new('/class/fn',
  ni"ni:/behavior/lifecycle",
  ni"ni:/behavior/anonymous_fn_init");
