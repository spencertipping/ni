# /class and /metaclass
'ni::/lib/branch'->new('/lib/module_base.b',
  '/lib/named.b',
  '/lib/named_in_ni.b',
  '/lib/tag.b',
  '/lib/namespaced_by_symbol.b',
  '/lib/resolver.b',
  '/lib/branch.b');

'ni::/lib/branch'->new('/lib/class_base.b',
  '/lib/module_base.b',
  '/lib/instantiable.b',
  '/lib/tag_init.b');

ni('ni:/lib/class_base.b')->apply("ni::/$_")
  for qw/class metaclass class.c metaclass.c module.c/;

'ni::/metaclass.c'->new('/metaclass', '/lib/class_base.b');

ni('ni:/metaclass')->new('/metaclass.c', '/lib/class_base.b');
ni('ni:/metaclass')->new('/object.c', '/lib/class_base.b');
ni('ni:/metaclass')->new('/module.c', '/object.c');
ni('ni:/module.c')->new('/module', '/lib/class_base.b');

ni('ni:/metaclass')->new('/class.c', '/module.c');
ni('ni:/class.c')->new('/class', '/module', '/lib/instantiable.b');
ni('ni:/metaclass.c')->add('/class');

ni('ni:/object.c')->add('/class');
ni('ni:/object.c')->new('/object', '/lib/instance.b');

ni('ni:/module')->add('/object');

ni('ni:/class')->add('/module');
ni('ni:/metaclass')->add('/module');

# /lib/{slice,tag,branch}
ni('ni:/metaclass')->new('/lib/behavior.c',  '/object.c');
ni('ni:/metaclass')->new('/lib/slice.c',     '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/tag.c',       '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/branch.c',    '/lib/behavior.c');

ni('ni:/lib/behavior.c')->new('/lib/behavior', '/object');
ni("ni:/lib/$_.c")->new("/lib/$_",
  '/lib/behavior',
  '/lib/module_base.b',
  '/lib/instantiable.b',
  "/lib/$_.b",
  "/lib/tag_init.b") for qw/branch tag/;

ni("ni:/lib/slice.c")->new("/lib/slice",
  '/lib/behavior',
  '/lib/module_base.b',
  '/lib/instantiable.b',
  "/lib/slice.b",
  "/lib/slice_init.b");

ni('ni:/module')->add('/lib/behavior');
ni('ni:/module.c')->add('/lib/behavior.c');

# Definition
ni('ni:/lib/branch')->new('/lib/definition.b');
ni('ni:/lib/branch')->add('/lib/definition.b');

ni('ni:/module')->add('/lib/definition.b');

ni('ni:/lib/definition.b')->add(
  ni('ni:/lib/slice')->new('/lib/definition_def.b',
    def => fn q{
      my $self = shift;
      my $name = shift;
      $name = "$$self{name}_$name" unless $name =~ /^\//;
      $self->add(ni->exists("ni:$name")
        ? ni"ni:$name"
        : ni('ni:/lib/slice')->new($name, @_));
      $self;
    }));

# Encoding variants
ni('ni:/lib/branch')->new('/lib/hash_encoding.b');
ni('ni:/lib/branch')->new('/lib/array_encoding.b');
ni('ni:/lib/branch')->new('/lib/packed_encoding.b');

ni('ni:/lib/definition.b')->add('/lib/hash_encoding.b');

ni('ni:/lib/hash_encoding.b')->def('/lib/hash_accessor.b',
  ro => fn q{
    my ($self, $slice, @rs) = @_;
    $self->def($slice, map +($_ => fn qq{shift->{'$_'}}), @rs);
  },
  rw => fn q{
    my ($self, $slice, @as) = @_;
    $self->def($slice,
      map +($_ => fn qq{
        if (\@_ == 2) {
          \$_[0]->{'$_'} = \$_[1];
          \$_[0];
        } else {
          shift->{'$_'};
        }
      }), @as);
  });

# Subclassing
ni('ni:/class')->def('/lib/subclass.b',
  child => fn q{
    my ($self, $name, @slices) = @_;
    ni("ni:/metaclass")->new("$name.c", $self->class)
    ->new($name, $self, @slices);
  });

# Common behaviors
ni('ni:/lib/definition.b')
  ->def('/lib/name_as_string.b', '(""' => fn q{shift->name})
  ->def('/lib/ref_eq.b',
    '(eq' => fn q{
      ref($_[0]) eq ref($_[1])
        and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);
    });

# Constructor patterns
ni('ni:/lib/hash_encoding.b')->def('/lib/hash_encoding_init_with_defaults.b',
  instantiate_with_defaults => fn q{
    my ($class, @slots) = @_;
    my $generator = pop @slots;
    $class->def("$$class{name}_init.b",
      instantiate => fc(
        generator => $generator,
        '@slots'  => \@slots,
        q{
          my %defaults = &$generator(@_);
          my $class    = shift;
          my %args     = @_;
          $defaults{$_} = $args{$_} for @slots;
          \%defaults;
        }));
  });

# Static function support
ni('ni:/module')->new('');
