ni('ni:/class')->doc
  ->synopsis(q[
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          # add existing behavior
      ->def('/message_init.b',          # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def('/behaviorname.b',          # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  ])

  ->description(
    q[ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.])

  ->behaviors(
    q[ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.],

    eg => fn q{
      my $fn = fn q{"hi"};
      my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
      $slice->apply('foo');
      now foo->f == 'hi';
    },

    q[TODO...])

  ->classes(
    q[ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.],

    q[TODO...]);
