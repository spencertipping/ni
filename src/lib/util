ni('ni:ni')->def('/lib/ni_static_util.b',
  sgr  => fn q{(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x},
  sr   => fn q{(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x},
  swap => fn q{@_[0, 1] = @_[1, 0]},
  dor  => fn q{defined $_[0] ? $_[0] : $_[1]},

  sum  => fn q{local $_; my $x = 0; $x += $_ for @_; $x},
  mean => fn q{sum(@_) / (@_ || 1)},

  max    => fn q{local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m},
  min    => fn q{local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m},
  maxstr => fn q{local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m},
  minstr => fn q{local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m},

  abbrev => fn q{length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'},

  indent => fn q{
    my ($s, $indent) = (@_, 2);
    join "\n", map ' ' x $indent . $_, split /\n/, $s;
  },

  outdent => fn q{
    my $x = shift;
    return $x if ref $x;
    my @lines = split /\n/, $x;
    return $x unless @lines > 1;
    my $indent = $lines[1] =~ /^(\s*)/ && length $1;
    for (@lines[2..$#lines]) {
      my $li = /^(\s*)/ && length $1;
      $indent = length $1 if length $1 < $indent;
    }
    my $spaces = ' ' x $indent;
    s/^$spaces// for @lines;
    join "\n", @lines;
  });
