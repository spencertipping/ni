ni('ni:/object')->child('/lib/ni')
  ->doc
  ->synopsis(q'my $value = ni->resolve($name);
               my $value = ni($name);   # alias for ni->resolve($name)
               my $self  = ni;')
  ->description(
    q[The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.])
  ->end

  ->def('/lib/ni_self.b',
    is_mutable => fn q{$0 ne '-' && -w $0},
    modify => fn q{
      my ($self, $fn) = @_;
      # TODO: replace all of this with a generalized "atomic-update" function
      # against UNIX files.
      die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
      my (undef, undef, $mode) = stat $0;
      my $temp = map chr 97 + rand(26), 1..16;
      my @r = split /\//, $0;
      $r[-1] =~ s/^/./;
      $r[-1] =~ s/$/.$temp/;
      my $r = join '/', @r;
      open my $w, '>', $r or die "ni: failed to create staging file: $!";
      chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
      &$fn($w);
      close $w;
      rename $r, $0 or die "ni: failed to rename: $!";
    },

    extend => fn q{
      my $self = shift;
      for (@_) {
        my $r = do $_;
        die "ni: failed to parse $_: $@" if $@;
        die "ni: failed to execute $_: $!" unless defined $r;
      }
      $self;
    })

  ->def('/lib/ni_main.b',
    run => fn q{
      my $self = shift;
      shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
      exit $self->default(@_);
    },

    '--internal/eval' => fn q{
      my $self = shift;
      for (@_) {
        my $r = ni::eval($_);
        print $@ ? "ERROR $@\n" : "$r\n";
      }
      0;
    },

    '--internal/+=' => fn q{
      my $self = shift;
      $self->extend($_) for @_;
      my $q = $self->quoted(use_newlines => 1);
      $self->modify(sub {$q->write(shift)});
      0;
    },

    '--internal/test' => fn q{
      my $self   = shift;
      my $failed = 0;
      my @tests  = map ni($_)->tests, grep /^ni\.doc:/, keys %{$$self{named}};
      for (@tests) {
        $_->run;
        print "$_\n";
      }
      for my $f (grep $_->failed, @tests) {
        ++$failed;
        print "\nTEST FAIL\n", $f->test, "\n";
        print "\nERROR ", $f->error if $f->error;
        print "\nASSERTIONS\n";
        print "  $_\n" for @{$f->assertions};
      }

      print "\nSUMMARY\n";
      printf "% 4d test(s) passed\n", @tests - $failed;
      printf "% 4d test(s) failed\n", $failed;
      !!$failed;
    },

    '--internal/image' => fn q{
      shift->quoted(use_newlines => 1)->write(\*STDOUT);
      0;
    });

ni('ni:/lib/slice')->new('/lib/ni_resolver.b',
  resolver_for => fn q{
    my $self = shift;
    ${$$self{resolvers}}{$_[0]} = $_[1];
    $self;
  },
  resolve => fn q{
    my $self = shift;
    return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
    return $$self{resolvers}{$1}->($_[0]) if
      $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
    die "ni:self failed to resolve $_[0]";
  });

ni('ni:/lib/slice')->new('/lib/ni_image.b',
  exists => fn q{exists $_[0]->{named}{$_[1]}},
  quoted => fn q{
    my $self = shift;
    my $q = ni('ni:/lib/image')->new(@_);
    my $gs = $q->quote($self);
    $q->side_effect("\$ni::self=$gs;");
    $q;
  });

{
  my $ni = ni('ni:/lib/ni');
  my $r  = ni('ni:/lib/ni_resolver.b');
  my $i  = ni('ni:/lib/ni_image.b');
  delete @{'lib/ni::'}{qw/resolve exists/};
  $ni->add($r, $i);
}
