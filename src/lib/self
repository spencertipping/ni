ni('ni:/object')->child('/lib/ni')
  ->doc
  ->synopsis(q'my $value = ni->resolve($name);
               my $value = ni($name);   # alias for ni->resolve($name)
               my $self  = ni;')
  ->description(
    q[The class for the currently-running ni instance. This includes all
      instance state, the table of named objects, and a bit of logic to update
      ni in place, for instance when adding extensions.])
  ->end

  ->def('self.b',
    is_mutable => fn q{$0 ne '-' && -w $0},
    modify => fn q{
      my ($self, $fn) = @_;
      die "ni: cannot modify immutable instance $0" unless $self->is_mutable;
      my (undef, undef, $mode) = stat $0;
      &$fn(ni('ni:/io/file')->new($0, $mode)->atomic_update);
    },

    extend => fn q{
      my $self = shift;
      for (@_) {
        my $r = do $_;
        die "ni: failed to parse $_: $@" if $@;
        die "ni: failed to execute $_: $!" unless defined $r;
      }
      $self;
    })

  ->def('dev_introspection.b',
    classes => fn q{
      my $self = shift;
      my $metaclass = $self->resolve('ni:/object.c');
      map $self->resolve($_),
          grep $self->exists($_),
          map "ni:" . substr($_, 4),
          grep !$$metaclass{applied_to}->{$_},
          sort keys %{$self->resolve('ni:/object')->{applied_to}};
    },

    metaclasses => fn q{
      my $self = shift;
      map $self->resolve($_),
          grep $self->exists($_),
          map "ni:" . substr($_, 4),
          sort keys %{$self->resolve('ni:/object.c')->{applied_to}};
    },

    docs => fn q{
      my $self = shift;
      map $self->resolve($_), grep /^ni\.doc:/, sort keys %{$$self{named}};
    },

    undocumented => fn q{
      my $self = shift;
      my %docs = map +($_->referent => 1), $self->docs;
      grep !$docs{$_}, $self->classes;
    },

    untested => fn q{
      my $self = shift;
      my %tests = map +($_->referent => 1), map $_->tests, $self->docs;
      grep !$tests{$_}, $self->classes;
    })

  ->def('main.b',
    run => fn q{
      my $self = shift;
      shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
      exit $self->default(@_);
    },

    '--internal/eval' => fn q{
      my $self = shift;
      for (@_) {
        my $r = ni::eval($_);
        print $@ ? "ERROR $@\n" : "$r\n";
      }
      0;
    },

    '--internal/+=' => fn q{
      my $self = shift;
      $self->extend($_) for @_;
      my $q = $self->quoted;
      $self->modify(sub {$q->io->into_sync(shift)});
      0;
    },

    '--internal/dev-state' => fn q{
      my $self = shift;
      my @tests = map $_->tests, $self->docs;
      $_->run for @tests;
      my @failed = grep $_->failed, @tests;

      print ni::json_encode_pretty({
        image_size     => length($self->quoted->io->read_all),
        named_entities => scalar(keys %{$$self{named}}),
        classes        => scalar($self->classes),
        metaclasses    => scalar($self->metaclasses),

        undocumented => [map "$_", $self->undocumented],
        untested     => [map "$_", $self->untested],

        tests => {
          total   => scalar(@tests),
          passing => @tests - @failed,
          failed  => (@failed ? [
            map +{
              referent => $_->referent->name,
              assertions => [
                map $_->failed ? +{diff => $_->diff} : +{passed => 1},
                    @{$_->assertions}
              ]
            }, @failed
          ] : undef)
        },

        todos => [map +{referent => $_->referent->name,
                        text     => join "\n", @{$_->todo}},
                  map $_->todos, $self->docs],
      }), "\n";
      0;
    },

    '--internal/test' => fn q{
      local $| = 1;
      my $self   = shift;
      my $failed = 0;
      my @docs   = $self->docs;
      my @todos  = map $_->todos, @docs;

      print "\n" . scalar(@todos) . " TODO item(s)\n" if @todos;
      print "\n$_\n" for @todos;

      my @tests = map $_->tests, @docs;
      $_->run for @tests;

      for my $f (grep $_->failed, @tests) {
        ++$failed;
        print "\nTEST FAIL\n", $f->test, "\n";
        print "\nERROR ", ni('ni:/lib/fn')->resolve_evals($f->error)
          if $f->error;
        print "\nASSERTIONS\n";
        print "  $_\n" for @{$f->assertions};
      }

      print "\nSUMMARY\n";
      printf "% 4d test(s) passed\n", @tests - $failed;
      printf "% 4d test(s) failed\n", $failed;
      !!$failed;
    },

    '--internal/image' => fn q{
      shift->quoted->io->into_sync(ni"fd:1");
      0;
    });

ni('ni:/lib/slice')->new('/lib/ni_resolver.b',
  resolver_for => fn q{
    my $self = shift;
    ${$$self{resolvers}}{$_[0]} = $_[1];
    $self;
  },
  resolve => fn q{
    my $self = shift;
    return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
    return $$self{resolvers}{$1}->($_[0]) if
      $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
    die "ni:self failed to resolve $_[0]";
  });

ni('ni:/lib/slice')->new('/lib/ni_image.b',
  exists => fn q{exists $_[0]->{named}{$_[1]}},
  quoted => fn q{
    my $self = shift;
    my $q = ni('ni:/lib/image')->new(@_);
    my $gs = $q->quote($self);
    $q->side_effect("\$ni::self=$gs;");
    $q;
  });

{
  my $ni = ni('ni:/lib/ni');
  my $r  = ni('ni:/lib/ni_resolver.b');
  my $i  = ni('ni:/lib/ni_image.b');
  delete @{'ni::/lib/ni::'}{qw/resolve exists/};
  $ni->add($r, $i);
}
