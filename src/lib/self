ni('ni:/object')->child('/lib/ni')
  ->def('/lib/ni_self.b',
    is_mutable => fn q{$0 ne "-" && -w $0},
    modify => fn q{
      my ($self, $fn) = @_;
      # TODO: replace all of this with a generalized "atomic-update" function
      # against UNIX files.
      die "ni: cannot modify immutable instance" unless $self->is_mutable;
      my (undef, undef, $mode) = stat $0;
      my $temp = map chr 97 + rand(26), 1..16;
      my @r = split /\//, $0;
      $r[-1] =~ s/^/./;
      $r[-1] =~ s/$/.$temp/;
      my $r = join '/', @r;
      open my $w, '>', $r or die "ni: failed to create staging file: $!";
      chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
      &$fn($w);
      close $w;
      rename $r, $0 or die "ni: failed to rename: $!";
    })

  ->def('/lib/ni_image.b',
    exists => fn q{exists $_[0]->{named}{$_[1]}},
    quoted => fn q{
      my $self = shift;
      my $q = ni('ni:/lib/image')->new(@_);
      my $gs = $q->quote($self);
      $q->side_effect("\$ni::self=$gs;");
      $q;
    })

  ->def('/lib/ni_main.b',
    run => fn q{
      my $self = shift;
      shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
      exit $self->default(@_);
    },

    '--internal/eval' => fn q{
      my $self = shift;
      for (@_) {
        my $r = ni::eval($_);
        print $@ ? "ERROR $@\n" : "$r\n";
      }
      0;
    },

    '--internal/+=' => fn q{
      my $self = shift;
      for (@_) {
        my $r = do $_;
        die "ni: failed to parse $_: $@" if $@;
        die "ni: failed to execute $_: $!" unless defined $r;
        die "ni: failed to run $_: $!" unless $r;
      }
      my $q = $self->quoted;
      $self->modify(sub {$q->write(shift)});
      0;
    },

    '--internal/image' => fn q{
      shift->quoted->write(\*STDOUT);
      0;
    });

ni('ni:/class')->new('/lib/ni_static')->apply('ni');

ni('ni:/lib/slice')->new('/lib/ni_resolver.b',
  resolver_for => fn q{
    my $self = shift;
    ${$$self{resolvers}}{$_[0]} = $_[1];
    $self;
  },
  resolve => fn q{
    my $self = shift;
    return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
    return $$self{resolvers}{$1}->($_[0]) if
      $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
    die "ni:/self failed to resolve $_[0]";
  });

{
  my $ni = ni('ni:/lib/ni');
  my $r  = ni('ni:/lib/ni_resolver.b');
  delete ${'/lib/ni::'}{resolve};
  $ni->add($r);
}
