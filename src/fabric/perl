ni('ni:/object')->child('/fabric/perl')
  ->doc
  ->description(
    q[A perl interpreter running somewhere. In the fabric sense, this means
      something that has a name table whose entries can respond to method
      calls.],

    q[There are some interesting design considerations that go into this.
      First, we want to jointly minimize the running transmission size while
      also being careful not to leak memory by caching things. A naive setup
      like the one ni uses to serialize itself would meet the first requirement
      but not the second.],

    q[Second, we don't want to incur parsing overhead for every request we
      make.])
  ->end

  ->def('/fabric/perl_init.b',
    instantiate => fn q{
      my ($class, $stdin, $stdout) = @_;
      +{stdin   => $stdin,
        stdout  => $stdout,
        pending => {}};
    })

  ->def('/fabric/perl_rmi.b',
    ni => fn q{ni('/fabric/perl_proxy')->new(@_)});

ni('ni:/object')->child('/fabric/perl_proxy')
  ->def('/fabric/perl_proxy_init.b',
    instantiate => fn q{
      my ($class, $perl, $name) = @_;
      +{perl => $perl,
        name => $name};
    })

  ->def('/fabric/perl_proxy_rmi.b',
    AUTOLOAD => fn q{
      my $self = shift;
      my $method = ${__PACKAGE__ . '::AUTOLOAD'};
      $$self{perl}->rmi($$self{name}, $method, @_);
    });
