ni('ni:/io/object')->child('/io/fd')
  ->doc
  ->synopsis(q[
    open my $fh, ...;
    my $fd = ni('ni:/io/fd')->new($fh); # from perl FH
    my $fd = ni('ni:/io/fd')->new(0);   # from number
    my $fd = ni('fd:0');                # same thing
    $fd->nonblock(1)->read($_, 100);
    $fd->be(10);                        # move FD number
  ])

  ->description(
    q[Represents a file descriptor as a child of /io/object (so the usual IO
      methods like into_async are available), and provides some convenience
      functions for things like setting up FDs for child processes. FDs are
      closed when destroyed.],

    eg q{
      my ($r, $w) = POSIX::pipe;
      {
        my $fd = ni('ni:/io/fd')->new($r);
      }
      ni('ni:/io/fd')->new($w)->be($r);   # fails unless $r was GC-closed
    })
  ->end

  ->ro('/io/fd_readers.b', qw/fd/)
  ->def('/io/fd_init.b',
    instantiate => fn q{
      my ($class, $fd) = @_;
      +{fd  => ref $fd ? fileno $fd : $fd,
        rfh => undef,
        wfh => undef};
    })

  ->def('/io/fd_shell.b',
    be => fn q{
      my ($self, $new) = @_;
      return $self if $new == $$self{fd};
      $self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
      $$self{rfh} = $$self{wfh} = undef;
      POSIX::close $$self{fd};
      $$self{fd} = $new;
      $self;
    })

  ->def('/io/fd_fcntl.b',
    fcntl_flag => fn q{
      my ($self, $flag, $value) = @_;
      $self->io_check_true(*main::open2, $$self{rfh}, "<&=$$self{fd}")
        unless $$self{rfh};
      my $flags = $self->io_check_true(
        *main::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
      if (@_) {
        if (shift) {$flags |= $flag}
        else       {$flags &= ~$flag}
        $self->io_check_true(*main::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
        $self;
      } else {
        !!($flags & $flag);
      }
    },

    nonblock => fn q{shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)},
    cloexec  => fn q{shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)})

  ->def('/io/fd_gc.b',
    dtor => fn q{shift->close},
    close => fn q{
      my $self = shift;
      close $$self{rfh} if $$self{rfh};
      close $$self{wfh} if $$self{wfh};
      POSIX::close $$self{fd} if defined $$self{fd};
      $$self{fd} = $$self{rfh} = $$self{wfh} = undef;
      $self;
    })

  ->def('/io/fd_perlio.b',
    read => fn q{
      my $self = shift;
      open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
      sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0;
    },
    write => fn q{
      my $self = shift;
      open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
      syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0;
    });

ni->resolver_for(fd => fn q{ni('ni:/io/fd')->new(0 + substr shift, 3)});
