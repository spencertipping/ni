ni('ni:/semantic/task')->child('/io/transfer')
  ->def('/io/transfer_io_interop.b',
    ctor => fn q{
      my $self = shift;
      @$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);
    },

    read => fn q{
      my $self = shift;
      my $start_time = time;
      my $n = $$self{source_io}->read(@_);
      my $end_time = time;
      $$self{read_bytes} += $n if defined $n;
      $$self{read_time} += $end_time - $start_time;
      $n;
    },

    write => fn q{
      my $self = shift;
      my $start_time = time;
      my $n = $$self{dest_io}->write(@_);
      my $end_time = time;
      $$self{write_bytes} += $n if defined $n;
      $$self{write_time} += $end_time - $start_time;
      $n;
    });

ni('ni:/io/transfer.c')->def('/io/transfer.c_into.b',
  ctor => fn q{
    my $self = shift;
    ni('ni:/io/object')->def("/io/object_transfer_$1.b",
      "into_$1" => fn qq{ni('ni:/io/transfer_$1')->new(\@_)->run})
    if $self->name =~ /transfer_(\w+)$/;
  });

ni('ni:/io/transfer')->child('/io/transfer_sync')
  ->def('/io/transfer_sync_init.b',
    instantiate => fn q{
      my ($class, $source, $dest) = @_;
      +{source_io => $source,
        dest_io   => $dest};
    })

  ->def('/io/transfer_sync_run.b',
    run => fn q{
      my $self = shift;
      my $buf;
      while ($self->read($buf, 32768)) {
        my $n = $self->write($buf);
        $self->failure($!) unless defined $n;
        while ($n < length $buf) {
          my $n0 = $self->write(substr $buf, $n);
          $self->failure($!) unless defined $n0;
          $n += $n0;
        }
      }
      $self->success;
    });

ni('ni:/io/transfer')->child('/io/transfer_async')
  ->def('/io/transfer_async_init.b',
    instantiate => fn q{
      my ($class, $source, $dest) = @_;
      $source->nonblock(1) if $source->can('nonblock');
      $dest  ->nonblock(1) if $dest  ->can('nonblock');
      +{source_io => $source,
        dest_io   => $dest,
        pending   => '',
        id        => $class->new_id};
    })

  ->def('/io/transfer_async_lifecycle.b',
    ctor => fn q{ni('ni:/io/transfer_async')->track(shift)},
    dtor => fn q{ni('ni:/io/transfer_async')->untrack(shift->{id})})

  ->def('/io/transfer_async_run.b',
    run       => fn q{shift},
    run_async => fn q{
      my $self = shift;
      my $n;
      if (length $$self{pending}) {
      write_branch:
        $n = 0;
        while ($n < length $$self{pending}) {
          my $x = $self->write($n ? substr($$self{pending}, $n)
                                  : $$self{pending});
          last unless defined $x;
          $n += $x;
        }
        $$self{pending} = substr $$self{pending}, $n;
      }
      unless (length $$self{pending}) {
        goto write_branch if $n = $self->read($$self{pending}, 32768);
        return $self if defined $n || $!{EAGAIN} || $!{EWOULDBLOCK};
        $self->failure($!);
      }
      $self;
    });
