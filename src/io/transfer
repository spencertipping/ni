ni('ni:/semantic/task')->child('/io/transfer')
  ->def('io_interop.b',
    ctor => fn q{
      my $self = shift;
      @$self{qw/read_bytes read_time write_bytes write_time/} = (0, 0, 0, 0);
    },

    read => fn q{
      my $self = shift;
      my $start_time = time;
      my $n = $$self{source_io}->read(@_);
      my $end_time = time;
      $$self{start_time} ||= $start_time;
      $$self{read_bytes} += $n if defined $n;
      $$self{read_time} += $end_time - $start_time;
      $n;
    },

    write => fn q{
      my $self = shift;
      my $start_time = time;
      my $n = $$self{dest_io}->write(@_);
      my $end_time = time;
      $$self{write_bytes} += $n if defined $n;
      $$self{write_time} += $end_time - $start_time;
      $n;
    })

  ->def('io_measurement.b',
    throughput => fn q{
      my $self = shift;
      my $end_time = $$self{end_time} || time;
      my $dt       = $end_time - $$self{start_time} || 1;
      $$self{write_bytes} / $dt;
    },

    read_limit_throughput => fn q{
      my $self = shift;
      $$self{read_bytes} / ($$self{read_time} || 1);
    },

    write_limit_throughput => fn q{
      my $self = shift;
      $$self{write_bytes} / ($$self{write_time} || 1);
    },

    pressure => fn q{
      my $self = shift;
      my $in_impedance  = log($$self{read_time}  || 1);
      my $out_impedance = log($$self{write_time} || 1);
      ($out_impedance - $in_impedance) / log 20;
    });

ni('ni:/io/object.c')->def('/io/object.c_transfer_def.b',
  def_transfer_method => fn q{
    my ($class, $transfer_class, $method_name) = @_;
    my $transfer_name = $transfer_class->name;
    $class->def("/io/object_transfer_$method_name.b",
      "into_$method_name" => fn qq{ni('$transfer_name')->new(\@_)->run},
      "connect_$method_name" => fn qq{
        my (\$self, \$rhs) = \@_;
        (\$self->into_$method_name(\$rhs),
         \$rhs->into_$method_name(\$self));
      });
  });

# TODO: this is terrible.
# Just use a "deftransfer" toplevel function that produces lower-level code
# snippets. The state space of classes/metaclasses isn't complicated enough to
# justify having heavy metaclasses instead of abstraction erasure.
ni('ni:/io/transfer.c')->def('/io/transfer.c_into.b',
  ctor => fn q{
    my $self = shift;
    ni('ni:/io/object')->def_transfer_method($self, $1)
      if $self->name =~ /transfer_(\w+)$/;
  });

ni('ni:/io/transfer')->child('/io/transfer_sync')
  ->def('init.b',
    instantiate => fn q{
      my ($class, $source, $dest) = @_;
      +{source_io => $source,
        dest_io   => $dest};
    })

  ->def('run.b',
    run => fn q{
      my $self = shift;
      my $bufsize = $$self{bufsize} || 32768;
      my $buf;
      my $r;
      while (($r = $self->read($buf, $bufsize)) || $!{EINTR}) {
        my $n = $self->write($buf);
        $self->failure($!) unless $n || $!{EINTR};
        while ($n < $r) {
          my $n0 = $self->write($buf, $r - $n, $n);
          $self->failure($!) unless $!{EINTR} || $n0;
          $n += $n0 || 0;
        }
      }
      $$self{end_time} = time;
      $self->success;
    });

ni('ni:/io/transfer')->child('/io/transfer_async')
  ->ro('ro.b', qw/ source_io dest_io id /)
  ->def('init.b',
    instantiate => fn q{
      my ($class, $source, $dest) = @_;
      $source->nonblock(1) if $source->can('nonblock');
      $dest  ->nonblock(1) if $dest  ->can('nonblock');
      +{source_io => $source,
        dest_io   => $dest,
        pending   => '',
        outcome   => undef,
        id        => $class->new_id};
    })

  ->def('lifecycle.b',
    ctor => fn q{ni('ni:/io/transfer_async')->track(shift)},
    dtor => fn q{ni('ni:/io/transfer_async')->untrack(shift->{id})})

  ->def('run.b',
    run       => fn q{shift},
    run_async => fn q{
      my $self = shift;
      my $n;

      # Step one: write everything in the pending queue, if possible. Invariant
      # after this if() condition is that $$self{pending} is empty unless there
      # was something preventing IO.
      if (length $$self{pending}) {
      write_branch:
        $n = 0;
        while ($n < length $$self{pending}) {
          my $x = $self->write($n ? substr($$self{pending}, $n)
                                  : $$self{pending});
          last unless defined $x;
          $n += $x;
        }
        $$self{pending} = substr $$self{pending}, $n;
      }

      # Step two: load more data into $$self{pending} and, if successful, go
      # back to step one and write it.
      unless (length $$self{pending}) {
        goto write_branch if $n = $self->read($$self{pending}, 32768);
        return $self if $!{EINTR} || $!{EAGAIN} || $!{EWOULDBLOCK};
        if (defined $n) {
          $$self{end_time} = time;
          return $self->success;
        } else {
          $self->failure($!);
        }
      }

      $self;
    });

ni('ni:/io/transfer_async.c')->def('tracker.b',
  ctor => fn q{
    my $self = shift;
    $$self{tracked_transfers} = {};
    $$self{transfer_id}       = 0;
  },
  new_id => fn q{++shift->{transfer_id}},
  track => fn q{
    my ($self, $transfer) = @_;
    Scalar::Util::weaken($$self{tracked_transfers}{$transfer->id} = $transfer);
    $self;
  },
  untrack => fn q{
    my ($self, $id) = @_;
    delete $$self{tracked_transfers}{$id};
    $self;
  });
