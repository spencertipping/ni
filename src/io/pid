ni('ni:/io/object')->child('/io/pid')
  ->doc
  ->eg(q{
    now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];
  })
  ->eg(q{
    my $pid = ni('sh:seq 4');
    my $data = $pid->read_all;
    now [$pid->await, $data] == [0, "1\n2\n3\n4\n"];
  })
  ->eg(q{
    my $seq = ni('sh:seq 10');
    my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
      ->connect(0 => $seq->stdout)
      ->fork;
    now [$grep->read_all, $seq->await, $grep->await]
     == ["1\n3\n5\n7\n9\n", 0, 0];
  })
  ->end

  ->ro('readers.b', qw/pid status/)
  ->def('init.b',
    instantiate => fn q{
      my ($class, $pid, $argv, $env, %external_fds) = @_;
      +{pid          => $pid,
        argv         => $argv,
        env          => $env,
        external_fds => \%external_fds,
        status       => undef};
    },
    dtor => fn q{shift->await})

  ->def('wait.b',
    running => fn q{not defined $_[0]->{status} and kill 0, $_[0]->{pid}},

    await => fn q{
      my $self = shift;
      return $$self{status} if defined $$self{status};
      $self->io_check_defined(*main::waitpid, $$self{pid}, 0);
      $$self{status} = $?;
    })

  ->def('io.b',
    read  => fn q{shift->stdout->read(@_)},
    write => fn q{shift->stdin->write(@_)})

  ->def('accessors.b',
    fd     => fn q{$_[0]->{external_fds}{$_[1]}},
    stdin  => fn q{shift->fd(0)},
    stdout => fn q{shift->fd(1)},
    stderr => fn q{shift->fd(2)});

ni->resolver_for(
  sh => fn q{ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork});
