ni('ni:/io/object')->child('/io/str')
  ->ro('ro.b', qw/data start end/)
  ->def('init.b',
    instantiate => fn q{
      my $class = shift;
      +{data  => \$_[0],
        start => $_[1] || 0,
        end   => $_[2] || length $_[0]};
    })

  ->def('io.b',
    remaining => fn q{my $self = shift; $$self{end} - $$self{start}},

    read => fn q{
      my $self = shift;
      my $l    = ni::min($$self{end} - $$self{start}, $_[1]);
      return 0 unless $l;
      if ($_[2]) {
        substr $_[0], $_[2], $l, substr ${$$self{data}}, $$self{start}, $l;
      } else {
        $_[0] = substr ${$$self{data}}, $$self{start}, $l;
      }
      $$self{start} += $l;
      $l;
    },
    write => fn q{
      my $self = shift;
      ${$$self{data}} .= $_[0];
      $$self{start} += length $_[0];
      $$self{end} = length ${$$self{data}};
      length $_[0];
    });

ni->resolver_for(str => fn q{
  my $s = shift;
  ni('ni:/io/str')->new(substr($s, 4) . "\n");
});
