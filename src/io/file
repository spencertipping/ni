ni('ni:/io/object')->child('/io/file')
  ->doc
  ->synopsis(q[
    my $f = ni('ni:/io/file')->new('/etc/passwd');
    my $f = ni('file:/etc/passwd');     # same as above
    $f->into_sync(ni('fd:1'));          # cat to stdout
  ])

  ->warning(
    q[Files overload the -X file test operators, but this feature wasn't
      introduced until Perl 5.12 -- prior versions won't recognize this
      overload. That means that using this overload in ni's base code will
      reduce its portability and cause tests to fail.])

  ->description(
    q[Represents a file that may or may not exist, and stores/constructs file
      descriptors for reading/writing. /io/files are one-shot objects: once
      you've consumed them for reading or written to them, you should destroy
      the object and start over (or close the file) if you want to operate on
      the file further -- put differently, /io/file objects own the FDs they
      create.],

    eg => fn q{
      my $ni = ni('file:/dev/zero');
      now [$ni->read($_, 8), $_] == [8, "\0" x 8];
    },

    q[File objects also provide some useful functions like atomic-updating.
      This lets you write a stream slowly into a tempfile, then rename over the
      original once the tempfile is closed. ni uses this to update itself to
      avoid race conditions.],

    eg => fn q{
      ni('file:tmp1')->write_all("original contents");
      {
        my $updater = ni('file:tmp1')->atomic_update;
        $updater->write_all('foo bar');
        now ni('file:tmp1')->read_all == "original contents";
      }
      now ni('file:tmp1')->read_all == "foo bar";
      ni('file:tmp1')->rm;
    })

  ->end

  ->ro('/io/file_readers.b', qw/name/)
  ->rw('/io/file_accessors.b', qw/mode/)
  ->def('/io/file_init.b',
    instantiate => fn q{
      my ($class, $name, $mode) = @_;
      +{name => $name,
        mode => $mode || 0644,
        r    => undef,
        w    => undef};
    })

  ->def('/io/file_fns.b',
    '(-X' => fn q{
      my ($self, $test) = @_;
      &{"-$test"}($$self{name});
    },

    mv => fn q{
      my ($self, $dest) = @_;
      $dest = $dest->name if ref $dest;
      $self->io_check_true(*POSIX::rename, $self->name, $dest);
      $$self{name} = $dest;
      $self;
    },

    rm => fn q{
      my $self = shift;
      $self->io_check_true(*POSIX::unlink, $self->name);
      $self;
    })

  ->def('/io/file_update.b',
    atomic_update => fn q{
      my $self = shift;
      my $suffix = 0;
      ++$suffix while -e $self->name . ".$suffix";
      ni('ni:/io/file_update_fd')->new(
        $self,
        $self->class->new($self->name . ".$suffix"));
    })

  ->def('/io/file_io.b',
    close => fn q{
      my $self = shift;
      $$self{r}->close if $$self{r};
      $$self{w}->close if $$self{w};
      $$self{r} = $$self{w} = undef;
      $self;
    },

    r => fn q{
      my $self = shift;
      $$self{r} ||= ni('ni:/io/fd')->new(
        $self->io_check_defined(
          *POSIX::open, $$self{name}, POSIX::O_RDONLY));
    },

    w => fn q{
      my $self = shift;
      $$self{w} ||= ni('ni:/io/fd')->new(
        $self->io_check_defined(
          *POSIX::open, $$self{name},
            POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
            $$self{mode}));
    },

    read  => fn q{shift->r->read(@_)},
    write => fn q{shift->w->write(@_)});

ni('ni:/io/object')->child('/io/file_update_fd')
  ->doc
  ->description(q[A write fd that performs a file rename upon closing.])
  ->end

  ->add('/io/fd_readers.b',
        '/io/fd_fcntl.b',
        '/io/fd_perlio.b')

  ->def('/io/file_update_fd_init.b',
    instantiate => fn q{
      my ($class, $file, $tempfile) = @_;
      my $fd = $tempfile->w;
      +{writer   => $fd,
        fd       => $fd->fd,
        wfh      => undef,
        tempfile => $tempfile,
        file     => $file};
    })

  ->def('/io/file_update_fd_gc.b',
    dtor => fn q{
      print STDERR "destroying file_update_fd\n";
      shift->close;
    },
    close => fn q{
      my $self = shift;
      close $$self{wfh} if $$self{wfh};
      $$self{writer}->close;
      $$self{tempfile}->rename($$self{file}->name);
      $self;
    });

ni->resolver_for(file => fn q{
  my $f = shift;
  $f =~ s/^file:(?:\/\/)?//;
  ni('ni:/io/file')->new($f);
});
