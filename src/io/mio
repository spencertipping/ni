ni('ni:/io/object')->child('/io/mio')
  ->doc
  ->synopsis(q'
    my $sender   = ni("ni:/io/mio")->new;
    my $receiver = ni("ni:/io/mio")->new;
    my $c1 = $mio->channel(1);
    my $c2 = $mio->channel(2);
    my $t1 = $channel1->write_all("8MB data" x 1000000);
    my $t2 = $channel2->write_all("short string");
    my ($t3, $t4) = $sender->connect_async($receiver);')

  ->description(
    q[Bidirectionally converts a single IO stream to a multi-channel interface.
      Internally, MIO objects encode channel data into packets of bounded size,
      scheduling channel traffic round-robin. The receiving MIO object decodes
      the multiplexed traffic into individual channels.],

    q[

      ])
  ->end

  ->ro('/io/mio_ro.b', qw/ io packet_size /)
  ->def('/io/mio_init.b',
    instantiate => fn q{
      my ($self, %args) = @_;
      +{channel_capacity => $args{channel_capacity} || 65536,
        closed           => 0,
        send_index       => 0,
        read_buffers     => [],
        write_buffers    => [],
        channel_id       => 0,
        channels         => []};
    })

  ->def('/io/mio_rr_scheduler.b',
    next_sender => fn q{
      my $self = shift;
      my $rs   = $$self{read_buffers};
      my $a    = $$self{send_index} + 1;
      for (my $i = 0; $i < @$rs; ++$i) {
        my $ai = ($a + $i) % @$rs;
        return $$self{send_index} = $ai if $$rs[$ai]->read_capacity;
      }
      undef;
    })

  ->def('/io/mio_io.b',
    close => fn q{
      my $self = shift;
      $$self{closed} = 1;
      $self;
    },

    read => fn q{
      my $self   = shift;
      my $length = $_[1];
      my $offset = $_[2] || 0;
      my $total_read = 0;

      while ($total_read + 8 < $length) {
        my $next_id = $self->next_sender;
        unless (defined $next_id) {
          return 0 if $$self{closed};
          $! = Errno::EWOULDBLOCK, return undef unless $total_read;
          return $total_read;
        }

        my $n = $$self{channels}[$next_id]->read(
          $_[0],
          $length - $total_read - 8,
          $offset + $total_read + 8);
        if ($n) {
          substr $_[0], $offset + $total_read, 8, pack 'NN', $next_id, $n;
          $total_read += $n + 8;
        } elsif (!defined $n) {
          return $total_read || undef;
        }
      }

      return $total_read if $total_read;
      $! = Errno::EWOULDBLOCK;
      undef;
    },

    write => fn q{
      my $self = shift;
      my $length = $#_ ? $_[1] : length $_[0];
      my $offset = $_[2] || 0;
      # TODO
    })

  ->def('/io/mio_channel.b',
    channels => fn q{sort {$a <=> $b} keys %{shift->{channels}}},
    channel  => fn q{
      my $self = shift;
      my $id = @_ ? shift : ++$$self{channel_id};
      return $$self{channels}{$id} if exists $$self{channels}{$id};
      my $c = ni('ni:/io/mio_channel')->new($self, $id);
      Scalar::Util::weaken($$self{channels}{$id} = $c);
      $$self{read_buffers}{$id}  = $$c{read_buffer};
      $$self{write_buffers}{$id} = $$c{write_buffer};
      push @{$$self{send_rr}}, $id;
      $c;
    },

    unchannel => fn q{
      my ($self, $id) = @_;
      delete $$self{channels}{$id};
      delete $$self{read_buffers}{$id}
        unless $$self{read_buffers}{$id}->read_capacity;
      delete $$self{write_buffers}{$id}
        unless $$self{write_buffers}{$id}->write_capacity;
      $$self{send_rr} = [map $_ ne $id, @{$$self{send_rr}}];
      $self;
    });

ni('ni:/io/object')->child('/io/mio_channel')
  ->doc
  ->description(
    q[
    ])
  ->end

  ->ro('/io/mio_channel_ro.b', qw/ mio id capacity /)
  ->def('/io/mio_channel_init.b',
    instantiate => fn q{
      my ($self, $mio, $id, $capacity) = @_;
      +{mio          => $mio,
        id           => $id,
        capacity     => $capacity,
        write_buffer => ni('ni:/io/buffer')->new($capacity >> 1),
        read_buffer  => ni('ni:/io/buffer')->new($capacity >> 1)};
    })

  ->def('/io/mio_channel_lifecycle.b', dtor => fn q{shift->close})

  ->def('/io/mio_channel_io.b',
    close => fn q{
      my $self = shift;
      $$self{mio}->unchannel($$self{channel_id});
    },
    read  => fn q{shift->{read_buffer} ->read(@_)},
    write => fn q{shift->{write_buffer}->write(@_)});
