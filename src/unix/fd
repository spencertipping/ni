ni('ni:/unix/io')->child('/unix/fd')
  ->ro('/unix/fd_readers.b', 'fd')
  ->def('/unix/fd_init.b',
    instantiate => fn q{
      my ($class, $fd) = @_;
      +{fd => ref $fd ? fileno $fd : $fd,
        fh => ref $fd ? $fd        : undef};
    })

  ->def('/unix/fd_shell.b',
    be => fn q{
      use POSIX qw/dup2/;
      my ($self, $new) = @_;
      return $self if $new == $$self{fd};
      close $$self{fh} if Scalar::Util::openhandle $$self{fh};
      dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
      POSIX::close $$self{fd};
      $$self{fd} = $new;
      $self;
    })

  ->has_fd
  ->def('/unix/fd_io.b',
    read_fh => fn q{
      my $self = shift;
      return $self->{fh} if Scalar::Util::openhandle $self->{fh};
      open my $fh, '<&=', $$self{fd}
        or die "ni:/unix/fd $$self{fd} failed to read: $!";
      $self->{fh} = $fh;
    },
    write_fh => fn q{
      my $self = shift;
      return $self->{fh} if Scalar::Util::openhandle $self->{fh};
      open my $fh, '>&=', $$self{fd}
        or die "ni:/unix/file $$self{fd} failed to write: $!";
      $self->{fh} = $fh;
    });

ni->resolver_for(fd => fn q{ni('ni:/unix/fd')->new(0 + substr shift, 3)});
